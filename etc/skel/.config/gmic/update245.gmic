#@gmic
#
#  File        : update250.gmic
#                ( G'MIC command file )
#
#  Description : Update file for G'MIC commands and filters (for version 2.5.0).
#                ( https://gmic.eu )
#
#  License     : CeCILL v2.1 or CeCILL-C v1.0
#                ( http://www.cecill.info/index.en.html )
#


#@gui !<b><i>&gt;&gt; UPDATE INFORMATION</i></b> : _none_, _none_
#@gui : note = note{"A <b>new version</b> of the <i>G'MIC</i> plug-in is available!\n\n
#@gui : You are strongly encouraged to upgrade your version, by visiting our <i>Download page</i> :\n\n"}
#@gui : url = link{"Visit G'MIC Download Page","https://gmic.eu/download.shtml"}
#@gui : note = note{"\nOf course, your plug-in will continue to work, but please note that we won't be able
#@gui : to provide filter updates anymore for your current plug-in version.\n\n
#@gui : Best regards,\n\n <i>The G'MIC team.</i>"}

#@cli :: Global Options
cli_noarg :
use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r version
v + e[] "\n[gmic] No commands, options or data provided (type "${c}"'gmic help'"$n" to get help)." v -
if {{*,u}>0}
v + e[] "[gmic] "${c}"Running in demo mode."$n v - parallel 0,"demo ," e[] ""
else
v + e[] "\n" v -
fi
file_update=${_path_rc}update$_version.gmic
need_update={"Y = date(0); M = date(1); D = date(2); date_current = Y*365 + M*31 + D;
Y = date(0,"$file_update"); M = date(1,"$file_update"); D = date(2,"$file_update"); date_file = Y*365 + M*31 + D;
date_current - date_file>=7"}
if $need_update
v + e[] "[gmic] Update commands..." v -
l[] update
v + e[] "\r[gmic] Update commands: "${g}"Succeeded!"$n v -
onfail
v + e[] "\r[gmic] Update commands: "${r}"Failed!"$n v -
endl
fi
cli_start :
#@cli debug : (+)
#@cli : Activate debug mode.
#@cli : When activated, the G'MIC interpreter becomes very verbose and outputs additional log
#@cli : messages about its internal state on the standard output (stdout).
#@cli : This option is useful for developers or to report possible bugs of the interpreter.
#@cli h : eq. to 'help'.
h :
help $*
#@cli help : command : (no arg)
#@cli : Display help (optionally for specified command only) and exit.
#@cli : (eq. to 'h').
help : skip ${1=""},${2=1}
if {!$!} return fi
y a y
+_help $1,$2 k[0]
if {narg(${})} _help[0] ${},0 fi
rm
_help : skip ${1=""}
v -1 use_vt100
if {!narg("$1")} _is_example=0 __help ascii v + e[] "" v - rm u "" return fi
({'"$1"'}) autocrop. {'-'}
if {{@100%}==_']'" && "i!=_'['} l. s -,{'['} k[0] endl fi
command={t} rm.
ks0="0" ks1="k[0]"
if $2 e[] "" __help_header_ascii[] fi
r 1,{h+1},1,1,0,0,0,1
s +,{'"#@cli "$command" :"'} s +,{'"#@cli "$command":"'} s +,{'"#@cli "$command"\n"'}
if {$!==1}
l[] m "foo : "$command
repeat 16 uncommand $command done
foo uncommand foo
onfail ({'${}'}) s -,{'" (did you mean "'} if {$!>1} s[1] -,39 k[1] misspelling={t} fi rm
endl
if {narg($misspelling)} misspelling=" (did you mean '"$misspelling"' ?)" fi
v + e[] "\n[gmic] Command '"$command"' has no description"$misspelling". Try 'gmic -h' for global help.\n\n" v -
rm u "" return
fi
rm[0] a y s -,10
stopflag=0
_is_example=0
_document_gmic_header_ascii[] 0
repeat $! l[$>] if {h>6" && "same([{^}],'#@cli',5)}
rows 6,100% autocrop {'" "'}
if {i!=_':'}
s -,{'": "'} autocrop {'" "'} autocrop {':'} autocrop {'" "'}
if {['{0,t}']==['$command']}
_document_gmic_declaration_ascii
if $_shortcut
v + e[] "\n    "$_gmic_m${_gmic_b}$command":"$_gmic_n" Shortcut for command '"$_gmic_m$_gmic_b$_shortcutlink0$_gmic_n"'." v -
u $_shortcutlink0 return
fi
else stopflag=1
fi
else
rows 1,100%
if {i==_':'} stopflag=1
else
_is_tutorial=
autocrop {'" "'}
if {i==_'$'}
rows 1,100% autocrop {'" "'}
if {i==_'$'}
v + e[] "" v -
if {h==1" && "i==_'$'} tuturl=https://gmic.eu/tutorial/_$command.shtml
else autocrop {'$'} autocrop {'" "'} tuturl=https://gmic.eu/tutorial/{0,t}.shtml
fi
rm ({'$_gmic_n${_gmic_b}"Tutorial:"$_gmic_n$_gmic_r" "$tuturl'}) y
_is_tutorial=1
else
if $_is_example i[0] ({'"\n               "'})
else i[0] ({'"\n      "$_gmic_n${_gmic_b}"Example: "$_gmic_n'}) _nb_example=0
fi
_is_example=1 _nb_example+=1
i[1] ({'$_gmic_n[#$_nb_example]"  "$_gmic_g'})
y a y
fi
fi
_document_gmic_description_ascii
fi
fi
else stopflag=1 fi ${ks{$!!=0}} endl if $stopflag break fi done
v + e[] $_gmic_n"\n" v - rm
u ""
__help :
m "_help_section : _help_section_$1 \"$""1\""
m "_help_paragraph : _help_paragraph_$1 \"$""1\""
_help_header_$1[]
_help_usage[]
s -,{'__help_end\ :'} k[0]
document_gmic $1,"img/",0
_help_examples[]
_help_footer_$1[]
_help_usage :
m "GMIC : u ${_gmic_g}G\47MIC$_gmic_n"
g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r
_help_paragraph "    "${c}${b}"gmic [command1 [arg1_1,arg1_2,..]] .. [commandN [argN_1,argN_2,..]]"$n"
\n
\n    '"${g}"gmic"$n"' is the open-source interpreter of the "${-GMIC}" language, a script-based programming
\n    language dedicated to the design of possibly complex image processing pipelines and operators.
\n    It can be used to convert, manipulate, filter and visualize image datasets made of one
\n    or several 1D/2D or 3D multi-spectral images.
\n
\n    This reference documentation describes all the technical rules governing the "${-GMIC}" language.
\n    As a starting point, you may want to visit our detailed tutorial pages, at:
\n     "${r}"https://gmic.eu/tutorial/"$n
_help_section "Overall context"
_help_paragraph "  - At any time, "${-GMIC}" manages one list of numbered (and optionally named) pixel-based images,
\n     entirely stored in computer memory (uncompressed).
\n
\n  - The first image of the list has index '"${g}"0"$n"' and is denoted by '"${c}"[0]"$n"'. The second image of the
\n     list is denoted by '"${c}"[1]"$n"', the third by '"${c}"[2]"$n"' and so on.
\n
\n  - Negative indices are treated in a periodic way: '"${c}"[-1]"$n"' refers to the last image of the list,
\n     '"${c}"[-2]"$n"' to the penultimate one, etc. Thus, if the list has 4 images, '"${c}"[1]"$n"' and '"${c}"[-3]"$n"' both
\n     designate the second image of the list.
\n
\n  - A named image may be also indicated by '"${c}"[name]"$n"', if '"${g}"name"$n"' uses the character set "${g}"[a-zA-Z0-9_]"$n"
\n     and does not start with a number. Image names can be set or reassigned at any moment during
\n     the processing pipeline (see command '"${c}"name"$n"' for this purpose).
\n
\n  - "${-GMIC}" defines a set of various commands and substitution mechanisms to allow the design of
\n     complex pipelines and operators managing this list of images, in a very flexible way:
\n     You can insert or remove images in the list, rearrange image order, process images
\n     (individually or grouped), merge image data together, display and output image files, etc.
\n
\n  - Such a pipeline can be then added as a new custom "${-GMIC}" command (stored in a user
\n     command file), so it can be re-used afterwards in a larger pipeline if necessary."
_help_section "Image definition and terminology"
_help_paragraph "  - In "${-GMIC}", each image is modeled as a 1D, 2D, 3D or 4D array of scalar values, uniformly
\n     discretized on a rectangular/parallelepipedic domain.
\n
\n  - The four dimensions of this array are respectively denoted by:
\n
\n    . '"${g}"width"$n"', the number of image columns (size along the "${g}"'x'-axis"$n").
\n    . '"${g}"height"$n"', the number of image rows (size along the "${g}"'y'-axis"$n").
\n    . '"${g}"depth"$n"', the number of image slices (size along the "${g}"'z'-axis"$n").
\n        (the depth is equal to "${g}"1"$n" for usual color or grayscale 2D images).
\n    . '"${g}"spectrum"$n"', the number of image channels (size along the "${g}"'c'-axis"$n").
\n        (the spectrum is respectively equal to "${g}"3"$n" and "${g}"4"$n" for usual "${g}"RGB"$n" and "${g}"RGBA"$n" color images).
\n
\n  - There are no hard limitations on the size of the image along each dimension. For instance,
\n     the number of image slices or channels can be of arbitrary size within the limits of
\n     the available memory.
\n
\n  - The "${g}"width, height"$n" and "${g}"depth"$n" of an image are considered as spatial dimensions, while the
\n     "${g}"spectrum"$n" has a multi-spectral meaning. Thus, a 4D image in "${-GMIC}" should be most often
\n     regarded as a 3D dataset of multi-spectral voxels. Most of the "${-GMIC}" commands will stick with
\n     this idea (e.g. command '"${c}"blur"$n"' blurs images only along the spatial '"${g}"xyz"$n"'-axes).
\n
\n  - "${-GMIC}" stores all the image data as buffers of '"${g}"float"$n"' values (32 bits, value range
\n     "${g}"[-3.4E38,+3.4E38]"$n"). It performs all its image processing operations with floating point
\n     numbers. Each image pixel takes then 32bits/channel (except if double-precision buffers have
\n     been enabled during the compilation of the software, in which case 64bits/channel can be the
\n     default).
\n
\n  - Considering '"${g}"float"$n"'-valued pixels ensure to keep the numerical precision when executing
\n     image processing pipelines. For image input/output operations, you may want to prescribe the
\n     image datatype to be different than '"${g}"float"$n"' (like '"${g}"bool"$n"', '"${g}"char"$n"', '"${g}"int"$n"', etc...).
\n     This is possible by specifying it as a file option when using I/O commands.
\n     (see section '"${c}"Input/output properties"$n"' to learn more about file options)."
_help_section "Items of a processing pipeline"
_help_paragraph "  - In "${-GMIC}", an image processing pipeline is described as a sequence of items separated by the
\n     space character ' '. Such items are interpreted and executed from the left to the right.
\n     For instance, the expression:
\n
\n       "${c}"filename.jpg blur 3,0 sharpen 10 resize 200%,200% output file_out.jpg"$n"
\n
\n     defines a valid pipeline composed of nine "${-GMIC}" items.
\n
\n  - Each "${-GMIC}" item is a string that is either a "${g}"command"$n", a list of command "${g}"arguments"$n",
\n     a "${g}"filename"$n", or a special "${g}"input string"$n".
\n
\n  - Escape characters '"${g}"\\"$n"' and double quotes '"${g}"\""$n"' can be used to define items containing spaces or
\n     other special characters. For instance, the two strings '"${c}"single\\ item"$n"' and '"${c}"\"single item\""$n"'
\n     both define the same single item, with a space in it."
_help_section "Input data items"
_help_paragraph "  - If a specified "${-GMIC}" item appears to be an existing filename, the corresponding image data
\n     are loaded and inserted at the end of the image list (which is equivalent to the use of
\n     '"${c}"input filename"$n"').
\n
\n  - Special filenames '"${c}"-"$n"' and '"${c}"-.ext"$n"' stand for the standard input/output streams, optionally
\n     forced to be in a specific '"${g}"ext"$n"' file format (e.g. '"${c}"-.jpg"$n"' or '"${c}"-.png"$n"').
\n
\n  - The following special input strings may be used as "${-GMIC}" items to create and insert new
\n     images with prescribed values, at the end of the image list:
\n
\n    . '"${c}"[selection]"$n"' or '"${c}"[selection]xN"$n"': Insert 1 or N copies of already existing images.
\n       '"${g}"selection"$n"' may represent one or several images
\n       (see section '"${c}"Command items and selections"$n"' to learn more about selections).
\n
\n    . '"${c}"width[%],_height[%],_depth[%],_spectrum[%],_values"$n"': Insert a new image with specified
\n       size and values (adding '"${g}"%"$n"' to a dimension means 'percentage of the size along the same
\n       axis, taken from the last image '"${g}"[-1]"$n"''). Any specified dimension can be also written as
\n       '"${c}"[image]"$n"', and is then set to the size (along the same axis) of the existing specified image
\n       "${g}"[image]"$n". '"${g}"values"$n"' can be either a sequence of numbers separated by commas '"${g}","$n"', or a
\n       mathematical expression, as e.g. in input item '"${c}"256,256,1,3,[x,y,128]"$n"' which
\n       creates a 256x256 RGB color image with a spatial shading on the red and green channels.
\n       (see section '"${c}"Mathematical expressions"$n"' to learn more about mathematical expressions).
\n
\n    . '"${c}"(v1,v2,..)"$n"': Insert a new image from specified prescribed values. Value separator inside
\n       parentheses can be '"${g}","$n"' (column separator), '"${g}";"$n"' (row separator), '"${g}"/"$n"' (slice separator) or
\n       '"${g}"^"$n"' (channel separator). For instance, expression '"${c}"(1,2,3;4,5,6;7,8,9)"$n"' creates a 3x3 matrix
\n       (scalar image), with values running from 1 to 9.
\n
\n    . '"${c}"0"$n"': Insert a new '"${g}"empty"$n"' image, containing no pixel data. Empty images are used only in rare
\n       occasions.
\n
\n  - Input item '"${c}"name=value"$n"' declares a new variable '"${g}"name"$n"', or assign a new value
\n     to an existing variable. Variable names must use the character set "${g}"[a-zA-Z0-9_]"$n" and cannot
\n     start with a number.
\n
\n  - A variable definition is always local to the current command except when it starts by the
\n     underscore character '"${g}"_"$n"'. In that case, it becomes also accessible by any command invoked
\n     outside the current command scope (global variable).
\n
\n  - If a variable name starts with two underscores '"${g}"__"$n"', the global variable is also shared among
\n     different threads and can be read/set by commands running in parallel (see command '"${c}"parallel"$n"'
\n     for this purpose). Otherwise, it remains local to the thread that defined it.
\n
\n  - Numerical variables can be updated with the use of these special operators:
\n     '"${g}"+="$n"' (addition), '"${g}"-="$n"' (subtraction), '"${g}"*="$n"' (multiplication), '"${g}"/="$n"' (division), '"${g}"%="$n"' (modulo),
\n     '"${g}"&="$n"' (bitwise and), '"${g}"|="$n"' (bitwise or), '"${g}"^="$n"' (power), '"${g}"<<="$n"' and '"${g}">>="$n"' (bitwise left and right
\n     shifts). For instance, '"${c}"foo=1 foo+=3"$n"'.
\n
\n  - Input item '"${c}"name.=string"$n"' concatenates specified '"${g}"string"$n"' to the end of variable '"${g}"name"$n"'.
\n
\n  - Multiple variable assignments and updates are allowed, with expressions:
\n     '"${c}"name1,name2,...,nameN=value"$n"' or '"${c}"name1,name2,...,nameN=value1,value2,...,valueN"$n"'
\n     where assignment operator '"${g}"="$n"' can be replaced by one of the allowed operators
\n     (e.g. '"${g}"+="$n"').
"
_help_section "Command items and selections"
_help_paragraph "  - A "${-GMIC}" item that is not a filename nor a special input string designates a "${g}"command"$n",
\n     most of the time. Generally, commands perform image processing operations on one or several
\n     available images of the list.
\n
\n  - Reccurent commands have two equivalent names ("${g}"regular"$n" and "${g}"short"$n"). For instance, command names
\n     '"${c}"resize"$n"' and '"${c}"r"$n"' refer to the same image resizing action.
\n
\n  - A "${-GMIC}" command may have mandatory or optional "${g}"arguments"$n". Command arguments must be specified
\n     in the next item on the command line. Commas '"${g}","$n"' are used to separate multiple arguments of a
\n     single command, when required.
\n
\n  - The execution of a "${-GMIC}" command may be restricted only to a "${g}"subset"$n" of the image list, by
\n     appending '"${c}"[selection]"$n"' to the command name. Examples of valid syntaxes for '"${g}"selection"$n"' are:
\n
\n    . '"${c}"command[-2]"$n"': Apply command only on the penultimate image "${g}"[-2]"$n" of the list.
\n    . '"${c}"command[0,1,3]"$n"': Apply command only on images "${g}"[0],[1]"$n" and "${g}"[3]"$n".
\n    . '"${c}"command[3-6]"$n"': Apply command only on images "${g}"[3]"$n" to "${g}"[6]"$n" (i.e, "${g}"[3],[4],[5]"$n" and "${g}"[6]"$n").
\n    . '"${c}"command[50%-100%]"$n"': Apply command only on the second half of the image list.
\n    . '"${c}"command[0,-4--1]"$n"': Apply command only on the first image and the last four images.
\n    . '"${c}"command[0-9:3]"$n"': Apply command only on images "${g}"[0]"$n" to "${g}"[9]"$n", with a step of 3
\n                          (i.e. on images "${g}"[0], [3], [6]"$n" and "${g}"[9]"$n").
\n    . '"${c}"command[0-9:25%]"$n"': Apply command only on images "${g}"[0]"$n" to "${g}"[9]"$n", with a step of 25%
\n                          (i.e. on images "${g}"[0], [3], [6]"$n" and "${g}"[9]"$n").
\n    . '"${c}"command[0--1:2]"$n"': Apply command only on images of the list with even indices.
\n    . '"${c}"command[0,2-4,50%--1]"$n"': Apply command on images "${g}"[0],[2],[3],[4]"$n" and on the second half of
\n                                 the image list.
\n    . '"${c}"command[^0,1]"$n"': Apply command on all images except the first two.
\n    . '"${c}"command[name1,name2]"$n"': Apply command on named images '"${g}"name1"$n"' and '"${g}"name2"$n"'.
\n
\n  - indices in selections are always sorted in increasing order, and duplicate indices are
\n     discarded. For instance, selections '"${c}"[3-1,1-3]"$n"' and '"${c}"[1,1,1,3,2]"$n"' are both equivalent to
\n     '"${c}"[1-3]"$n"'. If you want to repeat a single command multiple times on an image, use a
\n     '"${c}"repeat..done"$n"' loop instead. Inverting the order of images for a command is achieved by
\n     explicitly inverting the order of the images in the list, with command '"${c}"reverse[selection]"$n"'.
\n
\n  - Command selections '"${c}"[-1]"$n"','"${c}"[-2]"$n"' and '"${c}"[-3]"$n"' are so often used that they have their own
\n     shortcuts, respectively '"${c}"."$n"', '"${c}".."$n"' and '"${c}"..."$n"'. For instance, command '"${c}"blur.."$n"' is equivalent to
\n     '"${c}"blur[-2]"$n"'. These shortcuts work also when specifying command arguments.
\n
\n  - "${-GMIC}" commands invoked without '"${c}"[selection]"$n"' are applied on all images of the list, i.e. the
\n     default selection is '"${c}"[0--1]"$n"' (except for command '"${c}"input"$n"' whose default selection is '"${c}"[-1]"$n"').
\n
\n  - Prepending a single hyphen '"${g}"-"$n"' to a "${-GMIC}" command is allowed. This may be useful to recognize
\n     command items more easily in a one-liner pipeline (typically invoked from a shell).
\n
\n  - A "${-GMIC}" command prepended with a plus sign '"${g}"+"$n"' or a double hyphen '"${g}"--"$n"' does not act 'in-place'
\n     but inserts its result as one or several new images at the end of the image list.
\n
\n  - There are two different types of commands that can be run by the "${-GMIC}" interpreter:
\n
\n    . "${g}"Builtin commands"$n", are the hard-coded functionalities in the interpreter core. They are thus
\n       compiled as binary code and run fast, most of the time. Omitting an argument when invoking a
\n       builtin command is not permitted, except if all following arguments are also omitted.
\n       For instance, invoking '"${c}"plasma 10,,5"$n"' is invalid but '"${c}"plasma 10"$n"' is correct.
\n    . "${g}"Custom commands"$n", are defined as "${-GMIC}" pipelines of builtin or other custom commands.
\n       They are interpreted by the "${-GMIC}" interpreter, and thus run a bit slower than builtin commands.
\n       Omitting arguments when invoking a custom command is permitted. For instance, expressions
\n       '"${c}"flower ,,,100,,2"$n"' or '"${c}"flower ,"$n"' are correct.
\n
\n  - Most of the existing commands in "${-GMIC}" are actually defined as "${g}"custom commands"$n".
\n
\n  - A user can easily add its own custom commands to the "${-GMIC}" interpreter (see section
\n     '"${c}"Adding custom commands"$n"' for more details). New builtin commands cannot be added
\n     (unless you modify the "${-GMIC}" interpreter source code and recompile it)."
_help_section "Input/output properties"
_help_paragraph "  - "${-GMIC}" is able to read/write most of the classical image file formats, including:
\n
\n    . 2D grayscale/color files: "${c}".png, .jpeg, .gif, .pnm, .tif, .bmp, ..."$n"
\n    . 3D volumetric files: "${c}".dcm, .hdr, .nii, .pan, .inr, .pnk, ..."$n"
\n    . video files: "${c}".mpeg, .avi, .mov, .ogg, .flv, ..."$n"
\n    . Generic ascii or binary data files: "${c}".gmz, .cimg, .cimgz, .dlm, .asc, .pfm, .raw, .txt, .h."$n"
\n    . 3D object files: "${c}".off."$n"
\n
\n  - When dealing with color images, "${-GMIC}" generally reads, writes and displays data using the usual
\n     sRGB color space.
\n
\n  - "${-GMIC}" is able to manage "${g}"3D objects"$n" that may be read from files or generated by "${-GMIC}" commands.
\n     A 3D object is stored as a one-column scalar image containing the object data, in the
\n     following order: "${g}"{ magic_number; sizes; vertices; primitives; colors; opacities }"$n".
\n     These 3D representations can be then processed as regular images.
\n     (see command '"${c}"split3d"$n"' for accessing each of these 3D object data separately).
\n
\n  - Be aware that usual file formats may be sometimes not adapted to store all the available image
\n     data, since "${-GMIC}" uses float-valued image buffers. For instance, saving an image that was
\n     initially loaded as a 16bits/channel image, as a "${c}".jpg"$n" file will result in a loss of
\n     information. Use the "${-GMIC}"-specific file extension "${c}".gmz"$n" to ensure that all data
\n     precision is preserved when saving images.
\n
\n  - Sometimes, file options may/must be set for file formats:
\n
\n    . "${g}"Video files:"$n" Only sub-frames of an image sequence may be loaded, using the input expression
\n       '"${c}"filename.ext,[first_frame[,last_frame[,step]]]"$n"'. Set '"${g}"last_frame==-1"$n"' to tell it must be
\n       the last frame of the video. Set '"${g}"step"$n"' to 0 to force an opened video file to be
\n       opened/closed. Output framerate and codec can be also set by using the output expression
\n       '"${c}"filename.avi,_fps,_codec,_keep_open={ 0 | 1 }"$n"'. '"${g}"codec"$n"' is a 4-char string
\n       (see "${r}"http://www.fourcc.org/codecs.php"$n") or '"${g}"0"$n"' for the default codec. '"${g}"keep_open"$n"' tells if
\n       the output video file must be kept open for appending new frames afterwards.
\n
\n    . "${g}".cimg[z] files:"$n" Only crops and sub-images of .cimg files can be loaded, using the input
\n      expressions '"${c}"filename.cimg,N0,N1"$n"', '"${c}"filename.cimg,N0,N1,x0,x1"$n"',
\n      '"${c}"filename.cimg,N0,N1,x0,y0,x1,y1"$n"', '"${c}"filename.cimg,N0,N1,x0,y0,z0,x1,y1,z1"$n"' or
\n      '"${c}"filename.cimg,N0,N1,x0,y0,z0,c0,x1,y1,z1,c1"$n"'.
\n      Specifying '"${g}"-1"$n"' for one coordinates stands for the maximum possible value. Output expression
\n      '"${c}"filename.cimg[z][,datatype]"$n"' can be used to force the output pixel type. '"${g}"datatype"$n"' can be
\n      "${g}"{ auto | uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }"$n".
\n
\n    . "${g}".raw binary files:"$n" Image dimensions and input pixel type may be specified when loading "${g}".raw"$n"
\n       files with input expression
\n       '"${c}"filename.raw[,datatype][,width][,height[,depth[,dim[,offset]]]]]"$n"'. If no dimensions are
\n       specified, the resulting image is a one-column vector with maximum possible height. Pixel
\n       type can also be specified with the output expression '"${c}"filename.raw[,datatype]"$n"'.
\n       '"${g}"datatype"$n"' can be the same as for "${g}".cimg[z]"$n" files.
\n
\n    . "${g}".yuv files:"$n" Image dimensions must be specified when loading, and only sub-frames of an image sequence
\n       may be loaded, using the input expression
\n       '"${c}"filename.yuv,width,height[,chroma_subsampling[,first_frame[,last_frame[,step]]]"$n"'.
\n       '"${g}"chroma_subsampling"$n"' can be "${g}"{ 420 | 422 | 444 }"$n".
\n       When saving, chroma subsampling mode can be specified with output expression
\n       '"${c}"filename.yuv[,chroma_subsampling]"$n"'.
\n
\n    . "${g}".tiff files:"$n" Only sub-images of multi-pages tiff files can be loaded, using the input
\n       expression '"${c}"filename.tif,_first_frame,_last_frame,_step"$n"'.
\n       Output expression '"${c}"filename.tiff,_datatype,_compression,_force_multipage,_use_bigtiff"$n"' can
\n       be used to specify the output pixel type, as well as the compression method.
\n       '"${g}"datatype"$n"' can be the same as for "${g}".cimg[z]"$n" files. '"${g}"compression"$n"' can be
\n       "${g}"{ none (default) | lzw | jpeg }"$n". '"${g}"force_multipage"$n" can be "${g}"{ 0=no (default) | 1=yes }"$n".
\n       '"${g}"use_bigtiff"$n" can be "${g}"{ 0=no | 1=yes (default) }"$n".
\n
\n    . "${g}".gif files:"$n" Animated gif files can be saved, using the input expression
\n       '"${c}"filename.gif,fps>0,nb_loops"$n"'. Specify '"${g}"nb_loops=0"$n"' to get an infinite number of animation
\n       loops (this is the default behavior).
\n
\n    . "${g}".jpeg files:"$n" The output quality may be specified (in %), using the output expression
\n       '"${c}"filename.jpg,30"$n"' (here, to get a 30% quality output). '"${g}"100"$n"' is the default.
\n
\n    . "${g}".mnc files:"$n" The output header can set from another file, using the output expression
\n       '"${c}"filename.mnc,header_template.mnc"$n"'.
\n
\n    . "${g}".pan, .cpp, .hpp, .c and .h files:"$n" The output datatype can be selected with output expression
\n       '"${c}"filename[,datatype]"$n"'. '"${g}"datatype"$n"' can be the same as for "${g}".cimg[z]"$n" files.
\n
\n    . "${g}".gmic files:"$n" These filenames are assumed to be "${-GMIC}" custom commands files. Loading such a
\n       file will add the commands it defines to the interpreter. Debug information can be
\n       enabled/disabled by the input expression '"${c}"filename.gmic[,add_debug_info={ 0 | 1 }]"$n"'.
\n
\n    . Inserting '"${c}"ext:"$n"' on the beginning of a filename (e.g. '"${c}"jpg:filename"$n"') forces "${-GMIC}" to
\n       read/write the file as it would have been done if it had the specified extension '"${g}".ext"$n"'.
\n
\n  - Some input/output formats and options may not be supported, depending on the configuration
\n     flags that have been set during the build of the "${-GMIC}" software."
_help_section "Substitution rules"
_help_paragraph "  - "${-GMIC}" items containing '"${g}"$"$n"' or '"${g}"{}"$n"' are substituted before being interpreted. Use these
\n     substituting expressions to access various data from the interpreter environment.
\n
\n  - '"${c}"$name"$n"' and '"${c}"${name}"$n"' are both substituted by the value of the specified named "${g}"variable"$n"
\n     (set previously by the item '"${c}"name=value"$n"'). If this variable has not been already set, the
\n     expression is substituted by the highest positive "${g}"index"$n" of the named image '"${g}"[name]"$n"'. If no
\n     image has this name, the expression is substituted by the value of the "${g}"OS environment variable"$n"
\n     with same name (it may be thus an empty string).
\n     The following reserved variables are predefined by the "${-GMIC}" interpreter:
\n
\n       . '"${c}"$!"$n"': The current number of images in the list.
\n       . '"${c}"$>"$n"' and '"${c}"$<"$n"': The increasing/decreasing index of the latest (currently running)
\n          '"${c}"repeat...done"$n"' loop. '"${c}"$>"$n"' goes from '"${g}"0"$n"' (first loop iteration) to
\n          '"${g}"nb_iterations - 1"$n"' (last iteration). '"${c}"$>"$n"' does the opposite.
\n       . '"${c}"$/"$n"': The current call stack. Stack items are separated by slashes '"${g}"/"$n"'.
\n       . '"${c}"$|"$n"': The current value (expressed in seconds) of a millisecond precision timer.
\n       . '"${c}"$^"$n"': The current verbosity level.
\n       . '"${c}"$_cpus"$n"': The number of computation cores available on your machine.
\n       . '"${c}"$_pid"$n"': The current process identifier, as an integer.
\n       . '"${c}"$_prerelease"$n"': For pre-releases only, the date of the pre-release as '"${g}"yymmdd"$n"'.
\n          For stable releases, this variable is not defined.
\n       . '"${c}"$_version"$n"': A 3-digits number telling about the current version of the "${-GMIC}" interpreter
\n          (e.g. '"$g$_version$n"').
\n       . '"${c}"$_vt100"$n"': Set to "${g}"1"$n" (default value) if colored text output is allowed on the console.
\n       . '"${c}"$_path_rc"$n"': The path to the "${-GMIC}" folder used to store resources and configuration files
\n         (its value is OS-dependent).
\n       . '"${c}"$_path_user"$n"': The path to the "${-GMIC}" user file "${g}".gmic"$n" or "${g}"user.gmic"$n" (its value is
\n          OS-dependent).
\n
\n  - '"${c}"$$name"$n"' and '"${c}"$${name}"$n"' are both substituted by the G'MIC script code of the specified named
\n     "${g}"custom command"$n", or by an empty string if no custom command with specified name exists.
\n
\n  - '"${c}"${\"-pipeline\"}"$n"' is substituted by the "${g}"status value"$n" after the execution of the specified
\n     "${-GMIC}" pipeline (see command '"${c}"status"$n"'). Expression '"${c}"${}"$n"' thus stands for the
\n     "${g}"current status value"$n".
\n
\n  - '"${c}"{``string}"$n"' (starting with two backquotes) is substituted by a "${g}"double-quoted version"$n" of the
\n     specified string.
\n
\n  - '"${c}"{/string}"$n"' is substituted by the "${g}"escaped version"$n" of the specified string.
\n
\n  - '"${c}"{'string'}"$n"' (between single quotes) is substituted by the "${g}"sequence of ascii codes"$n" that compose
\n     the specified string, separated by commas '"${g}","$n"'. For instance, item '"${c}"{'foo'}"$n"' is substituted
\n     by '"${c}"102,111,111"$n"'.
\n
\n  - '"${c}"{image,feature}"$n"' is substituted by a specific feature of the image "${c}"[image]"$n". '"${g}"image"$n"' can be
\n     either an image number or an image name. It can be also eluded, in which case, the last image
\n     '"${c}"[-1]"$n"' of the list is considered for the requested feature.
\n     Specified '"${g}"feature"$n"' can be one of:
\n
\n       . '"${c}"b"$n"': The image basename (i.e. filename without the folder path nor extension).
\n       . '"${c}"f"$n"': The image folder name.
\n       . '"${c}"n"$n"': The image name or filename (if the image has been read from a file).
\n       . '"${c}"t"$n"': The text string from the image values regarded as ascii codes.
\n       . '"${c}"x"$n"': The image extension (i.e the characters after the last '.' in the image name).
\n       . '"${c}"^"$n" : The sequence of all image values, separated by commas ','.
\n       . '"${c}"@subset"$n"': The sequence of image values corresponding to the specified subset, and
\n          separated by commas ','.
\n       . Any other '"${c}"feature"$n"' is considered as a "${g}"mathematical expression"$n" associated to the image
\n          "${c}"[image]"$n" and is substituted by the result of its evaluation (float value). For instance,
\n          expression '"${c}"{0,w+h}"$n"' is substituted by the sum of the width and height of the first image
\n          (see section '"${c}"Mathematical expressions"$n"' for more details). If a mathematical expression
\n          starts with an underscore '"${g}"_"$n"', the resulting value is truncated to a readable format.
\n          For instance, item '"${c}"{_pi}"$n"' is substituted by '"${g}"3.14159"$n"' (while '"${c}"{pi}"$n"' is substituted by
\n          '"${g}"3.141592653589793"$n"').
\n       . A '"${c}"feature"$n"' delimited by backquotes is replaced by a string whose ascii codes correspond
\n          to the list of values resulting from the evaluation of the specified mathematical
\n          expression. For instance, item '"${c}"{`[102,111,111]`}"$n"' is substituted by '"${c}"foo"$n"' and item
\n          '"${c}"{`vector8(65)`}"$n"' by '"${c}"AAAAAAAA"$n"'.
\n
\n  - '"${c}"{*}"$n"' is substituted by the "${g}"visibility state"$n" of the instant display window "${c}"[0]"$n" (can be
\n     "${g}"{ 0=closed | 1=visible }"$n").
\n
\n  - '"${c}"{*,feature1,...,featureN}"$n"' or '"${c}"{*index,feature1,...,featureN}"$n"' is substituted by a specific
\n      set of features of the instant display window "${c}"#0"$n" (or "${c}"#index"$n", if specified).
\n      Requested '"${g}"features"$n"' can be:
\n
\n       . '"${c}"w"$n"': display width (i.e. width of the display area managed by the window).
\n       . '"${c}"h"$n"': display height (i.e. height of the display area managed by the window).
\n       . '"${c}"wh"$n"': display width x display height.
\n       . '"${c}"d"$n"': window width (i.e. width of the window widget).
\n       . '"${c}"e"$n"': window height (i.e. height of the window widget).
\n       . '"${c}"de"$n"': window width x window height.
\n       . '"${c}"u"$n"': screen width (actually independent on the window size).
\n       . '"${c}"v"$n"': screen height (actually independent on the window size).
\n       . '"${c}"uv"$n"': screen width x screen height.
\n       . '"${c}"n"$n"': current normalization type of the instant display.
\n       . '"${c}"t"$n"': window title of the instant display.
\n       . '"${c}"x"$n"': X-coordinate of the mouse position (or -1, if outside the display area).
\n       . '"${c}"y"$n"': Y-coordinate of the mouse position (or -1, if outside the display area).
\n       . '"${c}"b"$n"': state of the mouse buttons { 1=left-but. | 2=right-but. | 4=middle-but. }.
\n       . '"${c}"o"$n"': state of the mouse wheel.
\n       . '"${c}"k"$n"': decimal code of the pressed key if any, 0 otherwise.
\n       . '"${c}"c"$n"': boolean (0 or 1) telling if the instant display has been closed recently.
\n       . '"${c}"r"$n"': boolean telling if the instant display has been resized recently.
\n       . '"${c}"m"$n"': boolean telling if the instant display has been moved recently.
\n       . Any other '"${c}"feature"$n"' stands for a "${g}"keycode name"$n" (in capital letters), and is substituted by
\n          a boolean describing the current key state "${g}"{ 0=pressed | 1=released }"$n".
\n       . You can also prepend a hyphen '"${c}"-"$n"' to a '"${g}"feature"$n"' (that supports it) to flush the
\n          corresponding event immediately after reading its state (works for keys, mouse and
\n          window events).
\n
\n  - Item substitution is "${g}"never performed in items between double quotes"$n". One must break the quotes
\n    to enable substitution if needed, as in '"${c}"\"3+8 kg = \"{3+8}\" kg\""$n"'. Using double quotes is then
\n    a convenient way to disable the substitutions mechanism in items, when necessary.
\n
\n  - One can also disable the substitution mechanism on items outside double quotes, by escaping the
\n     '"${g}"{"$n"','"${g}"}"$n"' or '"${g}"$"$n"' characters, as in '"${c}"\\{3+4\\}\\ doesn\47t\\ evaluate"$n"'."
_help_section "Mathematical expressions"
_help_paragraph "  - "${-GMIC}" has an embedded "${g}"mathematical parser"$n". It is used to evaluate (possibly complex) expressions
\n     inside braces '"${g}"{}"$n"', or formulas in commands that may take one as an argument (e.g. '"${c}"fill"$n"').
\n
\n  - When the context allows it, a formula is evaluated "${g}"for each pixel"$n" of the selected images
\n     (e.g. '"${c}"fill"$n"').
\n
\n  - A math expression may return a "${g}"scalar"$n" or "${g}"vector"$n"-valued result (with a fixed number of
\n     components).
\n
\n  - The mathematical parser understands the following set of functions, operators and variables:
\n
\n    _ "${g}"Usual operators:"$n" "${c}"||"$n" (logical or), "${c}"&&"$n" (logical and), "${c}"|"$n" (bitwise or), "${c}"&"$n" (bitwise and),
\n       "${c}"!=, ==, <=, >=, <, >, <<"$n" (left bitwise shift), "${c}">>"$n" (right bitwise shift), "${c}"-, +, *, /,
\n       %"$n" (modulo), "${c}"^"$n" (power), "${c}"!"$n" (logical not), "${c}"~"$n" (bitwise not),
\n       "${c}"++"$n", "${c}"--"$n", "${c}"+="$n", "${c}"-="$n", "${c}"*="$n", "${c}"/="$n", "${c}"%="$n", "${c}"&="$n", "${c}"|="$n", "${c}"^="$n", "${c}">>="$n", "${c}"<<="$n" (in-place operators).
\n
\n    _ "${g}"Usual math functions:"$n" "${c}"abs(), acos(), acosh(), arg(), argkth(), argmax(), argmin(), asin(),
\n       asinh(), atan(), atan2(), atanh(), avg(), bool(), cbrt(), ceil(), cos(), cosh(), cut(), exp(), fact(),
\n       fibo(), floor(), gauss(), int(), isval(), isnan(), isinf(), isint(), isbool(), isfile(), isdir(), isin(),
\n       kth(), log(), log2(), log10(), max(), med(), min(), narg(), prod(), rol()"$n" (left bit rotation),
\n       "${c}"ror()"$n" (right bit rotation)"${c}", round(), sign(), sin(), sinc(), sinh(), sqrt(), std(),
\n       srand(_seed), sum(), tan(), tanh(), var(), xor()"$n".
\n
\n       . '"${c}"atan2(y,x)"$n"' is the version of '"${c}"atan()"$n"' with two arguments '"${g}"y"$n"' and '"${g}"x"$n"' (as in C/C++).
\n       . '"${c}"permut(k,n,with_order)"$n"' computes the number of permutations of "${g}"k"$n" objects from a set of
\n          "${g}"n"$n" objects.
\n       . '"${c}"gauss(x,_sigma,_is_normalized)"$n"' returns '"${g}"exp(-x^2/(2*s^2))/(is_normalized?sqrt(2*pi*sigma^2):1)"$n"'.
\n       . '"${c}"cut(value,min,max)"$n"' returns value if it is in range "${g}"[min,max]"$n", or "${g}"min"$n" or "${g}"max"$n" otherwise.
\n       . '"${c}"narg(a_1,...,a_N)"$n"' returns the number of specified arguments (here, "${g}"N"$n").
\n       . '"${c}"arg(i,a_1,..,a_N)"$n"' returns the "${g}"ith"$n" argument "${g}"a_i"$n".
\n       . '"${c}"isval()"$n"', '"${c}"isnan()"$n"', '"${c}"isinf()"$n"', '"${c}"isint()"$n"', '"${c}"isbool()"$n"' test the type of the given
\n          number or expression, and return "${g}"0 (false)"$n" or "${g}"1 (true)"$n".
\n       . '"${c}"isfile()"$n"' (resp. '"${c}"isdir()"$n"') returns "${g}"0 (false)"$n" or "${g}"1 (true)"$n" whether its argument is a
\n          path to an existing file (resp. to a directory) or not.
\n       . '"${c}"isin(v,a_1,...,a_n)"$n"' returns "${g}"0 (false)"$n" or "${g}"1 (true)"$n" whether the first value '"${g}"v"$n"' appears
\n          in the set of other values 'a_i'.
\n       . '"${c}"argmin()"$n"', '"${c}"argmax()"$n"', '"${c}"avg()"$n"', '"${c}"kth()"$n"', '"${c}"max()"$n"', '"${c}"med()"$n"', '"${c}"min()"$n"', '"${c}"std()"$n"', '"${c}"sum()"$n"'
\n          and '"${c}"var()"$n"' can be called with an arbitrary number of scalar/vector arguments.
\n       . '"${c}"round(value,rounding_value,direction)"$n"' returns a rounded value. '"${g}"direction"$n"' can be
\n          "${g}"{ -1=to-lowest | 0=to-nearest | 1=to-highest }"$n".
\n
\n    _ "${g}"Variable names"$n" below are pre-defined. They can be overridden.
\n
\n       . '"${c}"l"$n"': length of the associated list of images.
\n       . '"${c}"w"$n"': width of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"h"$n"': height of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"d"$n"': depth of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"s"$n"': spectrum of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"r"$n"': shared state of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"wh"$n"': shortcut for width x height.
\n       . '"${c}"whd"$n"': shortcut for width x height x depth.
\n       . '"${c}"whds"$n"': shortcut for width x height x depth x spectrum (i.e. number of image values).
\n       . '"${c}"im"$n"','"${c}"iM"$n"','"${c}"ia"$n"','"${c}"iv"$n"','"${c}"is"$n"','"${c}"ip"$n"','"${c}"ic"$n"': Respectively the minimum, maximum, average,
\n          variance, sum, product and median value of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"xm"$n"','"${c}"ym"$n"','"${c}"zm"$n"','"${c}"cm"$n"': The pixel coordinates of the minimum value in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"xM"$n"','"${c}"yM"$n"','"${c}"zM"$n"','"${c}"cM"$n"': The pixel coordinates of the maximum value in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . All these variables are considered as "${g}"constant values"$n" by the math parser (for optimization
\n          purposes) which is indeed the case most of the time. Anyway, this might not be the case,
\n          if function '"${c}"resize(#ind,..)"$n"' is used in the math expression.
\n          If so, it is safer to invoke functions '"${c}"l()"$n"', '"${c}"w(_#ind)"$n"', '"${c}"h(_#ind)"$n"', ... '"${c}"s(_#ind)"$n"'
\n          and '"${c}"ic(_#ind)"$n"' instead of the corresponding named variables.
\n       . '"${c}"i"$n"': current processed pixel value (i.e. value located at "${g}"(x,y,z,c)"$n") in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"iN"$n"': Nth channel value of current processed pixel (i.e. value located at "${g}"(x,y,z,N)"$n") in
\n          the associated image, if any ("${g}"0"$n" otherwise). '"${g}"N"$n"' must be an integer in range "${g}"[0,9]"$n".
\n       . '"${c}"R"$n"','"${c}"G"$n"','"${c}"B"$n"' and '"${c}"A"$n"' are equivalent to '"${c}"i0"$n"', '"${c}"i1"$n"', '"${c}"i2"$n"' and '"${c}"i3"$n"' respectively.
\n       . '"${c}"I"$n"': current vector-valued processed pixel in the associated image, if any ("${g}"0"$n" otherwise).
\n          The number of vector components is equal to the number of image channels
\n          (e.g. "${g}"I = [ R,G,B ]"$n" for a "${g}"RGB"$n" image).
\n       . You may add '"${c}"#ind"$n"' to any of the variable name above to retrieve the information for any
\n          numbered image "${g}"[ind]"$n" of the list (when this makes sense). For instance '"${c}"ia#0"$n"' denotes the
\n          average value of the first image of the list).
\n       . '"${c}"x"$n"': current processed column of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"y"$n"': current processed row of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"z"$n"': current processed slice of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"c"$n"': current processed channel of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"t"$n"': thread id when an expression is evaluated with multiple threads ("${g}"0"$n" means
\n          'master thread').
\n       . '"${c}"e"$n"': value of e, i.e. "${g}"2.71828..."$n"
\n       . '"${c}"pi"$n"': value of pi, i.e. "${g}"3.1415926..."$n"
\n       . '"${c}"u"$n"': a random value between "${g}"[0,1]"$n", following a uniform distribution.
\n       . '"${c}"g"$n"': a random value, following a gaussian distribution of variance 1
\n          (roughly in "${g}"[-6,6]"$n").
\n       . '"${c}"interpolation"$n"': value of the default interpolation mode used when reading pixel values
\n           with the pixel access operators (i.e. when the interpolation argument is not explicitly
\n           specified, see below for more details on pixel access operators). Its initial default
\n           value is "${g}"0"$n".
\n       . '"${c}"boundary"$n"': value of the default boundary conditions used when reading pixel values with
\n           the pixel access operators (i.e. when the boundary condition argument is not explicitly
\n           specified, see below for more details on pixel access operators). Its initial default
\n           value is "${g}"0"$n".
\n
\n    _ "${g}"Vector calculus:"$n" Most operators are also able to work with vector-valued elements.
\n
\n       . '"${c}"[ a0,a1,...,aN-1 ]"$n"' defines a "${g}"N"$n"-dimensional vector with scalar coefficients "${g}"ak"$n".
\n       . '"${c}"vectorN(a0,a1,,...,aN-1)"$n"' does the same, with the "${g}"ak"$n" being repeated periodically if only a
\n          few are specified.
\n       . In both previous expressions, the "${g}"ak"$n" can be vectors themselves, to be concatenated into a
\n          single vector.
\n       . The scalar element "${g}"ak"$n" of a vector "${g}"X"$n" is retrieved by '"${c}"X[k]"$n"'.
\n       . The sub-vector "${g}"[ X[p]...X[p+q-1] ]"$n" (of size "${g}"q"$n") of a vector "${g}"X"$n" is retrieved by '"${c}"X[p,q]"$n"'.
\n       . Equality/inequality comparisons between two vectors is done with operators '"${c}"=="$n"' and '"${c}"!="$n"'.
\n       . Some vector-specific functions can be used on vector values:
\n         '"${c}"cross(X,Y)"$n"' (cross product), '"${c}"dot(X,Y)"$n"' (dot product), '"${c}"size(X)"$n"' (vector dimension),
\n         '"${c}"sort(X,_is_increasing,_chunk_size)"$n"' (sorting values), '"${c}"reverse(A)"$n"' (reverse order of
\n         components), '"${c}"shift(A,_length,_boundary_conditions)"$n"' and
\n         '"${c}"same(A,B,_nb_vals,_is_case_sensitive)"$n"' (vector equality test).
\n       . Function '"${c}"normP(u1,...,un)"$n"' computes the LP-norm of the specified vector
\n          ("${c}"P"$n" being an "${g}"unsigned integer"$n" constant or '"${g}"inf"$n"'). If "${c}"P"$n" is omitted, the L2 norm is used.
\n       . Function '"${c}"resize(A,size,_interpolation,_boundary_conditions)"$n"' returns a resized version of
\n          a vector '"${g}"A"$n"' with specified interpolation mode. '"${g}"interpolation'"$n" can be "${g}"{ -1=none
\n          (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic |
\n          6=lanczos }"$n", and '"${g}"boundary_conditions'"$n"  can be "${g}"{ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }"$n".
\n       . Function '"${c}"find(A,B,_is_forward,_starting_index)"$n"' returns the index where sub-vector "${g}"B"$n"
\n          appears in vector "${g}"A"$n", (or "${g}"-1"$n" if "${g}"B"$n" is not found in "${g}"A"$n"). Argument "${g}"A"$n" can be also replaced by
\n          an image index "${g}"#ind"$n".
\n       . A "${g}"2"$n"-dimensional vector may be seen as a complex number and used in those particular
\n          functions/operators:
\n          '"${c}"**"$n"' (complex multiplication), '"${c}"//"$n"' (complex division), '"${c}"^^"$n"' (complex exponentiation),
\n          '"${c}"**="$n"' (complex self-multiplication), '"${c}"//="$n"' (complex self-division), '"${c}"^^="$n"' (complex
\n          self-exponentiation), '"${c}"cabs()"$n"' (complex modulus), '"${c}"carg()"$n"' (complex argument), '"${c}"cconj()"$n"'
\n          (complex conjugate), '"${c}"cexp()"$n"' (complex exponential) and '"${c}"clog()"$n"' (complex logarithm).
\n       . A "${g}"MN"$n"-dimensional vector may be seen as a "${g}"M"${n}" x "${g}"N"$n" matrix and used in those particular
\n          functions/operators:
\n          '"${c}"*"$n"' (matrix-vector multiplication), '"${c}"det(A)"$n"' (determinant), '"${c}"diag(V)"$n"' (diagonal matrix
\n          from a vector), '"${c}"eig(A)"$n"' (eigenvalues/eigenvectors), '"${c}"eye(n)"$n"' (n x n identity matrix),
\n          '"${c}"inv(A)"$n"' (matrix inverse), '"${c}"mul(A,B,_nb_colsB)"$n"' (matrix-matrix multiplication),
\n          '"${c}"pseudoinv(A,_nb_colsA)"$n"', '"${c}"rot(u,v,w,angle)"$n"' (3D rotation matrix), '"${c}"rot(angle)"$n"' (2D
\n          rotation matrix), '"${c}"solve(A,B,_nb_colsB)"$n"' (least-square solver of linear system A.X = B),
\n          '"${c}"svd(A,_nb_colsA)"$n"' (singular value decomposition), '"${c}"trace(A)"$n"' (matrix trace) and
\n          '"${c}"transp(A,nb_colsA)"$n"' (matrix transpose). Argument '"${c}"nb_colsB"$n"' may be omitted if it is
\n          equal to "${g}"1"$n".
\n       . Specifying a vector-valued math expression as an argument of a command that operates on
\n          image values (e.g. '"${c}"fill"$n"') modifies the whole spectrum range of the processed image(s),
\n          for each spatial coordinates "${g}"(x,y,z)"$n". The command does not loop over the "${g}"C"$n"-axis in this
\n          case.
\n
\n    _ "${g}"String manipulation:"$n" Character strings are defined and managed as vectors objects.
\n       Dedicated functions and initializers to manage strings are
\n
\n       . "${c}"[ 'string' ]"$n" and "${c}"'string'"$n" define a vector whose values are the ascii codes of the
\n          specified "${g}"character string"$n" (e.g. "${c}"'foo'"$n" is equal to "${g}"[ 102,111,111 ]"$n").
\n       . "${c}"_'character'"$n" returns the (scalar) ascii code of the specified character (e.g. "${c}"_'A'"$n" is
\n          equal to "${g}"65"$n").
\n       . A special case happens for "${g}"empty"$n" strings: Values of both expressions "${c}"[ '' ]"$n" and "${c}"''"$n" are "${g}"0"$n".
\n       . Functions '"${c}"lowercase()"$n"' and '"${c}"uppercase()"$n"' return string with all string characters
\n          lowercased or uppercased.
\n       . Function '"${c}"stov(str,_starting_index,_is_strict)"$n"' parses specified string '"${c}"str"$n"' and returns the value
\n          contained in it.
\n       . Function '"${c}"vtos(expr,_nb_digits,_siz)"$n"' returns a vector of size '"${c}"siz"$n"' which contains
\n          the ascii representation of values described by expression '"${c}"expr"$n"'.
\n          '"${c}"nb_digits"$n"' can be "${g}"{ -1=auto-reduced | 0=all | >0=max number of digits }"$n".
\n       . Function '"${c}"echo(str1,str2,...,strN)"$n"' prints the concatenation of given string arguments
\n          on the console.
\n       . Function '"${c}"cats(str1,str2,...,strN,siz)"$n"' returns the concatenation of given string arguments
\n          as a new vector of size '"${c}"siz"$n"'.
\n
\n    _ "${g}"Special operators"$n" can be used:
\n
\n       . '"${c}";"$n"': expression separator. The returned value is always the last encountered expression.
\n          For instance expression '"${c}"1;2;pi"$n"' is evaluated as '"${c}"pi"$n"'.
\n       . '"${c}"="$n"': variable assignment. Variables in mathematical parser can only refer to numerical
\n          values (vectors or scalars). Variable names are case-sensitive. Use this operator in
\n          conjunction with '"${c}";"$n"' to define more complex evaluable expressions, such as
\n          '"${c}"t=cos(x);3*t^2+2*t+1"$n"'.
\n          These variables remain "${g}"local"$n" to the mathematical parser and cannot be accessed outside
\n           the evaluated expression.
\n       . Variables defined in math parser may have a "${g}"constant"$n" property, by specifying keyword '"${c}"const"$n"'
\n          before the variable name (e.g. '"${c}"const foo = pi/4;"$n"'). The value set to such a variable must
\n          be indeed a "${c}"constant scalar"$n". Constant variables allows certain types of optimizations in
\n          the math JIT compiler.
\n
\n    _ The following "${g}"specific functions"$n" are also defined:
\n
\n       . '"${c}"u(max)"$n"' or '"${c}"u(min,max)"$n"': return a random value between "${g}"[0,max]"$n" or "${g}"[min,max]"$n", following
\n          a uniform distribution.
\n       . '"${c}"i(_a,_b,_c,_d,_interpolation_type,_boundary_conditions)"$n"': return the value of the pixel
\n          located at position "${g}"(a,b,c,d)"$n" in the associated image, if any ("${g}"0"$n" otherwise).
\n          '"${g}"interpolation_type"$n"' can be "${g}"{ 0=nearest neighbor | other=linear }"$n".
\n          '"${g}"boundary_conditions"$n"' can be "${g}"{ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }"$n".
\n          Omitted coordinates are replaced by their default values which are respectively
\n          "${c}"x, y, z, c, interpolation"$n" and "${c}"boundary"$n".
\n          For instance command '"${c}"fill 0.5*(i(x+1)-i(x-1))"$n"' will estimate the X-derivative of an
\n          image with a classical finite difference scheme.
\n       . '"${c}"j(_dx,_dy,_dz,_dc,_interpolation_type,_boundary_conditions)"$n"' does the same for the pixel
\n          located at position "${g}"(x+dx,y+dy,z+dz,c+dc)"$n" (pixel access relative to the current
\n          coordinates).
\n       . '"${c}"i[offset,_boundary_conditions]"$n"' returns the value of the pixel located at specified
\n          '"${g}"offset"$n"' in the associated image buffer (or "${g}"0"$n" if offset is out-of-bounds).
\n       . '"${c}"j[offset,_boundary_conditions]"$n"' does the same for an offset relative to the current pixel
\n          coordinates "${g}"(x,y,z,c)"$n".
\n       . '"${c}"i(#ind,_x,_y,_z,_c,_interpolation,_boundary_conditions)"$n"',
\n          '"${c}"j(#ind,_dx,_dy,_dz,_dc,_interpolation,_boundary_conditions)"$n"',
\n          '"${c}"i[#ind,offset,_boundary_conditions]"$n"' and '"${c}"i[offset,_boundary_conditions]"$n"' are similar expressions used to
\n          access pixel values for any numbered image "${g}"[ind]"$n" of the list.
\n       . '"${c}"I/J[offset,_boundary_conditions]"$n"' and '"${c}"I/J(#ind,_x,_y,_z,_interpolation,_boundary_conditions)"$n"' do
\n          the same as '"${c}"i/j[offset,_boundary_conditions]"$n"' and
\n          '"${c}"i/j(#ind,_x,_y,_z,_c,_interpolation,_boundary_conditions)"$n"' but return a vector instead of a scalar
\n          (e.g. a vector "${g}"[ R,G,B ]"$n" for a pixel at "${g}"(a,b,c)"$n" in a color image).
\n       . '"${c}"sort(#ind,_is_increasing,_axis)"$n"' sorts the values in the specified image "${g}"[ind]"$n".
\n       . '"${c}"crop(_#ind,_x,_y,_z,_c,_dx,_dy,_dz,_dc,_boundary_conditions)"$n"' returns a vector whose values come
\n          from the cropped region of image "${g}"[ind]"$n" (or from default image selected if '"${c}"ind"$n"' is not
\n          specified). Cropped region starts from point "${g}"(x,y,z,c)"$n" and has a size of
\n          "${g}"dx x dy x dz x dc"$n". Arguments for coordinates and sizes can be omitted if they are not
\n          ambiguous (e.g. '"${c}"crop(#ind,x,y,dx,dy)"$n"' is a valid invocation of this function).
\n       . '"${c}"draw(_#ind,S,x,y,z,c,dx,_dy,_dz,_dc,_opacity,_M,_max_M)"$n"' draws a sprite "${g}"S"$n" in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) at coordinates "${g}"(x,y,z,c)"$n".
\n          The size of the sprite "${g}"dx x dy x dz x dc"$n" must be specified. You can also specify a
\n          corresponding opacity mask "${g}"M"$n" if its size matches "${g}"S"$n".
\n       . '"${c}"polygon(_#ind,nb_vertices,coords,_opacity,_color)"$n"' draws a filled polygon in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) at specified coordinates.
\n          It draws a single line if '"${c}"nb_vertices"$n"' is set to 2.
\n       . '"${c}"polygon(_#ind,-nb_vertices,coords,_opacity,_pattern,_color)"$n"' draws a outlined polygon in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) at specified coordinates and with specified
\n          line pattern. It draws a single line if '"${c}"nb_vertices"$n"' is set to 2.
\n       . '"${c}"ellipse(_#ind,xc,yc,radius1,_radius2,_angle,_opacity,_color)"$n"' draws a filled ellipse in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) with specified coordinates.
\n          If both radius are negative, this function draws an outlined ellipse instead.
\n       . '"${c}"resize(#ind,w,_h,_d,_s,_interp,_boundary_conditions,_cx,_cy,_cz,_cc)"$n"' resizes an image of the
\n          associated list with specified dimension and interpolation method. When using this,
\n          function, you should consider retrieving the (non-constant) image dimensions using the
\n          dynamic functions '"${c}"w(_#ind)"$n"', '"${c}"h(_#ind)"$n"', '"${c}"d(_#ind)"$n"', '"${c}"s(_#ind)"$n"', '"${c}"wh(_#ind)"$n"',
\n          '"${c}"whd(_#ind)"$n"' and '"${c}"whds(_#ind)"$n"' instead of the corresponding constant variables.
\n       . '"${c}"if(condition,expr_then,_expr_else)"$n"': return value of '"${c}"expr_then"$n"' or '"${c}"expr_else"$n"',
\n          depending on the value of '"${c}"condition"$n"' "${g}"(0=false, other=true)"$n". '"${c}"expr_else"$n"' can be omitted
\n          in which case "${g}"0"$n" is returned if the condition does not hold. Using the ternary operator
\n          '"${c}"condition?expr_then[:expr_else]"$n"' gives an equivalent expression.
\n          For instance, "${-GMIC}" commands '"${c}"fill if(x%10==0,255,i)"$n"' and '"${c}"fill x%10?i:255"$n"' both draw
\n          blank vertical lines on every 10th column of an image.
\n       . '"${c}"do(expression,_condition)"$n"' repeats the evaluation of '"${c}"expression"$n"' until '"${c}"condition"$n"'
\n          vanishes (or until '"${c}"expression"$n"' vanishes if no '"${c}"condition"$n"' is specified). For instance,
\n          the expression: '"${c}"if(N<2,N,n=N-1;F0=0;F1=1;do(F2=F0+F1;F0=F1;F1=F2,n=n-1))"$n"' returns
\n          the Nth value of the Fibonacci sequence, for "${g}"N>=0"$n" (e.g., "${g}"46368"$n" for "${g}"N=24"$n").
\n          '"${c}"do(expression,condition)"$n"' always evaluates the specified expression at least once,
\n          then check for the loop condition. When done, it returns the last value of '"${c}"expression"$n"'.
\n       . '"${c}"for(init,condition,_procedure,body)"$n"' first evaluates the expression '"${c}"init"$n"', then
\n          iteratively evaluates '"${c}"body"$n"' (followed by '"${c}"procedure"$n"' if specified) while '"${c}"condition"$n"'
\n          is verified (i.e. not zero). It may happen that no iteration is done, in which case the
\n          function returns "${g}"nan"$n". Otherwise, it returns the last value of '"${c}"body"$n"'.
\n          For instance, the expression: '"${c}"if(N<2,N,for(n=N;F0=0;F1=1,n=n-1,F2=F0+F1;F0=F1;F1=F2))"$n"'
\n          returns the "${g}"Nth"$n" value of the Fibonacci sequence, for "${g}"N>=0"$n" (e.g., "${g}"46368"$n" for "${g}"N=24"$n").
\n       . '"${c}"while(condition,expression)"$n"' is exactly the same as '"${c}"for(init,condition,expression)"$n"'
\n          without the specification of an initializing expression.
\n       . '"${c}"break()"$n"' and '"${c}"continue()"$n"' respectively breaks and continues the current running bloc
\n          (loop, init or main environment).
\n       . '"${c}"fsize(filename)"$n"' returns the size of the specified 'filename' (or '-1' if file does not exist).
\n       . '"${c}"date(attr,path)"$n"' returns the date attribute for the given 'path' (file or directory),
\n          with '"${g}"attr"$n"' being "${g}"{ 0=year | 1=month | 2=day | 3=day of week | 4=hour | 5=minute |
\n          6=second }"$n", or a vector of those values.
\n       . '"${c}"date(_attr)"$n" returns the specified attribute for the current (locale) date.
\n       . '"${c}"print(expr1,expr2,...)"$n" or '"${c}"print(#ind)"$n" prints the value of the specified expressions
\n          (or image information) on the console, and returns the value of the last expression
\n          (or "${g}"nan"$n" in case of an image). Function '"${c}"prints(expr)"$n"' also prints the string composed
\n          of the ascii characters defined by the vector-valued expression (e.g. '"${c}"prints('Hello')"$n"').
\n       . '"${c}"debug(expression)"$n" prints detailed debug information about the sequence of operations done
\n          by the math parser to evaluate the expression (and returns its value).
\n       . '"${c}"display(_X,_w,_h,_d,_s)"$n" or '"${c}"display(#ind)"$n" display the contents of the vector '"${c}"X"$n"'
\n          (or specified image) and wait for user events. if no arguments are provided, a memory
\n          snapshot of the math parser environment is displayed instead.
\n       . '"${c}"begin(expression)"$n" and '"${c}"end(expression)"$n" evaluates the specified expressions only once,
\n          respectively at the beginning and end of the evaluation procedure, and this,
\n          even when multiple evaluations are required (e.g. in '"${c}"fill \">begin(foo = 0); ++foo\""$n"').
\n       . '"${c}"copy(dest,src,_nb_elts,_inc_d,_inc_s,_opacity)"$n" copies an entire memory block of '"${c}"nb_elts"$n"'
\n          elements starting from a source value '"${c}"src"$n"' to a specified destination '"${c}"dest"$n"', with
\n          increments defined by '"${c}"inc_d"$n"' and '"${c}"inc_s"$n"' respectively for the destination and source
\n          pointers.
\n       . '"${c}"stats(_#ind)"$n" returns the statistics vector of the running image '"${c}"[ind]"$n"', i.e the vector
\n          "${g}"[ im,iM,ia,iv,xm,ym,zm,cm,xM,yM,zM,cM,is,ip ]"$n" (14 values).
\n       . '"${c}"unref(a,b,...)"$n" destroys references to the named variable given as arguments.
\n       . '"${c}"breakpoint()"$n" inserts a possible computation breakpoint (not supported by the cli interface).
\n       . '"${c}"_(expr)"$n" just ignores its arguments (mainly useful for debugging).
\n       . '"${c}"ext('pipeline')"$n" executes the specified "${-GMIC}" pipeline as if it was called outside
\n          the currently evaluated expression.
\n
\n    - "${g}"User-defined macros:"$n"
\n
\n       . Custom macro functions can be defined in a math expression, using the assignment operator
\n          '"${c}"="$n"', e.g. '"${c}"foo(x,y) = cos(x + y); result = foo(1,2) + foo(2,3)"$n"'.
\n       . Trying to override a built-in function (e.g. '"${c}"abs()"$n"') has no effect.
\n       . Overloading macros with different number of arguments is possible. Re-defining a
\n          previously defined macro with the same number of arguments discards its previous
\n          definition.
\n       . Macro functions are indeed processed as "${g}"macros"$n" by the mathematical evaluator. You should
\n          avoid invoking them with arguments that are themselves results of assignments or
\n          self-operations. For instance, '"${c}"foo(x) = x + x; z = 0; foo(++z)"$n"' returns '"${g}"4"$n"' rather
\n          than expected value '"${g}"2"$n"'.
\n       . When substituted, macro arguments are placed inside parentheses, except if a number sign
\n          '"${c}"#"$n"' is located just before or after the argument name. For instance, expression
\n          '"${c}"foo(x,y) = x*y; foo(1+2,3)"$n"' returns '"${g}"9"$n"' (being substituted as '"${c}"(1+2)*(3)"$n"'), while
\n          expression '"${c}"foo(x,y) = x#*y#; foo(1+2,3)"$n"' returns '"${g}"7"$n"' (being substituted as '"${c}"1+2*3"$n"').
\n       . Number signs appearing between macro arguments function actually count for '"${c}"empty"$n"'
\n          separators. They may be used to force the substitution of macro arguments in unusual
\n          places, e.g. as in '"${c}"str(N) = ['I like N#'];"$n"'.
\n
\n    - "${g}"Multi-threaded"$n" and "${g}"in-place"$n" evaluation:
\n
\n       . If your image data are large enough and you have several CPUs available, it is likely that
\n          the math expression passed to a '"${c}"fill"$n"' or '"${c}"input"$n"' command is evaluated in parallel,
\n          using multiple computation threads.
\n       . Starting an expression with '"${c}":"$n"' or '"${c}"*"$n"' forces the evaluations required for an image to be
\n          run in parallel, even if the amount of data to process is small (beware, it may be slower
\n          to evaluate in this case!). Specify '"${c}":"$n"' (instead of '"${c}"*"$n"') to avoid possible image copy
\n          done before evaluating the expression (this saves memory, but do this only if you are
\n          sure this step is not required!)
\n       . If the specified expression starts with '"${c}">"$n"' or '"${c}"<"$n"', the pixel access operators
\n          '"${c}"i(), i[], j()"$n"' and '"${c}"j[]"$n"' return values of the image being currently modified,
\n          in forward ('"${c}">"$n"') or backward ('"${c}"<"$n"') order. The multi-threading evaluation of the
\n          expression is also disabled in this case.
\n       . Function '"${c}"critical(operands)"$n"' forces the execution of the given operands in a single thread at a
\n          time.
\n
\n    _ Expressions '"${c}"i(_#ind,x,_y,_z,_c)=value"$n"', '"${c}"j(_#ind,x,_y,_z,_c)=value"$n"', '"${c}"i[_#ind,offset]=value"$n"'
\n       and '"${c}"j[_#ind,offset]=value"$n"' set a pixel value at a different location than the running one
\n       in the image "${g}"[ind]"$n" (or in the associated image if argument '"${c}"#ind"$n"' is omitted), either with
\n       global coordinates/offsets (with '"${c}"i(...)"$n"' and '"${c}"i[...]"$n"'), or relatively to the current
\n       position "${g}"(x,y,z,c)"$n" (with '"${c}"j(...)"$n"' and '"${c}"j[...]"$n"'). These expressions always return '"${c}"value"$n"'.
\n
\n  - The last image of the list is always associated to the evaluations of '"${c}"{expressions}"$n"',
\n     e.g. "${-GMIC}" sequence '"${c}"256,128 fill {w}"$n"' will create a 256x128 image filled with value 256."
_help_section "Image and data viewers"
_help_paragraph "  - "${-GMIC}" has some very handy embedded "${g}"visualization modules"$n", for 1D signals (command '"${c}"plot"$n"'),
\n     1D/2D/3D images (command '"${c}"display"$n"') and 3D objects (command '"${c}"display3d"$n"'). It manages
\n     interactive views of the selected image data.
\n
\n  - The following keyboard shortcuts are available in the interactive viewers:
\n
\n    . "${g}"(mousewheel)"$n": Zoom in/out.
\n    . "${g}"CTRL+D"$n": Increase window size.
\n    . "${g}"CTRL+C"$n": Decrease window size.
\n    . "${g}"CTRL+R"$n": Reset window size.
\n    . "${g}"CTRL+W"$n": Close window.
\n    . "${g}"CTRL+F"$n": Toggle fullscreen mode.
\n    . "${g}"CTRL+S"$n": Save current window snapshot as numbered file 'gmic_xxxx.bmp'.
\n    . "${g}"CTRL+O"$n": Save current instance of the viewed data, as numbered file 'gmic_xxxx.cimgz'.
\n
\n  - Shortcuts specific to the 1D/2D/3D image viewer (command '"${c}"display"$n"') are:
\n
\n    . "${g}"CTRL+A"$n": Switch cursor mode.
\n    . "${g}"CTRL+P"$n": Play z-stack of frames as a movie (for volumetric 3D images).
\n    . "${g}"CTRL+V"$n": Show/hide 3D view (for volumetric 3D images).
\n    . "${g}"CTRL+(mousewheel)"$n": Go up/down.
\n    . "${g}"SHIFT+(mousewheel)"$n": Go left/right.
\n    . "${g}"Numeric PAD"$n": Zoom in/out (+/-) and move through zoomed image (digits).
\n    . "${g}"BACKSPACE"$n": Reset zoom scale.
\n
\n  - Shortcuts specific to the 3D object viewer (command '"${c}"display3d"$n"') are:
\n
\n    . "${g}"(mouse)+(left mouse button)"$n": Rotate 3D object.
\n    . "${g}"(mouse)+(right mouse button)"$n": Zoom 3D object.
\n    . "${g}"(mouse)+(middle mouse button)"$n": Shift 3D object.
\n    . "${g}"CTRL+F1 ... CTRL+F6"$n": Toggle between different 3D rendering modes.
\n    . "${g}"CTRL+Z"$n": Enable/disable z-buffered rendering.
\n    . "${g}"CTRL+A"$n": Show/hide 3D axes.
\n    . "${g}"CTRL+G"$n": Save 3D object, as numbered file 'gmic_xxxx.off'.
\n    . "${g}"CTRL+T"$n": Switch between single/double-sided 3D modes."
_help_section "Adding custom commands"
_help_paragraph "  - New custom commands can be added by the user, through the use of "${-GMIC}" "${g}"custom commands files"$n".
\n
\n  - A command file is a simple ascii text file, where each line starts either by
\n     '"${c}"command_name: command_definition"$n"' or '"${c}"command_definition (continuation)"$n"'.
\n
\n  - At startup, "${-GMIC}" automatically includes user's command file "${g}"$HOME/.gmic"$n" (on Unix) or
\n     "${g}"%APPDATA%/user.gmic"$n" (on Windows). The CLI tool '"${g}"gmic"$n"' automatically runs the command
\n     '"${c}"cli_start"$n"' if defined.
\n
\n  - Custom command names must use character set "${g}"[a-zA-Z0-9_]"$n" and cannot start with a number.
\n
\n  - Any '"${c}" ""# comment"$n"' expression found in a custom commands file is discarded by the "${-GMIC}" parser,
\n     wherever it is located in a line.
\n
\n  - In a custom command, the following "${g}"$-expressions"$n" are recognized and substituted:
\n
\n    . '"${c}"$""\*"$n"' is substituted by a copy of the specified string of arguments.
\n    . '"${c}"$\"*\""$n"' is substituted by a copy of the specified string of arguments, each being
\n       double-quoted.
\n    . '"${c}"$""#"$n"' is substituted by the maximum index of known arguments (either specified by the user
\n       or set to a default value in the custom command).
\n    . '"${c}"$""[]"$n"' is substituted by the list of selected image indices that have been specified during the
\n       command invocation.
\n    . '"${c}"$""?"$n"' is substituted by a printable version of '"${c}"$""[]"$n"' to be used in command descriptions.
\n    . '"${c}"$i"$n"' and '"${c}"${i}"$n"' are both substituted by the "${g}"i^th"$n" specified argument. Negative indices such as
\n       '"${c}"${-j}"$n"' are allowed and refer to the "${g}"j^th"$n" latest argument. '"${c}"$""0"$n"' is substituted by the
\n       custom command name.
\n    . '"${c}"${i=default}"$n"' is substituted by the value of "${c}"$i"$n" (if defined) or by its new value set to
\n        '"${g}"default"$n"' otherwise ('"${g}"default"$n"' may be a $-expression as well).
\n    . '"${c}"${subset}"$n"' is substituted by the argument values (separated by commas '"${g}","$n"') of a specified
\n       argument subset. For instance expression '"${c}"$""{2--2}"$n"' is substitued by all specified command
\n       arguments except the first and the last one. Expression '"${c}"$""{^0}"$n"' is then substituted by all
\n       arguments of the invoked command (eq. to '"${c}"$""*"$n"' if all specified arguments have indeed a
\n       value).
\n    . '"${c}"$""=var"$n"' is substituted by the set of instructions that will assign each argument "${c}"$i"$n" to the
\n       named variable '"${c}"var$i"$n"' (for i in "${g}"[0...$""#]"$n"). This is particularly useful when a custom
\n       command want to manage variable numbers of arguments. Variables names must use character set
\n       "${g}"[a-zA-Z0-9_]"$n" and cannot start with a number.
\n
\n  - These particular "${g}"$-expressions"$n" for custom commands are "${g}"always substituted"$n", even in
\n     double-quoted items or when the dollar sign '"${g}"$"$n"' is escaped with a backslash '"${g}"\\"$n"'. To avoid
\n     substitution, place an empty double quoted string just after the '"${g}"$"$n"' (as in '"${c}"$\"\"1"$n"').
\n
\n  - Specifying arguments may be skipped when invoking a custom command, by replacing them by commas
\n     '"${g}","$n"' as in expression '"${c}"flower ,,3"$n"'. Omitted arguments are set to their default values, which
\n     must be thus explicitly defined in the code of the corresponding custom command (using
\n     default argument expressions as '"${c}"$""{1=default}"$n"').
\n
\n  - If one numbered argument required by a custom command misses a value, an error is thrown by the
\n     "${-GMIC}" interpreter."
_help_section "List of commands"
_help_paragraph "   All available "${-GMIC}" commands are listed below, classified by themes. When several choices of
\n   command arguments are possible, they appear separated by '"${g}"|"$n"'. An argument specified inside '"${g}"[]"$n"'
\n   or starting by '"${g}"_"$n"' is optional except when standing for an existing image "${c}"[image]"$n", where '"${g}"image"$n"'
\n   can be either an index number or an image name. In this case, the '"${g}"[]"$n"' characters are mandatory
\n   when writing the item. A command marked with '"${g}"(+)"$n"' is one of the "${g}"builtin"$n" commands. Note also that
\n   all images that serve as illustrations in this reference documentation are normalized in "${g}"[0,255]"$n"
\n   before being displayed. You may need to do this explicitly (command '"${c}"normalize 0,255"$n"') if you
\n   want to save and view images with the same aspect than those illustrated in the example codes."
_help_examples :
g=$_gmic_g c=$_gmic_c n=$_gmic_n
_help_section "Examples of use"
_help_paragraph " '"${g}"gmic"$n"' is a generic image processing tool which can be used in a wide variety of situations.
\n The few examples below illustrate possible uses of this tool:
\n
\n  - View a list of images:
\n     "${c}"gmic file1.bmp file2.jpeg"$n"
\n
\n  - Convert an image file:
\n     "${c}"gmic input.bmp output output.jpg"$n"
\n
\n  - Create a volumetric image from a movie sequence:
\n     "${c}"gmic input.mpg append z output output.hdr"$n"
\n
\n  - Compute image gradient norm:
\n     "${c}"gmic input.bmp gradient_norm"$n"
\n
\n  - Denoise a color image:
\n     "${c}"gmic image.jpg denoise 30,10 output denoised.jpg"$n"
\n
\n  - Compose two images using overlay layer blending:
\n     "${c}"gmic image1.jpg image2.jpg blend overlay output blended.jpg"$n"
\n
\n  - Evaluate a mathematical expression:
\n     "${c}"gmic echo \"cos(pi/4)^2+sin(pi/4)^2={cos(pi/4)^2+sin(pi/4)^2}\""$n"
\n
\n  - Plot a 2D function:
\n     "${c}"gmic 1000,1,1,2 fill \"X=3*(x-500)/500;X^2*sin(3*X^2)+if(c==0,u(0,-1),cos(X*10))\" plot"$n"
\n
\n  - Plot a 3D elevated function in random colors:
\n     "${c}"gmic 128,128,1,3,\"u(0,255)\" plasma 10,3 blur 4 sharpen 10000 \\\
\n      elevation3d[-1] \"'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'\""$n"
\n
\n  - Plot the isosurface of a 3D volume:
\n     "${c}"gmic mode3d 5 moded3d 5 double3d 0 isosurface3d \"'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))'\",3"$n"
\n
\n  - Render a "${-GMIC}" 3D logo:
\n     "${c}"gmic 0 text G\\\47MIC,0,0,53,1,1,1,1 expand_xy 10,0 blur 1 normalize 0,100 +plasma 0.4 add \\\
\n      blur 1 elevation3d -0.1 moded3d 4"$n"
\n
\n  - Generate a 3D ring of torii:
\n     "${c}"gmic repeat 20 torus3d 15,2 color3d[-1] \"{u(60,255)},{u(60,255)},{u(60,255)}\" \\\
\n      *3d[-1] 0.5,1 if \"{$>%2}\" rotate3d[-1] 0,1,0,90 fi add3d[-1] 70 add3d \\\
\n      rotate3d 0,0,1,18 done moded3d 3 mode3d 5 double3d 0"$n"
\n
\n  - Create a vase from a 3D isosurface:
\n     "${c}"gmic moded3d 4 isosurface3d \"'x^2+2*abs(y/2)*sin(2*y)^2+z^2-3',0\" sphere3d 1.5 \\\
\n      sub3d[-1] 0,5 plane3d 15,15 rotate3d[-1] 1,0,0,90 center3d[-1] add3d[-1] 0,3.2 \\\
\n      color3d[-1] 180,150,255 color3d[-2] 128,255,0 color3d[-3] 255,128,0 add3d"$n"
\n
\n  - Display filtered webcam stream:
\n     "${c}"gmic apply_camera \\\"+mirror x +mirror y add div 4\\\""$n"
\n
\n  - Launch a set of "${-GMIC}" interactive demos:
\n     "${c}"gmic demo"$n"
\n"
_help_header_ascii :
__help_header_ascii
_section=0 _space1="" _space2=" "
_help_section "Usage"
__help_header_ascii :
if {narg($_prerelease)} strprerelease=" (pre-release ""#"$_prerelease")" else strprerelease="" fi
str="\n  "${_gmic_b}"gmic: GREYC\'s Magic for Image Computing."$_gmic_n"
\n
\n        "$_gmic_g${_gmic_b}"Version "${-strver}$strprerelease$_gmic_n", Copyright (c) 2008-2019, David Tschumperle.
\n        "$_gmic_g"(https://gmic.eu)"$_gmic_n
if {['$$_e']==0} m "_e : e[] \"$""*\"" fi
v + _e[] $str v -
_help_section_ascii :
_section+=1
{narg({'"$1"'})},1,1,1,{'-'}
v +
e[] "\n "$_gmic_m$_gmic_b$_section". $1"
e[] "    "${_space{narg({'$_section'})}}{t}$_gmic_n"\n"
v -
rm.
_help_paragraph_ascii :
v +
e[] "$*"
v -
_help_footer_ascii :
v +
e[] " "$_gmic_r$_gmic_b"** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: https://gmic.eu **"$_gmic_n
v -
_help_header_html :
_section=0
if {narg($_prerelease)} strprerelease=" (pre-release ""#"$_prerelease")" else strprerelease="" fi
_gmic_n="</span>"
_gmic_r="<span style=\"color: \#900000\">"
_gmic_g="<span style=\"color: \#900090\">"
_gmic_m="<span style=\"color: \#900090\">"
_gmic_c="<span style=\"color: \#005090\">"
_gmic_b="<span style=\"font-weight: bold\">"
_gmic_quotedc="<span class=\"ref_code\">"
_gmic_quotedg="<span style=\\\"color: \#203090; font-family: monospace\\\">"
v +
e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<!--#include file=\"header.html\" -->
\n<div id=\"bloc_option\">
\n<div id=\"top_rouge\"><div id=\"text_top\">Reference</div></div>
\n<div id=\"center\"><div id=\"text_centre_intro\">
\n<h2>Preamble</h2>
\n<ul>
\n<li>This document is distributed under the <a href=\"http://www.gnu.org/licenses/fdl-1.3.txt\">GNU Free Documentation License</a>, version 1.3.</li>
\n<li>A <a href=\"gmic_reference.pdf\">.pdf version</a> of this document is available.</li>
\n<li>We also suggest you read <a href=\"tutorial/index.shtml\">these tutorial pages</a> which provide a more user-friendly explanation of most of the G\47MIC basics.</li>
\n</ul>
\n<h2><a id=\"toc\">Table of contents</a></h2>
\n<ul>
\n<li><a href=\"#section0\">Version</a></li>
\n<li><a href=\"#section1\">Usage</a></li>
\n<ul>
\n<li><a href=\"#section2\">Overall context</a></li>
\n<li><a href=\"#section3\">Image definition and terminology</a></li>
\n<li><a href=\"#section4\">Items of a processing pipeline</a></li>
\n<li><a href=\"#section5\">Input data items</a></li>
\n<li><a href=\"#section6\">Command items and selections</a></li>
\n<li><a href=\"#section7\">Input/output properties</a></li>
\n<li><a href=\"#section8\">Substitution rules</a></li>
\n<li><a href=\"#section9\">Mathematical expressions</a></li>
\n<li><a href=\"#section10\">Image and data viewers</a></li>
\n<li><a href=\"#section11\">Adding custom commands</a></li>
\n</ul>
\n<li><a href=\"#section12\">List of commands</a></li>
\n<ul>
\n<li><a href=\"#subsection1\">Global options</a></li>
\n<li><a href=\"#subsection2\">Input/output</a></li>
\n<li><a href=\"#subsection3\">List manipulation</a></li>
\n<li><a href=\"#subsection4\">Mathematical operators</a></li>
\n<li><a href=\"#subsection5\">Values manipulation</a></li>
\n<li><a href=\"#subsection6\">Colors manipulation</a></li>
\n<li><a href=\"#subsection7\">Geometry manipulation</a></li>
\n<li><a href=\"#subsection8\">Filtering</a></li>
\n<li><a href=\"#subsection9\">Features extraction</a></li>
\n<li><a href=\"#subsection10\">Image drawing</a></li>
\n<li><a href=\"#subsection11\">Matrix computation</a></li>
\n<li><a href=\"#subsection12\">3D rendering</a></li>
\n<li><a href=\"#subsection13\">Control flow</a></li>
\n<li><a href=\"#subsection14\">Arrays,tiles and frames</a></li>
\n<li><a href=\"#subsection15\">Artistic</a></li>
\n<li><a href=\"#subsection16\">Warpings</a></li>
\n<li><a href=\"#subsection17\">Degradations</a></li>
\n<li><a href=\"#subsection18\">Blending and fading</a></li>
\n<li><a href=\"#subsection19\">Image sequences and videos</a></li>
\n<li><a href=\"#subsection20\">Convenience functions</a></li>
\n<li><a href=\"#subsection21\">Other interactive commands</a></li>
\n<li><a href=\"#subsection22\">Command shortcuts</a></li>
\n</ul>
\n<li><a href=\"#section13\">Examples of use</a></li>
\n</ul>
\n<a id=\"section0\"><h2>Version</h2></a>
\n<pre><font color=\"blue\"><b>gmic:</b> GREYC\'s Magic for Image Computing.</font>
\n
\n       Version <font color=\"brown\"><b>"${-strver}$strprerelease"</b></font>, Copyright (c) 2008-2019, David Tschumperl&eacute;
\n       (<a href=\"https://gmic.eu\">https://gmic.eu</a>)
\n</pre>
"
v -
_help_section "Usage"
_help_section_html :
_section+=1
v +
e[] "<hr style=\"border-top: 1px solid \#ccc;\"/>\n<h2><a href=\"#toc\"><img alt=\"\" border=\"0\" src=\"img/back_top.png\" />&nbsp;&nbsp;</a><a id=\"section"$_section"\">$1</a></h2>"
v -
_help_paragraph_html :
({'{/"$*"}'})
replace_str. "'"{/$_gmic_c},$_gmic_quotedc
replace_str. "'"{/$_gmic_g},$_gmic_quotedg
replace_str. $_gmic_n"'",$_gmic_n
replace_str. "  - ","  &bull; "
replace_str. "  . ","  &#9702; "
replace_str. "  _ ","  &#9654; "
add_link_html. 1
v + e[] "<pre>"{t}"</pre>" v -
rm.
_help_footer_html :
v +
e[] "
\n<br/><b><font color=\"brown\">** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: <a href=\"https://gmic.eu\">https://gmic.eu **</a></font></b>
\n</tt>
\n</div>
\n</div>
\n<div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div>
\n</div>
\n<!--#include file=\"copyright.html\" -->
\n<!--#include file=\"footer.html\" -->
"
v -
_help_header_latex :
strver=${-strver}
if {narg($_prerelease)} strprerelease=" (pre-release \\#"$_prerelease")" else strprerelease="" fi
_gmic_n="\\aftergroup\\Ccn"
_gmic_b="\\aftergroup\\Ccb"
_gmic_r="\\aftergroup\\Ccr"
_gmic_g="\\aftergroup\\Ccg"
_gmic_c="\\aftergroup\\Ccb"
_gmic_m=""
v + e[] "\\documentclass[a4paper,10.5pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,listings,color}
\n\\graphicspath{{img/}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{6in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\oddsidemargin}{15.5pt}
\n\\setlength{\\evensidemargin}{15.5pt}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\def\\Ccr{\\color{ca}}
\n\\def\\Ccb{\\color{cb}}
\n\\def\\Ccg{\\color{cc}}
\n\\def\\Ccc{\\color{cd}}
\n\\def\\Ccn{\\color{black}}
\n\\def\\comma{\\discretionary{,}{}{,}}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\title{\\fbox{\\parbox{\\textwidth}{\\begin{center}\\vspace*{2cm}\\includegraphics[width=12cm]{gmic_banner.jpg}\\\\\\vspace*{1cm}{\\Huge \\textbf{The Handbook}\\\\{\\small Version "$strver$strprerelease"}\\\\\\vspace*{1cm}}\\end{center}}}}
\n\\author{\\Large \\bf David Tschumperl\\'e}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\lstset{columns=fullflexible,basicstyle=\\normalfont}
\n\\begin{document}
\n\\maketitle
\n\\tableofcontents
\n\\chapter*{Preamble}
\n\\section*{License}
\n This document is distributed under the \\textbf{GNU Free Documentation License}, version 1.3.\\\\
\n Read the full license terms at \\url{http://www.gnu.org/licenses/fdl-1.3.txt}.\\\\~\\\\
\n An online version of this documentation is available at:\\\\\\url{https://gmic.eu/reference.shtml}.
\n\\section*{Motivations}
\n \\Cc{G\47MIC} is a full-featured open-source framework for image processing, distributed under the CeCILL free software licenses
\n (LGPL-like and/or GPL-compatible). It provides several user interfaces to
\n convert/manipulate/filter/visualize generic image datasets, ranging from 1D scalar signals to 3D+t sequences of multi-spectral
\n volumetric images, hence including 2D color images.
\n~\\\\G'MIC user interfaces are:
\n\\begin{itemize}
\n\\item '\\texttt{gmic}', a command-line tool to use the \\Cc{G\47MIC} image processing features from a shell.
\n In this setting, \\Cc{G\47MIC} may be seen as a friendly companion to the ImageMagick or GraphicsMagick software suites.
\n\\item '\\texttt{libgmic}', a small, portable, thread-safe and multi-threaded, C++ image processing library to be linked to third-party applications.
\n It's simple API allows programmers to add all \\Cc{G\47MIC} features in their own software without much efforts (a C API is available as well).
\n\\item '\\texttt{G'MIC-Qt}', a plug-in to bring \\Cc{G\47MIC} capabilities to the image retouching and painting software GIMP and Krita.
\n More than 500 filters are already available, sorted by category (Artistic, Black \\& white, Colors, Contours, Deformations,
\n Degradations, Details, Film emulation, Frames, Layers, Light \\& shadows, Patterns,
\n Rendering, Repair, Sequences, etc.).
\n\\item '\\texttt{\\Cc{G\47MIC} Online}', a web service to allow users applying image processing algorithms on their images, directly from a web browser.
\n\\item '\\texttt{ZArt}', a Qt-based interface for real-time processing of video streaming coming from webcams or video files.
\n\\end{itemize}
\n \\Cc{G\47MIC} is focused on the design of possibly complex pipelines for converting, manipulating, filtering and visualizing generic 1D/2D/3D multi-spectral image datasets. This includes of course color images, but also more complex data as image sequences or 3D(+t) volumetric float-valued datasets.\\\\
\n
\n \\Cc{G\47MIC} is an open framework: the default language can be extended with custom \\Cc{G\47MIC}-written commands, defining thus new available image filters or effects. By the way, \\Cc{G\47MIC} already contains a substantial set of pre-defined image processing algorithms and pipelines (more than 1000).\\\\
\n
\n \\Cc{G\47MIC} has been designed with portability in mind and runs on different platforms (Windows, Unix, MacOSX). It is distributed partly under the CeCILL licenses (CeCILL-C and/or CeCILL). Since 2008, it is developed in the Image Team of the GREYC laboratory, in Caen/France, by permanent researchers working in the field of image processing on a daily basis.
\n\\section*{Version}
\n
\n \\Ca{\\textbf{gmic:} GREYC\'s Magic for Image Computing.}\\\\
\n
\n        \\Cb{Version \\textbf{"$strver$strprerelease"}, Copyright (c) 2008-2019, David Tschumperl\\'e}\\\\
\n        \\Cb{(\\url{https://gmic.eu})}
\n\\chapter{Usage}
"
v -
_help_section_latex : skip "$1"
v +
e[] "~\\\\\\section{$1}"
v -
_help_paragraph_latex : skip "$1"
v +
e[] "\\small"
e[] "\\begin{lstlisting}[escapechar=]"
e[] "$1"
e[] "\\end{lstlisting}"
e[] "\\normalsize"
v -
_help_footer_latex :
v +
e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
v -
_help_header_man :
v + e[] ".TH G\47MIC 1\n\
.SH NAME\n\
gmic \\- Perform image processing operations using the G\47MIC framework.\n\
\n\
.SH HELP\n" v -
_gmic_n="\\fR"
_gmic_b="\\fB"
_gmic_r=""
_gmic_g=""
_gmic_c="\\fB"
_gmic_m=""
_prerelease=
__help_header_ascii
_gmic_n="__N"
_gmic_b="__B"
_gmic_r="__B"
_gmic_c="__B"
_section=0 _space1="" _space2=" "
_help_section "Usage"
_help_section_man :
_section+=1
{narg({'"$1"'})},1,1,1,{'-'}
v +
e[] "\n \\fB"$_section". $1"
e[] "    "${_space{narg({'$_section'})}}{t}"\\fR\n"
v -
rm.
_help_paragraph_man :
l[] ({'"$*"'})
replace_str "\\fR","__N"
replace_str "\\fB","__B"
replace_str "\\","\\\\\\\\"
replace_str "__N","\\\\fR"
replace_str "__B","\\\\fB"
v +
e[] {0,t}
v -
rm endl
_help_footer_man :
_help_footer_ascii $"*"
use_vt100 :
v - if {0$_vt100>0}
_gmic_n="\33[0;0;0m"
_gmic_r="\33[0;31;59m"
_gmic_g="\33[0;32;59m"
_gmic_m="\33[0;35;59m"
_gmic_c="\33[0;36;59m"
_gmic_b="\33[1m"
fi v +
#@cli version
#@cli : Display current version number on stdout.
version :
v -
m "_e : echo_stdout[] \"$""*\""
if {$^>=-1} _e "" fi
__help_header_ascii[]
uncommand _e
v +
v :
version
#@cli :: Input / Output
#@cli camera : _camera_index>=0,_nb_frames>0,_skip_frames>=0,_capture_width>=0,_capture_height>=0 : (+)
#@cli : Insert one or several frames from specified camera.
#@cli : When 'nb_frames==0', the camera stream is released instead of capturing new images.
#@cli : Default values: 'camera_index=0' (default camera), 'nb_frames=1', 'skip_frames=0' and 'capture_width=capture_height=0' (default size).
#@cli clut : "clut_name",_resolution>0
#@cli : Insert one of the pre-defined CLUTs at the end of the image list.\n
#@cli : 'clut_name' can be { 60's | 60's_faded | 60's_faded_alt | agfa_apx_100 | agfa_apx_25 | agfa_precisa_100 | agfa_ultra_color_100 | agfa_vista_200 | alien_green | analogfx_anno_1870_color | analogfx_old_style_i | analogfx_old_style_ii | analogfx_old_style_iii | analogfx_sepia_color | analogfx_soft_sepia_i | analogfx_soft_sepia_ii | black_and_white | bleach_bypass | blue_mono | color_rich | expired_fade | expired_polaroid | extreme | fade | faded | faded_alt | faded_analog | faded_extreme | faded_vivid | faux_infrared | fuji3510_constlclip | fuji3510_constlmap | fuji3510_cuspclip | fuji3513_constlclip | fuji3513_constlmap | fuji3513_cuspclip | fuji_160c | fuji_160c_+ | fuji_160c_++ | fuji_160c_- | fuji_400h | fuji_400h_+ | fuji_400h_++ | fuji_400h_- | fuji_800z | fuji_800z_+ | fuji_800z_++ | fuji_800z_- | fuji_astia_100f | fuji_fp-100c | fuji_fp-100c_+ | fuji_fp-100c_++ | fuji_fp-100c_+++ | fuji_fp-100c_++_alt | fuji_fp-100c_- | fuji_fp-100c_-- | fuji_fp-100c_cool | fuji_fp-100c_cool_+ | fuji_fp-100c_cool_++ | fuji_fp-100c_cool_- | fuji_fp-100c_cool_-- | fuji_fp-100c_negative | fuji_fp-100c_negative_+ | fuji_fp-100c_negative_++ | fuji_fp-100c_negative_+++ | fuji_fp-100c_negative_++_alt | fuji_fp-100c_negative_- | fuji_fp-100c_negative_-- | fuji_fp-3000b | fuji_fp-3000b_+ | fuji_fp-3000b_++ | fuji_fp-3000b_+++ | fuji_fp-3000b_- | fuji_fp-3000b_-- | fuji_fp-3000b_hc | fuji_fp-3000b_negative | fuji_fp-3000b_negative_+ | fuji_fp-3000b_negative_++ | fuji_fp-3000b_negative_+++ | fuji_fp-3000b_negative_- | fuji_fp-3000b_negative_-- | fuji_fp-3000b_negative_early | fuji_fp_100c | fuji_ilford_delta_3200 | fuji_ilford_delta_3200_+ | fuji_ilford_delta_3200_++ | fuji_ilford_delta_3200_- | fuji_ilford_hp5 | fuji_ilford_hp5_+ | fuji_ilford_hp5_++ | fuji_ilford_hp5_- | fuji_neopan_1600 | fuji_neopan_1600_+ | fuji_neopan_1600_++ | fuji_neopan_1600_- | fuji_neopan_acros_100 | fuji_provia_100f | fuji_provia_400f | fuji_provia_400x | fuji_sensia_100 | fuji_superia_100 | fuji_superia_100_+ | fuji_superia_100_++ | fuji_superia_100_- | fuji_superia_1600 | fuji_superia_1600_+ | fuji_superia_1600_++ | fuji_superia_1600_- | fuji_superia_200 | fuji_superia_200_xpro | fuji_superia_400 | fuji_superia_400_+ | fuji_superia_400_++ | fuji_superia_400_- | fuji_superia_800 | fuji_superia_800_+ | fuji_superia_800_++ | fuji_superia_800_- | fuji_superia_hg_1600 | fuji_superia_reala_100 | fuji_superia_x-tra_800 | fuji_velvia_50 | fuji_xtrans_ii_astia_v2 | fuji_xtrans_ii_classic_chrome_v1 | fuji_xtrans_ii_pro_neg_hi_v2 | fuji_xtrans_ii_pro_neg_std_v2 | fuji_xtrans_ii_provia_v2 | fuji_xtrans_ii_velvia_v2 | generic_fuji_astia_100 | generic_fuji_provia_100 | generic_fuji_velvia_100 | generic_kodachrome_64 | generic_kodak_ektachrome_100_vs | golden | golden_bright | golden_fade | golden_mono | golden_vibrant | goldfx_bright_spring_breeze | goldfx_bright_summer_heat | goldfx_hot_summer_heat | goldfx_perfect_sunset_01min | goldfx_perfect_sunset_05min | goldfx_perfect_sunset_10min | goldfx_spring_breeze | goldfx_summer_heat | green_mono | hong_kong | ilford_delta_100 | ilford_delta_3200 | ilford_delta_400 | ilford_fp4_plus_125 | ilford_hp5_plus_400 | ilford_hps_800 | ilford_pan_f_plus_50 | ilford_xp2 | kodak2383_constlclip | kodak2383_constlmap | kodak2383_cuspclip | kodak2393_constlclip | kodak2393_constlmap | kodak2393_cuspclip | kodak_bw_400_cn | kodak_e-100_gx_ektachrome_100 | kodak_ektachrome_100_vs | kodak_elite_100_xpro | kodak_elite_chrome_200 | kodak_elite_chrome_400 | kodak_elite_color_200 | kodak_elite_color_400 | kodak_elite_extracolor_100 | kodak_hie_(hs_infra) | kodak_kodachrome_200 | kodak_kodachrome_25 | kodak_kodachrome_64 | kodak_portra_160 | kodak_portra_160_+ | kodak_portra_160_++ | kodak_portra_160_- | kodak_portra_160_nc | kodak_portra_160_nc_+ | kodak_portra_160_nc_++ | kodak_portra_160_nc_- | kodak_portra_160_vc | kodak_portra_160_vc_+ | kodak_portra_160_vc_++ | kodak_portra_160_vc_- | kodak_portra_400 | kodak_portra_400_+ | kodak_portra_400_++ | kodak_portra_400_- | kodak_portra_400_nc | kodak_portra_400_nc_+ | kodak_portra_400_nc_++ | kodak_portra_400_nc_- | kodak_portra_400_uc | kodak_portra_400_uc_+ | kodak_portra_400_uc_++ | kodak_portra_400_uc_- | kodak_portra_400_vc | kodak_portra_400_vc_+ | kodak_portra_400_vc_++ | kodak_portra_400_vc_- | kodak_portra_800 | kodak_portra_800_+ | kodak_portra_800_++ | kodak_portra_800_- | kodak_t-max_100 | kodak_t-max_3200 | kodak_t-max_400 | kodak_tmax_3200 | kodak_tmax_3200_+ | kodak_tmax_3200_++ | kodak_tmax_3200_- | kodak_tri-x_400 | kodak_tri-x_400_+ | kodak_tri-x_400_++ | kodak_tri-x_400_- | light_blown | lomo | lomography_redscale_100 | lomography_x-pro_slide_200 | mono_tinted | mute_shift | muted_fade | natural_vivid | nostalgic | orange_tone | pink_fade | polaroid_664 | polaroid_665 | polaroid_665_+ | polaroid_665_++ | polaroid_665_- | polaroid_665_-- | polaroid_665_negative | polaroid_665_negative_+ | polaroid_665_negative_- | polaroid_665_negative_hc | polaroid_667 | polaroid_669 | polaroid_669_+ | polaroid_669_++ | polaroid_669_+++ | polaroid_669_- | polaroid_669_-- | polaroid_669_cold | polaroid_669_cold_+ | polaroid_669_cold_- | polaroid_669_cold_-- | polaroid_672 | polaroid_690 | polaroid_690_+ | polaroid_690_++ | polaroid_690_- | polaroid_690_-- | polaroid_690_cold | polaroid_690_cold_+ | polaroid_690_cold_++ | polaroid_690_cold_- | polaroid_690_cold_-- | polaroid_690_warm | polaroid_690_warm_+ | polaroid_690_warm_++ | polaroid_690_warm_- | polaroid_690_warm_-- | polaroid_polachrome | polaroid_px-100uv+_cold | polaroid_px-100uv+_cold_+ | polaroid_px-100uv+_cold_++ | polaroid_px-100uv+_cold_+++ | polaroid_px-100uv+_cold_- | polaroid_px-100uv+_cold_-- | polaroid_px-100uv+_warm | polaroid_px-100uv+_warm_+ | polaroid_px-100uv+_warm_++ | polaroid_px-100uv+_warm_+++ | polaroid_px-100uv+_warm_- | polaroid_px-100uv+_warm_-- | polaroid_px-680 | polaroid_px-680_+ | polaroid_px-680_++ | polaroid_px-680_- | polaroid_px-680_-- | polaroid_px-680_cold | polaroid_px-680_cold_+ | polaroid_px-680_cold_++ | polaroid_px-680_cold_++_alt | polaroid_px-680_cold_- | polaroid_px-680_cold_-- | polaroid_px-680_warm | polaroid_px-680_warm_+ | polaroid_px-680_warm_++ | polaroid_px-680_warm_- | polaroid_px-680_warm_-- | polaroid_px-70 | polaroid_px-70_+ | polaroid_px-70_++ | polaroid_px-70_+++ | polaroid_px-70_- | polaroid_px-70_-- | polaroid_px-70_cold | polaroid_px-70_cold_+ | polaroid_px-70_cold_++ | polaroid_px-70_cold_- | polaroid_px-70_cold_-- | polaroid_px-70_warm | polaroid_px-70_warm_+ | polaroid_px-70_warm_++ | polaroid_px-70_warm_- | polaroid_px-70_warm_-- | polaroid_time_zero_(expired) | polaroid_time_zero_(expired)_+ | polaroid_time_zero_(expired)_++ | polaroid_time_zero_(expired)_- | polaroid_time_zero_(expired)_-- | polaroid_time_zero_(expired)_--- | polaroid_time_zero_(expired)_cold | polaroid_time_zero_(expired)_cold_- | polaroid_time_zero_(expired)_cold_-- | polaroid_time_zero_(expired)_cold_--- | purple | retro | rollei_ir_400 | rollei_ortho_25 | rollei_retro_100_tonal | rollei_retro_80s | rotate_muted | rotate_vibrant | rotated | rotated_crush | smooth_cromeish | smooth_fade | soft_fade | solarized_color | solarized_color2 | summer | summer_alt | sunny | sunny_alt | sunny_rich | sunny_warm | super_warm | super_warm_rich | sutro_fx | technicalfx_backlight_filter | vibrant | vibrant_alien | vibrant_contrast | vibrant_cromeish | vintage | vintage_alt | vintage_brighter | warm | warm_highlight | warm_yellow | zilverfx_b_w_solarization | zilverfx_infrared | zilverfx_vintage_b_w | arabica12 | ava614 | azrael93 | bourbon64 | byers11 | chemical168 | clayton33 | clouseau54 | cobi3 | contrail35 | cubicle99 | django25 | domingo145 | faded47 | folger50 | fusion88 | hyla68 | korben214 | lenox340 | lucky64 | mckinnon75 | milo5 | neon770 | paladin1875 | pasadena21 | pitaya15 | reeve38 | remy24 | sprocket231 | teigen28 | trent18 | tweed71 | vireo37 | zed32 | zeke39 | fgcinebasic | fgcinebright | fgcinecold | fgcinedrama | fgcinetealorange1 | fgcinetealorange2 | fgcinevibrant | fgcinewarm }
#@cli : $ clut summer
clut : check "isval(${2=48}) && $2>0"
e[^-1] "Input CLUT with name '$1' and resolution $2."
v - l[]
if ${_path_rc}clut_"$1".cimgz i ${_path_rc}clut_"$1".cimgz fi
if {"!"$!" || w!=$2 || h!=$2 || d!=$2"}
if {narg($GMIC_SYSTEM_PATH)} g_path_unix=$GMIC_SYSTEM_PATH
else g_path_unix=/usr/lib/gimp/2.0/plug-ins/
fi
rm repeat 2
if {!$>" && "(\
isfile(${_path_rc}gmic_film_cluts.gmz)" || "\
isfile(${-path_gimp}plug-ins/gmic_film_cluts.gmz)" || "\
isfile(${-path_gimp}plug-ins/gmic_gimp_qt/gmic_film_cluts.gmz)" || "\
isfile(${g_path_unix}gmic_film_cluts.gmz))}
if {isfile(${_path_rc}gmic_film_cluts.gmz)} i ${_path_rc}gmic_film_cluts.gmz
elif {isfile(${-path_gimp}plug-ins/gmic_film_cluts.gmz)} i ${-path_gimp}plug-ins/gmic_film_cluts.gmz
elif {isfile(${-path_gimp}plug-ins/gmic_gimp_qt/gmic_film_cluts.gmz)} i ${-path_gimp}plug-ins/gmic_gimp_qt/gmic_film_cluts.gmz
elif {isfile(${g_path_unix}gmic_film_cluts.gmz)} i ${g_path_unix}gmic_film_cluts.gmz
fi
else l[] i https://gmic.eu/gmic_film_cluts.gmz o ${_path_rc}gmic_film_cluts.gmz,uchar endl
fi
repeat $! if {['{$>,n}']==['"$1"']} k[$>] break fi done
if {$!==1} break fi
rm
done
if {!$!} v + error[0--4] "Command '$0': Unknown CLUT name '$1'." fi
decompress_clut $2,$2,$2 round c 0,255
o. ${_path_rc}clut_$1.cimgz,uchar
fi
nm "[CLUT: $1]" k.
endl v +
#@cli m : eq. to 'command'. : (+)
#@cli command : _add_debug_info={ 0 | 1 },{ filename | http[s]://URL | "string" } : (+)
#@cli : Import G'MIC custom commands from specified file, URL or string.
#@cli : (eq. to 'm').\n
#@cli : Imported commands are available directly after the 'command' invocation.
#@cli : Default value: 'add_debug_info=1'.
#@cli : $ image.jpg command "foo : mirror y deform $""1" +foo[0] 5 +foo[0] 15
#@cli cursor : _mode = { 0=hide | 1=show } : (+)
#@cli : Show or hide mouse cursor for selected instant display windows.
#@cli : Command selection (if any) stands for instant display window indices instead of image indices.
#@cli : Default value: 'mode=1'.
#@cli d : eq. to 'display'. : (+)
#@cli display : _X[%]>=0,_Y[%]>=0,_Z[%]>=0,_exit_on_anykey={ 0 | 1 } : (+)
#@cli : Display selected images in an interactive viewer (use the instant display window [0] if opened).
#@cli : (eq. to 'd').\n
#@cli : Arguments 'X','Y','Z' determine the initial selection view, for 3D volumetric images.
#@cli : Default value: 'X=Y=Z=0' and 'exit_on_anykey=0'.
#@cli : $$
#@cli d0 : eq. to 'display0'.
d0 :
_display0
#@cli display0
#@cli : Display selected images without value normalization.
#@cli : (eq. to 'd0').
display0 :
_$0
_display0 :
v -
w=0 h=0 d=0 s=0
repeat $! l[$>] w+={w} h={max($h,h)} d={max($d,d)} s={max($s,s)} endl done
if {$!==1} w -1,-1,0,0,-1,-1,{0,n}\ ($wx$hx$dx$s)
elif {$!==2} w -1,-1,0,0,-1,-1,{0,n},{n}\ ($wx$hx$dx$s)
else w -1,-1,0,0,-1,-1,{0,n},...,{n}\ ($wx$hx$dx$s)
fi
v + d v - w[] 0 v +
#@cli d3d : eq. to 'display3d'. : (+)
#@cli display3d : _[background_image],_exit_on_anykey={ 0 | 1 } : _exit_on_anykey={ 0 | 1 } : (+)
#@cli : Display selected 3D objects in an interactive viewer (use the instant display window [0] if opened).
#@cli : (eq. to 'd3d').
#@cli : Default values: '[background_image]=(default)' and 'exit_on_anykey=0'.
#@cli da : eq. to 'display_array'.
da :
v - _gmic_s="$?" v +
_display_array $*
#@cli display_array : _width>0,_height>0
#@cli : Display images in interactive windows where pixel neighborhoods can be explored.
#@cli : Default values: 'width=13' and 'height=width'.
display_array :
v - _gmic_s="$?" v +
_$0 $*
_display_array : check ${1=13}>0" && "${2=$1}>0
e[0--3] "Display $1x$2 array of pixel values for image"$_gmic_s"."
v -
dxb={round($1/2,1,1)} dxf={$1-1-$dxb}
dyb={round($2/2,1,1)} dyf={$2-1-$dyb}
repeat $! l[$>]
if {w<128" && "h<128} r 128,128,100%,100%,0,0,0.5,0.5 fi
x0=0 y0=0 w={w} h={h}
wmax={0.9*{*,u}} hmax={0.9*{*,v}}
do
if {w>=$wmax||h>=$hmax}
n={n} nm. "Image "'{b}.{x}'" is too large, please select a sub-image."
+select. 2 x0={i[0]} y0={i[1]} w={1+i[3]-i[0]} h={1+i[4]-i[1]}
rm. nm. $n
fi
+z. $x0,$y0,0,{$x0+$w-1},{$y0+$h-1},0 round. 1 n. 0,255
while {w>=$wmax||h>=$hmax}
x1=-1 y1=-1 c1=0 ox1=-1 oy1=-1 oc1=-1
x2=-1 y2=-1 c2=0 ox2=-1 oy2=-1 oc2=-1
x3=-1 y3=-1 c3=0 ox3=-1 oy3=-1 oc3=-1
c0=0 oxm=-1 oym=-1
w. -1,-1,0,0,-1,-1,{-2,b}.{-2,x}
do
wait[0-3]
oc0=$c0
repeat 4
if {$>" && "!{*$>}" && "${x$>}>=0} w$> 0 x$>=-1 y$>=-1 c$>=0 fi
if {*$>,o} c$>={(${c$>}+sign({*$>,o}))%s} wait[$>] -1 fi
if {{*$>,SPACE}" || "{*$>,ENTER}" || "{*$>,ARROWRIGHT}" || "{*$>,ARROWDOWN}} c$>={(${c$>}+1)%s} wait[$>] -1 fi
if {{*$>,BACKSPACE}" || "{*$>,ARROWLEFT}" || "{*$>,ARROWUP}} c$>={(${c$>}-1)%s} wait[$>] -1 fi
done
if {$oc0!=$c0} c1=$c0 c2=$c0 c3=$c0 fi
xm={*,x} ym={*,y}
if {$xm>=0" && "{*,b}&1} x1=$xm y1=$ym fi
if {$xm>=0" && "{*,b}&2} x2=$xm y2=$ym fi
if {$xm>=0" && "{*,b}&4} x3=$xm y3=$ym fi
if {$xm>=0" && "($oxm!=$xm" || "$oym!=$ym)} w[] -1,-1,-1,-1,-1,-1,{-2,b}.{-2,x}" - ("$xm,$ym")" fi
if {$x1!=$ox1" || "$y1!=$oy1" || "$x2!=$ox2" || "$y2!=$oy2" || "$x3!=$ox3" || "$y3!=$oy3}
.
if {$x1>=0}
xb={$x1-$dxb} yb={$y1-$dyb} xe={$x1+$dxf} ye={$y1+$dyf}
rectangle. $xb,$yb,$xe,$ye,0.2,0,255,255
rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,0,255,255
fi
if {$x2>=0}
xb={$x2-$dxb} yb={$y2-$dyb} xe={$x2+$dxf} ye={$y2+$dyf}
rectangle. $xb,$yb,$xe,$ye,0.2,255,32,255
rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,32,255
fi
if {$x3>=0}
xb={$x3-$dxb} yb={$y3-$dyb} xe={$x3+$dxf} ye={$y3+$dyf}
rectangle. $xb,$yb,$xe,$ye,0.2,255,255,0
rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,255,0
fi
w. {-2,w},{-2,h} rm. oxm=$xm oym=$ym
fi
if {$x1>=0" && "($ox1!=$x1" || "$oy1!=$y1" || "$oc1!=$c1)}
+z.. {$x1-$dxb},{$y1-$dyb},0,$c1,{$x1+$dxf},{$y1+$dyf},0,$c1
+z.. {$x1-$dxb},{$y1-$dyb},0,{$x1+$dxf},{$y1+$dyf},0
__display_array[-2,-1] $1,$2,0,255,255
w1. {w},{h},0,0,-1,-1,{-3,b}" - ("$x1,$y1,c=$c1")"
rm. ox1=$x1 oy1=$y1 oc1=$c1
fi
if {$x2>=0" && "($ox2!=$x2" || "$oy2!=$y2" || "$oc2!=$c2)}
+z.. {$x2-$dxb},{$y2-$dyb},0,$c2,{$x2+$dxf},{$y2+$dyf},0,$c2
+z.. {$x2-$dxb},{$y2-$dyb},0,{$x2+$dxf},{$y2+$dyf},0
__display_array[-2,-1] $1,$2,255,32,255
w2. {w},{h},0,0,-1,-1,{-3,b}" - ("$x2,$y2,c=$c2")"
rm. ox2=$x2 oy2=$y2 oc2=$c2
fi
if {$x3>=0" && "($ox3!=$x3" || "$oy3!=$y3" || "$oc3!=$c3)}
+z.. {$x3-$dxb},{$y3-$dyb},0,$c3,{$x3+$dxf},{$y3+$dyf},0,$c3
+z.. {$x3-$dxb},{$y3-$dyb},0,{$x3+$dxf},{$y3+$dyf},0
__display_array[-2,-1] $1,$2,255,255,0
w3. {w},{h},0,0,-1,-1,{-3,b}" - ("$x3,$y3,c=$c3")"
rm. ox3=$x3 oy3=$y3 oc3=$c3
fi
while {{*}" && "\
!{*,ESC}" && "!{*,Q}" && "\
!{*1,ESC}" && "!{*1,Q}" && "\
!{*2,ESC}" && "!{*2,Q}" && "\
!{*3,ESC}" && "!{*3,Q}}
k[0] w 0 w1 0 w2 0 w3 0
endl done v +
__display_array :
round.. 1 c.. 0,999 r. 100%,100%,1,3,{s==1}
+luminance. r.. {$1*24},{$2*24} grid.. {100/$1}%,{100/$2}%,0,0,1,0
xb={24*int($1/2)} yb={24*int($2/2)} xe={$xb+24} ye={$yb+24}
rectangle.. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,$3,$4,$5
repeat $2,yg
repeat $1,xg
t.. {-3,i($xg,$yg)},{5+$xg*24},{5+$yg*24},13,0.8,{if(i($xg,$yg)>128,0,255)}
done
done
rm[-3,-1]
#@cli dfft : eq. to 'display_fft'.
dfft :
_display_fft
#@cli display_fft
#@cli : Display fourier transform of selected images, with centered log-module and argument.
#@cli : (eq. to 'dfft').
#@cli : $ image.jpg +display_fft
display_fft :
_$0
_display_fft :
e[0--3] "Render fourier transform of image$? with centered log-module and argument."
v - repeat $! l[$>] fftpolar +.. 1 log.. n 0,255 a x endl done s x,2 v +
#@cli dg : eq. to 'display_graph'.
dg : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
_display_graph ${1-8},"$9","$10"
#@cli display_graph : _width>=0,_height>=0,_plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_xlabel,_ylabel
#@cli : Render graph plot from selected image data.
#@cli : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@cli : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@cli : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@cli : if specified 'width' or 'height' is '0', then image size is set to half the screen size.
#@cli : Default values: 'width=0', 'height=0', 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0 (auto)', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@cli : $ 128,1,1,1,'cos(x/10+u)' +display_graph 400,300,3
display_graph : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
_display_graph ${1-8},"$9","$10"
_display_graph : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
e[0--3] "Render $1x$2 graph plot from data of image$?."
v - repeat $! l[$>] nm={0,n}
if {$1>0&&$2>0} w,h=$1,$2 else w,h={{*,u}/2},{{*,v}/2} fi
w,h={[max($w,33),max($h,33)]}
one={$3!=3} siz={w*h*d}
if {$5==$6} xmin=0 xmax={$siz-$one} else xmin={min($5,$6)} xmax={max($5,$6)} fi
if {$7==$8} ymin={im-(iM-im)/20} ymax={iM+(iM-im)/20} else ymin={min($7,$8)} ymax={max($7,$8)} fi
dx={$xmax-$xmin} dy={$ymax-$ymin}
u=${"_axes[] "$xmin,$xmax",{0.3*"$w"/14}"} offx={arg(1,$u)} deltax={arg(2,$u)}
u=${"_axes[] "$ymin,$ymax",{0.3*"$h"/14}"} offy={arg(1,$u)} deltay={arg(2,$u)}
gw={$w-32} gh={$h-32} gg={($gw-$one)/($siz-$one)}
$gw,$gh,1,3,255
grid. {$deltax*$gw/$dx},{$deltay*$gh/$dy},{($offx-$xmin)*$gw/$dx},{$gh-($offy-$ymin)*$gh/$dy},0.25,0xCCCCCCCC,0
if {{-2,s}==1} (120,120,200)
elif {{-2,s}<=3} (220,10,10;10,220,10;10,10,220)
else
(0,255) r. 256,1,1,1,3 map. 2 z. 2,100% permute. cxyz r. 3,{-3,max(3,s)},1,1,0,2
sh. 0,2,0,0 f. 255,0,0,0,255,0,0,0,255 rm.
fi
repeat {-3,s} sh... $> graph... .,$3,$4,$ymax,$ymin,1,{-2,@0-2} rm. shift. 0,-1 done
rm[-3,-1]
line. 0,0,100%,0,1,110 line. 100%,0,100%,100%,1,110
line. 100%,100%,0,100%,1,255 line. 0,100%,0,0,1,255
100%,100%,1,1,255
axes. $xmin,$xmax,$ymax,$ymin,14,1,0
if {$xmin>0} axes. 0,0,$ymax,$ymin,14,1,160 fi
if {$xmax<0} axes. {w-1},{w-1},$ymax,$ymin,14,1,160 fi
if {$ymin>0} axes. $xmin,$xmax,{h-1},{h-1},14,1,160 fi
if {$ymax<0} axes. $xmin,$xmax,0,0,14,1,160 fi
+erode. 3 !=. 255 r.. 100%,100%,1,3 j... ..,0,0,0,0,1,.,1 rm[-2,-1]
frame. 16,16,220
0 t. "$9",0,0,14,1,-220,-220,-220 j.. .,{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 rm.
0 t. "$10",0,0,14,1,-220,-220,-220 rotate. -90 j.. .,2,{({-2,h}-h)/2},0,0,-1 rm.
nm $nm endl done c 0,255 v +
#@cli dh : eq. to 'display_histogram'.
dh :
v - _gmic_s="$?" v +
_display_histogram $"*"
#@cli display_histogram : _width>=0,_height>=0,_clusters>0,_min_value[%],_max_value[%],_show_axes={ 0 | 1 },_expression.
#@cli : Render a channel-by-channel histogram.
#@cli : If selected images have several slices, the rendering is performed for all input slices.
#@cli : 'expression' is a mathematical expression used to transform the histogram data for visualization purpose.
#@cli : (eq. to 'dh').
#@cli : if specified 'width' or 'height' is '0', then image size is set to half the screen size.
#@cli : Default values: 'width=0', 'height=0', 'clusters=256', 'min_value=0%', 'max_value=100%', 'show_axes=1' and 'expression=i'.
#@cli : $ image.jpg +display_histogram 512,300
display_histogram :
v - _gmic_s="$?" v +
_$0 $"*"
_display_histogram : check "${1=0}>=0 && ${2=0}>=0 && ${3=256}>0" skip ${4=0%},${5=100%},${6=1},"${7=i}"
e[0--3] "Render $1x$2 channel-by-channel histogram of image"$_gmic_s", with $3 clusters, minimum value $4 and maximum value $5."
v - repeat $! l[$>] nm={0,n}
if ${is_percent\ $4} m={im+(iM-im)*$4} else m=$4 fi
if ${is_percent\ $5} M={im+(iM-im)*$5} else M=$5 fi
s={s} s c
repeat $s l[{-1-$>}] s z histogram $3,$m,$M a z endl done
a c f '"${7--1}"' vM={iM} s z
repeat $! l[$>]
if {$1>0&&$2>0} wh=$1,$2 else wh={{*,u}/2},{{*,v}/2} fi
$wh,1,{s},-255
repeat {s} sh[-2,-1] $> graph. ..,3,0,$vM,0,1,0 rm[-2,-1] done
rm.. + 255
if $6
100%,100%
axes. $m,$M,$vM,0,14,1,255
if {$m>0} axes. 0,0,$vM,0,14,1,200 fi
if {$M<0} axes. {w-1},{w-1},$vM,0,14,1,200 fi
+dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
fi
endl done
a z nm $nm
endl done v +
#@cli display_parametric : _width>0,_height>0,_outline_opacity,_vertex_radius>=0,_is_antialiased={ 0 | 1 },_is_decorated={ 0 | 1 },_xlabel,_ylabel
#@cli : Render 2D or 3D parametric curve or point clouds from selected image data.
#@cli : Curve points are defined as pixels of a 2 or 3-channel image.
#@cli : If the point image contains more than 3 channels, additional channels define the (R,G,B) color for each vertex.
#@cli : If 'outline_opacity>1', the outline is colored according to the specified vertex colors and 'outline_opacity-1' is used
#@cli : as the actual drawing opacity.
#@cli : Default values: 'width=512', 'height=width', 'outline_opacity=3', 'vertex_radius=0', 'is_antialiased=1', 'is_decorated=1', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@cli : $ 1024,1,1,2,'t=x/40;if(c==0,sin(t),cos(t))*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)' display_parametric 512,512
#@cli : $ 1000,1,1,2,u(-100,100) quantize 4,1 noise 12 channels 0,2 +normalize 0,255 append c display_parametric 512,512,0.1,8
display_parametric : check "${1=512}>0 && ${2=$1}>0 && ${4=0}>=0" skip ${3=3},${5=1},${6=1},"${7=x-axis}","${8=y-axis}"
v - s0="no " s1="" o0="" o1="colored "
v + e[^-1] "Render $1x$2 parametric graph plot from data of image$?, with "${o{$3>1}}"outline opacity "{if($3>1,$3-1,$3)}\
", vertex radius $4, "${s{$5!=0}}"antialiasing and "${s{$6!=0}}"decoration." v -
repeat $! l[$>]
nm={0,n} N={w*h*d}
i[0] ({'CImg3d'}) +[0] 0.5 i[1] ($N;$N)
if {s==4} +channels. 3,3 r. 100%,100%,1,2 a[-2,-1] c is_grayscale=1
else is_grayscale={s<4} channels. 0,5
fi
sh. 0 xm={im} xM={iM} rm.
sh. 1 ym={im} yM={iM} rm.
sh. 2 zm={im} zM={iM} rm.
permute. cxyz s. x,2
i.. (1,0;1,{$N-1}) r.. 2,$N,1,1,3 round.. 1,$N,1,1,1
y a y c3d n3d *3d 1,-1,1
{if($6,max(1,$1-32),$1)},{if($6,max(1,$2-32),$2)},1,{if($is_grayscale,1,3)},255
*3d[0] {0.96*min(w,h)}
if $6 L={0.1*max($1,$2)} grid[1] $L,$L,0,0,0.25,0xCCCCCCCC,0 fi
if $5
r[1] 200%,200%,1,100%,1 *3d[0] 2
if $4 +circles3d[0] {2*$4} j3d[1] [2],50%,50%,0,1,3,0,0 rm[2] fi
elif $4
+circles3d[0] $4 j3d[1] [2],50%,50%,0,1,3,0,0 rm[2]
fi
if $3 l[0] s3d f[1] 'i-y' rm[3] i[3] (2,0,1;2,{$N-2},{$N-1}) r[3] 3,{$N-1},1,1,3 round[3]
r[5] 1,{h-1},1,1,0
if {$3>1} r[4] 3,{4,h/3},1,1,-1 r[4] 3,{4,h-1},1,1,2 else rm[4] i[4] 3,{$N-1} fi
y a y endl j3d[1] [0],50%,50%,0,{if($3>1,$3-1,$3)},2,0,0
fi
rm[0]
if $5 r. 50%,50%,1,100%,2 fi
if $6
xc={0.5*($xm+$xM)} yc={0.5*($ym+$yM)} dx={0.5*($xM-$xm)/0.96} dy={0.5*($yM-$ym)/0.96}
xm={$xc-$dx} xM={$xc+$dx} ym={$yc-$dy} yM={$yc+$dy}
100%,100%,1,1,255 axes. $xm,$xM,$yM,$ym,14,1,0
if {$xm>0} axes. 0,0,$yM,$ym,14,1,160 fi
if {$xM<0} axes. {w-1},{w-1},$yM,$ym,14,1,160 fi
if {$ym>0} axes. $xm,$xM,{h-1},{h-1},14,1,160 fi
if {$yM<0} axes. $xm,$xM,0,0,14,1,160 fi
+erode. 3 !=. 255 r.. 100%,100%,1,3 j... ..,0,0,0,0,1,.,1 rm[-2,-1]
frame 1,1,128 frame 15,15,220
0 t. "$7",0,0,14,1,-220,-220,-220 j.. .,{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 rm.
0 t. "$8",0,0,14,1,-220,-220,-220 rotate. -90 j.. .,2,{({-2,h}-h)/2},0,0,-1 rm.
fi
nm. $nm
endl done v +
#@cli dp : eq. to 'display_parallel'.
dp :
v - _gmic_s="$?" v +
_display_parallel
#@cli display_parallel
#@cli : Display each selected image in a separate interactive display window.
#@cli : (eq. to 'dp').
display_parallel :
v - _gmic_s="$?" v +
_$0
_display_parallel :
e[0--3] "Display image$? in parallel."
print
v -
if {$!<=1} d v + return fi
$!,1,1,1,x ({'{^}'}) rm..
l.
s -,{','} y x
i[0--2] ({'d['})
i[2--2:2] ({'],'})
({']'})
a x com={t} rm
endl
m "__dp : parallel "$com __dp uncommand __dp
d[] v +
#@cli dp0 : eq. to 'display_parallel0'.
dp0 :
v - _gmic_s="$?" v +
_display_parallel0
#@cli display_parallel0
#@cli : Display each selected image in a separate interactive display window, without value normalization.
#@cli : (eq. to 'dp0').
display_parallel0 :
v - _gmic_s="$?" v +
_$0
_display_parallel0 :
e[0--3] "Display image$? in parallel, without value normalization."
print
v -
if {$!<=1} d0 v + return fi
$!,1,1,1,x ({'{^}'}) rm..
l.
s -,{','} y x
i[0--2] ({'d0['})
i[2--2:2] ({'],'})
({']'})
a x com={t} rm
endl
m "__dp0 : parallel "$com __dp0 uncommand __dp0
d[] v +
#@cli display_polar : _width>32,_height>32,_outline_type,_fill_R,_fill_G,_fill_B,_theta_start,_theta_end,_xlabel,_ylabel
#@cli : Render polar curve from selected image data.
#@cli : 'outline_type' can be { r<0=dots with radius -r | 0=no outline | r>0=lines+dots with radius r }.
#@cli : 'fill_color' can be { -1=no fill | R,G,B=fill with specified color }.
#@cli : Default values: 'width=500', 'height=width', 'outline_type=1', 'fill_R=fill_G=fill_B=200', 'theta_start=0', 'theta_end=360', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@cli : $ 300,1,1,1,'0.3+abs(cos(10*pi*x/w))+u(0.4)' display_polar 512,512,4,200,255,200
#@cli : $ 3000,1,1,1,'x^3/1e10' display_polar 400,400,1,-1,,,0,{15*360}
display_polar : check "${1=500}>32 && ${2=$1}>32" skip ${3=1},${4=200},${5=$4},${6=$5},${7=0},${8=360},"${9=x-axis}","${10=y-axis}"
e[^-1] "Render $1x$2 polar graph plot from data of image"$_gmic_s", with outline $4 and fill color ($4,$5,$6)."
v - repeat $! l[$>] nm={0,n}
M={max(abs(iM),abs(im))}
* {0.48*min($1,$2)/$M}
y ({$7*pi/180};{-$8*pi/180}) r. 1,..,1,1,3
+sin. cos.. *. ... *[-3,-2]
a[-2,-1] x N={h}
nm. coords
if $3
({'CImg3d'}) +. 0.5 ($N,$N)
+z[coords] 0,2
1,$N,1,1,2 1,$N,1,1,'y' ++. 1 a[-3--1] x =. 0,2,100%
3,$N,1,1,0 1,$N,1,1,1 y[-6--1] a[-6--1] y
nm. _plot_polar_outline
fi
if {"$4>=0 && $5>=0 && $6>=0"}
({'CImg3d'}) +. 0.5 ({$N+1},$N)
+z[coords] 0,-1,2,100% z. 0,2
1,$N,1,1,3 1,$N 1,$N,1,1,'1+y' ++. 1 a[-4--1] x =. 1,3,100%
3,$N,1,1,$4,$5,$6 1,$N,1,1,1
y[-6--1] a[-6--1] y
nm. _plot_polar_fill
fi
rm[coords]
{$1-32},{$2-32},1,3,255
L={0.1*max($1,$2)} grid. $L,$L,0,0,0.25,0xCCCCCCCC,0
if {"$4>=0 && $5>=0 && $6>=0"}
j3d. [_plot_polar_fill],50%,50%,0,1,2,1,0
rm[_plot_polar_fill]
fi
if $3
if {$3>=0}
j3d. [_plot_polar_outline],50%,50%,0,1,1,0,0
fi
if {$3!=0}
if {abs($3)>1} circles3d[_plot_polar_outline] {abs($3)} fi
j3d. [_plot_polar_outline],50%,50%,0,0.2,2,0,0
fi
rm[_plot_polar_outline]
fi
nM={$M/0.96}
100%,100%,1,1,255 axes. {-$nM},$nM,$nM,{-$nM},14,1,0
+erode. 3 !=. 255 r.. 100%,100%,1,3 j... ..,0,0,0,0,1,.,1 rm[-2,-1]
frame. 1,1,128 frame. 15,15,220
0 t. "$9",0,0,13,1,-220,-220,-220 j.. .,{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 rm.
0 t. "$10",0,0,13,1,-220,-220,-220 rotate. -90 j.. .,2,{({-2,h}-h)/2},0,0,-1 rm.
nm $nm endl done v +
#@cli dq : eq. to 'display_quiver'.
dq :
v - _gmic_s="$?" v +
_display_quiver $*
#@cli display_quiver : _size_factor>0,_arrow_size>=0,_color_mode={ 0=monochrome | 1=grayscale | 2=color }
#@cli : Render selected images of 2D vectors as a field of 2D arrows.
#@cli : (eq. to 'dq').
#@cli : Default values: 'size_factor=16', 'arrow_size=1.5' and 'color_mode=1'.
#@cli : $ image.jpg +luminance gradient[-1] xy rv[-2,-1] *[-2] -1 a[-2,-1] c crop 60,10,90,30 +display_quiver[1] ,
display_quiver :
v - _gmic_s="$?" v +
_$0 $*
_display_quiver : check "${1=16}>0 && ${2=1.5}>=0 && isint(${3=2}) && $3>=0 && $3<=2"
e[0--3] "Render field of 2D arrows from image"$_gmic_s", with size factor $1, arrow size $2 in "${arg\ 1+$3,monochrome,grayscale,color}" mode."
v - repeat $! l[$>]
+norm. /.. {max(1e-6,iM)} rm.
{$1*w},{$1*h},1,{"1<<cut($3,0,2)"}
eval.. "
begin(C = resize([255],s#1,1));
"${-math_lib}"
len = norm2(I(x,y));
ang = atan2(i(x,y,0,1),i(x,y,0,0))*180/pi;
P = [ -0.5,-0.05, 0.3,-0.05, 0.2,-0.25, 0.5,0, 0.2,0.25, 0.3,0.05, -0.5,0.05 ];
P*=$1*$2*len;
X = resize([(x+0.5)*w#1/w,(y+0.5)*h#1/h],size(P),0,2);
X+=mul(P,rot(-ang),2);
if ($3,
v = min(1,max(0.5,3*len));
if ($3==1,
C = [ 255*v,255 ],
C = [ hsv2rgb([ ang,1,v ]), 255 ];
);
);
for (k = 0, k<3, ++k,
i0 = arg(k + 1,0,2,4);
i1 = arg(k + 1,2,10,6);
i2 = arg(k + 1,12,12,8);
polygon(#1,3,X[i0,2],X[i1,2],X[i2,2],1,C);
); I"
rm..
endl done v +
#@cli drgba : eq. to 'display_rgba'.
drgba : skip "${1=none},${2=$1},${3=$1}"
v - _gmic_s="$?" v +
_display_rgba ${^0}
v - if {!${}} noarg fi v +
#@cli display_rgba : _background_RGB_color
#@cli : Render selected RGBA images over a checkerboard or colored background.
#@cli : (eq. to 'drgba').
#@cli : Default values: 'background_RGB_color=undefined' (checkerboard).
#@cli : $ image.jpg +norm threshold[-1] 40% blur[-1] 3 normalize[-1] 0,255 append c display_rgba
display_rgba : skip "${1=none},${2=$1},${3=$1}"
v - _gmic_s="$?" v +
_$0 ${^0}
v - if {!${}} noarg fi v +
_display_rgba : skip "${1=},${2=$1},${3=$1}"
v - l[] is_rgb={"isval($1)"} onfail is_rgb=0 endl v +
if $is_rgb e[0--4] "Render RGBA image"$_gmic_s" over RGB background ($*)."
else e[0--4] "Render RGBA image"$_gmic_s" over a checkerboard background."
fi
v - repeat $! l[$>] if {s==2" || "s==4}
if $is_rgb i[0] 100%,100%,1,3 fc[0] {[$*]}
else i[0] (160,128;128,160) r[0] 16,16 r[0] [1],[1],1,{s-1},0,2
fi
nm[0] {1,n}
sh. {s-1} j[0] [1],0,0,0,0,1,[2],255 k[0]
fi endl done to_rgb u $is_rgb v +
#@cli dt : eq. to 'display_tensors'.
dt :
v - _gmic_s="$?" v +
_display_tensors $*
#@cli display_tensors : _size_factor>0,_ellipse_size>=0,_color_mode={ 0=monochrome | 1=grayscale | 2=color },_outline>=0
#@cli : Render selected images of tensors as a field of 2D ellipses.
#@cli : (eq. to 'dt').
#@cli : Default values: 'size_factor=16', 'ellipse_size=1.5', 'color_mode=2' and 'outline=2'.
#@cli : $ image.jpg diffusiontensors 0.1,0.9 resize2dx 32 +display_tensors 64,2
#@cli : $$
display_tensors :
v - _gmic_s="$?" v +
_$0 $*
_display_tensors : check "${1=16}>0 && ${2=1.5}>=0 && isint(${3=2}) && $3>=0 && $3<=2 && ${4=2}>=0"
e[0--3] "Render field of 2x2 tensors from image"$_gmic_s", with size factor $1, ellipse size $2 in "${arg\ 1+$3,monochrome,grayscale,color}" mode and outline $4."
v - repeat $! l[$>]
* {($2*$1/2)/max(abs(im),abs(iM))}
{$1*w},{$1*h},1,{"1<<cut($3,0,2)"}
f.. "
begin(C = resize([255],s#1,1); Co = resize([0],s#1,1); Co[s#1 - 1] = $3?255:0);
"${-math_lib}"
X = ([ x,y ]+=0.5)*$1;
T = [ R, G, G, B ];
E = eig(T);
r1 = E[0];
r2 = E[1];
ang = atan2(E[3],E[2])*180/pi;
if ($3,
v = min(1,max(0.5,3*r1/($1*$2)));
if ($3==1,
C = [ 255*v,255 ],
C = [ hsv2rgb([ 2*ang,1-r2/r1,v ]), 255 ];
);
);
for (k = 1, k>=0, --k, ellipse(#1,X,r1 + k*$4,r2 + k*$4,ang,1,arg(k + 1,C,Co)));
I"
rm..
endl done v +
#@cli dw : eq. to 'display_warp'.
dw :
v - _gmic_s="$?" v +
_display_warp $*
#@cli display_warp : _cell_size>0
#@cli : Render selected 2D warping fields.
#@cli : (eq. to 'dw').
#@cli : Default value: 'cell_size=15'.
#@cli : $ 400,400,1,2,'x=x-w/2;y=y-h/2;r=sqrt(x*x+y*y);a=atan2(y,x);5*sin(r/10)*[cos(a),sin(a)]' +display_warp 10
display_warp :
v - _gmic_s="$?" v +
_$0 $*
_display_warp : check "${1=15}>0"
e[0--3] "Render 2D warping field"$_gmic_s", with cell size $1."
v - repeat $! l[$>]
if {d!=1||s!=2}
v + error[0--3] "Command 'display_warp': Invalid image ["{$!-$>-1}"]: Dimensions "{w}","{h}","{d}","{s}" does not represent a 2D field of 2D vectors."
fi
i[0] 100%,100%,1,1,1 grid[0] $1,$1 nm[0] {1,n}
warp[0] [1],1,1,0 rm[1]
endl done * 255 v +
#@cli document_gmic : _format={ ascii | bash | html | images | latex },_image_path,_write_wrapper={ 0 | 1 }
#@cli : Create documentation of .gmic command files (loaded as raw 'uchar' images), in specified format.
#@cli : Default values: 'format=ascii', 'image_path=""' and 'write_wrapper=1'.\n
#@cli : Example(s) : raw:filename.gmic,char document_gmic html,img
document_gmic : skip ${1="ascii"},${2=""},${3=1}
if {!$!} return fi
v -1
_name={0,b}
if {$!>1} i[1--2] (10) fi a y m {t} s -,10
_document_gmic_header_$1[] $3
_subsection=0
_example=0
_command=0
_is_example=0
_path="$2"
ks0="0" ks1="k[0]"
go_on=1
repeat $! l[$>] if {$go_on" && "h>7" && "same([{^}],'#@cli',5)" && (i[5]==_' ' || i[5]==_':')"}
rows 6,100% autocrop {'" "'}
_is_example=0
if {i!=_':'}
_command+=1
s -,{'": "'} autocrop {'" "'}
_document_gmic_declaration_$1
else
rows 1,100%
if {i==_':'}
_subsection+=1
rows 1,100% autocrop {'" "'}
if {"['"{t}"']=='Additional Gallery Images'"} go_on=0
else _document_gmic_subsection_$1
fi
else
autocrop {'" "'}
if {i==_'$'}
rows 1,100% autocrop {'" "'}
_is_example=1
if {i!=_'$'} _example+=1 fi
_filename=$_path$_name$_example.jpg
_document_gmic_example_$1
else
_document_gmic_description_$1
fi
fi
fi
fi ${ks{$!!=0}} endl done
rm
_document_gmic_footer_$1[] $3
_document_gmic_header_ascii : skip $1
_shortcut=0
_document_gmic_subsection_ascii :
v +
e[] "\n\n "$_gmic_r$_gmic_b"**** "{0,t}":"$_gmic_n"\n"
v -
_document_gmic_declaration_ascii :
if {[{^}]=='(+)'} qualifier=" "{t} rm. else qualifier="" fi
if {$!>1" && "same([{^}],'"eq. to "',7)}
rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
else
v + e[] "\n    "$_gmic_m${_gmic_b}{0,t}${qualifier}":"$_gmic_n v - rm[0]
if $!
s="        "
y x
repeat {$!-1} ({'" |"'}) a[$>,-1] x done
repeat $! l[$>] _document_gmic_split_ascii 80
repeat {$!-1} ({'\\\\\n$s" "'}) a[$>,-1] x done
a x v + e[] $_gmic_c$s{0,t}$_gmic_n v -
endl done
fi
v + e[] "" v -
fi
_document_gmic_description_ascii :
s="      " bs0="\n" bs1="\\\\\n         "
is_equivalent={same([{^}],"'(eq. to '",8)}
is_default={same([{^}],"'Default value'",13)}
y x if {!narg($_is_tutorial)} _document_gmic_split_ascii 96 fi
if {$!==1" && "0$_vt100>0" && "$is_equivalent}
replace_str "eq. to","equivalent to shortcut command"
s +,39 if {$!==5} i[2] ({'$_gmic_m$_gmic_b'}) i[4] ({'$_gmic_n'}) y fi a y
fi
repeat {$!-1} ({'${bs$_is_example}$s"  "'}) a[$>,-1] x done a x
if {0$_vt100>0}
replace_str "Default values:","\n"$s$_gmic_n${_gmic_b}"Default values:"$_gmic_n
replace_str "Default value:","\n"$s$_gmic_n${_gmic_b}"Default value:"$_gmic_n
replace_str "G'MIC",${_gmic_g}"G'MIC"$_gmic_n
replace_str "(no arg)",${_gmic_g}"(no arg)"$_gmic_n
if {!$_is_example" && "!$is_equivalent}
s +,39 if {$!>=3}
ind=0 closing=0
do
if {"const ind = "$ind"; h#ind==1 && i#ind==39 && h#(ind+2)==1 && i#(ind+2)==39 && h#(ind+1)<48 && (im#(ind+1)>32 || "$is_default")"}
l[$ind,{$ind+2}] rm (39,{'$_gmic_c'}) ({'$_gmic_n'},39) y endl
ind+=2
fi
ind+=1
while {$ind<$!-3}
a y
fi
s +,{'\{'} s +,{'\}'} if {$!>=3}
ind=0 closing=0
do
if {"const ind = "$ind"; h#ind==1 && i#ind==123 && h#(ind+2)==1 && i#(ind+2)==125"}
l[$ind,{$ind+2}] rm ({'$_gmic_g'},123) (125,{'$_gmic_n'}) y endl
ind+=2
fi
ind+=1
while {$ind<$!-3}
a y
fi
s +,{'['} s +,{']'} if {$!>=3}
ind=0 closing=0
do
if {"const ind = "$ind"; h#ind==1 && i#ind==91 && h#(ind+2)==1 && i#(ind+2)==93"}
l[$ind,{$ind+2}] rm ({'$_gmic_c'},91) (93,{'$_gmic_n'}) y endl
ind+=2
fi
ind+=1
while {$ind<$!-3}
a y
fi
fi
fi
v + repeat $! e[] $s{$>,t} v - done
_document_gmic_example_ascii :
_document_gmic_footer_ascii : skip $1
if $_shortcut
({'"Command shortcuts"'}) _document_gmic_subsection_ascii. v + e[] "" v - rm.
_document_gmic_sort_shortcuts[]
v + repeat $_shortcut
e[] "    "$_gmic_m${_gmic_b}${_sshortcut$>}" "${_sshortcutqualifier$>}":"$_gmic_n" eq. to '"$_gmic_g${_sshortcutlink$>}$_gmic_n"'."
done v -
fi
v + e[] "\n   "$_gmic_c"[ Total number of commands: "$_command" ]"$_gmic_n v -
_document_gmic_split_ascii :
do if {w>$1}
i={$1-1}
repeat {$1/2} if {C=i($1-1-$>);C==32||C==38||C==42||C==43||C==44||C==46||C==47||C==58||C==59||C==63||C==92||C==124} i={$1-1-$>} break
fi done
+z. {$i+1},100% z.. 0,$i
fi while {w>$1}
if {$!>1" && "w<10} a[-2,-1] x fi
_document_gmic_header_bash : skip $1
v +
e[] "#
\n#  Bash completion rules for 'gmic'.
\n#
\n# This file has been generated automatically.
\n# Do not edit!
\n#
\n# This file should be copied/renamed in '/usr/share/bash-completion/completions/gmic'.
\n#
\n
\n_"$_name"()
\n{
\n\tlocal cur prev opts coms
\n\t_init_completion || return
\n\tCOMPREPLY=()
\n\tcur=\"${COMP_WORDS[COMP_CWORD]}\"
\n\tprev=\"${COMP_WORDS[COMP_CWORD-1]}\"
"
v -
_opts=
_coms=
_argcommand=0
_shortcut=0
_nbopts=0
_nbcoms=0
_document_gmic_subsection_bash :
_document_gmic_description_bash :
_document_gmic_example_bash :
_document_gmic_declaration_bash :
_opts$_nbopts={0,t}" "-{0,t}" "--{0,t}" "+{0,t}
_nbopts+=1
_coms$_nbcoms={0,t}
_nbcoms+=1
if {"s = ["{^}"]; s=='input' || s=='i' || s=='output' || s=='o' || s=='command' || s=='m'"} return fi
repeat $! if {[{^}]=='(+)'} rm[$<] fi done
if {$!==2" && "same([{^}],'"eq. to "',7)}
rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39 autocrop. {'-'}
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut=${str2hex\ {1,t}}
rm.
_shortcut+=1
elif {$!>1}
_command$_argcommand={0,t}
if {[{0,^}]=='help'}
_argument$_argcommand="$coms\" -- \"$cur"
else
if {$!==2} ({'>'}) fi
replace_str[^0] " ","_"
replace_str[^0] "'","\\\\'"
i[2--2] ({'" "'}) a[^0] y
_argument$_argcommand={1,t}
fi
_argumentlink${str2hex\ {0,t}}=${_argument$_argcommand}
_argcommand+=1
fi
_document_gmic_footer_bash : skip $1
str_coms= repeat $_nbcoms str_coms=${str_coms}" "${_coms$>} done
v +
e[] "\tcoms=\""${str_coms}" \""
e[] "\topts=$(echo \"\$coms\" | sed \"s: \\([^ ]\\+\\): \\1 -\\1 \\+\\1 --\\1:g\")"
e[] "\n\tcase \"${prev}\" in"
repeat $_argcommand
if {'${_command$>}'!='i'" && "'${_command$>}'!='o'" && "!same('${_command$>}','input',5)" && "!same('${_command$>}','output',6)}
e[] "\t\t\""${_command$>}"\" | \"-"${_command$>}"\" | \"--"${_command$>}"\" | \"+"${_command$>}"\")\n\t\t    "\
"COMPREPLY=( $(compgen -W \""${_argument$>}"\") ); return 0;;"
fi
done
repeat $_shortcut
if {['${_shortcut$>}']!='i'" && "['${_shortcut$>}']!='o'" && "narg(${_argumentlink${_shortcutlink$>}})}
e[] "\t\t\""${_shortcut$>}"\" | \"-"${_shortcut$>}"\" | \"--"${_shortcut$>}"\" | \"+"${_shortcut$>}"\") "\
"COMPREPLY=( $(compgen -W \""${_argumentlink${_shortcutlink$>}}"\") ); return 0;;"
fi
done
e[] "\tesac\n
\n\tCOMPREPLY=( $(compgen -W \"$opts\" -- \"$cur\") )
\n\t_filedir
\n}
\ncomplete -F _"$_name" -o filenames gmic"
v -
_document_gmic_header_html :
if $1 v + e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<head>
\n<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>
\n<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />
\n<script type=\"text/javascript\">
\nhs.graphicsDir = 'highslide/graphics/';
\nhs.wrapperClassName = 'wide-border';
\n</script>
\n</head>
\n<body>
\n"
v - fi
m "don : _document_gmic_desc_on_html"
m "doff : _document_gmic_desc_off_html"
m "eon : _document_gmic_ex_on_html"
m "eoff : _document_gmic_ex_off_html"
_is_desc=0
_is_ex=0
_shortcut=0
_document_gmic_desc_on_html :
v -
if $_is_desc
u "<br/>"
else
u "<p style=\"margin-left:50px; text-align:left\"><tt>"
_is_desc=1
fi
v +
_document_gmic_desc_off_html :
v -
if $_is_desc
u "</tt></p>"
_is_desc=0
else u ""
fi
v +
_document_gmic_ex_on_html :
v -
if $_is_ex
u ""
else
u "<br/><table style=\"margin-left:50px\" width=\"95%\" bgcolor=\"#FFFFFF\" bordercolor=\"black\" border=\"1\" cellpadding=\"4\" cellspacing=\"0\">"\
"<tr><td colspan=\"2\" bgcolor=\"#000000\"><font color=\"white\"><b>Example of use:</b></font></td></tr>"
_is_ex=1
fi
v +
_document_gmic_ex_off_html :
v -
if $_is_ex
u "</table>"
_is_ex=0
else
u ""
fi
v +
_document_gmic_subsection_html :
v +
e[] ${-eoff}${-doff}"<hr style=\"border-top: 1px solid \#ccc;\"/>\n<br/><h2><a href=\"#toc\"><img alt=\"\" border=\"0\" src=\"img/back_top.png\" /></a>&nbsp;&nbsp;"\
"<a id=\"subsection"$_subsection"\"><font color=\"#B00000\">"{0,t}"</font></a></h2>"
v -
_document_gmic_declaration_html :
if {[{^}]=='(+)'} qualifier=" (+)" rm. else qualifier="" fi
s1="\n" s0=" |<br/>"
if {$!>1" && "same([{^}],'"eq. to "',7)}
rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
else
_command_name={0,t}
v +
e[] ${-eoff}${-doff}"<br/><hr style=\"border-top: 1px solid \#ccc;\"/><p><a id=\""{0,t}"\">"\
"<span class=\"ref_decl\"><b>"{0,t}"</b></span></a>"$qualifier"&nbsp;&nbsp;&nbsp;<a style=\"font-weight: normal\" href=\"#"$_command_name"\"><img src=\"img/icon_link.png\" /></a>"
if {$!>1}
e[] "<p style=\"margin-left:50px; font-family: monospace; color: \#900090; text-align: left\">"
repeat {$!-1} l[{1+$>}]
if {h>48} v - replace_str ",",", " v + fi
e[] "<span style=\"margin-left:-1.5em\">"{0,t}"</span>"${s{$<==0}}
endl done
e[] "</p>"
else e[] ""
fi
v -
fi
_document_gmic_description_html :
is_equivalent={same([{^}],"'(eq. to '",8)}
is_default={same([{^}],"'Default value'",13)}
replace_str "\\n","<br/>"
replace_str "G'MIC","<b><font color=\"#900090\">G\47MIC</font></b>"
replace_str "(no arg)","<font color=\"#900090\">(no arg)</font>"
add_link_html. 1
if {!$_is_example" && "!$is_equivalent}
s +,39 if {$!>=3}
ind=0 closing=0
do
if {"const ind = "$ind"; h#ind==1 && i#ind==39 && h#(ind+2)==1 && i#(ind+2)==39 && h#(ind+1)<48 && (im#(ind+1)>32 || "$is_default")"}
l[$ind,{$ind+2}] rm
({'"<span class=\"ref_code\">"'})
({'"</span>"'})
y endl
ind+=2
fi
ind+=1
while {$ind<$!-3}
a y
fi
s +,{'\{'} s +,{'\}'} if {$!>=3}
ind=0 closing=0
do
if {"const ind = "$ind"; h#ind==1 && i#ind==123 && h#(ind+2)==1 && i#(ind+2)==125"}
l[$ind,{$ind+2}] rm ({'"<span style=\"color: \#900090; font-family: monospace\">"'},123) (125,{'"</span>"'}) y endl
ind+=2
fi
ind+=1
while {$ind<$!-3}
a y
fi
s +,{'['} s +,{']'} if {$!>=3}
ind=0 closing=0
do
if {"const ind = "$ind"; h#ind==1 && i#ind==91 && h#(ind+2)==1 && i#(ind+2)==93"}
l[$ind,{$ind+2}] rm ({'"<font color=\"#005090\">"'},91) (93,{'"</font>"'}) y endl
ind+=2
fi
ind+=1
while {$ind<$!-3}
a y
fi
fi
if $is_default
s +,{':'} l[^0] a y endl autocrop {':'} autocrop {'" "'}
if {$!>1}
replace_str "ref_code","ref_defvals"
v + e[] ${-don}"<br/><b>"{0,t}"</b>: "{t}
else
v + e[] ${-don}"<br/>"{0,t}
fi
v -
elif $is_equivalent
replace_str "eq. to","equivalent to shortcut command"
s +,39 if {$!==5} rm[1,3] i[1]
({'"<span class=\"ref_code\">"'})
i[3] ({'"</span>"'})
y fi a y
v + e[] ${-don}"<i>"{t}"</i>" v -
else
if {(i<_'A'" || "i>_'Z')" && "i!=40" && "i!=39} v + e[] ${-don}"&nbsp;"{t} v -
else v + e[] ${-don}{t} v -
fi
fi
_document_gmic_example_html :
if {i==_'$'}
if {h==1" && "i==_'$'} tuturl=https://gmic.eu/tutorial/_$_command_name.shtml
else autocrop {'$'} autocrop {'" "'} tuturl=https://gmic.eu/tutorial/{0,t}.shtml
fi
v +
e[] ${-eon}"<tr><td width=\"24\" align=\"center\"><a target=\"_blank\" href=\""$tuturl"\"><img src=\"img/icon_info.png\" /></td>"\
"<td><a target=\"_blank\" href=\""$tuturl"\">A tutorial page exists for this command.</a></td></tr>"
v -
else
if $_filename else
m "foo : "{t}
l[] v -99 reset foo v -1 _document_gmic o $_filename,85 rm endl
uncommand foo
fi
({'${-eon}"<tr><td width=\"24\" align=\"center\"><div><a href=\""$_filename"\" class=\"highslide\" onclick=\"return hs.expand(this)\">"\
"<img src=\"img/icon_magnifier.png\" /></a><div class=\"highslide-caption\"><b>"{t}"</b></div></div></td><td><span style=\"font-family: monospace; text-align: left\"><b>"{t}"</b></span></td></tr>"'})
replace_str. " "$_command_name" "," <span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span> "
replace_str. " "$_command_name"."," <span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>."
replace_str. " "$_command_name"["," <span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>["
replace_str. "+"$_command_name" ","+<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span> "
replace_str. "+"$_command_name".","+<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>."
replace_str. "+"$_command_name"[","+<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>["
replace_str. $_command_name"<","<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span><"
replace_str. ">"$_command_name,"><span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>"
v +
e[] {t}
v - rm.
fi
_document_gmic_footer_html : skip $1
if $_shortcut
_subsection+=1
({'"Command shortcuts"'}) _document_gmic_subsection_html. rm.
_document_gmic_sort_shortcuts[]
v + e[] "<p style=\"margin-left:20px\">"
repeat $_shortcut
e[] "<font color=\"green\"><b>&nbsp;&nbsp;"${_sshortcut$>}" "${_sshortcutqualifier$>}"</b>:</font>"
v - ({'${_sshortcutlink$>}'}) scl={t} rm. v +
e[] "<font color=\"blue\"><i>Shortcut for command '<a href=\"#"$scl"\">"${_sshortcutlink$>}"</a>'</i></font><br/>"
done
e[] "</p>" v -
fi
v +
e[] ${-eoff}${-doff}"<p style=\"margin-left:50px\"><font color=\"blue\"><b>[ Total number of commands: "$_command" ]</b></font>"
v -
uncommand don,doff,eon,eoff
add_link_html : check "isbool(${1=0})"
repeat $!
_add_link_html[$>] $1,http://
_add_link_html[$>] $1,https://
done
_add_link_html :
if $1 target=" target=\"_blank\"" fi
s +,{'"$2"'}
repeat {$!-1} if {$>,crop()==['"$2"']}
l[{$>+1}]
s +,{'" "'} s[0] +,{')'} s[0] +,{']'} s[0] +,39 s[0] +,{'\"'} s[0] +,{'<'}
url="$2"{0,t} i[1] ({'</a>'}) y[1]
a y endl
rm[$>] i[$>] ({'"<a href=\""$url"\""$target">$2"'}) y[$>]
fi done a y
_document_gmic_header_images : skip $1
use_vt100
v +
e[] "\n - Generate example images from set of commands '"${_gmic_c}$_name${gmic_n}"'.\n"
if image.jpg else l[] sp pencils onfail testimage2d 400 endl o. image.jpg rm. fi
v -
_document_gmic_subsection_images :
v +
e[] "\n "${_gmic_r}"** Section ""#"$_subsection": "{0,t}"."${_gmic_n}"\n"
v -
_document_gmic_declaration_images : _command_name={0,t}
_document_gmic_description_images :
_document_gmic_example_images :
if {i==_'$'} return fi
v +
e[] "    "${_gmic_c}"["$_example"]"${_gmic_n}" Command '"${_gmic_g}$_command_name${_gmic_n}"': $ "{t}
v -
if $_filename else
m "foo"$_example" : "{t}
l[] v -1 reset v -99 etime=$| foo$_example etime={_round($|-$etime,0.01)} v -1 _document_gmic o $_filename,85 rm endl
uncommand foo$_example
v +
e[] "\r    "${_gmic_c}"["$_example"]"${_gmic_n}" Command '"${_gmic_g}$_command_name${_gmic_n}"': $ "{t}\
${_gmic_m}" (done in "$_gmic_n${etime}"s"$_gmic_m")."$_gmic_n
v -
fi
_document_gmic_footer_images : skip $1
v +
e[] " - [ All done! ]\n\n"
v -
_document_gmic_header_latex :
if $1 v +
e[] "\\documentclass[a4paper,10.5pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,color}
\n\\graphicspath{{"$_path"}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{5.875in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\oddsidemargin}{15.5pt}
\n\\setlength{\\evensidemargin}{15.5pt}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\def\\Ccr{\\color{ca}}
\n\\def\\Ccb{\\color{cb}}
\n\\def\\Ccg{\\color{cc}}
\n\\def\\Ccc{\\color{cd}}
\n\\def\\Ccn{\\color{black}}
\n\\def\\comma{\\discretionary{,}{}{,}}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\begin{document}
\n\\tableofcontents"
v - fi
v + e[] "\n\\chapter{List of commands}" v -
m "eon : _document_gmic_ex_on_latex"
m "eoff : _document_gmic_ex_off_latex"
_is_desc=0
_is_ex=0
_shortcut=0
_document_gmic_ex_on_latex :
v -
if $_is_ex
u "\\\\"
else
u "\\begin{center}"
_is_ex=1
fi
v +
_document_gmic_ex_off_latex :
v -
if $_is_ex
u "\\end{center}"
_is_ex=0
else
u ""
fi
v +
_document_gmic_subsection_latex :
_is_desc=0
_document_gmic_replace_latex
v + e[] ${-eoff}"\n\\section{"{0,t}"}" v -
_document_gmic_declaration_latex :
_is_desc=0
if {[{^}]=='(+)'} qualifier={t} rm. else qualifier="" fi
e1="\\end{flushleft}" e0="~~~\\\\"
if {$!>1" && "same([{^}],'"eq. to "',7)}
_document_gmic_replace_latex
rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
else
_document_gmic_replace_latex[0]
_command_name={0,t}
v + e[] ${-eoff}"\n\n\\subsection{\\emph{"{0,t}"\\index{"{0,t}"}} "$qualifier"}\\vspace*{-0.7em}"
if {$!>1}
e[] "~\\\\\\textbf{\\Cb{Arguments: }}\\begin{flushleft}"
repeat {$!-1} l[{1+$>}]
v - s y,-60 if {$!>1} i[1--2] ({'\\-'}) fi y a y
_document_gmic_replace_latex v +
e[] "{\\small \\Cb{\\hspace*{0.5cm}$\\bullet$~~\\texttt{"{0,t}"}}}"${e{$<==0}}
endl done
fi
v -
fi
_document_gmic_description_latex :
is_equivalent={same([{^}],"'(eq. to '",8)}
is_default={same([{^}],"'Default value'",13)}
s0="" s1="~\\\\" s=${s$_is_desc}
_document_gmic_replace_latex
if $is_default
s +,{':'} l[^0] a y endl autocrop {':'} autocrop {'" "'}
if {$!>1}
replace_str[1] " and ","} and \\\\texttt{"
v + e[] ${-eoff}"\\begin{flushleft}\\Cc{\\textbf{"{0,t}"}:\\\\~\\\\\\hspace*{0.5cm}{\\small $\\bullet$~~\\texttt{"{t}"}}}\\end{flushleft}" v -
else v + e[] ${-eoff}$s"~\\\\"{0,t} v -
fi
elif $is_equivalent
rows. 8,100% autocrop. {'.'} autocrop. {')'} autocrop. {'" "'}
v + e[] ${-eoff}$s"(\\emph{eq. to} {\\small \\texttt{"{t}"}})." v -
else
if {(i<_'A'" || "i>_'Z')" && "i!=40" && "i!=39} v + e[] ${-eoff}{t} v -
else v + e[] ${-eoff}$s{t} v -
fi
fi
_is_desc=1
_document_gmic_example_latex :
if {i==_'$'}
if {h==1" && "i==_'$'} tuturl=https://gmic.eu/tutorial/\\_$_command_name.shtml
else autocrop {'$'} autocrop {'" "'} tuturl=https://gmic.eu/tutorial/{0,t}.shtml
fi
l[] ({'$tuturl'}) replace_str "_","\\_"
s x,-60 if {$!>1} i[1--2] ({'\\\\-'}) fi a x
replace_str. "_","\\_" tuturl={t} rm endl
v +
e[] ${-eoff}
if {!$_is_ex} e[] "~\\\\" fi
e[] "~\\textbf{Tutorial page: }\\\\\\url{"$tuturl"}"
v -
else
_is_desc=0
if $_filename else
m "foo : "{t}
l[] v -99 reset foo v -1 _document_gmic o $_filename,85 rm endl
uncommand foo
fi
_document_gmic_replace_latex
v +
e[] ${-eon}"\\includegraphics[keepaspectratio=true,height=6cm,width=\\textwidth]{"$_filename"}\\\\"
e[] "{\\footnotesize \\textbf{Example "$_example"~:} \\texttt{"{t}"}}"
v -
fi
_document_gmic_footer_latex :
if $_shortcut
({'"Command shortcuts"'}) _document_gmic_subsection_latex. rm.
_document_gmic_sort_shortcuts[]
v + repeat $_shortcut
e[] "$\\bullet$~'\\texttt{\\Ca{"${_sshortcut$>}"}}' "${_sshortcutqualifier$>}"~is equivalent to~~'\\texttt{\\Ca{"${_sshortcutlink$>}"}}'.\\\\"
done v -
fi
if $1
v +
e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
v -
fi
uncommand eon,eoff
_document_gmic_replace_latex :
replace_str "\\","\\\\textbackslash "
replace_str "_","\\\\_"
replace_str "%","\\\\%"
replace_str "#","\\\\%"
replace_str "^","\\\\textasciicircum "
replace_str "$","\\\\$"
replace_str "\{","\\\\\{"
replace_str "\}","\\\\\}"
replace_str "&","\\\\&"
replace_str "|","~$|$~"
replace_str "<","$\<$"
replace_str ">","$\>$"
replace_str "\\\\textbackslash -","\\\\-"
replace_str ",","{\\\\\\comma}"
_document_gmic_header_man : skip $1
_gmic_n="\\fR"
_gmic_b="\\fB"
_gmic_r=""
_gmic_g=""
_gmic_c="\\fB"
_gmic_m=""
_document_gmic_header_ascii $"*"
_document_gmic_subsection_man :
v +
e[] "\n "$_gmic_b"** "{0,t}":"$_gmic_n
v -
_document_gmic_declaration_man :
if {[{^}]=='(+)'} qualifier=" "{t} rm. else qualifier="" fi
if {$!>1" && "same([{^}],'"eq. to "',7)}
rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
else
v + e[] "\n    "${_gmic_b}{0,t}${qualifier}":"$_gmic_n v - rm[0]
if $!
s="        "
y x
repeat {$!-1} ({'" |"'}) a[$>,-1] x done
repeat $! l[$>] _document_gmic_split_ascii 80
repeat {$!-1} ({'\n$s"  "'}) a[$>,-1] x done
a x v + e[] $s{0,t} v -
endl done
fi
v + e[] "" v -
fi
_document_gmic_description_man :
s="        " bs0="\n" bs1="\\\\\n         "
y x if {!narg($_is_tutorial)} _document_gmic_split_ascii 96 fi
repeat {$!-1} ({'${bs_is_example}$s"  "'}) a[$>,-1] x done a x
replace_str "Default values:","Default values:"
replace_str "Default value:","Default value:"
replace_str "\\","\\\\"
v + repeat $! e[] $s{$>,t} v - done
_document_gmic_example_man :
_document_gmic_footer_man : skip $1
_document_gmic_footer_ascii $"*"
_document_gmic :
repeat $! l[$>] W$>={w} H$>={h} D$>={d} S$>={s} IS_3D$>=${-_is_3d} endl done
repeat $! l[$>]
if ${IS_3D$>} r3d 1,1,0,-80 r3d 0,1,0,80 snapshot3d 400
else if {w>8192} z 0,8191 elif {h>8192} rows 0,8191 fi n 0,255
fi
endl done
+append_tiles 2 if {w>1024} r={round(1024*100/w,0.1)} r[^-1] $r%,$r%,1,100%,2 fi rm.
repeat $! l[$>]
if {s==1} r {w},{h},1,3 else r {w},{h},1,3,0 fi
if {w<=h&&h<256} r2dy 256,2 elif {h<=w&&w<256} r2dx 256,2 fi
if {w<=h&&h>512} r2dy 512,2 elif {h<=w&&w>512} r2dx 512,2 fi
if {h<48} r 100%,48 fi
if {w<48} r 48,100% fi
frame 1,1,0 frame 4,4,255
endl done
N=$! repeat $N l[$>]
{w},16,1,3,255
if {w>75}
if {$N>1} if {w>110} t. Image\ [$>]:,3,3,15 else t. [$>]:,3,3,15 fi fi
if ${IS_3D$>} 0 t. (3d\ object),0,0,13,1,255
else 0 t. (${W$>}x${H$>}x${D$>}x${S$>}),0,0,13,1,255
fi
negate. n. 0,255 +. 164 c. 0,255 to_rgb.
j.. .,{{-2,w}-w-5},{{-2,h}-h-1} rm.
else t. [$>]:,3,3,15 fi
rv[-2,-1] a[-2,-1] y
endl done
- 255 append_tiles 2 + 255
if {w<256} - 255 r 256,100%,1,3,0,0,0.5,0.5 + 255 fi
if {h<256} - 255 r 100%,256,1,3,0,0,0.5,0.5 + 255 fi
_document_gmic_sort_shortcuts :
$_shortcut,1,1,1,x s x repeat $! nm[$>] ${_shortcut$>} done sort_list +,n a x
repeat {w} i={i[$>]}
_sshortcut$>,_sshortcutqualifier$>,_sshortcutlink$>=${_shortcut$i},${_shortcutqualifier$i},${_shortcutlink$i}
done
rm
#@cli e : eq. to 'echo'. : (+)
#@cli echo : message : (+)
#@cli : Output specified message on the error output.
#@cli : (eq. to 'e').\n
#@cli : Command selection (if any) stands for displayed call stack subset instead of image indices.
#@cli echo_file : filename,message
#@cli : Output specified message, appending it to specified output file.
#@cli : (similar to 'echo' for specified output file stream).
echo_file : skip "${2='\n'}"
v - ({"'${2--1}\n'"}) o. raw:$1,char rm. v +
#@cli echo_stdout : message
#@cli : Output specified message, on the standard output (stdout).
#@cli : (similar to 'echo' for output on standard output instead of standard error).
echo_stdout :
v -  ({'"$*"\n'}) o. -.raw,char rm. v +
#@cli function1d : 0<=smoothness<=1,x0>=0,y0,x1>=0,y1,...,xn>=0,yn
#@cli : Insert continuous 1D function from specified list of keypoints (xk,yk)
#@cli : in range [0,max(xk)] (xk are positive integers).
#@cli : Default values: 'smoothness=1' and 'x0=y0=0'.
#@cli : $ function1d 1,0,0,10,30,40,20,70,30,80,0 +display_graph 400,300
function1d : check "${1=1}>=0 && $1<=1" skip ${2=0},${3=0}
e[^-1] "Input continuous 1D function, with smoothness $1 and keypoints (${2--1})."
v - l[]
smoothness={max(0,min(1,$1))}
(${2--1}) r 2,{int(w/2)},1,1,-1
sort +,y s x size={0,if(iM>=0,1+int(iM),0)}
if {!$size} rm 0 break fi
a x
+f '0.5*(j(0,1,0,0,0,1)-j(0,-1,0,0,0,1))' s. x max.. 0.01 /. .. rm.. a x
$size,1,1,1,-1
repeat {0,h-1}
x0={0,i(0,$>)} y0={0,i(1,$>)} x1={0,i(0,$>+1)} y1={0,i(1,$>+1)}
slope={($y1-$y0)/max(0.01,$x1-$x0)}
yp0={0,i(2,$>)*$smoothness+(1-$smoothness)*$slope}
yp1={0,i(2,$>+1)*$smoothness+(1-$smoothness)*$slope}
i={round($x0,1,1)} j={round($x1,1,0)}
line[1] $i,0,$j,0,1,$>
if {$j-$i<=1}
({$y0-$x0*$slope}^{$slope}^0^0)
else
(1,$x0,{($x0)^2},{($x0)^3};\
1,$x1,{($x1)^2},{($x1)^3};\
0,1,{2*$x0},{3*($x0)^2};\
0,1,{2*$x1},{3*($x1)^2})
($y0;$y1;$yp0;$yp1)
solve. .. rm.. y. c
fi
done
a[2--1] x map.. . rm.
100%,1,1,1,1
(0,{w-1}) r. {-2,w},1,1,1,3 round.
+sqr. +*[-2,-1] a[-4--1] c *[-2,-1] s. c +[-4--1] rm..
endl v +
#@cli i : eq. to 'input'. : (+)
#@cli input : [type:]filename : [type:]http://URL : [selection]x_nb_copies>0 : { width>0[%] | [image_w] },{ _height>0[%] | [image_h] },{ _depth>0[%] | [image_d] },{ _spectrum>0[%] | [image_s] },_{ value1,_value2,... | 'formula' } : (value1{,|;|/|^}value2{,|;|/|^}...) : 0 : (+)
#@cli : Insert a new image taken from a filename or from a copy of an existing image [index],
#@cli : or insert new image with specified dimensions and values. Single quotes may be omitted in
#@cli : 'formula'. Specifying argument '0' inserts an 'empty' image.
#@cli : (eq. to 'i' | (no arg)).
#@cli : Default values: 'nb_copies=1', 'height=depth=spectrum=1' and 'value1=0'.
#@cli : $ input image.jpg
#@cli : $ input (1,2,3;4,5,6;7,8,9^9,8,7;6,5,4;3,2,1)
#@cli : $ image.jpg (1,2,3;4,5,6;7,8,9) (255^128^64) 400,400,1,3,'if(x>w/2,x,y)*c'
#@cli : $$
#@cli input_cube : "filename",_convert_1d_cluts_to_3d={ 0 | 1 }.
#@cli : Insert CLUT data from a .cube filename (Adobe CLUT file format).
#@cli : Default value: 'convert_1d_cluts_to_3d=1'.
input_cube : skip ${2=1}
e[^-1] "Input CLUT from file '$1'."
v - l[]
i raw:"$1",uchar
f "i<_' ' && i!=10?_' ':i"
i[0] 0
range={"
line = vector512();
dmin = [ 0,0,0 ];
dmax = [ 1,1,1 ];
dim = size = 0;
target = 0;
pos = 0;
while (pos<h,
while (i[#-1,pos]<_' ', ++pos);
npos = find(#-1,'\n',1,pos);
if (npos<0, npos = h);
l = npos - pos;
copy(line[0],i[pos],l);
line[l] = 0;
if (same(line,'LUT_1D_SIZE ',12),
copy(line[0],line[12],size(line) - 12);
size = stov(line);
dim = 1;
resize(#0,3,size,1,1,0);
,_(else); if (same(line,'LUT_3D_SIZE ',12),
copy(line[0],line[12],size(line) - 12);
size = stov(line);
dim = 3;
resize(#0,3,size,size,size,0);
,_(else); if (same(line,'DOMAIN_MIN ',11),
copy(line[0],line[11],size(line) - 11);
dmin[0] = stov(line);
ind = find(line,_' ');
copy(line[0],line[ind + 1],size(line) - ind);
dmin[1] = stov(line);
ind = find(line,_' ');
copy(line[0],line[ind + 1],size(line) - ind);
dmin[2] = stov(line);
,_(else); if (same(line,'DOMAIN_MAX ',11),
copy(line[0],line[11],size(line) - 11);
dmax[0] = stov(line);
ind = find(line,_' ');
copy(line[0],line[ind + 1],size(line) - ind);
dmax[1] = stov(line);
ind = find(line,_' ');
copy(line[0],line[ind + 1],size(line) - ind);
dmax[2] = stov(line);
,_(else); val = stov(line); if (val>=0,
do (
i[#0,target++] = val;
ind = find(line,_' ');
if (ind<0, break());
copy(line[0],line[ind + 1],size(line) - ind);
val = stov(line);
,_(while); val>=0);
)))));
pos = ++npos;
);
[dmin,dmax];"}
rm.
permute yzcx
if {[$range]!=[0,0,0,1,1,1]}
f "begin(
range = ["$range"];
dmin = range[0,3];
dmax = range[3,3];
delta = dmax - dmin;
);
(I - dmin)*255/delta"
else * 255
fi
if {"w>1 && h==1 && d==1 && $2"} size={w} s c y.. y y. z r $size,$size,$size a c fi
nm "$1"
endl v +
#@cli ig : eq. to 'input_glob'.
ig :
_input_glob "$*"
#@cli input_glob : pattern
#@cli : Insert new images from several filenames that match the specified glob pattern.
input_glob :
_input_glob "$*"
_input_glob :
e[0--3] "Input all files that match glob pattern '$*'."
v -
files 3,"$*"
N=$!
m "_ig : $""=arg repeat $""# i ${arg{1+$>}} done"
_ig ${} uncommand _ig
if {$N==$!} v + error[0--3] "Command 'input_glob': No matching filenames for pattern '$*'." fi
v +
#@cli input_gpl : filename
#@cli : Input specified filename as a .gpl palette data file.
input_gpl :
e[^-1] "Input .gpl palette file '$*'."
v - l[]
i raw:"$*",char replace 9,32 s -,10
colors=0
repeat $! l[$>]
s -,32
if {$!>=3" && "isint({0,t})" && "isint({1,t})" && "isint({2,t})} colors=$colors;{0,t},{1,t},{2,t} fi
rm 0
onfail rm 0 endl done
rm ($colors) rows 1,100% nm "$1" permute yzcx
endl v +
#@cli o : eq. to 'output'. : (+)
#@cli output : [type:]filename,_format_options : (+)
#@cli : Output selected images as one or several numbered file(s).
#@cli : (eq. to 'o').
#@cli : Default value: 'format_options'=(undefined).
#@cli output_cube : filename
#@cli : Output selected CLUTs as a .cube file (Adobe CLUT format).
output_cube :
e[^-1] "Output CLUT$? as file '$1'."
v - N=$! repeat $N +l[$>] to_rgb
l={round((w*h*d)^(1/3))}
if {w*h*d!=$l^3} v + error "Command '$0': CLUT '"{n}"' has invalid dimensions "({w},{h},{d},{s}). fi
r $l,$l,$l,3,-1 permute cxyz / 255
if {$N>1} fn=${"filename \"$1\",$>"} else fn="$1" fi
o dlm:$fn rm i raw:$fn,uchar replace {','},32
0 nm. $fn basename={b} rm.
header="\# Created by: G'MIC (https://gmic.eu)\n"\
"TITLE \""$basename"\"\n\n"\
"# LUT size\n"\
"LUT_3D_SIZE "$l"\n\n"\
"# Data domain\n"\
"DOMAIN_MIN 0.0 0.0 0.0\n"\
"DOMAIN_MAX 1.0 1.0 1.0\n\n"\
"# LUT data points\n"
i[0] ({'$header'})
y a y o raw:$fn,uchar rm
endl done v +
#@cli output_ggr : filename,_gradient_name
#@cli : Output selected images as .ggr gradient files (GIMP).
#@cli : If no gradient name is specified, it is deduced from the filename.
output_ggr : skip "${2=}"
e[^-1] "Output image$? as .ggr gradient file '$1'."
v - N=$!
repeat $N +l[$>] r 1,{w*h*d},1,100%,-1 to_rgba / 255
if {narg("$2")} name="$2"
else l[] 1 nm. "$1" ({'{b}'}) f "if(x==0 && i>=_'a' && i<=_'z',i-_'a'+_'A',i)" name={t} rm endl
fi
({'"GIMP Gradient\nName: "$name\n{0,h}\n'})
repeat {0,h}
start={_$>/{0,h}}
end={_($>+1)/{0,h}}
mid={_0.5*($start+$end)}
rgba={0,I(0,$>)}
r={arg(1,$rgba)} g={arg(2,$rgba)} b={arg(3,$rgba)} a={arg(4,$rgba)}
({'$start" "$mid" "$end" "$r" "$g" "$b" "$a" "$r" "$g" "$b" "$a" 0 0\n"'})
done
rm[0] a x
if {$N>1} o raw:${"filename \"$1\",$>"},char else o raw:"$1",char fi
rm
endl done v +
#@cli on : eq. to 'outputn'.
on :
v - _gmic_s="$?" v +
_outputn $*
#@cli outputn : filename,_index
#@cli : Output selected images as automatically numbered filenames in repeat...done loops.
#@cli : (eq. to 'on').
outputn :
v - _gmic_s="$?" v +
_$0 $*
_outputn :
v -
if {$#==1} filename=${filename\ "$1",$>}
else filename=${filename\ "$1",$2}
fi
v +
e[0--3] "Output image"$_gmic_s" as file '"$filename"'."
v - o $filename v +
#@cli op : eq. to 'outputp'.
op :
v - _gmic_s="$?" v +
_outputp $*
#@cli outputp : prefix
#@cli : Output selected images as prefixed versions of their original filenames.
#@cli : (eq. to 'op').
#@cli : Default value: 'prefix=_'.
outputp :
v - _gmic_s="$?" v +
_$0 $*
_outputp : skip ${1="_"}
if {$!>1} e[0--4] "Output image"$_gmic_s" as their initial locations, prefixed by '$1'."
else e[0--4] "Output image"$_gmic_s" as its initial location, prefixed by '$1'."
fi
v - repeat $! o[$>] {$>,f}$1{$>,b}.{$>,x} done v +
#@cli ow : eq. to 'outputw'.
ow :
v - _gmic_s="$?" v +
_outputw
#@cli outputw
#@cli : Output selected images by overwriting their original location.
#@cli : (eq. to 'ow').
outputw :
v - _gmic_s="$?" v +
_$0 $*
_outputw :
if {$!>1} e[0--4] "Output image"$_gmic_s" as their initial location."
else e[0--4] "Output image"$_gmic_s" as its initial location."
fi
v - repeat $! o[$>] {$>,n} done v +
#@cli ox : eq. to 'outputx'.
ox :
v - _gmic_s="$?" v +
_outputx $*
#@cli outputx : extension1,_extension2,_...,_extensionN,_output_at_same_location={ 0 | 1 }
#@cli : Output selected images with same base filenames but for N different extensions.
#@cli : (eq. to 'ox').
#@cli : Default value: 'output_at_same_location=0'.
outputx :
v - _gmic_s="$?" v +
_$0 $*
_outputx :
v -
$=arg
is_last_arg=0 is_same_location=0
if {isval($-1)} is_last_arg={isint($-1)&&$-1>=0&&$-1<=1} is_same_location=$-1 fi
N={$#-$is_last_arg} s0= s1=s
if {!$N} v + e[0--3] "Output image"$_gmic_s" at same location, with same base filename but extension '' (skipped, no extension provided)." return
fi
if $is_same_location
v +
if $is_last_arg e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}"' ${^-1}'."
else e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}" '$*'."
fi
v -  repeat $! l[$>]
repeat $N o {0,f}{0,b}.${arg{1+$>}} done
endl done
else
v +
if $is_last_arg e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}"' ${^-1}'."
else e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}" '$*'."
fi
v -  repeat $! l[$>]
repeat $N o {0,b}.${arg{1+$>}} done
endl done
fi
v +
#@cli pass : _shared_state={ 0=non-shared (copy) | 1=shared | 2=adaptive } : (+)
#@cli : Insert images from parent context of a custom command or a local environment.
#@cli : Command selection (if any) stands for a selection of images in the parent context.
#@cli : By default (adaptive shared state), selected images are inserted in a shared state if they do not belong to the context (selection) of the current custom command or local environment as well.
#@cli : Typical use of command 'pass' concerns the design of custom commands that take images as arguments.
#@cli : Default value: 'shared_state=2'.
#@cli : $ command "average : pass$""1 add[^-1] [-1] remove[-1] div 2" sample ? +mirror y +average[0] [1]
#@cli plot : _plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_exit_on_anykey={ 0 | 1 } : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_exit_on_anykey={ 0 | 1 } : (+)
#@cli : Display selected images or formula in an interactive viewer (use the instant display window [0] if opened).
#@cli : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@cli : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@cli : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@cli : Default values: 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0 (auto)' and 'exit_on_anykey=0'.
#@cli p : eq. to 'print'. : (+)
#@cli print : (+)
#@cli : Output information on selected images, on the standard error (stderr).
#@cli : (eq. to 'p').
#@cli rainbow_lut
#@cli : Input a 256-entries RGB colormap of rainbow colors.
#@cli : $ image.jpg rainbow_lut +luminance[-2] map[-1] [-2]
rainbow_lut :
e[^-1] "Input RGB colormap of 256 rainbow colors."
v -
base642img "MiB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KMjU2IDEgMSAzICM2MjgKeJxj4uLl5Rfg5xcSl5JXVFVT19LS0dXR0dXVAdK6hkYmZuYWlhYWlpZWllZW1lY21lbWIGBjAyatIcDKysrCwszYQEddUYSVgYERjKAEHKDycABWSSOnwKi03LLGzgkz5q3YtH3f8fNX7zx+9ubTt1/////9+/fP71+/fv748f3Ht2/fvn77+vXrNyj4CgJfgBAGvgCZn9+/fvbozo3LZ04e2rdjw+olC2ZM6GqqKspOCPdztTTSU5MXZmXm4uMXFBIWEhaXlJNXVlUHetvA0MjYxNTC2t7JycXV3dPL28fH18/fPyAwMCgoOAQEQkPDgCA8IhxERURGRsXExCUkp2Vk55dW1DV19E2dvXD5mg2bNm/eBAQbN27cAATr165dt3bNaqxg7dq16zcAlW7dtmPXrn0HDh4+duLkmXMXL184d+rooX07t21as3zR3BkTulvqK4tz0pJiwv29XR3srMxNjAz1oUAPCIARp6WlqamhrqaqoiQvJysnJ6+goKCoqKSkqKSoIA8UkZIUFxXm5+UVEBISEuTn5eFkYhOWVNA0NHd09w+JSkjLyi+tbGhp6+6fNHXG7Dlz589fsHDR4iVLli5bvmzpsmXLl69YsWIlEKyCgNUQcvUakPs3bt6yfefufQePnTx39fbDx4/v37p25viBHZvXrFg0Z/rE7ta6isKspKjQIDQQEgKmgoMDAwMDAvz8/Hy8PD3dPVxdnB3trK0sjI0MdbU11FSVFeQhPlFWUQGlUh1dPT19A0MDOACHga6utrYW2P9qaqpArKamrgGCGurqQAFlJQU5GSlxEQE+HgFgAAgK8PFyMgEAsxoliDEgMTggMSAxICMyNgp4nHP3jWKILkrMzEvKL1fIKS2JZQAAON0GDg=="
nm. [rainbow\ lut]
v +
#@cli screen : _x0[%],_y0[%],_x1[%],_y1[%] : (+)
#@cli : Take screenshot, optionally grabbed with specified coordinates, and insert it
#@cli : at the end of the image list.
#@cli select : feature_type,_X[%]>=0,_Y[%]>=0,_Z[%]>=0,_exit_on_anykey={ 0 | 1 },_is_deep_selection={ 0 | 1 } : (+)
#@cli : Interactively select a feature from selected images (use the instant display window [0] if opened).
#@cli : 'feature_type' can be { 0=point | 1=segment | 2=rectangle | 3=ellipse }.
#@cli : Arguments 'X','Y','Z' determine the initial selection view, for 3D volumetric images.
#@cli : The retrieved feature is returned as a 3D vector (if 'feature_type==0') or as a 6d vector
#@cli : (if 'feature_type!=0') containing the feature coordinates.
#@cli : Default values: 'X=Y=Z=(undefined)', 'exit_on_anykey=0' and 'is_deep_selection=0'.
#@cli serialize : _datatype,_is_compressed={ 0 | 1 },_store_names={ 0 | 1 } : (+)
#@cli : Serialize selected list of images into a single image, optionnally in a compressed form.
#@cli : 'datatype' can be { auto | uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.
#@cli : Specify 'datatype' if all selected images have a range of values constrained to a particular datatype, in order to minimize the memory footprint.
#@cli : The resulting image has only integers values in [0,255] and can then be saved as a raw image of
#@cli : unsigned chars (doing so will output a valid .cimg[z] or .gmz file).
#@cli : If 'store_names' is set to '1', serialization uses the .gmz format to store data in memory (otherwise the .cimg[z] format).
#@cli : Default values: 'datatype=auto', 'is_compressed=1' and 'store_names=1'.
#@cli : $ image.jpg +serialize uchar +unserialize[-1]
#@cli shape_circle : _size>=0
#@cli : Input a 2D circle binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_circle ,
shape_circle : check "${1=512}>=0"
e[^-1] "Input a $1x$1 circle binary shape."
v -
ir={round($1)}
if {!$ir} 0
elif {$ir<2} $ir,$ir,1,1,1
else
{int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} =. 1,100%,100%
distance. 1 <=. {(i+0.4)/sqrt(2)}
+mirror. x
if {$ir>1&&($ir%2)} r. {w-1},100%,1,1,0,0,1 fi
a[-2,-1] x +mirror. y
if {$ir>1&&($ir%2)} r. 100%,{h-1},1,1,0,0,0,1 fi
a[-2,-1] y
fi
nm. "[2D circle shape]"
v +
#@cli shape_cupid : _size>=0
#@cli : Input a 2D cupid binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_cupid ,
shape_cupid : check "${1=512}>=0"
e[^-1] "Input a $1x$1 cupid binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMjMwMSAxIDEgIzI2NDQKeJx1mOl3lEUWxm+n6aS7IUSQRQQEFA37FtkFVFAEBxHZEoKACwRQEUHU0fGM58yZxa9z5i9AFBAhAZKwg8qACMM6CDgZIIQ9Kx0CmAHqzq/u2yR80A91nue5daveWm5tb2moNBSSkAiptCoq9RqToa6p3NVmMtyli2pzecp1IHWUke6R30wjyB9hfh0o97AMIw11D8kQ0mDXRga6VpLlWsoA10L6uQzpQ909XVy6u6hkulTp6lJkyamw1GhTGc33b2iGHHYR+RT8RVvIUReThKbI3+H/0wflGD512kT+oa3EaRt0M7mlEanFZ4X2QqdTLiLX8flK+5i+rWn36eb0MYqOyErT7eBp8rX2gz8Ej9H3iGww3Y5vZRg/QztvaqMuox13tAvpAdMX3JO0J+CX3AuGl904wytuvOFV9yLYF5wgG8Fy9xK6j1S4iWBvcBL23lLpXkH3kio3Bd1Tqt10sIdcczOkULtLws0Eu4GzwEypdbPJfxx8S3aC190i2aWPge+iu0idW4ruJDfcMvARuek+Ajsa7tT24O9lB33zuE3b4rdY1mtrw3zGPFtTZbm+K9/Qv+mM1Re6iPFKl2mM1Qp9R1Yxd1NJX8FXYptCDK2Ef0m5yfitgtcy7qsNMyi7iLY9IGsMW1Cvx5aylm94XGfYSgp0seF6w9aMyWLKt6HP76HbShFYCxaDCXCTYTvZqksYq4fp01KwA31dKjXE6ff6PthZ9uoyxrSL7AOr3KNyQD9gzB+Tg2CFe1yOGHaTf4Plrrv8BNYRq7eZi1OUqSN+7zJPJfCDGpJu6tdNXzmDPqRh6aHPShn8MDHXQ5+Ti8bD0l3HyiXa4u3ddZxcpT2ed9PxUtHAX5RKfA4Z/51UJXkmvJp+HYQ/Aa+BH2J8M3WCXKPfB+GPUzbgacYTxmNWNsGYHqSdmWb3vBn1jIcvop4IcZzKfKbKSdp1Td+2b9ajsyl/ClsC22H8/NrKoewp+pLQt8x2kzSDeT6lz1N2ofWjDlsue8hJ+p/QBeZXR30ziaEy2ndXx7BmA3st9le1JWPzstmOoBPYX2WNXzHbfPOrwT6LuKzQSazT+dbGauqaTcxW6SvUH/hVYZtDPNckbUewVZjtYeoNbEepqxzba8R/gvoCW4Q5iWLrQP3etoAYiMhlK8v60Yn2XW+7ZGUfZe+ZSPvyiJGIXKDOOdqVcXuJdr0hJ7CVYZvNGr3DHFToa4xRRErN70O+P0d+hp81/QHfno2OEEdpDboE/V+rY5lpz0tMv8/YzEJHrIzXl3Wm6VM2TkvJD/RJ00tMn0afsDFbgn8uuokct/F/j/wZfDsVnYZenNQROYYtlzi5ojmWf9Ri4B3ak2Nt9/P1BvFdT4xc1Wwr42NzHrFzhxgpT/p5W55+zDjk2Bj8i7RAPyHefX6EdRjoqqT/ftJC/QPzOMP8f2zQgf8+2vkW+lpS7yXf60SyfKA/RU+3Nv2zIT+Vto4z2+5knSU60vq2O9mGEh1h+rsGPczG8lvrwyeM21Cbi2+tn38iHoaY3kWb5uqf6fNg0ztIb+pf6GOjfl3/RhsCvd3m/nNibbDVv83m5nPiKsj3eib+9ejT6C2kHP0r6yf4ntfT9VvL22zzcMD4JvvuAfPZRB3zdCfnZ5rpYjAPfRheZHyH7QGFxrfbPN3j3mej8W3GN1hdW22drbe+brH59/xN3ZTkUfpY1GCfpRtsvRVYXwosnvLh2bqWtRTwV3QVa8jzKGdJAeOdZvbp1FkKrjP/rbae1uGTQ9sumD3K3rPL1uhaUo5+RwymwqP4f0+sRThfPP/B5t3bp+t+1nLApzJGt5I+U+D1ST4Jfsd4TCbC1fxj8rz+aPgcuA4co/usnjGmozIazDfcT39jhuvBZ8ENGpdnwI3oUfgVgk9RvhgcqLuZv7hk0eYt6CzdQ2x4/IEz2tv3c341Bc/JfwyvyDn24QFazvmSDlYRcxnST6tZHy05XyroV2swHuqhTUMlrPOpmh46Q53Z2jp0mTpytHPoOnt0rj4Rus39aoYOD03WJqGb+gTndkqoWjszJimh89QzWUOhMvZjj+eo/2VV5iVDxuovrLV0xuMW6yVOf2/anvU02IbUWuukhV6TGO2N6iVJ1YvSRM9LmBTSUql3P8stt4+7Uzr3j48Z8xhzlsk5wz3PfWjzcZF23EDXOn9OtSD2s8kPs889wNqPc89qTmxPw5ZCrMe5fzWFT6P/IcY2Lhe5a966Tx/nPnXP99e4n4+fXHbSPyYnuHcFPjE56XIb/Eu4f93zP+3mWJu8zxn3GmUD/7PudePe55x7Ax74lLk3OTe9PSrn3dwkj9HWeQ38ksuDh83H8xtJ+xU3v4FfdQuMF+FT7hbCw2avuI9Xci+sS/r/Fq9yb8ODtnl+Pdn+Knxqf4VX41OL/+Yk93f0+/kWxqcGfs14jLhPI969DnM/8+unOfW8TaymmB5LTG1J6m2UHUfMbeXsqMbfr4Px+hD2Rj2BM3o7ugr/Hfjncj9u1DH2md7gQvbdMOsnxnnWp0Hvwn8W97VGHUP3x28BayiFPT3OHjwgqcOcAT7f6/nsLWHWoc/PQuex76SgfX6j3m35T1JvHudCmHPH5z9JvXnEclj2WHsGYl8g5/G/p/fR/zL0Xmv/IM7DRaZ/QOey3x/izC2l/I/W3zGss0Wm96NzuHuVcmafxX+/rfEXqHsxazKFemKs/Qj311Gc4Uuwhbn/xeUFzrxK7g1eH0I/j67mnnGaMofRY/BPcE/xdRxBP82ZeF0/Mv9j6BE6nJj5mG+G2cfjMpgz6iZno/c/jh5An3/hbPX+J9D90PWcx2dt7TaVPujb+kfrw8/oXui7+pn1we9xPbTYfE+zz3WDe78zdm8tMn4Wn65w7+/3wke10Ph59pLOcO9zEXtH3Wj8Mrw93Ptcxacd55Ln5fC2ut54JbwV3PvXEKMtOYu8PQHP0Hzj19n30nWd8Trs8SS/RdlUzjTP6+Fh/cbafwcuugb+oDj3NdhCbrvVYHP2vlVgnHfLV2CU9fOl3V0qDbmPui/AJuxxcxmrIcYv2v4yyOo+z9vvBrHj+Tn2plp4Kd8/w15Ww3hudZPpU5Zs5s15mRgu5k16gVjf4J6hTD/Jd8MY676y1vVlzvvIN64r8dhb1vCe2swbdDXvsULePavYYwvAlbx91rLWVrgmvON6yATXm/MsLMvdAOI5zf4jrOQtvIc+3WF+VruBxHMz+5+wxg0iljvyrcGG+W4IeR2lwA1Fd6JNw5I4FHsnKXTDkziM+h4x3I1/Efj9fVgMfsd+UES5Xdzni8Gd3PWLqH8774BivreV/aOI72/WNobFnGVFtG0j+04h7d0AFoEFnCke19HeIpfFG7UZ5bN4z0bx6897N9X0cuZhEzgN36mkALNkiqX+Msn1I/WViYzPBNdTXuQdOc5lyljel8/x1hzN+/MZ0tOuk4wijWzA4J9K8D+lvf1PCf6ltLU0iPdvkO7Xngf/XIbw/r2H98r4fzD9eWf3Zu5GVv4foPOEnDEgMjAgMSAxICMzOQp4nHNn8GWIYmBgSGfIZchkSGaIZzCAQj0gLxMoms5QBZQHAHyqBfY="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>480} b. 0.2% fi >=. 40%
fi
nm "[2D cupid shape]" v +
#@cli shape_diamond : _size>=0
#@cli : Input a 2D diamond binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_diamond ,
shape_diamond : check "${1=512}>=0"
e[^-1] "Input a $1x$1 diamond binary shape."
v -
ir={round($1)}
if {!$ir} 0
elif {$ir<2} $ir,$ir,1,1,1
else
{int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} =. 1,100%,100%
distance. 1,1 <=. {i/2}
+mirror. x
if {$ir>1&&($ir%2)} r. {w-1},100%,1,1,0,0,1 fi
a[-2,-1] x +mirror. y
if {$ir>1&&($ir%2)} r. 100%,{h-1},1,1,0,0,0,1 fi
a[-2,-1] y
fi
nm. "[2D diamond shape]"
v +
#@cli shape_fern : _size>=0,_density[%]>=0,_angle,0<=_opacity<=1,_type={ 0=Asplenium adiantum-nigrum | 1=Thelypteridaceae }
#@cli : Input a 2D Barnsley fern with specified size.
#@cli : Default value: 'size=512', 'density=50%', 'angle=30', 'opacity=0.3' and 'type=0'.
#@cli : $ shape_fern ,
shape_fern : check "${1=512}>=0 && ${2=50%}>=0 && isval(${3=30}) && ${4=0.3}>=0 && $4<=1 && isval(${5=0})"
e[^-1] "Input a $1x$1 Barnsley fern, with density $2, angle $3 and opacity $4."
v -
ir={round($1)}
if {!$ir} 0
else l[]
N={${"is_percent $2"}?$ir^2*$2:$2}
$N,1,1,2
eval "
if ($5==0,
f1 = [ 0,0,0,0.16 ];           g1 = [ 0,0 ];
f2 = [ 0.2,-0.26,0.23,0.22 ];  g2 = [ 0,1.6 ];
f3 = [ -0.15,0.28,0.26,0.24 ]; g3 = [ 0,0.44 ];
f4 = [ 0.85,0.04,-0.04,0.85 ]; g4 = [ 0,1.6 ],
f1 = [ 0,0,0,0.25 ];             g1 = [ 0,-0.4 ];
f2 = [ 0.035,-0.2,0.16,0.04 ];   g2 = [ -0.09,0.02 ];
f3 = [ -0.04,0.2,0.16,0.04 ];    g3 = [ 0.12,0.07 ];
f4 = [ 0.95,0.005,-0.005,0.93 ]; g4 = [ -0.002,0.5 ];
);
xy = [ 0,0 ];
for (n = 0, n<"$N", ++n,
r = u(100);
xy = r<=1?((f1*xy)+=g1):
r<=8?((f2*xy)+=g2):
r<=15?((f3*xy)+=g3):((f4*xy)+=g4);
I[n] = xy
)"
permute xczy
i.. 2,2,1,1,{"R=rot(-$3); R[2] = -R[2]; R[3] = -R[3]; R"} m*
repeat 2 sh. $>,$>,0,0 -. {im} rm. done n 0,{$ir-1}
pointcloud -$4 r $ir,$ir,1,1,0,0,0.5,0.5
endl fi
nm "[2D Barnsley fern]"
v +
#@cli shape_gear : _size>=0,_nb_teeth>0,0<=_height_teeth<=100,0<=_offset_teeth<=100,0<=_inner_radius<=100
#@cli : Input a 2D gear binary shape with specified size.
#@cli : Default value: 'size=512', 'nb_teeth=12', 'height_teeth=20', 'offset_teeth=0' and 'inner_radius=40'.
#@cli : $ shape_gear ,
shape_gear : check "${1=512}>=0 && isint(${2=12}) && $2>0 && ${3=20}>=0 && $3<=100 && ${4=0}>=0 && $4<=100 && ${5=40}>=0 && $5<=100"
e[^-1] "Input a $1x$1 gear binary shape with $2 teeth, teeth height $3, teeth offset $4 and inner radius $5."
v -
ir={round($1)}
if {!$ir} 0
else l[]
$ir,$ir
polygon {"
const nb_teeth = $2;
const height_teeth = $3%;
const offset_teeth = 2*$4%;
pts = vector2048();
for (i = 0, i<size(pts),
a = i*2*pi/size(pts);
r =  1 - height_teeth + height_teeth*(int(a*nb_teeth/pi + 2*nb_teeth - offset_teeth)%2);
pts[i++] = round(w/2*(1 + r*cos(a)));
pts[i++] = round(h/2*(1 + r*sin(a)));
);
[size(pts)/2,pts];
"},1,1
if $5 circle. 50%,50%,{0.5*w*$5%},1,0 fi
endl fi
nm "[2D gear shape]"
v +
#@cli shape_heart : _size>=0
#@cli : Input a 2D heart binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_heart ,
shape_heart : check "${1=512}>=0"
e[^-1] "Input a $1x$1 heart binary shape."
v -
ir={round($1)}
if {!$ir} 0
else l[]
2048,1,1,1,"t = x*2*pi/w; 16*sin(t)^3"
2048,1,1,1,"t = x*2*pi/w; 13*cos(t) - 5*cos(2*t) - 2*cos(3*t) - cos(4*t)"
a c display_parametric $ir,$ir,1,0,0,0
flood 50%,50%,0,0,0,1,0 ==. 0
endl
fi
nm "[2D heart shape]"
v +
#@cli shape_polygon : _size>=0,_nb_vertices>=3,_angle
#@cli : Input a 2D polygonal binary shape with specified geometry.
#@cli : Default value: 'size=512', 'nb_vertices=5' and 'angle=0'.
#@cli : $ repeat 6 shape_polygon 256,{3+$>} done
shape_polygon : check "${1=512}>=0 && isint(${2=5}) && $2>=3" skip ${3=0}
e[^-1] "Input a $1x$1 polygon binary shape, with $2 vertices and angle $3 deg."
v -
ir={round($1)}
if {!$ir} 0
else l[]
(0;{2*pi}) + {($3-90)*pi/180} r. 1,{$2+1},1,1,3 rows. 0,{h-2}
ir2={round($ir/2)}
+sin. cos..
a x n 0,{$ir-1} s x +.. {-2,0.5*($ir-im-iM)} +. {-1,0.5*($ir-im-iM)} a x
$ir,$ir polygon. $2,{-2,^},1,1 rm..
endl
fi
nm "[2D $2-polygon shape]"
v +
#@cli shape_snowflake : size>=0,0<=_nb_recursions<=6
#@cli : Input a 2D snowflake binary shape with specified size.
#@cli : Default values: 'size=512' and 'nb_recursions=5'.
#@cli : $ repeat 6 shape_snowflake 256,$> done
shape_snowflake : check "${1=512}>=0 && isint(${2=5}) && $2>=0 && $2<=6"
e[^-1] "Input a $1x$1 snowflake binary shape, with $2 recursions."
v -
ir={round($1)}
if {!$ir} 0
else l[]
$ir,$ir (0;120;240) *. {pi/180} +sin. cos.. a[-2,-1] c
repeat $2
1,{4*h},1,2
f.. "
p0 = I;
p1 = I[(y+1)%h];
t = (p1 - p0)/3;
pm = (p0 + p1)/2 - 0.866*[ -t[1], t[0] ];
k = 4*y;
I[#-1,k++] = p0;
I[#-1,k++] = p0 + t;
I[#-1,k++] = pm;
I[#-1,k] = p1 - t;
"
rm..
done
*. {0.5*$1} +. {$1/2} permute. cyzx polygon.. {h},{^},1,1 rm.
endl fi
nm "[2D snowflake shape]"
v +
#@cli shape_star : _size>=0,_nb_branches>0,0<=_thickness<=1
#@cli : Input a 2D star binary shape with specified size.
#@cli : Default values: 'size=512', 'nb_branches=5' and 'thickness=0.38'.
#@cli : $ repeat 9 shape_star 256,{$>+2} done
shape_star : check "${1=512}>=0 && ${2=5}>0 && ${3=0.5}>=0 && $3<=1"
e[^-1] "Input a $1x$1 star binary shape, with $2 branches and thickness $3."
v -
ir={round($1)}
if {!$ir} 0
else l[]
star3d $2,$3 col3d 1 c3d n3d *3d $1,$1
$1,$1 j3d. ..,50%,50%,0,1,2 rm..
endl
fi
nm "[2D star shape]"
v +
#@cli sh : eq. to 'shared'. : (+)
#@cli shared : x0[%],x1[%],y[%],z[%],v[%] : y0[%],y1[%],z[%],v[%] : z0[%],z1[%],v[%] : v0[%],v1[%] : v0[%] : (no arg) : (+)
#@cli : Insert shared buffers from (opt. points/rows/planes/channels of) selected images.
#@cli : Shared buffers cannot be returned by a command, nor a local environment.
#@cli : (eq. to 'sh').
#@cli : $ image.jpg shared 1 blur[-1] 3 remove[-1]
#@cli : $ image.jpg repeat {s} shared 25%,75%,0,$> mirror[-1] x remove[-1] done
#@cli : $$
#@cli sp : eq. to 'sample'.
sp : skip "${1=?}",${2=0}
v - _sample[] "$1",${2--1}
if {!${}} noarg fi v +
#@cli sample : _name1={ ? | apples | barbara | boats | bottles | butterfly | cameraman | car | cat | cliff | david | dog | duck | eagle | elephant | earth | flower | fruits | gmicky | gmicky_mahvin | gmicky_wilber | greece | gummy | house | inside | landscape | leaf | lena | leno | lion | mandrill | monalisa | monkey | parrots | pencils | peppers | roddy | rooster | rose | square | teddy | tiger | wall | waterfall | zelda },_name2,...,_nameN,_width={ >=0 | 0 (auto) },_height = { >=0 | 0 (auto) } : (no arg)
#@cli : Input a new sample RGB image (opt. with specified size).
#@cli : (eq. to 'sp').\n
#@cli : Argument 'name' can be replaced by an integer which serves as a sample index.
#@cli : $ repeat 6 sample done
sample : skip "${1=?}",${2=0}
v - _sample[] "$1",${2--1}
if {!${}} noarg fi v +
__sample :
u apples,barbara,boats,bottles,butterfly,cameraman,car,cat,cliff,\
david,dog,duck,eagle,elephant,earth,flower,fruits,gmicky,gmicky_mahvin,gmicky_wilber,greece,gummy,house,\
inside,landscape,leaf,lena,leno,lion,mandrill,monalisa,monkey,parrots,\
pencils,peppers,roddy,rooster,rose,square,teddy,tiger,wall,waterfall,zelda
_sample :
if {"$#>=3 && isval($-2) && isint($-2) && $-2>=0 && isval($-1) && isint($-1) && $-1>=0"}
N={$#-2} W=$-2 H=$-1
elif {"$#>=2 && isval($-1) && isint($-1) && $-1>=0"}
N={$#-1} W=$-1 H=0
else
N={$#} W=0 H=0
fi
$=arg
samples=${-__sample}
M=${"arg2var _sp_name",$samples}
is_arg=1
repeat $N
arg=${arg{1+$>}} is_rand{1+$>}=0
if {['$arg']=='?'} arg={round(u(1,$M))} is_rand{1+$>}=1
elif {!isval($arg)" || "!isint($arg)} repeat $M name=${_sp_name{1+$>}} if {'$name'!=0" && "'$name'==['$arg']} arg={1+$>} break fi done
else arg={($arg%$M)+1} fi
if {!isval($arg)" || "!isint($arg)} is_arg=0 break fi
arg{1+$>}=$arg
done
if {!$is_arg} N=1 W=0 H=0 arg1={round(u(1,$M))} fi
repeat $N
name=${_sp_name${arg{1+$>}}}
filename=${_path_rc}sample_$name.png
url=https://gmic.eu/img/sample_$name.png
if $filename $filename
else
if ${is_rand{1+$>}} l[] $url o. $filename onfail testimage2d {m=max($W,$H);m>0?m:400} endl
else $url o. $filename
fi
fi
if {$W>0" && "$H==0} r2dx. $W round.
elif {$W==0" && "$H>0} r2dy. $H round.
elif {$W>0" && "$H>0}
if {w/$W>h/$H} r2dy. $H else r2dx. $W fi
r. $W,$H,1,100%,0,0,0.5,0.5 round.
fi
nm. $name
v + e[0--4] "Input sample image '"{n}"' (1 image "{w}x{h}x{d}x{s}")." v -
done
+. 0 u $is_arg
#@cli srand : value : (no arg) : (+)
#@cli : Set random generator seed.
#@cli : If no argument is specified, a random value is used as the random generator seed.
#@cli string : "string"
#@cli : Insert new image containing the ascii codes of specified string.
#@cli : $ string "foo bar"
string :
e[^-1] "Input new image from string '$1'."
v - ({'"$1"'}) nm. "$1" v +
#@cli testimage2d : _width>0,_height>0,_spectrum>0
#@cli : Input a 2D synthetic image.
#@cli : Default values: 'width=512', 'height=width' and 'spectrum=3'.
#@cli : $ testimage2d 512
testimage2d : check "${1=512}>0 && ${2=$1}>0 && ${3=3}>0"
e[^-1] "Input 2D synthetic image of size $1x$2x$3."
v -
Dmax2={0.15*min($1,$2)^2}
$1,$2,1,$3,'X=x-w/2;Y=y-h/2;a=atan2(Y,X);if(X^2+Y^2<=$Dmax2,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))'
polygon. 4,20%,20%,60%,20%,70%,70%,35%,45%,0.9,0,255,0
torus3d {$1/7},{$1/20} r3d. 0,1,1,-80 col3d. 128,200,255
j3d.. .,30%,70%,0,1,5,0,0 rm. round. 1
nm. "[2D test image]"
v +
#@cli uncommand : command_name[,_command_name2,...] : * : (+)
#@cli : Discard definition of specified custom commands.
#@cli : Set argument to '*' for discarding all existing custom commands.
#@cli uniform_distribution : nb_levels>=1,spectrum>=1
#@cli : Input set of uniformly distributed spectrum-d points in [0,1]^spectrum.
#@cli : $ uniform_distribution 64,3 * 255 +distribution3d circles3d[-1] 10
uniform_distribution : check "isint($1) && $1>0 && isint($2) && $2>0"
e[^1] "Input set of $1 uniformly distributed $2-d points in [0,1]^$2."
v - n={round($1^(1/$2),1,1)}
(0,1) r. $n,1,1,1,3
repeat {$2-1} +channels. 100% r. {$n*w},1,1,1,1 r.. .,1,1,100%,0,2 a[-2,-1] c done
r. $1,1,1,$2,1 nm. "[uniform $2D distribution]" v +
#@cli unserialize : : (+)
#@cli : Recreate lists of images from serialized image buffers, obtained with command 'serialize'.
#@cli up : eq. to 'update'.
up :
_update
#@cli update
#@cli : Update commands from the latest definition file on the G'MIC server.
#@cli : (eq. to 'up').
update :
_$0
_update :
e[0--3] "Update commands from the latest definition file on the G\47MIC server."
v -
out=${_path_rc}update$_version.gmic
l[] cimgz:https://gmic.eu/update$_version.gmic
if {h>7" && "same([{^}],'#@gmic',6)} o raw:$out,char fi
rm
onfail v + error[0--3] "Command 'update' : Unreachable update file."
endl
m $out
v +
update_instimg :
sp gmicky,600
+l
r2dx 164
0 t. "G'MIC-Qt for GIMP",0,0,96,1,1
0 t. "(version "${-strver}")",0,0,64,1,1
a[-2,-1] y,0.5 rows. -5,100%
*. -1 n. 0,255 to_rgb. r2dx. {0,0.95*w}
- 255 a y,0.5 + 255
- 255 r 164,314,1,3,0,0,0.5,0.25 + 255
o $HOME/work/src/gmic/resources/gmic_instimg.bmp
rm
endl
r2dx 55 - 255 r 55,55,1,3,0,0,0.5,0.5 + 255
o $HOME/work/src/gmic/resources/gmic_instimg_small.bmp
rm
update_film_emulation_html :
if {!$!} error[^-1] "Command '$0': Missing input images !" fi
v -
jpeg_quality=70
thumb_width=180
thumb_height=90
categories=bw,instant_consumer,instant_pro,fujixtransii,negative_color,negative_new,negative_old,picturefx,print,colorslide,various
category_names="Black and White",\
"Instant [consumer]",\
"Instant [pro]",\
"Fuji XTrans II",\
"Negative [color]",\
"Negative [new]",\
"Negative [old]",\
"PictureFX",\
"Print films",\
"Slide [color]",\
"Various"
category_authors="Pat David",\
"Pat David",\
"Pat David",\
"Stuart Sowerby",\
"Pat David",\
"Pat David",\
"Pat David",\
"Marc Roovers",\
"Juan Melara",\
"Pat David",\
0
category_authors_url="http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
"http://blog.sowerby.me/fuji-film-simulation-profiles",\
"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
"http://www.digicrea.be/haldclut-set-style-a-la-nik-software",\
"http://juanmelara.com.au/print-film-emulation-luts-for-download",\
"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
0
m "_thumb : frame 3%,3%,255 to_rgba drop_shadow 2,2,3 repeat $! l[$>] i[0] 100%,100%,1,3,245 blend alpha endl done"
m "_title : string \"$""*\" replace. {'_'},32 f. if((x==0||j(-1)==32)&&i>=_'a'&&i<=_'z',i+_'A'-_'a',i) u {t} rm."
nb_presets=0
repeat {narg($categories)}
category=${arg\ {1+$>},$categories}
presets=${-_fx_emulate_film_$category}
nb_presets+={narg({/$presets})}
done
v + e[] "\n > Update film emulation pages, for "$!" image samples and "$nb_presets" presets." v -
v + e[] "\n  * Prepare folder structure." v -
x "ln -fs ../copyright.html ."
x "ln -fs ../favicon.ico ."
x "ln -fs ../favicon.png ."
x "ln -fs ../footer.html ."
x "ln -fs ../header.html ."
x "ln -fs ../gmicmenu ."
x "ln -fs ../jquery-1.11.0.min.js ."
x "ln -fs ../style.css ."
x "ln -fs ../images ."
x "mkdir -p img"
x "cd img && ln -fs ../../img/logo4.jpg ."
x "cd img && ln -fs ../../img/logos.jpg ."
x "cd img && ln -fs ../../img/rss.png ."
x "ln -fs ../highslide ."
v + e[] "\n  * Generate thumbnails from samples." v -
if original else x "mkdir original" fi
nb_samples=$!
to_rgb repeat $nb_samples l[$<]
nm[0] sample_{1+$<}
basename={0,b} basename$<=$basename
v + e[] "    - "$basename v -
+r2dx $thumb_width
+to[0] "Reference",4,{0,h-28},20,2 frame. 1,1,0
o. original/$basename.jpg,$jpeg_quality rm.
+_thumb[1] o. original/thumb_$basename.jpg,$jpeg_quality rm.
+r2dy[0] $thumb_height _thumb. o. original/minithumb_$basename.jpg,$jpeg_quality rm.
endl done
ind_preset=0
repeat {narg($categories)}
category=${arg\ {1+$>},$categories}
presets=${-_fx_emulate_film_$category}
v + e[] "\n  * Category ""#"{1+$>}": "$category"\n" v -
if $category else x "mkdir "$category fi
if $category/clut else x "mkdir "$category/clut fi
repeat {narg({/$presets})}
preset=${arg\ {1+$>},$presets}
v + e[] "    - "$preset v -
clut $preset to_rgb. s={sqrt(w*h*d)}
if {!isint($s)}
v + warn[] "Preset '"$preset"' must be resampled." v -
r. 64,64,64,3,3
fi
s={sqrt(w*h*d)} +r. $s,$s,1,3,-1
if {iM<=255} *. 257 fi
o. $category/clut/$preset.png
rm.
repeat $nb_samples l[{2*$>},{2*$>+1},-1]
basename={0,b}
if $category/$basename/$preset.jpg else
if $category/$basename else x "mkdir \""$category/$basename"\"" fi
+map_clut[^-1] .
to.. ${_title\ $preset},4,{-2,h-28},20,2 frame.. 1,1,0
o.. $category/$basename/$preset.jpg,$jpeg_quality
_thumb. o. $category/$basename/thumb_$preset.jpg,$jpeg_quality
rm[-2,-1]
fi
endl done
rm.
ind_preset+=1
done
done
rm[1--1:2]
v + e[] "\n  * Generate html code.\n" v -
repeat {narg($categories)}
category=${arg\ {1+$>},$categories}
arg {1+$>},$category_names
category_name=${}
presets=${-_fx_emulate_film_$category}
repeat $nb_samples
width={$>,64+w} height={$>,64+h}
basename={$>,b}
v + e[] "    - "$category_name" / "$basename v -
string "
<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n
\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n
<!--#include file=\"header.html\" -->\n
<script type=\"text/javascript\">\n
hs.align = 'center';\n
</script>\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Film Emulation</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<p>Among all features available in <b><font color=\"#000066\">G\47MIC</font></b>, our <b>Film Emulation</b> filters are able to apply various pre-defined <b>color presets</b> on your images.\n
Most of those <b>300+</b> presets have been designed by <a href=\"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html\">Patrick David</a>, in order to emulate the look of\n
analog films. They have a dedicated section in the open-source <b><font color=\"#000066\">G\47MIC</font></b> plug-in for GIMP and Krita, so you can apply all these easily in GIMP.</p>\n\n
<p>Below, you can navigate through the different proposed color presets and see how they modify the colors of some sample images.\n
You can also download each color preset separately as its corresponding <a href=\"http://www.quelsolaar.com/technology/clut.html\">HaldCLUT</a> file (in <b>.png</b> format), to use it in\n
other software that support this feature.</p>\n\n
<p><b>Image credits:</b> Sample images below have been borrowed from <a href=\"https://www.flickr.com/photos/patdavid/\">Patrick David</a> and\n
<a href=\"https://www.flickr.com/photos/davelau/\">Chi King</a>\47s Flickr accounts, distributed under\n
<a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-by-SA 2.0</a>.</p>\n\n
<p><font size=\"-1\"><b>Disclaimer:</b><br/>\n
<i>The trademarked names which may appear in the filenames of the HaldCLUT images are there for informational purposes only. They serve only to inform the user which film stock the given HaldCLUT image\n
is designed to approximate. As there is no way to convey this information other than by using the trademarked name, we believe this constitutes fair use. Neither the publisher nor the authors are affiliated\n
with or endorsed by the companies that own the trademarks.</i></font></p>\n\n
</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\"><a id=\"browse\">Browse</a></div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<table><tr>\n
<td valign=\"top\" width=\"300\">Select film category:\n
<ul>\n"
repeat {narg($categories)}
_category=${arg\ {1+$>},$categories}
arg {1+$>},$category_names
_category_name=${}
arg {1+$>},$category_authors_url
if {isval(${})} _category_author_url_start= _category_author_url_end=
else _category_author_url_start="<a href=\""${}"\">" _category_author_url_end="</a>"
fi
arg {1+$>},$category_authors
if {isval(${})} _category_author=""
else _category_author=$_category_author_url_start${}$_category_author_url_end
fi
if {narg($_category_author)}
_category_author="<font size=\"1\">(by "$_category_author")</font>"
fi
if {['$_category']==['$category']}
string "<li><font color=\"#CC7700\"><b>"$_category_name"</b> "$_category_author"</font></li>\n"
else
string "<li><a href=\""${_category}_$basename.shtml"#browse\">"$_category_name"</a> "$_category_author"</li>\n"
fi
done
string "</ul>\n</td>\n<td valign=\"top\">Select sample image:<br/><br/>\n"
repeat {$nb_samples}
_basename=${basename$>}
if {['$_basename']==['$basename']}
string "<a href=\""${category}_$_basename.shtml"#browse\"><img alt=\"\" style=\"border-color:#CC7700;\" border=\"3\" src=\""original/minithumb_$_basename.jpg"\"/></a>\n"
else
string "<a href=\""${category}_$_basename.shtml"#browse\"><img alt=\"\" border=\"0\" src=\""original/minithumb_$_basename.jpg"\"/></a>\n"
fi
done
string "</td>\n</tr></table>\n</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n"
string "\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Presets ("{narg({/$presets})}")</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<center><table>\n
<tr><td>\n
<div><a href=\"original/"$basename".jpg\" class=\"highslide\" onclick=\"return hs.expand(this)\"><img alt=\"\" border=\"0\" src=\"original/thumb_"$basename".jpg\" /></a>\n
<div class=\"highslide-caption\"><b>Reference Image</b></div></div>\n
</td></tr>\n
<tr><td align=\"center\"><b>Reference Image</b></td></tr>\n\n"
repeat {narg({/$presets})}
preset=${arg\ {1+$>},$presets}
({'$preset'}) replace_seq. 39,"92,92,39" preset_esc={t} rm.
title=${_title\ $preset}
if {$>%4==0} if $> string "</tr>\n" fi string "<tr>" fi
string "
<td><table>\n
<tr><td>\n
<div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "$width", height: "$height" })\">\n
<img alt=\"\" border=\"0\" src=\""$category/$basename/thumb_$preset".jpg\" />\n
</a>\n
<div class=\"highslide-maincontent\"><center>\n
<img alt=\"\" border=\"0\" src=\""$category/$basename/$preset.jpg"\" onclick=\"hs.close()\" onmouseover=\"javascript:this.src='"$category/$basename/$preset_esc.jpg"';\" onmouseout=\"javascript:this.src='original/"$basename".jpg';\" />\n
</center></div>\n
<div class=\"highslide-caption\"><b>Preset:</b> <i>"$title"</i> [<a href=\""$category/clut/$preset.png"\">Download HaldCLUT</a>]</div></div>\n
</td></tr>\n
<tr><td align=\"center\"><font size=\"-1\">"$title"</font></td></tr>\n
</table></td>\n\n"
done
string "
</tr></table></center>\n
</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n"
string "<!--#include file=\"copyright.html\" -->\n
<!--#include file=\"footer.html\" -->\n"
a[$nb_samples--1] x o. raw:${category}_$basename.shtml,char rm.
done
done
rm
category=${arg\ 1,$categories}
x "ln -fs "${category}_$basename0.shtml" index.shtml"
v + e[] "\n > All done, for "$nb_presets" presets.\n"
update_gallery_html : check "isbool(${1=0})"
e[^-1] "Generate gallery pages for the G'MIC website."
v -
use_vt100
if {narg(${"files *"})}
if {narg(${"files *_full_*.jpg"})" && "\
narg(${"files *_thumb_*.jpg"})" && "\
narg(${"files *_original_*.jpg"})}
if $1 x 0,"rm -f *" fi
else v + error[0--4] "Current folder should be empty!"
fi
fi
v + e[] "  * Prepare folder structure." v -
x "ln -fs ../copyright.html ."
x "ln -fs ../favicon.ico ."
x "ln -fs ../favicon.png ."
x "ln -fs ../footer.html ."
x "ln -fs ../header.html ."
x "ln -fs ../gmicmenu ."
x "ln -fs ../jquery-1.11.0.min.js ."
x "ln -fs ../style.css ."
x "ln -fs ../images ."
x "ln -fs ../highslide ."
categories=arrays,artistic,blackandwhite,colors,deformations,filtering,patterns,3drendering,stylization,codesamples
nb_categories={narg($categories)}
commands_arrays=gallery_arrays,array,array_fade,array_mirror,frame_blur,frame_cube,frame_painting,img2ascii,imagegrid,rotate_tiles,vignette,tunnel
commands_artistic=gallery_artistic,boxfitting,cartoon,cubism,draw_whirl,fractalize,halftone,sketchbw,light_relief,mosaic,linify,polaroid,polygonize,poster_hope,rodilius,stencil,stained_glass
commands_blackandwhite=gallery_blackandwhite,pencilbw,old_photo,sepia
commands_colors=gallery_colors,solarize,hsv2rgb,transfer_rgb
commands_deformations=gallery_deformations,deform,map_sphere,seamcarve,spherize,twirl,warp_perspective,water,wave
commands_filtering=gallery_filtering,blur_angular,blur_linear,blur_radial,glow,smooth,bilateral,dog,deriche,distance,gradient_norm,normalize_local,sharpen,solidify
commands_patterns=gallery_patterns,tsp,chessboard,mandelbrot,maze_mask,plasma,shape_fern,shape_snowflake,sierpinski,syntexturize_matchpatch,truchet,turbulence,watermark_visible,weave
commands_3drendering=gallery_3drendering,add3d,distribution3d,elevation3d,gmic3d,imageblocks3d,imagerubik3d,skeleton3d,spherical3d,tensors3d,text3d,torus3d,weird3d
commands_stylization=gallery_stylization
commands_codesamples=gallery_codesamples
pics=apples,bottles,butterfly,car,cat,cliff,david,dog,duck,eagle,elephant,earth,flower,fruits,greece,gummy,inside,landscape,leaf,leno,lion,mandrill,monalisa,parrots,pencils,rooster,rose,square,teddy,tiger,wall,waterfall,zelda
i raw:$HOME/work/src/gmic/src/gmic_stdlib.gmic,uchar
nb_cols=3
repeat $nb_categories,ncat
category=${arg\ 1+$>,$categories}
if {isfile($category.shtml)} continue fi
v + e[] "\n  * Process category '"$_gmic_b$category$_gmic_n"'." v -
commands=${commands_$category}
nb_commands={narg($commands)}
col,nex=0
repeat $nb_categories
cat=${arg\ 1+$>,$categories}
if {;'$cat'=='$category'} td_$cat="<td bgcolor=\"#DDDDDD\">"
else td_$cat="<td>"
fi
done
html="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"\
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n"\
"<!--#include file=\"header.html\" -->\n\n"\
"<link rel=\"stylesheet\" href=\"//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css\">\n"\
"<script src=\"https://code.jquery.com/jquery-1.12.4.js\"></script>\n"\
"<script src=\"https://code.jquery.com/ui/1.12.1/jquery-ui.js\"></script>\n\n"\
"<div id=\"bloc_option\"><div id=\"top_vert\"><div id=\"text_top\">Image gallery</div></div>\n"\
"<div id=\"center\"><div id=\"text_centre_intro\">\n"\
"This gallery gives a quick overview of the kind of features and generic filters available in the "\
"<b><font color=\"#000066\">G\47MIC</font></b> open-source image processing framework.<br/>\n"\
"All the images below have been processed by the CLI interface <tt><a href=\"documentation.shtml\">gmic</a></tt>\n"\
"  of <b><font color=\"#000066\">G\47MIC</font></b>, from a set of initial 2D color images.\n"\
"Click on an image to enlarge it and display the <b><font color=\"#000066\">G\47MIC</font></b> command-line "\
"used for the processing (<i>note: to reproduce this, you may have to escape some characters, according to type of shell you use!</i>).<br/>\n"\
"Remember, <b><font color=\"#000066\">G\47MIC</font></b> lets you define your own image pipelines through\n"\
"custom <a href=\"https://gmic.eu/gmic_stdlib.gmic\">command files</a>.\n"\
"Your custom filters can be easily added afterwards in the plug-in for <a href=\"http://www.gimp.org\">GIMP</a> or "\
"<a href=\"http://www.krita.org\">Krita</a>.</br>\n\n"\
"For more details, visit the <a href=\"https://gmic.eu/tutorial\">tutorial pages</a> as well as the "\
"<a href=\"https://gmic.eu/reference.shtml\">technical reference</a> to get a full documentation on this software.\n"\
"<br/><br/>\n<div id=\"menu\">\n"
html_menu="<font size=\"-1\"><table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" align=\"center\"><tr>\n"\
$td_arrays"<a href=\"arrays.shtml#menu\">Arrays &amp; Frames</a></td>"\
$td_artistic"<a href=\"artistic.shtml#menu\">Artistic</a></td>"\
$td_blackandwhite"<a href=\"blackandwhite.shtml#menu\">B&amp;W</a></td>"\
$td_colors"<a href=\"colors.shtml#menu\">Colors</a></td>"\
$td_deformations"<a href=\"deformations.shtml#menu\">Deformations</a></td>"\
$td_filtering"<a href=\"filtering.shtml#menu\">Filtering</a></td>"\
$td_patterns"<a href=\"patterns.shtml#menu\">Patterns</a></td>"\
$td_3drendering"<a href=\"3drendering.shtml#menu\">3D Rendering</a></td>"\
$td_stylization"<a href=\"stylization.shtml#menu\">Stylization</a></td>"\
$td_codesamples"<a href=\"codesamples.shtml#menu\">Code samples</a></td>"\
"</tr></table></font>\n"
html=${html}${html_menu}\
"</div><br/>\n"\
"<table align=\"center\">\n"
repeat $nb_commands
command=${"arg "1+$>,$commands}
is_stylization={;'$command'=='gallery_stylization'}
v + e[] $_gmic_m"    - Command '"$_gmic_b$command$_gmic_n"' ["{1+$>}/$nb_commands"]."$_gmic_n v -
+l
s -,{'"#@cli "$command" :"'}
if {$!<2} s -,{'"#@cli "$command"\n"'} i[1] ({'\n'}) a[-2,-1] y fi
if {$!<2} v + warn[] "    ** Command '"$command"' not found! **" v -
else
k.
eval "
str = crop(#-1);
ind = 0;
while ((ind = find(str,'\n#@cli ',1,ind))>=0,
++ind;
str[ind+6]!=_':' ? break() :
str[ind+7]==_' ' && str[ind+8]==_'$' && str[ind+9]==_' '?(
beg = ind + 10;
end = find(str,_'\n',1,beg) - 1;
com = vector1024(0);
ext('+rows[0] ',beg,',',end);
);
);
";
rm[0]
nb_examples=$!
repeat $nb_examples
example$nex={$>,t}
v + e[] $_gmic_g"        $ "${example$nex}$_gmic_n v -
sample=${"arg 1+"{($nex+8*$ncat)%narg($pics)},$pics}
is_codesample=0
l[]
({'${example$nex}'}) y
is_input={find(#-1,'image.jpg')>=0}
if {!$is_input" && "find(#-1,'"sample "')>=0}
s +,{'"sample "'}
if {0,crop()=='"sample "'" && "$!>1} l[1]
s +,{'" "'}
if {find(#0,_',')==-1} sample={0,t} is_input=1 fi
a y
endl fi
a y
fi
replace_str. "image.jpg","<a href=\"https://gmic.eu/img/sample_"$sample".png\" target=\"_blank\">"$sample".png</a>"
replace_str. "_output_mode=1",""
l. s +,{'" "'} repeat $! if {$<,crop(0,0,1,5)=='_fps='||crop(0,0,1,7)=='_label='}
rm[$<]
fi done a y endl
l. s +,{'" "'} repeat $! if {$<,crop(0,0,1,8)=='https://'} l[$<]
if {crop(0,0,1,24)=='https://gmic.eu/samples/'}
is_codesample=1
basename_codesample={`crop(0,24,1,h-24)`}
filename_codesample="../../resources/samples"/$basename_codesample
url_codesample="https://gmic.eu/samples/"$basename_codesample
if $1 x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"put -O /www/gmic/samples \\\""$filename_codesample"\\\"; quit\" >/dev/null" fi
i[0] ({'"<a onclick=\"javascript:$( '\#dialog"$nex"' ).dialog( 'open' );\" style=\"cursor: pointer;\">"'})
else i[0] ({'"<a href=\""{$<,t}"\" target=\"_blank\">"'})
fi
({'</a>'}) y a y
endl fi done a y endl
replaced_example$nex={t} rm
endl
({'${example$nex}'}) replace_str. "https://gmic.eu/samples/","../../resources/samples/" example$nex={t} rm.
m "_run : _preview_width,_preview_height=450,300 "${example$nex}
if $is_input sample_=${sample}_ else sample_= fi
filename_original=${category}_${sample_}original_$nex.jpg
filename_thumb_original=${category}_${sample_}thumb_original_$nex.jpg
if {"find(['"${example$nex}"'],' _fps=')>=0"}
filename_full=${category}_${sample_}full_$nex.gif
filename_thumb=${category}_${sample_}thumb_$nex.gif
_is_animated=1
else
filename_full=${category}_${sample_}full_$nex.jpg
filename_thumb=${category}_${sample_}thumb_$nex.jpg
_is_animated=0
fi
etime=
_label=
if {!isfile($filename_thumb)} l[]
if $is_input sp $sample,600 o image.jpg rm fi
db3d m3d md3d f3d l3d sl3d ss3d 0.8 srand 512
etime=$| _run etime={_round($|-$etime,0.01)}
if $is_stylization
+l _gallery o $filename_full,70 rm endl k.
_gallery
width,height={[w,h]}
else
_gallery
width,height={[w,h]}
if $_is_animated o $filename_full,$_fps else o $filename_full,70 fi
fi
v + e[] "\r"$_gmic_g"        $ "${example$nex}" (done in "$_gmic_n${etime}"s"$_gmic_g")."$_gmic_n v -
crop 5,5,{w-6},{h-6}
frame 3%,3%,255 rr2d 440,440,0,3 drop_shadow 2,2,2
if $_is_animated rr2d 230,230,0,3 else rr2d 300,300,0,3 fi
100%,100%,1,3,245 blend[^-1] .,alpha,1,1 rm.
if $_is_animated o $filename_thumb,$_fps else o $filename_thumb,60 fi
rm
if $is_input
image.jpg _gallery
rr2d $width,$height,0,5 c 0,255
to "Input",2%,2%,6%
- 255 r $width,$height,1,3,0,0,0.5,0.5 + 255
o $filename_original,60
crop 5,5,{w-6},{h-6}
frame 3%,3%,255 rr2d 440,440,0,3 drop_shadow 2,2,2
if $_is_animated rr2d 230,230,0,3 else rr2d 300,300,0,3 fi
100%,100%,1,3,245 blend[^-1] .,alpha,1,1 rm.
o $filename_thumb_original,60
rm
fi
endl fi
is_samesize=0
l[]
$filename_full
width,height={round([w,h]*(max(w,h)<300?1.75:1))}
if $filename_original $filename_original is_samesize={w==w#0" && "h==h#0} fi
rm
endl
if {!$is_samesize} filename_original=$filename_full fi
if {!($col%$nb_cols)} html=${html}"<tr>\n" fi
if {$nb_examples==1} counter= else counter=" <font size=\"-2\"><i>"[{$>+1}/$nb_examples]"</i></font>" fi
html_etime=
if {narg($etime)} html_etime="<br/><font size=\"-2\"><i>(generated in "${etime}"s)</i></font>" fi
html_codesample=
if $is_codesample
html_codesample="\n<div id=\"dialog"$nex"\" title=\""samples/$basename_codesample"\">\n<font size=\"-1\"><pre>\n"
i raw:$url_codesample,uchar html_codesample=${html_codesample}{t} rm.
html_codesample=${html_codesample}"\n</pre></font></div>\n"\
"<br/><script>$( function() { $( \"#dialog"$nex"\" ).dialog({ autoOpen: false, width:600 }); } );</script>\n"\
"<a onclick=\"javascript:$( '#dialog"$nex"' ).dialog( 'open' );\" style=\"cursor: pointer;\"><i><font size=\"-1\">[ Source code ]</font></i></a>\n"
fi
if {['$_label']==0} _label=$command$counter else ({'$_label'}) replace_str. "~"," " _label={t} rm. fi
if $is_input
html=${html}\
"  <td><center><div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "{$width+64}", height: "{$height+64}" })\">\n"\
"  <img alt=\""gallery_$command$nex"\" border=\"0\" src=\""$filename_thumb"\" "\
"onmouseover=\"javascript:this.src='"$filename_thumb_original"';\" onmouseout=\"javascript:this.src='"$filename_thumb"';\"/><br/><b>"${_label}${html_codesample}"</b></a>\n"\
"  <div class=\"highslide-maincontent\"><center>\n"\
"  <img alt=\""gallery_$command$nex"\" border=\"0\" width=\""$width"\" src=\""$filename_full"\" onclick=\"hs.close()\" onmouseover=\"javascript:this.src='"$filename_full"';\" onmouseout=\"javascript:this.src='"$filename_original"';\"/>\n"\
"</center></div>\n"\
"<div class=\"highslide-caption\">Command: <tt>$ gmic "${replaced_example$nex}"</tt>"${html_etime}"</div></div></center></td>\n"
else
html=${html}\
"  <td><center><div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "{$width+64}", height: "{$height+64}" })\">\n"\
"  <img alt=\""gallery_$command$nex"\" border=\"0\" src=\""$filename_thumb"\" /><br/><b>"${_label}${html_codesample}"</b></a>\n"\
"  <div class=\"highslide-maincontent\"><center>\n"\
"  <img alt=\""gallery_$command$nex"\" border=\"0\" width=\""$width"\" src=\""$filename_full"\" onclick=\"hs.close()\" />\n"\
"</center></div>\n"\
"<div class=\"highslide-caption\">Command: <tt>$ gmic "${replaced_example$nex}"</tt>"${html_etime}"</div></div></center></td>\n"
fi
nex+=1
col={($col+1)%$nb_cols}
if {!$col} html=${html}"</tr>\n" fi
done
fi
rm
endl
done
if $col html=${html}"</tr>\n" fi
html=${html}"</table><br/>\n"\
${html_menu}\
"</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n\n"\
"<!--#include file=\"copyright.html\" -->\n"\
"<!--#include file=\"footer.html\" -->\n"
({'$html'}) o. raw:$category.shtml,uchar rm.
done
rm
x "ln -fs artistic.shtml index.shtml"
if $1
v + e[] "\n  * Transfer gallery on G'MIC server.\n" v -
x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"mirror -eRL . /www/gmic/gallery ; quit\""
fi
v + e[] "  * All done!.\n"
_gallery :
repeat $! l[$>] W$>={w} H$>={h} D$>={d} S$>={s} IS_3D$>=${-_is_3d} endl done
repeat $! l[$>]
if ${IS_3D$>} r3d 1,1,0,-80 r3d 0,1,0,80 snapshot3d 400
else if {w>8192} z 0,8191 elif {h>8192} rows 0,8191 fi n 0,255
fi
endl done
if {!$_is_animated}
+__gallery
if {w>1024} r={round(1024*100/w,0.1)} r[^-1] $r%,$r%,1,100%,2 fi rm.
fi
repeat $! l[$>]
if {s==1} r {w},{h},1,3
elif {s==4} drgba
else r {w},{h},1,3,0 fi
if {w<=h&&h<256} r2dy 256,2 elif {h<=w&&w<256} r2dx 256,2 fi
if {w<=h&&h>620} r2dy 620,2 elif {h<=w&&w>620} r2dx 620,2 fi
if {h<48} r 100%,48 fi
if {w<48} r 48,100% fi
if {$_is_animated" && "(w>480" || "h>480)} rr2d 480,480,0,2 fi
frame 1,1,0 frame 4,4,255
endl done
if {$_is_animated}
- 255 r ${-max_wh},1,3,0,0,0.5,0.5 + 255
else
- 255 __gallery + 255
if {w<256} - 255 r 256,100%,1,100%,0,0,0.5,0.5 + 255 fi
if {h<256} - 255 r 100%,256,1,100%,0,0,0.5,0.5 + 255 fi
fi
__gallery :
if {$!==2} if {w>h} a y else a x fi
else montage A
fi
update_deprecate : check "isint($1) && $1>0 && $1<999"
e[^-1] "Deprecate filter updates for G'MIC version $1."
v - l[]
file=${_path_rc}update$1.gmic
i cimgz:"https://gmic.eu/update$1.gmic",uchar
+l. s +,{'"UPDATE"" INFORMATION"'} is_deprecated={$!>1} rm endl
if $is_deprecated
v + e[0--4] "  > Version $1 already deprecated -> Removing deprecation." v -
off1={"data = crop(); find(data,'\n#@gui !<b><i>&gt;&gt; UPDATE"" INFORMATION</i></b>')"}
if {$off1>0}
+rows $off1,100% rows[0] 0,{$off1-1}
off2={"data = crop(); find(data,'\n\n')"}
if {$off2>0}
rows. {$off2+2},100% a y
o cimgz:$file,uchar
_update_server_upload $file
v + e[0--6] "  > Done! Version $1 is not deprecated anymore." v -
fi
fi
else
s +,{'"#@cli :: "'}
i[1] ({'"\n\
\#@gui !<b><i>&gt;&gt; UPDATE"" INFORMATION</i></b> : _none_, _none_\n\
\#@gui : note = note{\"A <b>new version</b> of the <i>G\47MIC</i> plug-in is available!\\n\\n\n\
\#@gui : You are strongly encouraged to upgrade your version, by visiting our <i>Download page</i> :\\n\\n\"}\n\
\#@gui : url = link{\"Visit G\47MIC Download Page\",\"https://gmic.eu/download.shtml\"}\n\
\#@gui : note = note{\"\\nOf course, your plug-in will continue to work, but please note that we won\47t be able\n\
\#@gui : to provide filter updates anymore for your current plug-in version.\\n\\n\n\
\#@gui : Best regards,\\n\\n <i>The G\47MIC team.</i>\"}\n\n"'})
y[1] a y
o cimgz:$file,uchar
_update_server_upload $file
v + e[0--4] "  > Done! Version $1 is now deprecated." v -
fi
rm endl v +
update_server :
v -
use_vt100
_update_server_move[] "/Testing/Garagecoder/Anti~Alias","/Repair"
_update_server_move[] "/Testing/Garagecoder/Aurora","/Artistic"
_update_server_move[] "/Testing/Garagecoder/Auto~Balance","/Colors"
_update_server_move[] "/Testing/Garagecoder/Compression~Blur","/Repair"
_update_server_move[] "/Testing/Garagecoder/Despeckle","/Repair"
_update_server_move[] "/Testing/Garagecoder/Emboss","/Black~&amp;~White"
_update_server_move[] "/Testing/Garagecoder/HSL~Adjustment","/Colors"
_update_server_move[] "/Testing/Garagecoder/HSV~Select","/Colors"
_update_server_move[] "/Testing/Garagecoder/JPEG~Smooth","/Repair"
_update_server_move[] "/Testing/Garagecoder/Normalize~Brightness","/Colors"
_update_server_move[] "/Testing/Garagecoder/Stereo~Image","/Stereoscopic~3D"
_update_server_move[] "/Testing/Garagecoder/Undo~Anaglyph","/Stereoscopic~3D"
_update_server_move[] "/Testing/Garagecoder/Sharpen~[Gradient]","/Details"
_update_server_move[] "/Testing/Garagecoder/Sharpen~[Tones]","/Details"
_update_server_move[] "/Testing/Garagecoder/Temperature~Balance","/Colors"
_update_server_move[] "/Testing/Garagecoder/Unquantize~[JPEG~Smooth]","/Repair"
_update_server_move[] "/Testing/Garagecoder/Wiremap","/Rendering"
_update_server_move[] "/Testing/Garagecoder/Smooth~[Geometric-Median]","/Repair"
_update_server_move[] "/Testing/Gmic~Tutorials/Hedcut~(Experimental)","/Patterns"
_update_server_move[] "/Testing/Iain~Fergusson/Constrained~Sharpen","/Details"
_update_server_move[] "/Testing/Iain~Fergusson/Easy~Skin~Retouch","/Details"
_update_server_move[] "/Testing/Iain~Fergusson/Moire~Removal","/Repair"
_update_server_move[] "/Testing/Iain~Fergusson/Halftone~Shapes","/Patterns"
_update_server_move[] "/Testing/Iain~Fergusson/Simple~Local~Contrast","/Details"
_update_server_move[] "/Testing/Iain~Fergusson/Turbulent~Halftone","/Patterns"
_update_server_move[] "/Testing/Joan~Rake/Artistic/Ultrawarp++++","/Degradations"
_update_server_move[] "/Testing/J&#233;J&#233;/Rays","/Patterns"
_update_server_move[] "/Testing/Naggobot/Blockism","/Artistic"
_update_server_move[] "/Testing/Samj/Arrays~&amp;~Tiles/Annular~Steiner~Chain~Round~Tile","/Arrays~&amp;~Tiles"
_update_server_move[] "/Testing/Samj/Arrays~&amp;~Tiles/Reptile","/Patterns"
_update_server_move[] "/Testing/Samj/Artistic/Anguish","/Artistic"
_update_server_move[] "/Testing/Samj/Artistic/Chalk~It~Up","/Artistic"
_update_server_move[] "/Testing/Samj/Artistic/Paint~Daub","/Artistic"
_update_server_move[] "/Testing/Samj/Patterns/Denim","/Patterns"
_update_server_move[] "/Testing/Samj/Patterns/Soft~Random~Shades","/Patterns"
_update_server_move[] "/Testing/Samj/Rendering/Pythagoras~Tree","/Rendering"
_update_server_move[] "/Testing/Samj/Rendering/Snowflake~2","/Rendering"
_update_server_move[] "/Testing/Samj/Rendering/Twisted~Rays","/Rendering"
_update_server_move[] "/Testing/Souphead/Disco","/Rendering"
_update_server_move[] "/Testing/Souphead/Moon2panorama","/Deformations"
_update_server_move[] "/Testing/Souphead/Spiral~RGB","/Rendering"
_update_server_move[] "/Testing/Souphead/Kitaoka~Spin~Illusion","/Rendering"
_update_server_move[] "/Testing/Zonderr/Spiral","/Rendering"
m "parent : l[] ({'$""1'}) s -,{'/'} if $! rm. fi i[0--1] (47) a y u {0,t} rm endl"
m "varname : ({'\"$""1\"'}) f. if((i>=48&&i<=57)||(i>=65&&i<=90)||(i>=97&&i<=122),i,95) u {t} rm."
m "load_gmic : "\
"_nb_sources+=1 filename=${\"basename $""1\"} "\
"v + e[] $_gmic_c\"  \"$_nb_sources\". \"$_gmic_n$filename\"  \" v - "\
"l[] "\
"  i raw:$""1,char nm {0,b} v + e[] $_gmic_g\"      [retrieved from source '$""1']\"$_gmic_n v - "\
"  l "\
"    o raw:/tmp/$filename,char "\
"    _update_server_upload /tmp/$filename,include/$filename "\
"    v + e[] $_gmic_g\"      [archived]\n\"$_gmic_n v - "\
"  onfail v + e[] $_gmic_r\"      [could not be archived!]\n\"$_gmic_n v - endl "\
"onfail l[] "\
"  source=https://gmic.eu/include/$filename "\
"  i raw:$source,char v + e[] $_gmic_c\"      [retrieved from archive '\"$source\"']\n\"$_gmic_n v - "\
"  onfail v + e[] $_gmic_r\"      [error, not reachable!]\n\"$_gmic_n v -"\
"  endl endl"
v + e[] "> Upload latest version ("${-strver}") of commands on G'MIC server.\n" v -
_update_server_upload $HOME/work/src/gmic/src/gmic_stdlib.gmic,gmic_stdlib.$_version
_update_server_upload $HOME/work/src/gmic/src/gmic_stdlib.gmic
v + e[] "> Load and archive .gmic source files.\n" v -
_nb_sources=0
load_gmic ${HOME}/work/src/gmic/src/gmic_stdlib.gmic
x "cd $HOME/work/src/gmic-community && git pull 2>&1 >/dev/null"
load_gmic ${HOME}/work/src/gmic-community/include/afre.gmic
load_gmic ${HOME}/work/src/gmic-community/include/andreas_pahlsson.gmic
load_gmic ${HOME}/work/src/gmic-community/include/andy_kelday.gmic
load_gmic ${HOME}/work/src/gmic-community/include/arto_huotari.gmic
load_gmic ${HOME}/work/src/gmic-community/include/david_tschumperle.gmic
load_gmic ${HOME}/work/src/gmic-community/include/garry_osgood.gmic
load_gmic ${HOME}/work/src/gmic-community/include/gentlemanbeggar.gmic
load_gmic ${HOME}/work/src/gmic-community/include/iain_fergusson.gmic
load_gmic ${HOME}/work/src/gmic-community/include/james_prichard.gmic
load_gmic ${HOME}/work/src/gmic-community/include/jerome_boulanger.gmic
load_gmic ${HOME}/work/src/gmic-community/include/jerome_ferrari.gmic
load_gmic ${HOME}/work/src/gmic-community/include/joan_rake.gmic
load_gmic ${HOME}/work/src/gmic-community/include/karsten_rodenacker.gmic
load_gmic ${HOME}/work/src/gmic-community/include/mccap.gmic
load_gmic ${HOME}/work/src/gmic-community/include/martin_souphead.gmic
load_gmic ${HOME}/work/src/gmic-community/include/mathew_callaghan.gmic
load_gmic ${HOME}/work/src/gmic-community/include/photocomix.gmic
l[]
load_gmic ${HOME}/work/src/gmic-community/include/sylvie_alexandre.gmic
s +,{'"#@gui <b>"'} i[1--2:2] ({'"#@gui ________<b>Testing<b>\n#@gui <i>Samj</i>\n"'}) y a y
endl
load_gmic ${HOME}/work/src/gmic-community/include/tom_keil.gmic
load_gmic ${HOME}/work/src/gmic-community/include/reptorian.gmic
load_gmic ${HOME}/work/src/gmic-community/include/translation_ca.gmic
load_gmic ${HOME}/work/src/gmic-community/include/translation_fr.gmic
load_gmic ${HOME}/work/src/gmic-community/include/translation_ja.gmic
i[0] (10) i[2--1] ({"'\n#@gui ________________\n'"}) y a y discard 13 replace 9,32
s +,{'"#@gui"'}
repeat {int(($!-1)/2)} a[{$>+1},{$>+2}] y done
nm[0] !header
v + e[] "> Start filter parsing.\n" v -
progress_factor={100/($!-1)}
merge_request=0
merge_start=0
nb_filters=0
offset=0
path=/
repeat $!
ind={$>-$offset}
if {{{$ind-1},@-1}==10" && "same([{^}],'#@gui',5)" && "({$ind,@5}==32" || "{$ind,@5}==_'_')} l[$ind]
if {i[5]==_'_'} locale=_{`[i[6],i[7]]`}
else locale=
fi
is_folder=0
s +,10
if {{0,@5}==_'_'} +rows[0] 8,100% rows[0] 0,7
else +rows[0] 5,100% rows[0] 0,4
fi
autocrop. 32 mv. 1
if {narg($locale)" && "find(#1,'hide(')>=0}
i[1] ({'" "'})
elif {{1,@0}!=_':'}
l[1]
s +,{':'}
replace_str[0] "<b>"
replace_str[0] "</b>"
replace_str[0] "<i>"
replace_str[0] "</i>"
replace[0] {'/'},{'-'}
replace[0] {','},{';'}
autocrop[0] 32
if {$!>1}
_update_server_calibrate_name[0] +replace[0] 32,{'~'}
name=$path{t} rm.
merge_request=1
nb_filters+=1
i[0,1] (32) a y
v + e[] $_gmic_c"  "$nb_filters". "$_gmic_n$name" ("{round($>*$progress_factor)}"%)." v -
else
if {i==_'_'}
do path=${"parent[] "$path} shift 0,-1,0,0 while {i==_'_'}
autocrop 0
fi
autocrop 32
if {w}
varname {0,t} locale_${}=$locale
_update_server_calibrate_name[0]
replace 32,{'~'}
path=$path{0,t}/
fi
is_folder=1
fi
endl
if $is_folder rm[0,1] i[0] (10)
else nm[0] $name fi
else
if {$!>=3} l[1]
s +,{'='}
if {$!>=3} if {{1,@0}==_'='}
if {find(#0,'"<span "')<0}
rows[0] 1,100%
_update_server_calibrate_name[0]
i[0] ({':'};32) i[2] (32)
fi
fi fi
endl fi
i[1] (32)
fi
a y
endl fi
if {$merge_request" && "$ind>0}
a[$merge_start-{$ind-1}] y
offset+={$ind-$merge_start-1}
merge_start+=1
merge_request=0
fi
done
a[$merge_start--1] y
v + e[] "\n> Force filters to move, if necessary." v -
repeat $!,ind repeat $_nbm if {['{$ind,n}']==['${_to_move$>}']}
v + e[] $_gmic_c"  "$ind$_gmic_n". Move '"${_gmic_g}{$ind,n}$_gmic_n"' to '"$_gmic_g${_move_to$>}$_gmic_n"'." v -
nm[$ind] ${_move_to$>}/{$ind,b}
fi done done
v + e[] "\n> Sort filters by lexicographic order." v -
sort_list +,n
v + e[] "\n> Rebuild folder structure." v -
m "nb_levels : l[] ({'$""1'}) s -,{'/'} u $! rm endl"
path=/
repeat $! l[$>]
npath=${"parent "{0,n}}
if {['$path']!=['$npath']}
nc=${"nb_levels[] "$path}
nn=${"nb_levels[] "$npath}
nb_up=0
nb_down=0
basis=$path nbasis=$npath
do
nc=${"nb_levels[] "$basis}
nn=${"nb_levels[] "$nbasis}
if {$nc>$nn} basis=${"parent[] "$basis} nb_up+=1
elif {$nn>$nc} nbasis=${"parent[] "$nbasis} nb_down+=1
elif {['$nbasis']!=['$basis']} basis=${"parent[] "$basis} nb_up+=1 nbasis=${"parent[] "$nbasis} nb_down+=1
fi
while {['$nbasis']!=['$basis']}
command=
if $nb_up 1,$nb_up,1,1,{'_'} command="#@gui "{t}"\n" rm. fi
if $nb_down l[]
({'$npath'}) s -,{'/'} k[-$nb_down--1] replace {'~'},32
level={${"nb_levels "$path}-$nb_up}
balise=${"if "{$level<=0" && "['$npath']!='/About/'}" u b else u i fi"}
repeat $!
varname {$>,t} locale=${locale_${}}
command=$command"#@gui"$locale" <"$balise">"{$>,t}"</"$balise">\n"
balise="i"
done rm
endl fi
if {narg(['$command'])} nm={0,n} i[0] ({'$command'}) y[0] a y nm $nm
fi
path=$npath
fi
endl done
v + e[] "> Search and replace strings." v -
replace_str "#@gmic\n",""
replace_str "<small>Author: <i>Samj</i>.","<small>Author: <i>Samj</i>."
replace_str "   Latest Update: <i>20","   Latest Update: <i>20"
repeat $! l[$>] s -,10 repeat $! l[$<]
if {i[0]==_'#'" && "i[1]!=_'@'} rm fi
endl done i[^0] ({'\n'}) a y endl done
repeat $! +l[$>] command_name$>=""
+rows 0,5 head={t} rm.
if {['$head']=='"#@gui "'} s -,{':'}
if {$!>=1} l[1] s -,{','}
if $! autocrop[0] 32 command_name$>={0,t} fi
endl fi
fi
rm endl done
if {$nb_filters>400}
v + e[] "> Compress and save output .gmic files." v -
+a y l.
compress_gmic[0]
i[0] ({'"#@gmic"\n\
"#"\n\
"#  File        : update"$_version".gmic"\n\
"#                ( G\47MIC command file )"\n\
"#"\n\
"#  Description : Update file for G\47MIC commands and filters (for version "${-strver}")."\n\
"#                ( https://gmic.eu )"\n\
"#"\n\
"#  License     : CeCILL v2.1 or CeCILL-C v1.0"\n\
"#                ( http://www.cecill.info/index.en.html )"\n\
"#"\n\n'})
({'"\n\n# Local Variables:"\n\
"# mode: sh"\n\
"# End:"\n\
"#"\n\
"# (End of G\47MIC update file)"'})
y a y
o raw:${_path_rc}update$_version.gmic,uchar
if {"d = date(3); h = date(4); h>=7 && d>=1 && d<=5"} url=https://goo.gl/Ryf7Cv
else url=http://ow.ly/wpsV30fzhdI
fi
replace_str "<i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>","<i><a href=\""$url"\">David Tschumperl&#233;</a></i>"
o cimgz:/tmp/update$_version.gmic,uchar
(242,243,244,245,250)
repeat {w}
v={i[$>]}
_update_server_upload[] ${_path_rc}update$_version.gmic,plain_update$v.gmic
_update_server_upload[] /tmp/update$_version.gmic,update$v.gmic
done rm.
rm endl
fi
v + e[] "> Output list of filters in stdout.\n" v -
echo_stdout "*** List of filters in the G\47MIC plug-in ("$nb_filters" filters, on "{date(0)}/{date(1)}/{date(2)}" "{date(4)}:{date(5)}") ***\n"
echo_stdout "* List of filters, sorted by path:\n"
repeat $! l[$>]
({'{0,n}'}) if {i!=_'!'}
r. {w-1},1,1,1,0,0,1
replace_str. "&amp;","&"
replace_str. "&#233;","e"
replace_str. "/","~/~"
replace. {'~'},32
if {narg(${command_name$>})} echo_stdout[] "  "{t}" (command '"${command_name$>}"')"
else echo_stdout[] "  "{t}
fi
fi rm.
endl done
echo_stdout "\n* List of filters, sorted alphabetically:\n"
repeat $!
name={$>,b}
path={$>,f}
nm[$>] $name"~(in~'"$path"')"
done
sort_list +,n
repeat $! l[$>]
({'{0,n}'}) if {i!=_'!'}
replace_str. "&amp;","&"
replace_str. "&#233;","e"
replace. {'~'},32
echo_stdout[] "  "{t}
fi rm.
endl done
echo_stdout "\n*** End of list ***\n"
rm v + e[] $_gmic_g"> All done !\n"$_gmic_n
_update_server_calibrate_name :
replace {'_'},{'" "'} autocrop {'" "'}
in={t}
s +,{'.'} s +,{':'} s +,{';'}
repeat $! l[$>]
s +,{'" "'} s +,{'"/"'} s +,{'"["'} s +,{'"<"'} s +,{'"("'} s +,{'">"'} s +,{'"-"'}
first={"ind = 0; while (ind<l && (c = lowercase(i[#ind,0]); !((c>=_'a' && c<=_'z') || (c>=_'0' && c<=_'9'))), ++ind); ind<l?ind:0"}
f "x+y?i:(
s = crop();
s=='a' || s=='an' || s=='and' ||
s=='as' || s=='at' || s=='but' || s=='by' ||
s=='for' || s=='from' || s=='in' || s=='into' ||
s=='like' || s=='near' || s=='nor' || s=='of' || s=='off' ||
s=='on' || s=='onto' || s=='or' || s=='over' || s=='past' ||
s=='per' || s=='than' || s=='the' || s=='to' || s=='up' ||
s=='upon' || s=='via' || s=='with'?i:uppercase(i)
)"
f[$first,-1] "x+y?i:uppercase(i)"
a y
endl done
a y
replace_str "<B>","<b>"
replace_str "</B>","</b>"
replace_str "<I>","<i>"
replace_str "</I>","</i>"
replace_str "<Img Src","<img src"
replace_str "<A Href","<a href"
replace_str "<a Href","<a href"
replace_str ".Gpl",".gpl"
replace_str ".Png",".png"
replace_str "(Deg)","(deg)"
replace_str "(Px)","(px)"
replace_str "(S)","(s)"
replace_str "(T)","(t)"
replace_str "Re-","re-"
replace_str "Min-T","Min-t"
replace_str "Max-T","Max-t"
replace_str "SRGB","sRGB"
if {['{t}']=='Sep'} replace_str "Sep","sep" fi
if {['{t}']=='Note'} replace_str "Note","note" fi
if {['{t}']=='Url'} replace_str "Url","url" fi
out={t}
if {['$in']!=['$out']} v + e[] $_gmic_m"       Warning: String '"$in"' substituted by '"$out"'"$_gmic_n v - fi
_update_server_move :
if {!narg($_nbm)} _nbm=0 fi
_to_move${_nbm}="$1" _move_to${_nbm}="$2" _nbm+=1
_update_server_upload : skip "${2=""}"
if {narg("$2")} out="$2" else basename "$1" out=${} fi
l[] GMIC_LOGIN=${gmic_ftp\ 0} onfail GMIC_LOGIN="" endl
l[] GMIC_PASSWD=${gmic_ftp\ 1} onfail GMIC_PASSWD="" endl
if {narg($GMIC_LOGIN)}
x 0,"lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"put -O /www/gmic/ \\\"$1\\\" -o \\\""$out"\\\"; quit\" >/dev/null"
fi
_update_server_binaries :
e[^-1] "Upload released binaries ($1) on the G'MIC web server."
v -
is_pre=${"strcontains $1,_pre"}
N=0
file$N=gmic_$1_debian_wheezy_amd64.deb               N+=1
file$N=gmic_$1_debian_jessie_amd64.deb               N+=1
file$N=gmic_$1_debian_stretch_amd64.deb              N+=1
file$N=gmic_$1_debian_sid_amd64.deb                  N+=1
file$N=gmic_$1_ubuntu_xenial_amd64.deb               N+=1
file$N=gmic_$1_ubuntu_artful_amd64.deb               N+=1
file$N=gmic_$1_ubuntu_bionic_amd64.deb               N+=1
file$N=gmic_$1_ubuntu_cosmic_amd64.deb               N+=1
file$N=gmic_gimp2.8_qt_$1_linux64.zip                N+=1
file$N=gmic_gimp2.8_qt_$1_debian_jessie_amd64.zip    N+=1
file$N=gmic_gimp2.8_qt_$1_debian_stretch_amd64.zip   N+=1
file$N=gmic_gimp2.10_qt_$1_debian_sid_amd64.zip      N+=1
file$N=gmic_gimp2.8_qt_$1_ubuntu_xenial_amd64.zip    N+=1
file$N=gmic_gimp2.8_qt_$1_ubuntu_artful_amd64.zip    N+=1
file$N=gmic_gimp2.8_qt_$1_ubuntu_bionic_amd64.zip    N+=1
file$N=gmic_gimp2.10_qt_$1_ubuntu_cosmic_amd64.zip   N+=1
file$N=gmic_krita_qt_$1_debian_jessie_amd64.zip      N+=1
file$N=gmic_krita_qt_$1_debian_stretch_amd64.zip     N+=1
file$N=gmic_krita_qt_$1_debian_sid_amd64.zip         N+=1
file$N=gmic_krita_qt_$1_ubuntu_xenial_amd64.zip      N+=1
file$N=gmic_krita_qt_$1_ubuntu_artful_amd64.zip      N+=1
file$N=gmic_krita_qt_$1_ubuntu_bionic_amd64.zip      N+=1
file$N=gmic_krita_qt_$1_ubuntu_cosmic_amd64.zip      N+=1
file$N=gmic_cli_$1_win64.zip                         N+=1
file$N=gmic_lib_$1_win64.zip                         N+=1
file$N=gmic_gimp2.10_qt_$1_win64.zip                 N+=1
file$N=gmic_gimp2.10_qt_$1_win64.exe                 N+=1
file$N=gmic_gimp2.8_qt_$1_win64.zip                  N+=1
file$N=gmic_gimp2.8_qt_$1_win64.exe                  N+=1
file$N=gmic_krita_qt_$1_win64.zip                    N+=1
t0=$| n=0 t=0
v + e[] "- Waiting for binary files to be build." v -
do
repeat $N
file=${file$>}
if $file
strreplace $file,_$1_,_
file_short=${}
is_win=${strcontains[]" "$file,win}
if $is_win folder="windows" else folder="linux" fi
v + e[] "- Upload file '"$file"' to 'https://gmic.eu/files/prerelease/"$file_short"'." v -
_update_server_upload $file,"files/prerelease/"$file_short
v + e[] "- Upload file '"$file"' to 'https://gmic.eu/files/prerelease_"$folder/$file_short"'." v -
_update_server_upload $file,"files/prerelease_"$folder/$file_short
if {!$is_pre}
v + e[] "- Upload file '"$file"' to 'https://gmic.eu/files/"$folder/$file_short"'." v -
_update_server_upload $file,"files/"$folder/$file_short
fi
file$>= n+=1
fi
done
if {$n<$N}
if {!($t%4)}
remaining= sep=
repeat $N if {narg(${file$>})} remaining.=${sep}${file$>} sep=", " fi done
v + e[] "- Waiting for files: "$remaining"." v -
fi
wait 5000 t+=1
fi
while {$n<$N" && "$|<$t0+60*60*4}
v +
if {$n<$N} e[] "- Partial uploads done (timeout reached)."
else e[] "- All uploads done !"
fi
update_tutorial_html :
e[^-1] "Convert G\47MIC tutorial from Garry Osgood\47s blog (http://www.particularart.com), for the G\47MIC web page."
v - rm m "add_page : __update_tutorial_html $""*"
use_vt100
add_page command-guide/list-manipulation/-name,8000,,,commands-list-manipulation
v + e[] "\n  * Prepare folder structure." v -
x "ln -fs ../../gmic/html/tutorial.css ."
x "ln -fs ../../gmic/html/copyright.html ."
x "ln -fs ../../gmic/html/favicon.ico ."
x "ln -fs ../../gmic/html/favicon.png ."
x "ln -fs ../../gmic/html/footer.html ."
x "ln -fs ../../gmic/html/header.html ."
x "ln -fs ../../gmic/html/gmicmenu ."
x "ln -fs ../../gmic/html/jquery-1.11.0.min.js ."
x "ln -fs ../../gmic/html/style.css ."
x "ln -fs ../../gmic/html/images ."
x "mkdir -p img"
x "cd img && ln -fs ../../../gmic/html/img/logo4.jpg ."
x "cd img && ln -fs ../../../gmic/html/img/logos.jpg ."
x "cd img && ln -fs ../../../gmic/html/img/rss.png ."
x "cd img && ln -fs ../../../gmic/html/convert_raw_img/* ."
x "ln -fs ../../gmic/html/convert_raw.html ../../gmic/html/convert_raw.shtml ."
x "ln -fs ../../gmic/html/tutorial_toc.html ."
x "ln -fs ../../gmic/html/highslide ."
11,11,1,3,255 frame 1,1,0 line 3,50%,{w-4},50%,1,0 +line 50%,3,50%,{h-4},1,0
a x o img/toc_buttons.png
100%,100%,1,4 fc. 245,245,245,0 o. img/toc_void.png
rm
if {!narg($_N)} _N=0 fi
0 repeat $_N
o. ${_output_html$>} o. ${_output_shtml$>}
done rm.
repeat $_N
v + _update_tutorial_html[] ${_input$>},${_height$>},${_output_shtml$>},${_output_html$>},${_img_prefix$>},${_tocid$>} v -
done
x "rm -f __tmp.html"
v + e[] "\n  * All done !.\n\n"
__update_tutorial_html : skip ${3=""},${4=""},${5=""}
if {!narg($_N)} _N=0 fi
_input$_N=$1 _height$_N=$2
if {narg("$5")} _tocid$_N="$5"
else
({'"$1"'}) s -,{'/'} if $! _tocid$_N={0,t} rm else _tocid$_N=index fi
fi
({'"$1"'}) s -,{'/'}
output_base=""
if $! output_base={t} fi
if {$!>2" && "i[0]!=_'-'} output_base={-2,t}_{t} fi
rm
if {narg($output_base)}
({'$output_base'}) if {i==_'-'} =. {'_'} output_base={t} fi rm.
fi
if {narg("$3")} _output_shtml$_N="$3".shtml _output_html$_N="$3".html _img_prefix$_N="$3"
else _output_shtml$_N=$output_base.shtml _output_html$_N=$output_base.html _img_prefix$_N=$output_base
fi
if {narg("$4")} _output_html$_N="$4".html fi
_N+=1
_update_tutorial_html :
v -
url="http://particularart.com/tools-and-toys/gmic/$1"
v + e[] "\n  * Convert tutorial page '"$url"'." v -
v + e[] "    > Retrieve page '"$url"'." v -
x "wget -q "$url" -O __tmp.html"
i raw:__tmp.html,char
discard 13
replace_str "class=\"internal\" "
replace_str "class=\"external\" "
replace_str "dir=\"ltr\" "
replace_str "border: 1px","border: 0px"
replace_str "G\140MIC","G\47MIC"
replace_str "CNTL","CTRL"
replace_str "Rashid","Rachid"
replace_str "gmic.sourceforge.net","gmic.eu"
replace_str "gmic_def","gmic_stdlib"
replace_str "@#","$!"
replace_str "@{-1,","{"
replace_str "@{","{"
replace_str "gmic-minimal","gmic"
s -,{'"<!-- GIMMICKRY! -->"'} k[1]
s -,{'"<!-- GIMMICKRY! End -->"'} k[0]
s +,{'"   </div>\n</div>\n<footer>"'} k[0]
i[0] ({'"<!DOCTYPE html>"\n\
"<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
"<link rel=\"stylesheet\" href=\"tutorial.css\">"\n\
"<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>"\n\
"<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />"\n\
"<script type=\"text/javascript\">"\n\
"hs.graphicsDir = 'highslide/graphics/';"\n\
"hs.wrapperClassName = 'wide-border';"\n\
"</script>"\n\
"<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>"\n\
"<body>"\n\n'})
({'\n</body></html>'})
y a y
replace_str "\"/static/media/uploads/","\"http://particularart.com/static/media/uploads/"
replace_str "\"/tools-and-toys/gmic/","\"http://particularart.com/tools-and-toys/gmic/"
replace_str "\"http://particularart.com/","\"http://www.particularart.com/"
s +,{'"<a "'}
repeat $! if {$>>0" && "[{{$>-1},^}]=='"<a "'} l[$>] s +,{'href=\"'} l.
s +,{'\"'}
if {$!>0}
link={0,t}
({'$link'}) z. 0,48 baselink={t} rm.
if {['$baselink']=='http://www.particularart.com/tools-and-toys/gmic/'}
l[] anchor="" ({'$link'}) s +,{"'#'"} if {$!>1} anchor=#{t} link={0,t} fi rm endl
({'$link'}) autocrop. {'/'}
l. s -,{'/'} if {com='command-guide';$!>6" && "[{-2,^}]!=com" && "[{-3,^}]!=com} relink={-2,t}_{t}.shtml else relink={t}.shtml fi rm endl
({'$relink'}) if {i==_'-'} =. {'_'} relink={t} fi rm.
if $relink
relink=$relink$anchor
v + e[] "    > Local link '"$link$anchor"' relinked to '"$relink"'." v -
rm[0] i[0] ({'$relink'}) y[0]
else
({'$relink'}) if {i==_'_'}
l. z 1,100% s -,{'.'} command=${basename\ {0,t}} k[0] endl
relink="https://gmic.eu/reference.shtml#"$command
v + e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_g}"(reference command)."${_gmic_n} v -
rm[0] i[0] ({'$relink'}) y[0]
else
relink=$link$anchor
v + e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_r}"(no corresponding local page)."${_gmic_n} v -
rm[0] i[0] ({'$relink'}) y[0]
fi
rm.
fi
else l
0 nm. $link ext={x} rm.
if {narg($ext)} ext=${strlowercase\ $ext} fi
if {s=['$ext'];s=='png'||s=='jpg'||s=='jpeg'}
basename $link relink=img/$5_${} 0 nm. $relink relink={f}{b}.jpg rm.
if $relink v + e[] "    > External image link '"$link"' relinked to '"$relink"'." v -
else
l[] i $link k[0] is_opaque=0
split_opacity if {$!==1" || "ia>250} is_opaque=1 fi a c
if {$is_opaque} to_rgb else to_rgba i[0] 100%,100%,1,3 fc[0] 245,245,245 blend alpha fi
o $relink,60 rm
v + e[] "    > Image link '"$link"' converted and relinked to '"$relink"'." v -
onfail relink=$link v + e[] "    > Failed to retrieve image link '"$link"'." v - rm
endl
fi
rm[0] i[0] ({'$relink'})
i[2] ({'" class=\"highslide\" onclick=\"return hs.expand(this)\""'})
y[0,2]
else
v + e[] "    > External link '"$link"' found." v -
fi
onfail endl fi
a y
fi
endl a y endl fi done
a y
s +,{'"<img"'}
repeat $! if {$>>0" && "[{{$>-1},^}]=='"<img "'}
l[$>]
s +,{'"src=\""'}
l[2]
s +,{'\"'} link={0,t}
relink=img/$5_${basename\ $link} 0 nm. $relink relink={f}{b}.jpg rm.
if $relink v + e[] "    > Image '"$link"' relinked to '"$relink"'." v -
else
l[] i $link k[0] is_opaque=0
split_opacity if {$!==1" || "ia>250} is_opaque=1 fi a c
if $is_opaque to_rgb frame 1,1,0 frame 10,10,245
else to_rgba i[0] 100%,100%,1,3 fc[0] 245,245,245 blend alpha
fi
o $relink,60 rm
v + e[] "    > Image '"$link"' converted and relinked to '"$relink"'." v -
onfail relink=$link v + e[] "      > Failed to retrieve image '"$link"'." v - rm
endl
fi
rm[0] i[0] ({'$relink'}) y[0]
endl
a y
endl
fi done
a y
replace_str "<td><img","<td width=\"256\"><img"
replace_str "<td>\n<p><img","<td width=\"256\"><p><img"
replace_str "<td>&nbsp;<img","<td width=\"256\"><img"
replace_str "<a ","<a target=\"_parent\" "
o raw:$4,char
rm
({'"<!DOCTYPE html>"\n\
"<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
"<!--#include file=\"header.html\" -->"\n\
"<div id=\"bloc_option\"><div id=\"top_vert\"><div id=\"text_top\">Tutorial</div></div>"\n\
"<div id=\"center\"><div id=\"text_centre_intro\">"\n\
"<script language=\"javascript\">var gFilename = '$6';</script>"\n\
"<!--#include file=\"tutorial_toc.html\" -->"\n\
"<iframe width=\"100%\" height=\"$2\" frameborder=\"0\" src=\""$4"\" seamless></iframe>"\n\
"</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>"\n\
"<!--#include file=\"copyright.html\" -->"\n\
"<!--#include file=\"footer.html\" -->"\n'})
o raw:$3,char
rm
wait {5000+u(2000)}
v +
_update_header_html : check "${2=0}>=0 && isbool(${3=0})"
if {!$2} return fi
v -
filename=$1
l[]
i raw:$filename,uchar
s +,{'\n'}
repeat $! if {$>,h>=64} l[$>]
+autocrop {'" "'} autocrop. {'\t'}
if {"s = ['Latest stable version: ']; crop(0,0,1,size(s))==s"}
is_gmic={find(#-1,'gmic.eu')>=0}
is_cimg={find(#-1,'cimg.eu')>=0}
if (!$is_gmic" && "!$is_cimg} v + return fi
+l. s -,{'>'}
if {2,"i[0]>=_'0' && i[0]<=_'9' && i[1]==_'.' && i[2]>=_'0' && i[2]<=_'9' && i[3]==_'.' && i[4]>=_'0' && i[4]<=_'9'"}
sta={2,`crop(0,0,1,5)`}
fi
if $3 pre=${strver\ $2} else sta=${strver\ $2} fi
rm endl
rm[0]
if $is_gmic
i[0] ({'"                Latest stable version: <b><a href=\"https://gmic.eu/download.shtml\">"$sta"</a></b>"'})
if $3 i[1] ({'" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Current pre-release: <b><a href=\"https://gmic.eu/files/prerelease\">"$pre"</a></b>"'}) fi
else
i[0] ({'"                Latest stable version: <b><a href=\"http://cimg.eu/files/CImg_"$sta".zip\">"$sta"</a></b>"'})
if $3 i[1] ({'" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Current pre-release: <b><a href=\"http://cimg.eu/files/CImg_latest.zip\">"$pre"</a></b>"'}) fi
fi
y
fi
rm.
endl fi done
a y
o raw:$filename,uchar
endl v +
#@cli v : eq. to 'verbose'. : (+)
#@cli verbose : level : { + | - } : (+)
#@cli : Set or increment/decrement the verbosity level. Default level is 0.
#@cli : (eq. to 'v').\n
#@cli : When 'level'>=0, G'MIC log messages are displayed on the standard error (stderr).
#@cli : Default value: 'level=0'.
#@cli wait : delay : (no arg) : (+)
#@cli : Wait for a given delay (in ms), optionally since the last call to 'wait'.
#@cli : or wait for a user event occurring on the selected instant display windows.
#@cli : 'delay' can be { <0=delay+flush events | 0=event | >0=delay }.
#@cli : Command selection (if any) stands for instant display window indices instead of image indices.
#@cli : If no window indices are specified and if 'delay' is positive, the command results
#@cli : in a 'hard' sleep during specified delay.
#@cli : Default value: 'delay=0'.
#@cli warn : _force_visible={ 0 | 1 },_message : (+)
#@cli : Print specified warning message, on the standard error (stderr).
#@cli : Command selection (if any) stands for displayed call stack subset instead of image indices.
#@cli w : eq. to 'window'. : (+)
#@cli window : _width[%]>=-1,_height[%]>=-1,_normalization,_fullscreen,_pos_x[%],_pos_y[%],_title : (+)
#@cli : Display selected images into an instant display window with specified size, normalization type,
#@cli : fullscreen mode and title.
#@cli : (eq. to 'w').\n
#@cli : If 'width' or 'height' is set to -1, the corresponding dimension is adjusted to the window
#@cli : or image size.
#@cli : When arguments 'pos_x' and 'pos_y' are both different than -1, the window is moved to
#@cli : the specified coordinates.
#@cli : 'width'=0 or 'height'=0 closes the instant display window.
#@cli : 'normalization' can be { -1=keep same | 0=none | 1=always | 2=1st-time | 3=auto }.
#@cli : 'fullscreen' can be { -1=keep same | 0=no | 1=yes }.
#@cli : You can manage up to 10 different instant display windows by using the numbered variants
#@cli : 'w0' (default, eq. to 'w'),'w1',...,'w9' of the command 'w'.
#@cli : Invoke 'window' with no selection to make the window visible, if is has been closed by the user.
#@cli : Default values: 'width=height=normalization=fullscreen=-1' and 'title=(undefined)'.
#@cli :: List Manipulation
#@cli k : eq. to 'keep'. : (+)
#@cli keep : (+)
#@cli : Keep only selected images.
#@cli : (eq. to 'k').
#@cli : $ image.jpg split x keep[0-50%:2] append x
#@cli : $ image.jpg split x keep[^30%-70%] append x
#@cli mv : eq. to 'move'. : (+)
#@cli move : position[%] : (+)
#@cli : Move selected images at specified position.
#@cli : (eq. to 'mv').
#@cli : $ image.jpg split x,3 move[1] 0
#@cli : $ image.jpg split x move[50%--1:2] 0 append x
#@cli nm : eq. to 'name'. : (+)
#@cli name : "name1","name2",... : (+)
#@cli : Set names of selected images.
#@cli : - If the selection contains a single image, then it is assumed the command has a single name argument (possibly containing multiple comas).
#@cli : - If the selection contains more than one image, each command argument defines a single image name for each image of the selection.
#@cli : (eq. to 'nm').
#@cli : $ image.jpg name image blur[image] 2
#@cli : $$
#@cli rm : eq. to 'remove'. : (+)
#@cli remove : (+)
#@cli : Remove selected images.
#@cli : (eq. to 'rm').
#@cli : $ image.jpg split x remove[30%-70%] append x
#@cli : $ image.jpg split x remove[0-50%:2] append x
#@cli remove_duplicates
#@cli : Remove duplicates images in the selected images list.
#@cli : $ (1,2,3,4,2,4,3,1,3,4,2,1) split x remove_duplicates append x
remove_duplicates :
e[^-1] "Remove duplicates images in selected list of image$?."
v - repeat $!,base
off=0
repeat {$!-$>-1}
comp={$base+1+$>-$off}
if {$comp>=$!} break fi
+-[$base,$comp] abs. is_duplicate={!is} rm.
if $is_duplicate rm[$comp] off+=1 fi
done
done v +
#@cli remove_empty
#@cli : Remove empty images in the selected image list.
remove_empty :
e[^-1] "Remove empty images in selected list of image$?."
v - repeat $! if {$<,!whds} rm[$<] fi done v +
#@cli rv : eq. to 'reverse'. : (+)
#@cli reverse : (+)
#@cli : Reverse positions of selected images.
#@cli : (eq. to 'rv').
#@cli : $ image.jpg split x,3 reverse[-2,-1]
#@cli : $ image.jpg split x,-16 reverse[50%-100%] append x
#@cli sort_list : _ordering={ + | - },_criterion
#@cli : Sort list of selected images according to the specified image criterion.
#@cli : Default values: 'ordering=+', 'criterion=i'.
#@cli : $ (1;4;7;3;9;2;4;7;6;3;9;1;0;3;3;2) split y sort_list +,i append y
sort_list : skip ${1=+},${2=i}
v - s0="descending" s1="ascending" v +
e[^-1] "Sort list of image$? in "${s{_'+'=='$1'}" order, according to the image criterion '$2'."
v - if $!
if {;'$2'=='n'}
op={`;'$1'=='-'?_'>':_'<'`}
(0,{$!-1})
do
lo0={i(0,h-1)} hi0={i(1,h-1)}
lo=$lo0 hi=$hi0
if {h>1} r. 2,{h-1},1,1,0 else rm. 0 fi
pivot={{int(($lo+$hi)/2)},n}
do if {$lo<=$hi}
do if ${_sort_list_lexi\ \"{$lo,n}\",\"$pivot\",$op} lo+=1 else break fi while 1
do if ${_sort_list_lexi\ \"$pivot\",\"{$hi,n}\",$op} hi-=1 else break fi while 1
if {$lo<=$hi} rv[$lo,$hi] lo+=1 hi-=1 fi
else break fi while 1
if {$lo0<$hi} ($lo0,$hi) a[-2,-1] y fi
if {$lo<$hi0} ($lo,$hi0) a[-2,-1] y fi
while {h}
rm.
else
i=$! repeat $! ({$>,$2}) done a[$i--1] y +f. 'y' a[-2,-1] x sort. $1,y z. 1,1
repeat {h} nm$>={$>,n} nm[$>] sortlist$> done
repeat {h} mv[sortlist{i(0,$>)}] -1 done
repeat {h} nm[$>] ${nm{i(0,$>)}} done
rm.
fi
fi v +
_sort_list_lexi :
u {"
str1 = ['$1'];
str2 = ['$2'];
siz = min(size(str1),size(str2));
lex = -1;
for (i = 0, i<siz && lex<0, ++i,
s1 = lowercase(str1[i]);
s2 = lowercase(str2[i]);
lex = s1"$3"s2?1:s2"$3"s1?0:-1;
);
lex<0?size(str1)"$3"size(str2):lex;
"}
#@cli sort_str
#@cli : Sort selected images (viewed as a list of strings) in lexicographic order.
sort_str :
e[^-1] "Sort image$? in lexicographic order."
v - y a x
repeat {round(h/4,1,1)} y={4*$>}
repeat $! l[$<]
+rows $y,{$y+3} f[1] 'if(i>=97&&i<=122,i-32,i)' -. 32 c. 0,63 s. y *.. 64 *... 4096 *[-4] 262144 +[-4--1]
rv a y sort +,x +rows 0 rows[0] 1,100% label[1] %[1] 2
s[1] +,0 N={$!-1}
x0=0 repeat {$!-1} x1={$x0+{{1+$>},h}} +z[0] $x0,{$x1-1} x0=$x1 done
rm[0-$N]
endl done
done s x v +
#@cli :: Mathematical Operators
#@cli abs : (+)
#@cli : Compute the pointwise absolute values of selected images.
#@cli : $ image.jpg +sub {ia} abs[-1]
#@cli : $ 300,1,1,1,'cos(20*x/w)' +abs display_graph 400,300
#@cli acos : (+)
#@cli : Compute the pointwise arccosine of selected images.
#@cli : $ image.jpg +normalize -1,1 acos[-1]
#@cli : $ 300,1,1,1,'cut(x/w+0.1*u,0,1)' +acos display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands
#@cli acosh : (+)
#@cli : Compute the pointwise hyperbolic arccosine of selected images.
#@cli + : eq. to 'add'. : (+)
#@cli add : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Add specified value, image or mathematical expression to selected images,
#@cli : or compute the pointwise sum of selected images.
#@cli : (eq. to '+').
#@cli : $ image.jpg +add 30% cut 0,255
#@cli : $ image.jpg +blur 5 normalize 0,255 add[1] [0]
#@cli : $ image.jpg add '80*cos(80*(x/w-0.5)*(y/w-0.5)+c)' cut 0,255
#@cli : $ image.jpg repeat 9 +rotate[0] {$>*36},1,0,50%,50% done add div 10
#@cli & : eq. to 'and'. : (+)
#@cli and : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise AND of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential bitwise AND of selected images.
#@cli : (eq. to '&').
#@cli : $ image.jpg and {128+64}
#@cli : $ image.jpg +mirror x and
#@cli argmax
#@cli : Compute the argmax of selected images. Returns a single image
#@cli : with each pixel value being the index of the input image with maximal value.
#@cli : $ image.jpg sample lena,lion,square +argmax
argmax :
e[^-1] "Compute argmax of image$?."
v - $!,1,1,1,x ({'{^}'}) l. s +,{','} i[0--1:2] ({'i#'}) y a y str={t} endl rm[-2,-1]
${-max_whds},"argmax("$str")" k. nm [argmax] v +
#@cli argmin
#@cli : Compute the argmin of selected images. Returns a single image
#@cli : with each pixel value being the index of the input image with minimal value.
#@cli : $ image.jpg sample lena,lion,square +argmin
argmin :
e[^-1] "Compute argmin of image$?."
if {!$!} return fi
v - $!,1,1,1,x ({'{^}'}) l. s +,{','} i[0--1:2] ({'i#'}) y a y str={t} endl rm[-2,-1]
${-max_whds},"argmin("$str")" k. nm [argmin] v +
#@cli asin : (+)
#@cli : Compute the pointwise arcsine of selected images.
#@cli : $ image.jpg +normalize -1,1 asin[-1]
#@cli : $ 300,1,1,1,'cut(x/w+0.1*u,0,1)' +asin display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands
#@cli asinh : (+)
#@cli : Compute the pointwise hyperbolic arcsine of selected images.
#@cli atan : (+)
#@cli : Compute the pointwise arctangent of selected images.
#@cli : $ image.jpg +normalize 0,8 atan[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +atan display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands
#@cli atan2 : [x_argument] : (+)
#@cli : Compute the pointwise oriented arctangent of selected images.
#@cli : Each selected image is regarded as the y-argument of the arctangent function, while the
#@cli : specified image gives the corresponding x-argument.
#@cli : $ (-1,1) (-1;1) resize 400,400,1,1,3 atan2[1] [0] keep[1] mod {pi/8}
#@cli : $$ trigometric-and-inverse-trigometric-commands
#@cli atanh : (+)
#@cli : Compute the pointwise hyperbolic arctangent of selected images.
#@cli << : eq. to 'bsl'. : (+)
#@cli bsl : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise left shift of selected images with specified value, image or
#@cli : mathematical expression, or compute the pointwise sequential bitwise left shift of
#@cli : selected images.
#@cli : (eq. to '<<').
#@cli : $ image.jpg bsl 'round(3*x/w,0)' cut 0,255
#@cli >> : eq. to 'bsr'. : (+)
#@cli bsr : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise right shift of selected images with specified value, image or"
#@cli : mathematical expression, or compute the pointwise sequential bitwise right shift of
#@cli : selected images.
#@cli : (eq. to '>>').
#@cli : $ image.jpg bsr 'round(3*x/w,0)' cut 0,255
#@cli cos : (+)
#@cli : Compute the pointwise cosine of selected images.
#@cli : $ image.jpg +normalize 0,{2*pi} cos[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +cos display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands
#@cli cosh : (+)
#@cli : Compute the pointwise hyperbolic cosine of selected images.
#@cli : $ image.jpg +normalize -3,3 cosh[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +cosh display_graph 400,300
#@cli / : eq. to 'div'. : (+)
#@cli div : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Divide selected images by specified value, image or mathematical expression,
#@cli : or compute the pointwise quotient of selected images.
#@cli : (eq. to '/').
#@cli : $ image.jpg div '1+abs(cos(x/10)*sin(y/10))'
#@cli : $ image.jpg +norm add[-1] 1 +div
#@cli div_complex : [divider_real,divider_imag],_epsilon>=0
#@cli : Perform division of the selected complex pairs (real1,imag1,...,realN,imagN) of images by specified complex pair of images (divider_real,divider_imag).
#@cli : In complex pairs, the real image must be always located before the imaginary image in the image list.
#@cli : Default value: 'epsilon=1e-8'.
div_complex : check ${3=1e-8}>=0
e[^-1] "Divide complex pair$? by complex pair $1,$2 (with epsilon $3)."
v - repeat {int($!/2)} pass${1,2} 0 l[$>,{$>+1},-2,-1]
+*[1,2] +*[0,3] -[-2,-1]
*[0] [2] *[1] [3] +[0,1]
sqr[1,2] +[1,2] +[1] $3
/[2] [1] /[0,1]
endl done v +
#@cli == : eq. to 'eq'. : (+)
#@cli eq : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean equality of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean equality of selected images.
#@cli : (eq. to '==').
#@cli : $ image.jpg round 40 eq {round(ia,40)}
#@cli : $ image.jpg +mirror x eq
#@cli exp : (+)
#@cli : Compute the pointwise exponential of selected images.
#@cli : $ image.jpg +normalize 0,2 exp[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +exp display_graph 400,300
#@cli >= : eq. to 'ge'. : (+)
#@cli ge : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'greater or equal than' of selected images with specified value, image
#@cli : or mathematical expression, or compute the boolean 'greater or equal than' of selected images.
#@cli : (eq. to '>=').
#@cli : $ image.jpg ge {ia}
#@cli : $ image.jpg +mirror x ge
#@cli > : eq. to 'gt'. : (+)
#@cli gt : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'greater than' of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean 'greater than' of selected images.
#@cli : (eq. to '>').
#@cli : $ image.jpg gt {ia}
#@cli : $ image.jpg +mirror x gt
#@cli <= : eq. to 'le'. : (+)
#@cli le : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'less or equal than' of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean 'less or equal than' of selected images.
#@cli : (eq. to '<=').
#@cli : $ image.jpg le {ia}
#@cli : $ image.jpg +mirror x le
#@cli < : eq. to 'lt'. : (+)
#@cli lt : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'less than' of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean 'less than' of selected images.
#@cli : (eq. to '<').
#@cli : $ image.jpg lt {ia}
#@cli : $ image.jpg +mirror x lt
#@cli log : (+)
#@cli : Compute the pointwise base-e logarithm of selected images.
#@cli : $ image.jpg +add 1 log[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +log display_graph 400,300
#@cli log10 : (+)
#@cli : Compute the pointwise base-10 logarithm of selected images.
#@cli : $ image.jpg +add 1 log10[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +log10 display_graph 400,300
#@cli log2 : (+)
#@cli : Compute the pointwise base-2 logarithm of selected images
#@cli : $ image.jpg +add 1 log2[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +log2 display_graph 400,300
#@cli max : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the maximum between selected images and specified value, image or
#@cli : mathematical expression, or compute the pointwise maxima between selected images.
#@cli : $ image.jpg +mirror x max
#@cli : $ image.jpg max 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'
#@cli m/ : eq. to 'mdiv'. : (+)
#@cli mdiv : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the matrix division of selected matrices/vectors by specified value, image or
#@cli : mathematical expression, or compute the matrix division of selected images.
#@cli : (eq. to 'm/').
#@cli min : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the minimum between selected images and specified value, image or
#@cli : mathematical expression, or compute the pointwise minima between selected images.
#@cli : $ image.jpg +mirror x min
#@cli : $ image.jpg min 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'
#@cli % : eq. to 'mod'. : (+)
#@cli mod : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the modulo of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential modulo of selected images.
#@cli : (eq. to '%').
#@cli : $ image.jpg +mirror x mod
#@cli : $ image.jpg mod 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'
#@cli m* : eq. to 'mmul'. : (+)
#@cli mmul : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the matrix right multiplication of selected matrices/vectors by specified value, image or
#@cli : mathematical expression, or compute the matrix right multiplication of selected images.
#@cli : (eq. to 'm*').
#@cli : $ (0,1,0;0,0,1;1,0,0) (1;2;3) +mmul
#@cli * : eq. to 'mul'. : (+)
#@cli mul : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Multiply selected images by specified value, image or mathematical expression,
#@cli : or compute the pointwise product of selected images.
#@cli : (eq. to '*').
#@cli : $ image.jpg +mul 2 cut 0,255
#@cli : $ image.jpg (1,2,3,4,5,6,7,8) resize[-1] [0] mul[0] [-1]
#@cli : $ image.jpg mul '1-3*abs(x/w-0.5)' cut 0,255
#@cli : $ image.jpg +luminance negate[-1] +mul
#@cli mul_channels : value1,_value2,...,_valueN
#@cli : Multiply channels of selected images by specified sequence of values.
#@cli : $ image.jpg +mul_channels 1,0.5,0.8
mul_channels :
e[^-1] "Multiply channels of image$? by value sequence ($*)."
v - $=arg repeat $#,i
fact=${arg{1+($>%$#)}}
repeat $! if {$>,$i<s} sh[$>] $i *. $fact rm. fi done
done v +
#@cli mul_complex : [multiplier_real,multiplier_imag]
#@cli : Perform multiplication of the selected complex pairs (real1,imag1,...,realN,imagN) of images by specified complex pair of images (multiplier_real,multiplier_imag).
#@cli : In complex pairs, the real image must be always located before the imaginary image in the image list.
mul_complex :
e[^-1] "Multiply complex pair$? by complex pair $1,$2."
v - repeat {int($!/2)} pass${1,2} 0 l[$>,{$>+1},-2,-1]
+*[0,3] +*[1,2] +[-2,-1]
*[0,2] *[1,2] -[0,1]
endl done v +
#@cli != : eq. to 'neq'. : (+)
#@cli neq : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean inequality of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean inequality of selected images.
#@cli : (eq. to '!=').
#@cli : $ image.jpg round 40 neq {round(ia,40)}
#@cli | : eq. to 'or'. : (+)
#@cli or : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise OR of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential bitwise OR of selected images.
#@cli : (eq. to '|').
#@cli : $ image.jpg or 128
#@cli : $ image.jpg +mirror x or
#@cli ^ : eq. to 'pow'. : (+)
#@cli pow : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Raise selected images to the power of specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential powers of selected images.
#@cli : (eq. to '^').
#@cli : $ image.jpg div 255 +pow 0.5 mul 255
#@cli : $ image.jpg gradient pow 2 add pow 0.2
#@cli rol : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise left rotation of selected images with specified value, image or
#@cli : mathematical expression, or compute the pointwise sequential bitwise left rotation of
#@cli : selected images.
#@cli : $ image.jpg rol 'round(3*x/w,0)' cut 0,255
#@cli ror : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise right rotation of selected images with specified value, image or
#@cli : mathematical expression, or compute the pointwise sequential bitwise right rotation of
#@cli : selected images.
#@cli : $ image.jpg ror 'round(3*x/w,0)' cut 0,255
#@cli sign : (+)
#@cli : Compute the pointwise sign of selected images.
#@cli : $ image.jpg +sub {ia} sign[-1]
#@cli : $ 300,1,1,1,'cos(20*x/w+u)' +sign display_graph 400,300
#@cli sin : (+)
#@cli : Compute the pointwise sine of selected images.
#@cli : $ image.jpg +normalize 0,{2*pi} sin[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +sin display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands
#@cli sinc : (+)
#@cli : Compute the pointwise sinc function of selected images.
#@cli : $ image.jpg +normalize {-2*pi},{2*pi} sinc[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +sinc display_graph 400,300
#@cli sinh : (+)
#@cli : Compute the pointwise hyperbolic sine of selected images.
#@cli : $ image.jpg +normalize -3,3 sinh[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +sinh display_graph 400,300
#@cli sqr : (+)
#@cli : Compute the pointwise square function of selected images.
#@cli : $ image.jpg +sqr
#@cli : $ 300,1,1,1,'40*x/w+u' +sqr display_graph 400,300
#@cli sqrt : (+)
#@cli : Compute the pointwise square root of selected images.
#@cli : $ image.jpg +sqrt
#@cli : $ 300,1,1,1,'40*x/w+u' +sqrt display_graph 400,300
#@cli - : eq. to 'sub'. : (+)
#@cli sub : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Subtract specified value, image or mathematical expression to selected images,
#@cli : or compute the pointwise difference of selected images.
#@cli : (eq. to '-').
#@cli : $ image.jpg +sub 30% cut 0,255
#@cli : $ image.jpg +mirror x sub[-1] [0]
#@cli : $ image.jpg sub 'i(w/2+0.9*(x-w/2),y)'
#@cli : $ image.jpg +mirror x sub
#@cli tan : (+)
#@cli : Compute the pointwise tangent of selected images.
#@cli : $ image.jpg +normalize {-0.47*pi},{0.47*pi} tan[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +tan display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands
#@cli tanh : (+)
#@cli : Compute the pointwise hyperbolic tangent of selected images.
#@cli : $ image.jpg +normalize -3,3 tanh[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +tanh display_graph 400,300
#@cli xor : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise XOR of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential bitwise XOR of selected images.
#@cli : $ image.jpg xor 128
#@cli : $ image.jpg +mirror x xor
#@cli :: Values Manipulation
#@cli apply_curve : 0<=smoothness<=1,x0,y0,x1,y1,x2,y2,...,xN,yN
#@cli : Apply curve transformation to image values.
#@cli : Default values: 'smoothness=1', 'x0=0', 'y0=100'.
#@cli : $ image.jpg +apply_curve 1,0,0,128,255,255,0
apply_curve : check "${1=1}>=0 && $1<=1" skip ${2=0},${3=100}
e[^-1] "Apply intensity curve with smoothness $1 and keypoints (${2--1}) on image$?."
v - function1d ${^0} map[^-1] .,1 rm.
v +
#@cli apply_gamma : gamma>=0
#@cli : Apply gamma correction to selected images.
#@cli : $ image.jpg +apply_gamma 2
apply_gamma : check $1>=0
e[^-1] "Apply Gamma-correction to image$?, with gamma $1."
if {$1==1} return fi
v - repeat $! l[$>] mM={[im,iM]} n 0,1 ^ {1/$1} n $mM endl done v +
#@cli balance_gamma : _ref_color1,...
#@cli : Compute gamma-corrected color balance of selected image, with respect to specified reference color.
#@cli : Default value: 'ref_color1=128'.
#@cli : $ image.jpg +balance_gamma 128,64,64
balance_gamma : skip ${1=128}
e[^-1] "Apply gamma-corrected color balance of image$?, with reference color ("${^0}")."
v - repeat $! l[$>]
(${^0}) r. {-2,s},1,1,1,0,1 s.. c /. 255
repeat {$!-1} /[$>] 255 ^[$>] {log({@$>})/log({$>,ia})} *[$>] 255 done
rm. a c c 0,255
endl done v +
#@cli cast : datatype_source,datatype_target
#@cli : Cast datatype of image buffer from specified source type to specified target type.
#@cli : 'datatype_source' and 'datatype_target' can be { uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.
cast :
e[^-1] "Cast datatype of image buffer$? from '$1' to '$2'."
v -
stype="$1"
if {s='$stype';s[0]==_'u'&&s[1]!=_'n'} stype="unsigned_"{`s='$stype';s[1,size(s)-1]`}
elif {s='$stype';s[0]==_'u'&&s[0,9]=='"unsigned "'} stype="unsigned_"{`s='$stype';s[9,size(s)-9]`}
fi
dtype="$2"
if {s='$dtype';s[0]==_'u'&&s[1]!=_'n'} dtype="unsigned_"{`s='$dtype';s[1,size(s)-1]`}
elif {s='$dtype';s[0]==_'u'&&s[0,9]=='"unsigned "'} dtype="unsigned_"{`s='$dtype';s[9,size(s)-9]`}
fi
ssize={s='$stype';s=='"unsigned_char"'||s=='char'?1:s=='"unsigned_short"'||s=='short'?2:s=='"unsigned_int"'||s=='int'||s=='float'?4:8}
dsize={s='$dtype';s=='"unsigned_char"'||s=='char'?1:s=='"unsigned_short"'||s=='short'?2:s=='"unsigned_int"'||s=='int'||s=='float'?4:8}
repeat $! l[$>]
w,h,d,s={[w,h,d,s]}
serialize $1,0,0
s -,{'\n$w\ $h\ $d\ $s\n'}
i[1] ({'\n1\ {int($w*$h*$d*$s*$ssize/$dsize)}\ 1\ 1\n'}) y[1]
replace_str[0] $stype,$dtype
a y unserialize
endl done v +
#@cli complex2polar
#@cli : Compute complex to polar transforms of selected images.
#@cli : $ image.jpg +fft complex2polar[-2,-1] log[-2] shift[-2] 50%,50%,0,0,2 remove[-1]
complex2polar :
e[^-1] "Compute complex to polar transforms of image$?."
v - repeat {int($!/2)} l[{2*$>},{2*$>+1}]
r[1] [0],3 +atan2[1] [0] nm. {1,n} sqr[-3,-2] +[-3,-2] sqrt..
endl done v +
#@cli compress_clut : _max_error>0,_avg_error>0,_max_nbpoints>=8
#@cli : Compress selected color LUTs as sequences of colored keypoints.
#@cli : Default values: 'max_error=8', 'avg_error=2' and 'max_nb_points=2048'.
compress_clut : check "isint(${1=8}) && $1>0 && ${2=2}>0 && isint(${3=2048}) && $3>8"
e[^-1] "Compress color LUT$? as a set of colored keypoints, with maximum error $1, average error $2 and $3 maximum keypoints."
v - max_error,avg_error,max_keypoints=${1--1}
repeat $! l[$>] strvar {b} nm=${}
if {iM>255} / 257 fi
if {d==1} S={round(cbrt(wh))} r $S,$S,$S,100%,-1 fi
v + e[] "\n* Process CLUT '"$nm"' ("{w}"x"{h}"x"{d}")." v -
1,8,1,{s+3}
eval "
coords = [ 0,0,0, 255,0,0, 255,255,0, 0,255,0, 0,0,255, 255,0,255, 255,255,255, 0,255,255 ];
for (k = 0, k<size(coords)/3, ++k,
P = coords[3*k,3];
I[k] = [ P, I(#0,round(P*([w#0,h#0,d#0]-1)/255)) ]
)"
sep="\n"
do
+decompress_clut. {0,[w,h,d]} -. [0] norm. emax,eavg={[iM,ia]}
v + e[] "\r"$sep"  > Add [#"{1,h}"] Max_Err = "{_$emax}", Avg_Err = "{_$eavg}"         " v - sep=""
if {$emax<=$max_error" && "$eavg<=$avg_error} rm. break fi
1,1,1,{0,s+3},{"P = [ xM,yM,zM ]; [ round(P*255/[max(1,w#0-1),max(1,h#0-1),max(1,d#0-1)]), I(#0,P) ]"} rm..
a[-2,-1] y
while {1,h<$max_keypoints}
max_error,avg_error={[max($max_error,ceil($emax)),max($avg_error,ceil($avg_error))]}
index=0 sep="\n"
repeat {h}
+l. s y rm[$index] a y endl
+decompress_clut. {0,[w,h,d]} -. [0] norm. emax,eavg={[iM,ia]} rm.
if {$emax<=$max_error" && "$eavg<=$avg_error} rv[-2,-1] else index+=1 fi
v + e[] "\r"$sep"  > Rem [#"$index/{1,h}"] Max_Err = "{_$emax}", Avg_Err = "{_$eavg}"       " v - sep=""
rm.
done
k. nm $nm
1,100%,1,1,"P = I(#0); P[0]*65536 + P[1]*256 + P[2]" rv a x sort +,y z. 1,100%
endl done v +
#@cli compress_rle : _is_binary_data={ 0 | 1 },_maximum_sequence_length>=0
#@cli : Compress selected images as 2xN data matrices, using RLE algorithm.
#@cli : Set 'maximum_sequence_length=0' to disable maximum length constraint.
#@cli : Default values: 'is_binary_data=0' and 'maximum_sequence_length=0'.
#@cli : $ image.jpg resize2dy 100 quantize 4 round +compress_rle , +decompress_rle[-1]
compress_rle : skip ${1=0} check "isint(${2=0}) && $2>=0"
v - s0=" for binary data" s1=""
if $2 s=", with maximal sequence length "$2 else s="" fi
v + e[^-1] "Compress image$? using RLE algorithm"${s{!$1}}$s"." v -
repeat $! l[$>] nm={0,n} im={im} header={w};{h};{d};{s};$im;{$1!=0}
- $im y x ({{0,@-1}+1}) a x r 100%,3
f '>if(y==0,i,if(y==1,if(i(x,0)==i(x+1,0),-1,x),if(i(x-1,1)==-1,i(x-1,2)+1,1)))'
if $2
transpose mirror x
f. '>if(x==2,i,if(x==0,if(j(0,-1)==$2,1,if(i!=1,j(0,-1)+1,1)),if(i==-1&&j(-1)==$2,y,i)))'
mirror x transpose
fi
z 0,{w-2} s y,3 discard[1] -1 warp[0,2] [1],0,0 rm[1]
if $1
!=[0] 0 *[0] 2 -[0] 1 *
else
*. -1 rv a x y discard -1 f '>if(i(0,y-1)<0&&i==0&&i(0,y+1)<0,-1,i)' discard -1
fi
i[0] ($header) a y nm $nm
endl done v +
#@cli cumulate : { x | y | z | c }...{ x | y | z | c } : (no arg) : (+)
#@cli : Compute the cumulative function of specified image data, optionally along the specified axes.
#@cli : $ image.jpg +histogram +cumulate[-1] display_graph[-2,-1] 400,300,3
#@cli c : eq. to 'cut'. : (+)
#@cli cut : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (no arg) : (+)
#@cli : Cut values of selected images in specified range.
#@cli : (eq. to 'c').\n
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : In interactive mode, the chosen cut values are returned in the status.
#@cli : $ image.jpg +add 30% cut[-1] 0,255
#@cli : $ image.jpg +cut 25%,75%
#@cli decompress_clut : _width>0,_height>0,_depth>0
#@cli : Decompress selected colored keypoints into 3D CLUTs.
#@cli : Default value: 'width=height=depth=64'.
decompress_clut : check "isint(${1=64}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=$1}) && $3>0"
e[^-1] "Decompress colored keypoint$? into $1x$2x$3 CLUTs."
v - repeat $! l[$>]
if {w==6" && "s==1} permute cyzx fi
1,1,1,{s-3}
do
+f. 0 .,.,.,1
eval[0] "PC = I; X = round(PC[0,3]*([w#1,h#1,d#1] - 1)/255); I(#2,X)+=PC[3,s-3]; ++i(#3,X); I"
f. "*i?(I(#2)/=i;1):0"
if {im} rm[-3,-1]
else
+distance. 1 .,.,.,3
eval.. "*
const boundary = 1;
maxabs(a,b) = (abs(a)>abs(b)?a:b);
I(#-1) = [ maxabs(j(1) - i,i - j(-1)),
maxabs(j(0,1) - i,i - j(0,-1)),
maxabs(j(0,0,1) - i,i - j(0,0,-1)) ]"
orientation. rm..
repeat 20
j[-4] ...,0,0,0,0,1,..
+warp[-4] .,1,2,1 *.. -1 warp[-5] ..,1,2,1 +[-5,-1] /[-4] 2
done
j[-4] ...,0,0,0,0,1,.. k[0,1]
fi
if {"w<$1 || h<$2 || d<$3"} r. {[min($1,2*w),min($2,2*h),min($3,2*d)]},100%,3 else break fi
while 1 k.
endl done v +
#@cli decompress_rle
#@cli : Decompress selected data vectors, using RLE algorithm.
decompress_rle :
e[^-1] "Decompress data vector$?, using RLE algorithm."
v - repeat $! l[$>]
y whds={0,@0-3} im={0,@4} is_binary_data={0,@5} rows 6,100%
if $is_binary_data
+>= 0 abs[0] a x
else
+<. 0
(0;1;1)
erode.. .,0 rm. -. 1 a x discard -1
+< 0 (0;1;1) dilate.. . rm. *. -2 +. 1
rv abs. a x discard -1
r 2,{h/2},1,1,-1
fi
s y,-256
repeat $! l[$>]
i[0] ({'CImg3d'}) +[0] 0.5
i[1] ({2*h};{h})
s. x,2 cumulate.. siz={-2,@-1}
+shift.. 0,1 -... 1 rv[-3,-1] z[-3,-1] 0,2 a[-3,-1] x
i[3] (2,0,1;2,{2*h-2},{2*h-1}) r[3] 3,{h},1,1,3 round[3]
r[4] 3 1,100%,1,1,1 y a y
$siz j3d. ..,0,0,0,1,2,0,0 rm..
endl done
a x r $whds,-1 + $im
endl done v +
#@cli discard : _value1,_value2,... : { x | y | z | c}...{ x | y | z | c},_value1,_value2,... : (no arg) : (+)
#@cli : Discard specified values in selected images or discard neighboring duplicate values,
#@cli : optionally only for the values along the first of a specified axis.
#@cli : If no values are specified, neighboring duplicate values are discarded.
#@cli : If all pixels of a selected image are discarded, an empty image is returned.
#@cli : $ (1;2;3;4;3;2;1) +discard 2
#@cli : $ (1,2,2,3,3,3,4,4,4,4) +discard x
#@cli eigen2tensor
#@cli : Recompose selected pairs of eigenvalues/eigenvectors as 2x2 or 3x3 tensor fields.
#@cli : $$
eigen2tensor :
e[^-1] "Recompose pairs in eigen field$? as 2x2 or 3x3 tensor fields."
v - repeat {$!/2} l[$>,{$>+1}] nm={0,n}
if {s==2}
s. c
+sqr. *.. ... sqr...
sh. +*... -1
sh[-5]
a[-3--1] c a[-4--2] c
sh... 0 *[-3,-1]
sh... 1 *[-2,-1]
rm... +[-2,-1]
elif {s==6}
s. c
l[-6--4] +sqr.. +*[-2,-3] +sqr... *[-5] [-6] *[-4] [-6] sqr[-6] a c endl
l[-3--1] +sqr.. +*[-2,-3] +sqr... *[-5] [-6] *[-4] [-6] sqr[-6] a c endl
s... c
-[-5] ... -[-4] ... *.. [-5] *. [-4]
(1^0^0^1^0^1) r. ... *. [-4] rm[-6--4] +[-3--1]
else v + error[0--3] "Command '$0': Invalid image ["{$!-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2D or 3D eigenvectors."
fi
nm $nm endl done v +
#@cli endian : _datatype : (+)
#@cli : Reverse data endianness of selected images, eventually considering the pixel being of the specified datatype.
#@cli : 'datatype' can be { uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.
#@cli equalize : _nb_levels>0[%],_value_min[%],_value_max[%] : (+)
#@cli : Equalize histograms of selected images.
#@cli : If value range is specified, the equalization is done only for pixels in the specified
#@cli : value range.
#@cli : Default values: 'nb_levels=256', 'value_min=0%' and 'value_max=100%'.
#@cli : $ image.jpg +equalize
#@cli : $ image.jpg +equalize 4,0,128
#@cli f : eq. to 'fill'. : (+)
#@cli fill : value1,_value2,... : [image] : 'formula' : (+)
#@cli : Fill selected images with values read from the specified value list, existing image
#@cli : or mathematical expression. Single quotes may be omitted in 'formula'.
#@cli : (eq. to 'f').
#@cli : $ 4,4 fill 1,2,3,4,5,6,7
#@cli : $ 4,4 (1,2,3,4,5,6,7) fill[-2] [-1]
#@cli : $ 400,400,1,3 fill "X=x-w/2; Y=y-h/2; R=sqrt(X^2+Y^2); a=atan2(Y,X); if(R<=180,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))"
#@cli : $$
#@cli index : { [palette] | predefined_palette },0<=_dithering<=1,_map_palette={ 0 | 1 } : (+)
#@cli : Index selected vector-valued images by specified vector-valued palette.
#@cli : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@cli : Default values: 'dithering=0' and 'map_palette=0'.
#@cli : $ image.jpg +index 1,1,1
#@cli : $ image.jpg (0;255;255^0;128;255^0;0;255) +index[-2] [-1],1,1
#@cli : $$
#@cli ir : eq. to 'inrange'.
ir :
v - _gmic_s="$?" v +
_inrange $*
#@cli inrange : min[%],max[%]
#@cli : Detect pixels whose values are in specified range [min,max], in selected images.
#@cli : (eq. to 'ir').
#@cli : $ image.jpg +inrange 25%,75%
inrange :
v - _gmic_s="$?" v +
_$0 $*
_inrange :
e[0--3] "Detect pixel values in range [$1,$2] in image"$_gmic_s"."
v - repeat $! l[$>]
m=$1 M=$2
if ${is_percent\ $1} m={im+(iM-im)*$1} fi
if ${is_percent\ $2} M={im+(iM-im)*$2} fi
- {0.5*($m+$M)} abs <= {0.5*abs($M-$m)}
endl done v +
#@cli map : [palette],_boundary_conditions : predefined_palette,_boundary_conditions : (+)
#@cli : Map specified vector-valued palette to selected indexed scalar images.
#@cli : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'boundary_conditions=0'.
#@cli : $ image.jpg +luminance map[-1] 3
#@cli : $ image.jpg +rgb2ycbcr split[-1] c (0,255,0) resize[-1] 256,1,1,1,3 map[-4] [-1] remove[-1] append[-3--1] c ycbcr2rgb[-1]
#@cli : $$
#@cli map_clut : [clut] | "clut_name"
#@cli : Map specified RGB color LUT to selected images.
#@cli : $ image.jpg uniform_distribution {2^6},3 mirror[-1] x +map_clut[0] [1]
map_clut :
e[^-1] "Map color LUT $1 on image$?."
if {!$!} return fi
v - to_color
if ${"is_image_arg $1"} pass$1 0 to_rgb. else clut "$1" fi
l={round((w*h*d)^(1/3))}
if {w*h*d!=$l^3} v + error "Command '$0': Specified CLUT $1 has invalid dimensions "({w},{h},{d},{s}). fi
r. $l,$l,$l,3,-1
repeat {$!-1} l[$>,-1] nm={0,n} split_opacity[0] /[0] {256/$l}
+warp. [0],0,1,1
rm[0] mv. 0 a[^-1] c nm[0] $nm
endl done rm. v +
#@cli mix_channels : (a00,...,aMN) : [matrix]
#@cli : Apply specified matrix to channels of selected images.
#@cli : $ image.jpg +mix_channels (0,1,0;1,0,0;0,0,1)
mix_channels :
e[^-1] "Apply matrix $1 to channels of image$?."
v -
if ${"is_image_arg $1"} pass$1 1 else i ${^0} fi
repeat {$!-1} l[$>] nm={n}
whd={[w,h,d]} r. {[whd,s]},1,1,-1
pass. 0 mv. 0 m* r $whd,{h},-1
nm $nm endl done rm. v +
#@cli negate : base_value : (no arg)
#@cli : Negate image values.
#@cli : Default value: 'base_value=(undefined)'.
#@cli : $ image.jpg +negate
negate : skip "${1=,}"
if {isval("$*")}
e[0--3] "Negate values of image$?, according to base value $*."
v - - {"$*"} * -1 v +
else
e[0--3] "Negate values of image$?."
v - repeat $! -[$>] {$>,iM} done * -1
if {;['"$1"']!=','} noarg fi
v +
fi
#@cli noise : std_deviation>=0[%],_noise_type : (+)
#@cli : Add random noise to selected images.
#@cli : 'noise_type' can be { 0=gaussian | 1=uniform | 2=salt&pepper | 3=poisson | 4=rice }.
#@cli : Default value: 'noise_type=0'.
#@cli : $ image.jpg +noise[0] 50,0 +noise[0] 50,1 +noise[0] 10,2 cut 0,255
#@cli : $ 300,300,1,3 [0] noise[0] 20,0 noise[1] 20,1 +histogram 100 display_graph[-2,-1] 400,300,3
#@cli noise_perlin : _scale_x[%]>0,_scale_y[%]>0,_scale_z[%]>0,_seed_x,_seed_y,_seed_z
#@cli : Render 2D or 3D Perlin noise on selected images, from specified coordinates.
#@cli : The Perlin noise is a specific type of smooth noise, described here : 'https://en.wikipedia.org/wiki/Perlin_noise'.
#@cli : Default values: 'scale_x=scale_y=scale_z=16' and 'seed_x=seed_y=seed_z=0'.
#@cli : $$ 500,500,1,3 noise_perlin ,
noise_perlin : check "${1=16}>0 && ${2=$1}>0 && ${3=$1}>0 && isval(${4=0}) && isval(${5=0}) && isval(${6=0})"
e[^-1] "Render Perlin noise on image$?, with scales (${1-3}) and seeds (${4-6})."
v -
init="permutation = [ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,
168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,
244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,
198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,
28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,
113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,
239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,
24,72,243,141,128,195,78,66,215,61,156,180 ];
p = [ permutation,permutation ];
fade(t) = (t*t*t*(t*(t*6 - 15) + 10));
lerp(t,a,b) = (a + t*(b - a));
pcmod255 = vectors(); for (k = 0, k<s, ++k, pcmod255[k] = p[k%255]);
sx = ['$1']; is_px = sx[size(sx) - 1]==_'%';
sy = ['$2']; is_py = sy[size(sy) - 1]==_'%';
sz = ['$3']; is_pz = sz[size(sz) - 1]==_'%';
x0 = $4;
y0 = $5;
z0 = $6;
x1 = x0 + (is_px?1/$1:w/$1);
y1 = y0 + (is_py?1/$2:h/$2);
z1 = z0 + (is_pz?1/$3:d/$3);
fw = (x1 - x0)/max(w - 1,1);
fh = (y1 - y0)/max(h - 1,1);
fd = (z1 - z0)/max(d - 1,1);"
repeat $! if {$>,d>1}
f[$>] "*begin("$init" grad(hash,x,y,z) = ( gh = hash&15; gu = gh<8?x:y; gv = gh<4?y:gh==12 || gh==14?x:z; (!(gh&1)?gu:-gu) + (!(gh&2)?gv:-gv)));
x = x0 + x*fw + pcmod255[c]; y = y0 + y*fh + pcmod255[c]; z = z0 + z*fd + pcmod255[c];
ix = floor(x); iy = floor(y); iz = floor(z);
X = ix&255; Y = iy&255; Z = iz&255;
fx = x - ix; fy = y - iy; fz = z - iz;
u = fade(fx); v = fade(fy); w = fade(fz);
A = p[X] + Y; AA = p[A] + Z; AB = p[A + 1] + Z;
B = p[X + 1] + Y; BA = p[B] + Z; BB = p[B + 1] + Z;
fx1 = fx - 1; fy1 = fy - 1; fz1 = fz - 1;
lerp(w,lerp(v,lerp(u,grad(p[AA],fx,fy,fz),
grad(p[BA],fx1,fy,fz)),
lerp(u,grad(p[AB],fx,fy1,fz),
grad(p[BB],fx1,fy1,fz))),
lerp(v,lerp(u,grad(p[AA + 1],fx,fy,fz1),
grad(p[BA + 1],fx1,fy,fz1)),
lerp(u,grad(p[AB + 1],fx,fy1,fz1),
grad(p[BB+1],fx1,fy1,fz1))))"
else
f[$>] "*begin("$init" grad(hash,x,y) = ( gh = hash&15; gu = gh<8?x:y; gv = gh<4?y:gh==12 || gh==14?x:0; (!(gh&1)?gu:-gu) + (!(gh&2)?gv:-gv)));
x = x0 + x*fw + pcmod255[c]; y = y0 + y*fh + pcmod255[c];
ix = floor(x); iy = floor(y);
X = ix&255; Y = iy&255;
fx = x - ix; fy = y - iy;
u = fade(fx); v = fade(fy);
A = p[X] + Y; B = p[X + 1] + Y;
fx1 = fx - 1; fy1 = fy - 1;
lerp(v,lerp(u,grad(p[A],fx,fy),
grad(p[B],fx1,fy)),
lerp(u,grad(p[A + 1],fx,fy1),
grad(p[B + 1],fx1,fy1)))"
fi done v +
#@cli noise_poissondisk : _radius[%]>0,_max_sample_attempts>0
#@cli : Add poisson disk sampling noise to selected images.
#@cli : Implements the algorithm from the article "Fast Poisson Disk Sampling in Arbitrary Dimensions", by Robert Bridson (SIGGRAPH'2007).
#@cli : Default values: 'radius=8' and 'max_sample_attempts=30'.
#@cli : $ 300,300 noise_poissondisk 8
noise_poissondisk : check "${1=8}>0 && ${2=30}>0"
e[^-1] "Add poisson disk sampling points to image$?, with radius $1 and max sample attempts $2."
v - repeat $! l[$>]
R={${"is_percent $1"}?max(w,h,d)*$1:$1}
dim={d>1?3:h>1?2:1} cw={0.999*$R/sqrt($dim)}
({[w,h,d,1]}) y. c
{[ceil(I/$cw)]}
r[1] 1,1,1,$dim,-1
1,1,1,$dim 1,1,1,1
{vector$dim(2*ceil(sqrt($dim))+1)} r. 100%,100%,100%,2
f. "P=[x,y,z]-int([w/2,h/2,d/2]);[sum(sqr(P)),dot(P,[1,w#2,w#2*h#2])]"
r. {[whd,s,1,1,-1]} sort. +,x z. 0,1,100%,100% y. c
nm[1] dims nm[2] grid nm[3] samples nm[4] active nm[5] prox
eval ${-math_lib}"
begin(
dotoff = resize([ 1,w#2,w#2*h#2 ],d#2>1?3:h#2>1?2:1,0);
);
const N = "$dim";
const radius = "$R";
const grid_cw = "$cw";
const max_sample_attempts = $2;
const value = iM#0 + (im#0==iM#0);
mag2(vec) = sum(sqr(vec));
prox = I#5;
lim = I#1;
dar_insert(#3,I#1,0);
dar_insert(#3,u(I#1),1);
dar_insert(#4,1,0);
I(#2,int(I[#3,1]/grid_cw)) = 1;
I(#0,I[#3,1]) = value;
while (dar_size(#4)>0,
R = int(u(dar_size(#4)-1e-4));
P = i[#4,R];
T = I[#3,P];
for (attempts=0, attempts < max_sample_attempts, ++attempts,
do (S = 4*(u(vectorN(1)) - 0.5); M = mag2(S), M <= 1 || M > 4);
X = T + radius * S;
if (min(X)<0 || min(lim-X)<0, continue());
G = int(X/grid_cw);
GI = dot(G,dotoff);
for (K = 0; rejected = 0, K<size(prox), ++K,
V = i[#2,GI+prox[K]];
if (V>0 && mag2(I[#3,V]-X)<sqr(radius), rejected = 1;break())
);
if (!rejected,
Q = dar_size(#3);
dar_insert(#3,X);
dar_insert(#4,Q);
I(#2,G) = Q;
I(#0,X) = value;
break();
);
);
if (attempts == max_sample_attempts, dar_remove(#4,R));
);
" k[0]
endl done v +
#@cli normp : p>=0
#@cli : Compute the pointwise Lp-norm norm of vector-valued pixels in selected images.
#@cli : Default value: 'p=2'.
#@cli : $ image.jpg +normp[0] 0 +normp[0] 1 +normp[0] 2 +normp[0] inf
normp : check "isval(${1==2}) && $1>=0"
e[^-1] "Compute pointwise L"$1"-norm of vectors, in image$?."
v -
if {$1==0} != 0 compose_channels +
elif {$1==1} abs compose_channels +
elif {$1==2} norm
elif {$1==inf} abs compose_channels max
else ^ $1 compose_channels + ^ {1/$1}
fi
v +
#@cli norm
#@cli : Compute the pointwise euclidean norm of vector-valued pixels in selected images.
#@cli : $ image.jpg +norm
#@cli : $$
norm :
e[^-1] "Compute pointwise euclidean norm of vectors, in image$?."
v - sqr compose_channels + sqrt v +
#@cli n : eq. to 'normalize'. : (+)
#@cli normalize : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (+)
#@cli : Linearly normalize values of selected images in specified range.
#@cli : (eq. to 'n').
#@cli : $ image.jpg split x,2 normalize[-1] 64,196 append x
#@cli : $$
#@cli normalize_sum
#@cli : Normalize selected images with a unitary sum.
#@cli : $ image.jpg +histogram normalize_sum[-1] display_graph[-1] 400,300
normalize_sum :
e[^-1] "Normalize image$? with a unitary sum."
v - repeat $! /[$>] {sum={$>,is};if(sum!=0,sum,1)} done v +
#@cli not
#@cli : Apply boolean not operation on selected images.
#@cli : $ image.jpg +ge 50% +not[-1]
not :
e[^-1] "Apply boolean not operation on image$?."
v - == 0 v +
#@cli orientation
#@cli : Compute the pointwise orientation of vector-valued pixels in selected images.
#@cli : $ image.jpg +orientation +norm[-2] negate[-1] mul[-2] [-1] reverse[-2,-1]
#@cli : $$
orientation :
e[^-1] "Compute pointwise orientation vectors, in image$?."
v - repeat $! +norm[$>] replace. 0,1 /[$>,-1] done v +
#@cli oneminus
#@cli : For each selected image, compute one minus image.
#@cli : $ image.jpg normalize 0,1 +oneminus
oneminus :
e[^-1] "Compute one minus selected images$?."
v + * -1 + 1 v -
#@cli otsu : _nb_levels>0
#@cli : Hard-threshold selected images using Otsu's method.
#@cli : The computed thresholds are returned as a list of values in the status.
#@cli : Default value: 'nb_levels=256'.
#@cli : $ image.jpg luminance +otsu ,
otsu : check "isint(${1=256}) && $1>0"
e[^-1] "Hard-threshold image$? using Otsu\47s method, with $1 histogram levels."
v - repeat $! l[$>]
imM={[im,iM]} +histogram $1,$imM
otsu={"
sum = sumB = wB = best_variance = best_t = 0;
for (t = 0, t<w, ++t, sum+=t*i[t]);
for (t = 0, t<w, ++t,
wB+=i[t];
if (!wB, continue());
wF = whds#-2 - wB;
if (!wF, break());
sumB+=t*i[t];
mB = sumB/wB;
mF = (sum - sumB)/wF;
variance = wB*wF*(mB - mF)^2;
if (variance>best_variance, best_variance = variance; best_t = t);
);
imM = ["$imM"];
imM[0] + best_t*(imM[1] - imM[0])/(w - 1)"}
rm. >=. $otsu
if $> u ${},$otsu else u $otsu fi
endl done v +
#@cli polar2complex
#@cli : Compute polar to complex transforms of selected images.
polar2complex :
e[^-1] "Compute polar to complex transforms of image$?."
v - repeat {int($!/2)} l[{2*$>},{2*$>+1}]
r[1] [0],3 +sin. cos.. *. ... *[-3,-2]
endl done v +
#@cli quantize : nb_levels>=1,_keep_values={ 0 | 1 },_is_uniform={ 0 | 1 }
#@cli : Quantize selected images.
#@cli : Default value: 'keep_values=1' and 'is_uniform=0'.
#@cli : $ image.jpg luminance +quantize 3
#@cli : $ 200,200,1,1,'cos(x/10)*sin(y/10)' +quantize[0] 6 +quantize[0] 4 +quantize[0] 3 +quantize[0] 2
quantize : check "isint($1) && $1>=1" skip ${2=1},${3=0}
e[^-1] "Quantize image$? using $1 levels, "${arg\ 1+!$2,with,without}" keeping value range."
v - repeat $! l[$>]
if $3
if {s==1}
if $2 mM={[im,iM]} n 0,$1 round 1,-1 min {$1-1} n $mM
else n 0,$1 round 1,-1 min {$1-1} fi
else mM={[im,iM]} uniform_distribution $1,{s} n. $mM index.. .,0,$2 rm.
fi
else +colormap $1,1,1 index.. .,0,$2 rm.
fi
endl done v +
#@cli quantize_area : _min_area>0
#@cli : Quantize selected images such that each flat region has an area greater or equal to 'min_area'.
#@cli : Default value: 'min_area=10'.
#@cli : $ image.jpg quantize 3 +blur 1 round[-1] +quantize_area[-1] 2
quantize_area : check "${1=10}>0"
e[^-1] "Quantize image$? by regions of areas greater than $1."
v -
if {$1==1} v + return fi
repeat $! l[$>]
if {s>1} +f. "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm. round. 0.01 else [0] fi
area. 0,0 <. $1
do
[0]
f.. "*
begin(
const boundary = 1;
offx = [ -1,1,0,0,0,0 ];
offy = [ 0,0,-1,1,0,0 ];
offz = [ 0,0,0,0,-1,1 ];
nb_offs = d>1?6:h>1?4:2;
);
is_neighbor = j(-1) && j(-1);
if (h>1, is_neighbor&=j(1,0) && j(0,1));
if (d>1, is_neighbor&=j(0,0,-1) && j(0,0,1));
is_neighbor = !is_neighbor;
i && is_neighbor?(
col0 = I(#0);
kmin = -1;
distmin = inf;
for (k = 0, k<nb_offs, ++k,
p = offx[k];
q = offy[k];
r = offz[k];
if (!j(p,q,r),
col = J(#0,p,q,r);
dist = norm(col-=col0);
if (dist<distmin, distmin = dist; kmin = k);
);
);
if (kmin>=0,
I(#-1) = J(#0,offx[kmin],offy[kmin],offz[kmin]);
0,
1
);
):i"
rv[0,-1] rm.
while {iM}
rm.
endl done v +
#@cli rand : { value0[%] | [image0] },_{ value1[%] | [image1] } : [image] : (+)
#@cli : Fill selected images with random values uniformly distributed in the specified range.
#@cli : $ 400,400,1,3 rand -10,10 +blur 10 sign[-1]
#@cli replace : source,target
#@cli : Replace pixel values in selected images.
#@cli : $ (1;2;3;4) +replace 2,3
replace :
e[^-1] "Replace pixel values $1 with $2 in image$?."
v - f "i==$1?$2:i" v +
#@cli replace_inf : _expression
#@cli : Replace all infinite values in selected images by specified expression.
#@cli : $ (0;1;2) log +replace_inf 2
replace_inf :
e[^-1] "Replace all infinite values in image$? by expression '$1'."
v - f "isinf(i)?$1:i" v +
#@cli replace_nan : _expression
#@cli : Replace all NaN values in selected images by specified expression.
#@cli : $ (-1;0;2) sqrt +replace_nan 2
replace_nan :
e[^-1] "Replace all NaN values in images$? by expression '$1'."
v - f "isnan(i)?$1:i" v +
#@cli replace_seq : "search_seq","replace_seq"
#@cli : Search and replace a sequence of values in selected images.
#@cli : $ (1;2;3;4;5) +replace_seq "2,3,4","7,8"
replace_seq : skip "${2=}"
e[^-1] "Replace value sequence '$1' by value sequence '${2--1}' in image$?."
v - ns,nd={[narg($1),narg(${2--1})]}
repeat $! l[$>]
s +,$1 ind={"w#0 && crop(#0,0,0,0,0,1,min("$ns",h#0),1,1)!=[$1]"}
if {$ind<$!}
if $nd
eval "for (t = "$ind", t<l, t+=2, resize(#t,1,round(h#t*"$nd/$ns"),1,1,0))"
f[$ind--1:2] ${2--1}
else
rm[$ind--1:2]
fi
a y
fi
endl done v +
#@cli replace_str : "search_str","replace_str"
#@cli : Search and replace a string in selected images (viewed as strings, i.e. sequences of ascii codes).
#@cli : $ ({'"Hello there, how are you ?"'}) +replace_str "Hello there","Hi David"
replace_str : skip "${2=}"
e[^-1] "Replace string '$1' by string '${2--1}' in image$? (viewed as string$?)."
v -
replace_seq {``{'"$1"'}},{'"${2--1}"'}
v +
#@cli round : rounding_value>=0,_rounding_type : (no arg) : (+)
#@cli : Round values of selected images.
#@cli : 'rounding_type' can be { -1=backward | 0=nearest | 1=forward }.
#@cli : Default value: 'rounding_type=0'.
#@cli : $ image.jpg +round 100
#@cli : $ image.jpg mul {pi/180} sin +round
#@cli roundify : gamma>=0
#@cli : Apply roundify transformation on float-valued data, with specified gamma.
#@cli : Default value: 'gamma=0'.
#@cli : $ 1000 fill '4*x/w' repeat 5 +roundify[0] {$>*0.2} done append c display_graph 400,300
roundify : check $1>=0
e[^-1] "Roundify image$?, with gamma $1."
if {$1==1} return fi
v - repeat $! l[$>]
+round 1 -.. . +*.. 2 abs. ^. $1 sign... *[-3,-1] *.. 0.5 +
endl done v +
#@cli = : eq. to 'set'. : (+)
#@cli set : value,_x[%],_y[%],_z[%],_c[%] : (+)
#@cli : Set pixel value in selected images, at specified coordinates.
#@cli : (eq. to '=').\n
#@cli : If specified coordinates are outside the image bounds, no action is performed.
#@cli : Default values: 'x=y=z=c=0'.
#@cli : $ 2,2 set 1,0,0 set 2,1,0 set 3,0,1 set 4,1,1
#@cli : $ image.jpg repeat 10000 set 255,{u(100)}%,{u(100)}%,0,{u(100)}% done
#@cli set_vector_covariance : coef1,coef2,...,coefN
#@cli : Apply linear transformation on selected images so that the covariance matrix of their vector-valued pixels
#@cli : is prescribed to given matrix. Matrix size 'N' must be equal to 'spectrum^2'.
set_vector_covariance :
e[^-1] "Set covariance matrix of image$? to [ $* ]."
v - repeat $! l[$>]
if {narg($*)!=s^2} error[0--4] "Command '$0': Invalid arguments '$*' for image '"{n}"' with size ("{[w,h,d,s]}") ("{s^2}" argument"${"if {s==1} u \"\" else u s fi"}" expected)." fi
C=${"vector_covariance _avg"}
f "begin(
avg = [ "$_avg" ];
C1 = [ "$C" ];
C2 = [ $* ];
eig1 = eig(C1);
eig2 = eig(C2);
for (k = 0, k<s, ++k,
k1s = (k + 1)*s;
if (dot(eig2[k1s,s],eig1[k1s,s])<0, copy(eig2[k1s],eig2[k1s,s]*=-1,s));
);
invD1 = diag(eig1[0,s]^-0.5);
invR1 = eig1[s,size(eig1)-s];
D2 = diag(eig2[0,s]^0.5);
R2 = transp(eig2[s,size(eig2)-s],s);
T = mul(R2,mul(D2,mul(invD1,invR1,s),s),s);
);
avg + T*(I - avg)"
endl done v +
#@cli threshold : value[%],_is_soft={ 0 | 1 } : (no arg) : (+)
#@cli : Threshold values of selected images.
#@cli : 'soft' can be { 0=hard-thresholding | 1=soft-thresholding }.
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : In interactive mode, the chosen threshold value is returned in the status.
#@cli : Default value: 'is_soft=0'.
#@cli : $ image.jpg +threshold[0] 50% +threshold[0] 50%,1
#@cli : $$
#@cli unrepeat
#@cli : Remove repetition of adjacent values in selected images.
#@cli : $ (1;1;1;1;1;2;2;2;3;4;4;4;5;5;5) +unrepeat
unrepeat :
e[^-1] "Remove repetition of adjacent values in image$?."
v - repeat $! l[$>] nm={0,n}
y x ({{0,@-1}+1}) a x r 100%,2
f. '>if(y==0,i,if(i(x,0)==i(x+1,0),-1,x))'
z 0,{w-2} s y,2 discard[1] -1 map[1] [0]
rm[0] nm $nm
endl done v +
#@cli vector2tensor
#@cli : Convert selected vector fields to corresponding tensor fields.
vector2tensor :
e[^-1] "Convert vector field$? to tensor field$?."
v - repeat $! l[$>]
s c
if {$!==2} +sqr. *.. ... sqr...
elif {$!==3} +sqr.. +*... .. +sqr... *[-5,-4] [-6] sqr[-6]
else v + error[0--4] "Command '$0': Invalid image ["{$!-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2D or 3D vectors."
fi
a c
endl done v +
#@cli :: Colors Manipulation
#@cli adjust_colors : -100<=_brightness<=100,-100<=_contrast<=100,-100<=_gamma<=100,-100<=_hue_shift<=100,-100<=_saturation<=100,_value_min,_value_max
#@cli : Perform a global adjustment of colors on selected images.
#@cli : Range of correct image values are considered to be in [value_min,value_max] (e.g. [0,255]).
#@cli : If 'value_min==value_max==0', value range is estimated from min/max values of selected images.
#@cli : Processed images have pixel values constrained in [value_min,value_max].
#@cli : Default values: 'brightness=0', 'contrast=0', 'gamma=0', 'hue_shift=0', 'saturation=0', 'value_min=value_max=0'.
#@cli : $ image.jpg +adjust_colors 0,30,0,0,30
adjust_colors : check "${1=0}>=-100 && $1<=100 && ${2=0}>=-100 && $2<=100 && ${3=0}>=-100 && $3<=100 && ${4=0}>=-100 && $4<=100 && ${5=0}>=-100 && $5<=100" skip ${6=0},${7=0}
e[^-1] "Adjust colors of image$?, with brightness $1, contrast $2, gamma $3, hue shift $4, saturation $5 and value range [$6,$7]."
v - repeat $! l[$>] split_opacity
range={"$6==$7 && $6==0?[im,iM]:[min($6,$7),max($6,$7)]"}
m={arg(1,$range)} M={arg(2,$range)} fact={255/max(1e-5,$M-$m)}
- $m * $fact
if {$4" || "$5}
to_rgb[0] rgb2hsv[0]
sh[0] 0 +. {$4*1.8} rm.
sh[0] 1 +. {($5%)^(1+($5>0))} c. 0,1 rm.
hsv2rgb[0]
fi
if $3
/[0] 255 ^[0] {10^-($3%)} *[0] 255
fi
if $2
-[0] 128 *[0] {exp($2/64)} +[0] 128
fi
+[0] {$1*2}
/[0] $fact +[0] $m c[0] $range
a c
endl done v +
#@cli ac : eq. to 'apply_channels'.
ac :
v - _gmic_s="$?" v +
_apply_channels $"*"
#@cli apply_channels : "command",color_channels,_value_action={ 0=none | 1=cut | 2=normalize }
#@cli : Apply specified command on the chosen color channel(s) of each selected images.
#@cli : (eq. to 'ac').\n
#@cli : Argument 'color_channels' refers to a colorspace, and can be basically one of { all | rgba | rgb | lrgb | ycbcr | lab | lch | hsv | hsi | hsl | cmy | cmyk | yiq }.
#@cli : You can also make the processing focus on a few particular channels of this colorspace, by setting 'color_channels' as 'colorspace_channel' (e.g. 'hsv_h' for the hue).
#@cli : All channel values are considered to be provided in the [0,255] range.
#@cli : Default value: 'value_action=0'.
#@cli : $ image.jpg +apply_channels "equalize blur 2",ycbcr_cbcr
apply_channels :
v - _gmic_s="$?" v +
_$0 $"*"
_apply_channels : check "isint(${3=0}) && $3>=0 && $3<=2"
v - mode="$2"
if {isval("$2")} if {isint("$2")}
mode=${arg\ 1+$2,all,rgba,rgb,rgb_r,rgb_g,rgb_b,rgba_a,\
lrgb,lrgb_r,lrgb_g,lrgb_b,\
ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
lab_l,lab_ab,lab_a,lab_b,\
lch_ch,lch_c,lch_h,\
hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
yiq_y,yiq_iq}
fi fi
v + e[^-1] "Apply command '$1' on channels '"$mode"' of image"$_gmic_s"." v -
({'$/'}) id={h=0;for(k=0,k<w,((h*=31)+=i[k++])%=1048576)} rm.
_ac_$mode m _ac_precond$id:$_p m _ac_forward$id:$_f m _ac_backward$id:$_b
repeat $! l[$>]
_ac_precond$id is_alpha={s==2" || "s==4}
if $is_alpha s c,{1-s} fi
_ac_forward$id[0] a c
sh $_s _ac. "$1"
if {$3==1} c. 0,255 elif {$3==2} n. 0,255 fi
rm.
if $is_alpha s c,{1-s} fi
_ac_backward$id[0] a c
endl done
uncommand _ac_precond$id,_ac_forward$id,_ac_backward$id
v +
_ac :
whds={w},{h},{d},{s} ${1--1} k[0] r $whds,0
_ac_all : _p="" _f="" _b="" _s=0,100%
_ac_rgba : _p="to_rgba" _f="" _b="" _s=0,3
_ac_rgba_r : _p="to_color" _f="" _b="" _s=0
_ac_rgba_g : _p="to_color" _f="" _b="" _s=1
_ac_rgba_b : _p="to_color" _f="" _b="" _s=2
_ac_rgba_a : _p="to_rgba" _f="" _b="" _s=3
_ac_rgb : _p="to_color" _f="" _b="" _s=0,2
_ac_rgb_r : _ac_rgba_r
_ac_rgb_g : _ac_rgba_g
_ac_rgb_b : _ac_rgba_b
_ac_lrgb : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=0,2
_ac_lrgb_r : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=0
_ac_lrgb_g : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=1
_ac_lrgb_b : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=2
_ac_ycbcr : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=0,2
_ac_ycbcr_y : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=0
_ac_ycbcr_cbcr : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=1,2
_ac_ycbcr_cb : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=1
_ac_ycbcr_cr : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=2
_ac_ycbcr_cg : _p="to_color" _f="sh 0,1 mirror. c rm. rgb2ycbcr" _b="ycbcr2rgb sh 0,1 mirror. c rm." _s=2
_ac_lab : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=0,2
_ac_lab_l : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=0
_ac_lab_ab : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=1,2
_ac_lab_a : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=1
_ac_lab_b : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=2
_ac_lch : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=0,2
_ac_lch_l : _ac_lab_l
_ac_lch_ch : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=1,2
_ac_lch_c : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=1
_ac_lch_h : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=2
_ac_hsv : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=0,2
_ac_hsv_h : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=0
_ac_hsv_s : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=1
_ac_hsv_v : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=2
_ac_hsi : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=0,2
_ac_hsi_h : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=0
_ac_hsi_s : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=1
_ac_hsi_i : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=2
_ac_hsl : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=0,2
_ac_hsl_h : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=0
_ac_hsl_s : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=1
_ac_hsl_l : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=2
_ac_cmy : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=0,2
_ac_cmy_c : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=0
_ac_cmy_m : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=1
_ac_cmy_y : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=2
_ac_cmyk : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=0,3
_ac_cmyk_c : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=0
_ac_cmyk_m : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=1
_ac_cmyk_y : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=2
_ac_cmyk_k : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=3
_ac_yiq : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=0,2
_ac_yiq_y : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=0
_ac_yiq_iq : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=1,2
_ac_yiq_i : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=1
_ac_yiq_q : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=2
#@cli autoindex : nb_colors>0,0<=_dithering<=1,_method={ 0=median-cut | 1=k-means }
#@cli : Index selected vector-valued images by adapted colormaps.
#@cli : Default values: 'dithering=0' and 'method=1'.
#@cli : $ image.jpg +autoindex[0] 4 +autoindex[0] 8 +autoindex[0] 16
autoindex : check "isint($1) && $1>0 && ${2=0}>=0" skip ${3=1}
e[^-1] "Index colors in images$? by adapted colormap with $1 entries, dithering level $2 and "\
${arg\ 1+!$3,k-means,median-cut}" method."
v - repeat $! l[$>]
if {w>h} if {w>256} +r2dx 256 else [0] fi
else if {h>256} +r2dy 256 else [0] fi
fi
colormap[1] $1,$3,0
index[0] [1],$2,1 rm[1]
endl done v +
#@cli bayer2rgb : _GM_smoothness,_RB_smoothness1,_RB_smoothness2
#@cli : Transform selected RGB-Bayer sampled images to color images.
#@cli : Default values: 'GM_smoothness=RB_smoothness=1' and 'RB_smoothness2=0.5'.
#@cli : $ image.jpg rgb2bayer 0 +bayer2rgb 1,1,0.5
bayer2rgb : skip ${1=1},${2=1},${3=0.5}
e[^-1] "Transform RGB-Bayer image$? to color images, with smoothness ($1,$2,$3)."
v - channels 0 repeat $! l[$>]
expand_x {"2 + 4*$1"},0 expand_y {"2 + 4*$1"},0
(-1,1;1,-1) r. ..,..,1,1,0,2
+*.. .
(0.25,0.5,0.25) convolve.. . transpose. convolve.. . rm.
b. $1
*.. .
-[-3,-2]
(1,-1) r. ..,..,1,1,0,2
*. ...
(0.25,0.5,0.25) convolve.. . transpose. convolve.. . rm.
blur_y. $2 blur_x. $3
(1;-1) r. ..,..,1,1,0,2
*. [-4]
(0.25,0.5,0.25) convolve.. . transpose. convolve.. . rm.
blur_x. $2 blur_y. $3
+[-2,-1] /. 2
(2,0;0,-2) r. ..,..,1,1,0,2
*. ..
-[-4,-1]
a[-3--1] c
mix_rgb. 1,-1,2,1,1,0,1,-1,-2
shrink_x {"2 + 4*$1"},0 shrink_y {"2 + 4*$1"},0
c 0,255
endl done v +
#@cli cmy2rgb
#@cli : Convert color representation of selected images from CMY to RGB.
cmy2rgb :
e[^-1] "Convert color representation of image$? from CMY to RGB."
v - rgb2cmy v +
#@cli cmyk2rgb
#@cli : Convert color representation of selected images from CMYK to RGB.
cmyk2rgb :
e[^-1] "Convert color representation of image$? from CMYK to RGB."
v - repeat $! l[$>]
s c +/. -255 +. 1 *[0-2] . rm. +[0-2] . rm.
a c cmy2rgb
endl done v +
#@cli colorblind : type={ 0=protanopia | 1=protanomaly | 2=deuteranopia | 3=deuteranomaly | 4=tritanopia | 5=tritanomaly | 6=achromatopsia | 7=achromatomaly }
#@cli : Simulate color blindness vision.
#@cli : $ image.jpg +colorblind 0
colorblind : check "isint($1) && $1>=0 && $1<=7"
v - s0="protanopia" s1="protanomaly" s2="deuteranopia" s3="deuteranomaly" s4="tritanopia" s5="tritanomaly" s6="achromatopsia" s7="achromatomaly"
v + e[^-1] "Simulate color blindness of type '"${s$1}"' on image$?." v -
type0=(0.567,0.433,0;0.558,0.442,0;0,0.242,0.758)
type1=(0.817,0.183,0;0.333,0.667,0;0,0.125,0.875)
type2=(0.625,0.375,0;0.7,0.3,0;0,0.3,0.7)
type3=(0.8,0.2,0;0.258,0.742,0;0,0.142,0.858)
type4=(0.95,0.05,0;0,0.433,0.567;0,0.475,0.525)
type5=(0.967,0.033,0;0,0.733,0.267;0,0.183,0.817)
type6=(0.299,0.587,0.114;0.299,0.587,0.114;0.299,0.587,0.114)
type7=(0.618,0.320,0.062;0.163,0.775,0.062;0.163,0.320,0.516)
repeat $! l[$>] split_opacity l[0] to_rgb mix_channels ${type$1} endl a c endl done
v +
#@cli colormap : nb_levels>=0,_method={ 0=median-cut | 1=k-means },_sort_vectors={ 0 | 1 }
#@cli : Estimate best-fitting colormap with 'nb_colors' entries, to index selected images.
#@cli : Set 'nb_levels==0' to extract all existing colors of an image.
#@cli : Default value: 'method=1' and 'sort_vectors=1'.
#@cli : $ image.jpg +colormap[0] 4 +colormap[0] 8 +colormap[0] 16
#@cli : $$
colormap : check "isint($1) && $1>=0" skip ${2=1},${3=1}
if $1 e[0--3] "Estimate colormap with $1 entries for image$?, by "${arg\ 1+!$2,k-means,median-cut}" method."
else e[0--3] "Estimate full colormap for image$?."
fi
v - repeat $! l[$>] nm={b}
r {w*h*d},1,1,100%,-1
if $1
if {!$2} _colormap $1
else
+_colormap $1
max_diff={(iM-im+1)/8192}
do
+index.. .
..,1,1,{-2,s+1}
f.. ">I[#3,i]+=[ I[#0,x],1 ]" rm..
f. "s = i(x,0,0,s-1); s?I/s:[ I[#1,x], 0 ]"
+-.. . abs. diff={iM/w} rm.
j.. . rm.
while {$diff>$max_diff}
rm..
fi
else
repeat {s} ap "sort +,x" s x,0 ap "shift 0,0,0,1,2" done
ap "discard x" a x
fi
if $3 +norm rv a c sort +,x channels 1,100% fi
nm "[colormap of "$nm"]"
endl done v +
_colormap :
m "__colormap : repeat {s} sh[$""1] $> =.. {iv},$""1,0,0,$> rm. done"
1,1,1,{s} __colormap 0
repeat {$1-1}
b,a={[xM,cM]}
shift[$b] 0,0,0,{-$a},2 sort[$b] +,x shift[$b] 0,0,0,$a,2 s[$b] x,2
mv[$b] -1 r. {w+1},1,1,100%,0
__colormap $b __colormap {$!-2}
done
rm. r 1,1,1,100%,2 a x
uncommand __colormap
#@cli compose_channels
#@cli : Compose all channels of each selected image, using specified arithmetic operator (+,-,or,min,...).
#@cli : Default value: '1=+'.
#@cli : $ image.jpg +compose_channels and
#@cli : $$
compose_channels : skip ${1="+"}
e[^-1] "Compose all channels of image$?, with operator '$1'."
v - repeat $! l[$>]
sh 0
repeat {-2,s-1} sh.. {$>+1} l[-2,-1] $1 endl done
rm. r 100%,100%,100%,1,-1
endl done v +
#@cli direction2rgb
#@cli : Compute RGB representation of selected 2D direction fields.
#@cli : $ image.jpg luminance gradient append c blur 2 orientation +direction2rgb
direction2rgb :
e[^-1] "Compute RGB representation of 2D direction field$?."
v - channels 0,1 repeat $! l[$>] nm={0,n}
s c complex2polar round.. 0.001
*. {180/pi} %. 360 100%,100%,1,1,1 mv... $!
if {im!=iM} n. 0,1 else f. 1 fi
a c hsv2rgb
nm $nm endl done v +
#@cli ditheredbw
#@cli : Create dithered B&W version of selected images.
#@cli : $ image.jpg +equalize ditheredbw[-1]
ditheredbw :
e[^-1] "Create dithered B&W version of image$?."
v - repeat $! l[$>] split_opacity
luminance[0] n[0] 0,255 (0,255) index[0] .,1,1 rm.
a c endl done v +
#@cli fc : eq. to 'fill_color'.
fc :
v - _gmic_s="$?" v +
_fill_color $*
#@cli fill_color : col1,...,colN
#@cli : Fill selected images with specified color.
#@cli : (eq. to 'fc').
#@cli : $ image.jpg +fill_color 255,0,255
#@cli : $$
fill_color :
v - _gmic_s="$?" v +
_$0 $*
_fill_color :
e[0--3] "Fill image"$_gmic_s" with color (${^0})."
v - repeat $! l[$>]
repeat {s} sh[0] $> f. {arg(1+$>,${^0})} done k[0]
nm {n} endl done v +
#@cli gradient2rgb : _is_orientation={ 0 | 1 }
#@cli : Compute RGB representation of 2D gradient of selected images.
#@cli : Default value: 'is_orientation=0'.
#@cli : $ image.jpg +gradient2rgb 0 equalize[-1]
gradient2rgb : check "isbool(${1=0})"
arg 1+!$1,"orientation ",""
e[^-1] "Compute RGB representation of 2D gradient "${}"of image$?."
v - norm repeat $! l[$>]
if $1 gradient_orientation 2 else g xy fi
a c direction2rgb
endl done v +
#@cli hcy2rgb :
#@cli : Convert color representation of selected images from HCY to RGB.
hcy2rgb :
e[^-1] "Convert color representation of image$? from HCY to RGB."
v - to_color f "
H = (R/60)%6;
X = G*(1 - abs(H%2 - 1));
RGB = arg(1 + int(H),[G,X,0],[X,G,0],[0,G,X],[0,X,G],[X,0,G],[G,0,X]);
m = B - 0.3*RGB[0] - 0.59*RGB[1] - 0.11*RGB[2];
cut((RGB+=m)*=255,0,255)"
v +
#@cli hsi2rgb
#@cli : Convert color representation of selected images from HSI to RGB.
hsi2rgb :
e[^-1] "Convert color representation of image$? from HSI to RGB."
v - to_color
f "
H = (R/60)%6;
S = cut(G,0,1);
I = cut(B,0,1);
Z = 1 - abs((H%2) - 1);
C = I*S/(1 + Z);
X = C*Z;
m = I*(1 - S)/3;
RGB = arg(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
cut((RGB+=m)*=3*255,0,255);
"
v +
#@cli hsi82rgb
#@cli : Convert color representation of selected images from HSI8 to RGB.
hsi82rgb :
e[^-1] "Convert color representation of image$? from HSI8 to RGB."
v - _hsx82rgb hsi2rgb v +
#@cli hsl2rgb
#@cli : Convert color representation of selected images from HSL to RGB.
hsl2rgb :
e[^-1] "Convert color representation of image$? from HSL to RGB."
v - to_color
f "
H = (R/60)%6;
S = cut(G,0,1);
L = cut(B,0,1);
C = (1 - abs(2*L - 1))*S;
X = C*(1 - abs(H%2 - 1));
m = L - C/2;
RGB = arg(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
cut((RGB+=m)*=255,0,255);
"
v +
#@cli hsl82rgb
#@cli : Convert color representation of selected images from HSL8 to RGB.
hsl82rgb :
e[^-1] "Convert color representation of image$? from HSL8 to RGB."
v - _hsx82rgb hsl2rgb v +
#@cli hsv2rgb
#@cli : Convert color representation of selected images from HSV to RGB.
#@cli : $ (0,360;0,360^0,0;1,1^1,1;1,1) resize 400,400,1,3,3 hsv2rgb
hsv2rgb :
e[^-1] "Convert color representation of image$? from HSV to RGB."
v - to_color
f "
H = (R/60)%6;
S = cut(G,0,1);
V = cut(B,0,1);
C = V*S;
X = C*(1 - abs(H%2 - 1));
m = V - C;
RGB = arg(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
cut((RGB+=m)*=255,0,255);
"
v +
#@cli hsv82rgb
#@cli : Convert color representation of selected images from HSV8 to RGB.
hsv82rgb :
e[^-1] "Convert color representation of image$? from HSV8 to RGB."
v - _hsx82rgb hsv2rgb v +
_hsx82rgb :
repeat $!
sh[$>] 0 /. 0.708333 rm.
sh[$>] 1,2 /. 255 rm.
done
#@cli int2rgb
#@cli : Convert color representation of selected images from INT24 to RGB.
int2rgb :
e[^-1] "Convert color representation of image$? from INT24 scalars to RGB."
v - round repeat $! l[$>]
+>> 8 &[1] 255 +&[0] 255 >>[0] 16 a c
endl done v +
#@cli lab2lch
#@cli : Convert color representation of selected images from Lab to Lch.
lab2lch :
e[^-1] "Convert color representation of image$? from Lab to Lch."
v - r 100%,100%,100%,3 repeat $! l[$>]
s c complex2polar[-2,-1] a c
endl done v +
#@cli lab2rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab to RGB.
#@cli : Default value: 'illuminant=1'.
#@cli : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) resize 400,400,1,3,3 lab2rgb
lab2rgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from Lab to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v - lab2xyz $illu xyz2rgb $illu v +
#@cli lab2srgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab to sRGB.
#@cli : Default value: 'illuminant=1'.
#@cli : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) resize 400,400,1,3,3 lab2rgb
lab2srgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from Lab to sRGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v - lab2rgb $illu rgb2srgb v +
#@cli lab82srgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab8 to sRGB.
#@cli : Default value: 'illuminant=1'.
#@cli : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) resize 400,400,1,3,3 lab2rgb
lab82srgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from Lab8 to sRGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v - lab82rgb $illu rgb2srgb v +
#@cli lab2xyz : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab to XYZ.
#@cli : Default value: 'illuminant=1'.
lab2xyz : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from Lab to XYZ, using the D"{arg(1+$illu,50,65)}" illuminant."
v - to_color
f "
begin(
D65 = [ 0.4124564, 0.3575761, 0.1804375,
0.2126729, 0.7151522, 0.0721750,
0.0193339, 0.1191920, 0.9503041 ];
D50 = [ 0.43603516, 0.38511658, 0.14305115,
0.22248840, 0.71690369, 0.06060791,
0.01391602, 0.09706116, 0.71392822 ];
white = ("$illu"?D65:D50)*[ 1,1,1 ];
);
cY = (R + 16)/116;
cZ = cY - B/200;
cX = G/500 + cY;
XYZ = [ 24389*cX>216?cX^3:(116*cX - 16)*27/24389,
27*R>216?cY^3:27*R/24389,
24389*cZ>216?cZ^3:(116*cZ - 16)*27/24389 ];
XYZ*=white;
"
v +
#@cli lab82rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab8 to RGB.
#@cli : Default value: 'illuminant=1'.
lab82rgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from Lab8 to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v - repeat $!
sh[$>] 0 /. 2.55 rm.
sh[$>] 1 /. 1.275 -. 100 rm.
sh[$>] 2 /. 1.15909 -. 110 rm.
done lab2rgb $illu v +
#@cli lch2lab
#@cli : Convert color representation of selected images from Lch to Lab.
lch2lab :
e[^-1] "Convert color representation of image$? from Lch to Lab."
v - r 100%,100%,100%,3 repeat $! l[$>]
s c polar2complex[-2,-1] a c
endl done v +
#@cli lch2rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lch to RGB.
#@cli : Default value: 'illuminant=1'.
lch2rgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from Lch to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v - lch2lab lab2rgb $illu v +
#@cli lch82rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lch8 to RGB.
#@cli : Default value: 'illuminant=1'.
lch82rgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from Lch8 to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v - repeat $!
sh[$>] 0 /. 2.55 rm.
sh[$>] 1 /. 1.88889 rm.
sh[$>] 2 /. 40.5845 -. 3.14159 rm.
done lch2rgb $illu v +
#@cli luminance
#@cli : Compute luminance of selected sRGB images.
#@cli : $ image.jpg +luminance
luminance :
e[^-1] "Compute luminance of image$?."
v - remove_opacity srgb2rgb
repeat $! l[$>]
if {s==3} sh 0 sh[0] 1 sh[0] 2 *[1] 0.22248840 *[2] 0.71690369 *[3] 0.06060791 +[1-3] rm[1]
elif {s!=1} norm n 0,255
fi endl done
channels 0 rgb2srgb v +
#@cli mix_rgb : a11,a12,a13,a21,a22,a23,a31,a32,a33
#@cli : Apply 3x3 specified matrix to RGB colors of selected images.
#@cli : Default values: 'a11=1', 'a12=a13=a21=0', 'a22=1', 'a23=a31=a32=0' and 'a33=1'.
#@cli : $ image.jpg +mix_rgb 0,1,0,1,0,0,0,0,1
#@cli : $$
mix_rgb : skip ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
e[^-1] "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
v - to_color repeat $! sh[$>] 0,2 mix_channels. (${1-3};${4-6};${7-9}) rm. done v +
#@cli pseudogray : _max_increment>=0,_JND_threshold>=0,_bits_depth>0
#@cli : Generate pseudogray colormap with specified increment and perceptual threshold.
#@cli : If 'JND_threshold' is 0, no perceptual constraints are applied.
#@cli : Default values: 'max_increment=5', 'JND_threshold=2.3' and 'bits_depth=8'.
#@cli : $ pseudogray 5
pseudogray : check "isint(${1=5}) && $1>=0 && ${2=2.3}>=0 && isint(${3=8}) && $3>0"
e[^-1] "Generate pseudogray colormap with increment $1, JND threshold $2 and $3 bits depth."
v -
{round(2^$3)},1,1,3,'x'
if {!$1} n. 0,255 v + return fi
{$1+1},{$1+1},{$1+1},1,'x' +f. 'y' +f. 'z' a[-3--1] c r. {w*h*d},1,1,3,-1
f. 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(min(R,G,B),-1,i)'
permute. cxyz discard. -1 r. 3,{h/3},1,1,-1 permute. yzcx
r.. {w*100}% r. ..,0,2 +[-2,-1]
f. 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(max(R,G,B)>2^$3-1,-1,i)'
permute. cxyz discard. -1 r. 3,{h/3},1,1,-1 permute. yzcx
n. 0,255
+srgb2lab. rv[-2,-1] a[-2,-1] y sort. +,x
if {!$2} rows. 1
else
s. y rv[-2,-1] . sh. 1,2 f. 0 rm. -[-2,-1] norm.
<=. $2 *. 'x+1' discard. 0 -. 1 map. .. rm..
repeat 10000
+srgb2lab. +shift. 0,{1-2*($>%2)},0,0,1 -[-2,-1] norm.
<=. $2
if {im} rm. break fi
*. 'y+1' discard. 0 -. 1 map. .. rm..
done
transpose.
fi
v +
#@cli replace_color : tolerance[%]>=0,smoothness[%]>=0,src1,src2,...,dest1,dest2,...
#@cli : Replace pixels from/to specified colors in selected images.
#@cli : $ image.jpg +replace_color 40,3,204,153,110,255,0,0
replace_color : check "$1>=0 && $2>=0"
v - l[] (${3--1}) y c s c,2 col1={0,^} col2={1,^} rm endl v +
e[^-1] "Replace color ("$col1") by color ("$col2") in image$?, with tolerance $1 and smoothness $2."
v - repeat $! l[$>]
1,1,1,100%,$col1 r[1] [0]
if $1 -[1] [0] norm[1] <=[1] $1 else ==[1] [0] l[1] s c & endl fi
b[1] $2
1,1,1,{0,s},$col2 r[2] [0] j[0] [2],0,0,0,0,1,[1] k[0]
endl done v +
#@cli retinex : _value_offset>0,_colorspace={ hsi | hsv | lab | lrgb | rgb | ycbcr },0<=_min_cut<=100,0<=_max_cut<=100,_sigma_low>0,_sigma_mid>0,_sigma_high>0
#@cli : Apply multi-scale retinex algorithm on selected images to improve color consistency.
#@cli : (as described in the page http://www.ipol.im/pub/art/2014/107/).
#@cli : Default values: 'offset=1', 'colorspace=hsv', 'min_cut=1', 'max_cut=1', 'sigma_low=15','sigma_mid=80' and 'sigma_high=250'.
retinex : check "${1=5}>0 && ${3=1}>=0 && $3<=100 && ${4=1}>=0 && $4<=100 && ${5=15}>0 && ${6=80}>0 && ${7=250}>0" skip "${2=hsv}"
e[^-1] "Apply Retinex color consistency algorithm on image$?, with value offset $1, colorspace '$2', cuts ($3,$4) and sigmas (${5-7})."
v -
if {;'$2'=='hsi'} mode=hsi_i
elif {;'$2'=='hsv'} mode=hsv_v
elif {;'$2'=='lab'} mode=lab_l
elif {;'$2'=='rgb'} mode=rgb
elif {;'$2'=='lrgb'} mode=lrgb
elif {;'$2'=='ycbcr'} mode=ycbcr_y
else v + error[0--2] "Command '$0': Invalid colorspace argument '$2'."
fi
ac "_retinex $1,${3--1}",$mode
v +
_retinex :
- {im-$1} {[w,h,d,s]},1
repeat 3 +b[0] {arg(1+$>,${4-6})} +/[0,-1] rm.. *[1,-1] done
rm[0] log c $2%,{100-$3}% n 0,255
#@cli rgb2bayer : _start_pattern=0,_color_grid=0
#@cli : Transform selected color images to RGB-Bayer sampled images.
#@cli : Default values: 'start_pattern=0' and 'color_grid=0'.
#@cli : $ image.jpg +rgb2bayer 0
rgb2bayer : skip ${1=0},${2=0}
e[^-1] "Transform image$? to a RGB-Bayer "${arg\ 1+!$2,color,monochrome}" grid, starting from pattern '$1'."
v - to_rgb repeat $! l[$>]
_rgb2bayer$1 r[1] [0],0,2 * if {!$2} s c + fi
endl done v +
_rgb2bayer0 : (1,0;0,0^0,1;1,0^0,0;0,1)
_rgb2bayer1 : (0,0;0,1^0,1;1,0^1,0;0,0)
_rgb2bayer2 : (0,1;0,0^1,0;0,1^0,0;1,0)
_rgb2bayer3 : (0,0;1,0^1,0;0,1^0,1;0,0)
#@cli rgb2cmy
#@cli : Convert color representation of selected images from RGB to CMY.
#@cli : $ image.jpg rgb2cmy split c
rgb2cmy :
e[^-1] "Convert color representation of image$? from RGB to CMY."
v - to_rgb * -1 + 255 c 0,255 v +
#@cli rgb2cmyk
#@cli : Convert color representation of selected images from RGB to CMYK.
#@cli : $ image.jpg rgb2cmyk split c
#@cli : $ image.jpg rgb2cmyk split c fill[3] 0 append c cmyk2rgb
rgb2cmyk :
e[^-1] "Convert color representation of image$? from RGB to CMYK."
v - rgb2cmy repeat $! l[$>]
s c +min -[0-2] . +/. 255 -. 1 *. -1 +==. 0 +[-2,-1]
/[0-2] . rm. a c
endl done v +
#@cli rgb2hcy
#@cli : Convert color representation of selected images from RGB to HCY.
#@cli : $ image.jpg rgb2hcy split c
rgb2hcy :
e[^-1] "Convert color representation of image$? from RGB to HCY."
v - to_color f "
M = max(R,G,B);
C = M - min(R,G,B);
H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
Y = 0.299*R + 0.587*G + 0.114*B;
[ H,C/255,Y/255 ]"
v +
#@cli rgb2hsi
#@cli : Convert color representation of selected images from RGB to HSI.
#@cli : $ image.jpg rgb2hsi split c
rgb2hsi :
e[^-1] "Convert color representation of image$? from RGB to HSI."
v - to_color
f "
m = min(R,G,B);
M = max(R,G,B);
C = M - m;
sum = R + G + B;
H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
S = sum<=0?0:1 - 3*m/sum;
I = sum/(3*255);
[ cut(H,0,360), cut(S,0,1), cut(I,0,1) ];
"
v +
#@cli rgb2hsi8
#@cli : Convert color representation of selected images from RGB to HSI8.
#@cli : $ image.jpg rgb2hsi8 split c
rgb2hsi8 :
e[^-1] "Convert color representation of image$? from RGB to HSI8."
v - rgb2hsi _rgb2hsx8 v +
#@cli rgb2hsl
#@cli : Convert color representation of selected images from RGB to HSL.
#@cli : $ image.jpg rgb2hsl split c
#@cli : $ image.jpg rgb2hsl +split c add[-3] 100 mod[-3] 360 append[-3--1] c hsl2rgb
rgb2hsl :
e[^-1] "Convert color representation of image$? from RGB to HSL."
v - to_color
f "
m = min(R,G,B);
M = max(R,G,B);
C = M - m;
H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
L = 0.5*(m + M)/255;
S = L>=1 || L<=0?0:C/(1-abs(2*L-1))/255;
[ cut(H,0,360), cut(S,0,1), cut(L,0,1) ];
"
v +
#@cli rgb2hsl8
#@cli : Convert color representation of selected images from RGB to HSL8.
#@cli : $ image.jpg rgb2hsl8 split c
rgb2hsl8 :
e[^-1] "Convert color representation of image$? from RGB to HSL8."
v - rgb2hsl _rgb2hsx8 v +
#@cli rgb2hsv
#@cli : Convert color representation of selected images from RGB to HSV.
#@cli : $ image.jpg rgb2hsv split c
#@cli : $ image.jpg rgb2hsv +split c add[-2] 0.3 cut[-2] 0,1 append[-3--1] c hsv2rgb
rgb2hsv :
e[^-1] "Convert color representation of image$? from RGB to HSV."
v - to_color
f "
M = max(R,G,B);
C = M - min(R,G,B);
H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
S = M<=0?0:C/M;
[ cut(H,0,360), cut(S,0,1), cut(M/255,0,1) ];
"
v +
#@cli rgb2hsv8
#@cli : Convert color representation of selected images from RGB to HSV8.
#@cli : $ image.jpg rgb2hsv8 split c
rgb2hsv8 :
e[^-1] "Convert color representation of image$? from RGB to HSV8."
v - rgb2hsv _rgb2hsx8 v +
_rgb2hsx8 :
repeat $!
sh[$>] 0 *. 0.708333 rm.
sh[$>] 1,2 *. 255 rm.
done
#@cli rgb2lab : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lab.
#@cli : Default value: 'illuminant=1'.
rgb2lab : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from RGB to Lab, using the D"{arg(1+$illu,50,65)}" illuminant."
v - rgb2xyz $illu xyz2lab $illu v +
#@cli rgb2lab8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lab8.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2lab8 split c
rgb2lab8 : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from RGB to Lab8, using the D"{arg(1+$illu,50,65)}" illuminant."
v - rgb2lab $illu repeat $!
sh[$>] 0 *. 2.55 rm.
sh[$>] 1 +. 100 *. 1.275 rm.
sh[$>] 2 +. 110 *. 1.15909 rm.
done v +
#@cli rgb2lch : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lch.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2lch split c
rgb2lch : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from RGB to Lch, using the D"{arg(1+$illu,50,65)}" illuminant."
v - rgb2lab $illu lab2lch v +
#@cli rgb2lch8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lch8.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2lch8 split c
rgb2lch8 : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from RGB to Lch8, using the D"{arg(1+$illu,50,65)}" illuminant."
v - rgb2lch $illu repeat $!
sh[$>] 0 *. 2.55 rm.
sh[$>] 1 *. 1.88889 rm.
sh[$>] 2 +. 3.14159 *. 40.5845 rm.
done v +
#@cli rgb2luv
#@cli : Convert color representation of selected images from RGB to LUV.
#@cli : $ image.jpg rgb2luv split c
rgb2luv :
e[^-1] "Convert color representation of image$? from RGB to LUV."
v - repeat $! l[$>]
+rgb2xyz rgb2lab.. channels.. 0 s. c
*. 3 +*.. 15 +[-2,-1] +. ... +. 1e-8
*... 4 *.. 9 /[-3,-2] . rm.
-.. 0.2009 -. 0.4610
+*... 13 *... . *[-2,-1] a c
endl done v +
#@cli rgb2int
#@cli : Convert color representation of selected images from RGB to INT24 scalars.
#@cli : $ image.jpg rgb2int
rgb2int :
e[^-1] "Convert color representation of image$? from RGB to INT24 scalars."
v - to_rgb round repeat $! l[$>]
s c <<[0] 16 <<[1] 8 +
endl done v +
#@cli rgb2srgb
#@cli : Convert color representation of selected images from linear RGB to sRGB.
rgb2srgb :
e[^-1] "Convert color representation of image$? from linear RGB to sRGB."
v - f "val = i/255; sval = val<=0.0031308?val*12.92:1.055*val^0.416667 - 0.055; cut(255*sval,0,255)" v +
#@cli rgb2xyz : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to XYZ.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2xyz split c
rgb2xyz : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from RGB to XYZ, using the D"{arg(1+$illu,50,65)}" illuminant."
v -
if $illu
mix_rgb {[0.4124564,0.3575761,0.1804375,\
0.2126729,0.7151522,0.0721750,\
0.0193339,0.1191920,0.9503041]/255}
else
mix_rgb {[0.43603516,0.38511658,0.14305115,\
0.22248840,0.71690369,0.06060791,\
0.01391602,0.09706116,0.71392822]/255}
fi
v +
#@cli rgb2xyz8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to XYZ8.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2xyz8 split c
rgb2xyz8 : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from RGB to XYZ8, using the D"{arg(1+$illu,50,65)}" illuminant."
v - rgb2xyz $illu repeat $!
sh[$>] 0 *. 255 rm.
sh[$>] 1 *. 255 rm.
sh[$>] 2 *. 231.8182 rm.
done v +
#@cli rgb2yiq
#@cli : Convert color representation of selected images from RGB to YIQ.
#@cli : $ image.jpg rgb2yiq split c
rgb2yiq :
e[^-1] "Convert color representation of image$? from RGB to YIQ."
v -
mix_rgb 0.299,0.587,0.114,\
0.595716,-0.274453,-0.321263,\
0.211456,-0.522591,0.311135
v +
#@cli rgb2yiq8
#@cli : Convert color representation of selected images from RGB to YIQ8.
#@cli : $ image.jpg rgb2yiq8 split c
rgb2yiq8 :
e[^-1] "Convert color representation of image$? from RGB to YIQ."
v - rgb2yiq
repeat $!
sh[$>] 1 +. 151.908 *. 0.8393238012481239 rm.
sh[$>] 2 +. 133.261 *. 0.9567690472081104 rm.
done v +
#@cli rgb2ycbcr
#@cli : Convert color representation of selected images from RGB to YCbCr.
#@cli : $ image.jpg rgb2ycbcr split c
rgb2ycbcr :
e[^-1] "Convert color representation of image$? from RGB to YCbCr."
v - mix_rgb 66,129,25,-38,-74,112,112,-94,-18
repeat $!
sh[$>] 0,2 +. 128 /. 256 rm.
sh[$>] 0 +. 16 rm.
sh[$>] 1,2 +. 128 rm.
done v +
#@cli rgb2yuv
#@cli : Convert color representation of selected images from RGB to YUV.
#@cli : $ image.jpg rgb2yuv split c
rgb2yuv :
e[^-1] "Convert color representation of image$? from RGB to YUV."
v -
mix_rgb {[0.299,0.587,0.114,\
-0.14713,-0.28886,0.436,\
0.615,-0.51498,-0.10001]/255}
v +
#@cli rgb2yuv8
#@cli : Convert color representation of selected images from RGB to YUV8.
#@cli : $ image.jpg rgb2yuv8 split c
rgb2yuv8 :
e[^-1] "Convert color representation of image$? from RGB to YUV8."
v - rgb2yuv repeat $!
sh[$>] 0 *. 255 rm.
sh[$>] 1 +. 0.44 *. 289.773 rm.
sh[$>] 2 +. 0.62 *. 205.645 rm.
done v +
#@cli remove_opacity
#@cli : Remove opacity channel of selected images.
remove_opacity :
e[^-1] "Remove opacity channel of image$?."
v - repeat $! l[$>]
if {s==2} channels 0
elif {s==4} channels 0,2
fi
nm {n} endl done v +
#@cli select_color : tolerance[%]>=0,col1,...,colN
#@cli : Select pixels with specified color in selected images.
#@cli : $ image.jpg +select_color 40,204,153,110
#@cli : $$
select_color : skip ${1=0}
e[^-1] "Select color (${2--1}) in image$?, with tolerance $1."
v - repeat $! l[$>]
+fc ${2--1} - norm <= $1
endl done v +
#@cli sepia
#@cli : Apply sepia tones effect on selected images.
#@cli : $ image.jpg sepia
sepia :
e[^-1] "Apply sepia tones effect on image$?."
v - (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200) r. 256,1,1,3,3
repeat {$!-1} l[$>,-1] split_opacity luminance[0] map[0] . a[^-1] c endl done
rm. v +
#@cli solarize
#@cli : Solarize selected images.
#@cli : $ image.jpg solarize
solarize :
e[^-1] "Solarize image$?."
v - luminance n 0,128 map 1 v +
#@cli split_colors : _tolerance>=0,_max_nb_outputs>0,_min_area>0
#@cli : Split selected images as several image containing a single color.
#@cli : One selected image can be split as at most 'max_nb_outputs' images.
#@cli : Output images are sorted by decreasing area of extracted color regions and have an additional alpha-channel.
#@cli : Default values: 'tolerance=0', 'max_nb_outputs=256' and 'min_area=8'.
#@cli : $ image.jpg quantize 5 +split_colors , display_rgba
split_colors : check "${1=0}>=0 && isint(${2=256}) && $2>0 && ${3=8}>=1"
e[^-1] "Split image$? as single color outputs, with tolerance $1, $2 maximal outputs and minimal color area $3."
v - repeat $! l[$>]
+label 0,1 norm. area. 0,1
repeat {$2-1}
coordsM={1,[xM,yM,zM,cM]}
if {1,i($coordsM)<$3} break fi
color={0,I($coordsM)}
+select_color[0] $1,$color
==. 0 *[1] . ==. 0
done
if {1,iM} !=[1] 0 mv[1] $!
else rm[1] fi
r[^0] [0],[0],[0],{0,s+1}
N={$!-1}
sh[^0] 0,{s-2} *[-$N--1] [0] rm[-$N--1]
sh[^0] 100% *[-$N--1] 255 rm[0,-$N--1]
endl done v +
#@cli split_opacity
#@cli : Split color and opacity parts of selected images.
split_opacity :
e[^-1] "Split color and opacity parts of image$?."
v - repeat $! l[$<] s c,{if(s==4,-3,if(s==2,-1,-s))} endl done v +
#@cli srgb2lab : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from sRGB to Lab.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg srgb2lab split c
#@cli : $ image.jpg srgb2lab +split c mul[-2,-1] 2.5 append[-3--1] c lab2srgb
srgb2lab : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from sRGB to Lab, using the D"{arg(1+$illu,50,65)}" illuminant."
v - srgb2rgb rgb2lab $illu v +
#@cli srgb2lab8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from sRGB to Lab8.
#@cli : Default value: 'illuminant=1'.
srgb2lab8 : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from sRGB to Lab8, using the D"{arg(1+$illu,50,65)}" illuminant."
v - srgb2rgb rgb2lab8 $illu v +
#@cli srgb2rgb
#@cli : Convert color representation of selected images from sRGB to linear RGB.
srgb2rgb :
e[^-1] "Convert color representation of image$? from sRGB to linear RGB."
v - f "sval = i/255; val = sval<=0.04045?sval/12.92:((sval + 0.055)/(1.055))^2.4; cut(255*val,0,255)" v +
#@cli to_a
#@cli : Force selected images to have an alpha channel.
to_a :
e[^-1] "Force image$? to have an alpha channel."
v - repeat $! l[$>]
if {s==1||s==3} channels 0,{s} sh. {s-1} f. 255 rm. fi
endl done v +
#@cli to_color
#@cli : Force selected images to be in color mode (RGB or RGBA).
to_color :
e[^-1] "Force image$? to be in color mode."
v - repeat $! l[$>]
if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
elif {s==2} r 100%,100%,1,4,0,1,0,0,0,1
elif {s==1} r 100%,100%,1,3,1
fi
endl done v +
#@cli to_colormode : mode={ 0=adaptive | 1=G | 2=GA | 3=RGB | 4=RGBA }
#@cli : Force selected images to be in a given color mode.
#@cli : Default value: 'mode=0'.
to_colormode : skip ${1=0}
if {$1==1} to_gray
elif {$1==2} to_graya
elif {$1==3} to_rgb
elif {$1==4} to_rgba
else
v - is_rgb=0 is_alpha=0
repeat $!
if {$>,!s||s>4} v + error "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
elif {$>,s==2} is_alpha=1
elif {$>,s==3} is_rgb=1
elif {$>,s==4} is_rgb=1 is_alpha=1
fi
done
to_colormode {if($is_rgb,3,1)+$is_alpha}
v +
fi
#@cli to_gray
#@cli : Force selected images to be in GRAY mode.
#@cli : $ image.jpg +to_gray
to_gray :
e[^-1] "Force image$? to be in GRAY mode."
v - repeat $! l[$>]
if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
elif {s>=3} channels 0,2 luminance
elif {s==2} r 100%,100%,100%,1,0
fi
endl done v +
#@cli to_graya
#@cli : Force selected images to be in GRAYA mode.
to_graya :
e[^-1] "Force image$? to be in GRAYA mode."
v - repeat $! l[$>]
if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
elif {s==4} +channels 3 channels.. 0,2 luminance.. a c
elif {s==3} luminance channels 0,1 sh. 1 f. 255 rm.
elif {s==1} channels 0,1 sh. 1 f. 255 rm.
fi
endl done v +
#@cli to_pseudogray : _max_step>=0,_is_perceptual_constraint={ 0 | 1 },_bits_depth>0
#@cli : Convert selected scalar images ([0-255]-valued) to pseudo-gray color images.
#@cli : Default values: 'max_step=5', 'is_perceptual_constraint=1' and 'bits_depth=8'.
#@cli : The original pseudo-gray technique has been introduced by Rich Franzen [http://r0k.us/graphics/pseudoGrey.html].
#@cli : Extension of this technique to arbitrary increments for more tones, has been done by David Tschumperle.
to_pseudogray : check "isint(${1=5}) && $1>=0 && isint(${3=8}) && $3>0" skip ${2=1}
e[^-1] "Convert scalar image$? to pseudo-gray color images, with steps $1."
v - channels 0 srgb2rgb pseudogray $1,{2.3*$2},$3
+srgb2lab. channels. 0 *. {65535/100} round. rows. 0,2
rv[-2,-1] permute. xcyz +. 1 a[-2,-1] y pointcloud. 0
+norm. !=. 0 distance. 1 *. -1 watershed.. . rm. -. 1
repeat {$!-1}
to_rgb[$>] rgb2lab[$>] channels[$>] 0 *[$>] {65535/100} round[$>] c[$>] 0,65535
map[$>] .
done rm. v +
#@cli to_rgb
#@cli : Force selected images to be in RGB mode.
to_rgb :
e[^-1] "Force image$? to be in RGB mode."
v - repeat $! l[$>]
if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
elif {s==4} channels 0,2
elif {s==2} channels 0,0 r 100%,100%,100%,3
elif {s==1} r 100%,100%,100%,3
fi
endl done v +
#@cli to_rgba
#@cli : Force selected images to be in RGBA mode.
to_rgba :
e[^-1] "Force image$? to be in RGBA mode."
v - repeat $! l[$>]
if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
elif {s==3} channels 0,3 sh. 3 f. 255 rm.
elif {s==2} r 100%,100%,100%,4 sh. 2 f. .. rm.
elif {s==1} r 100%,100%,100%,4 sh. 3 f. 255 rm.
fi
endl done v +
#@cli transfer_histogram : [reference_image],_nb_levels>0,_color_channels
#@cli : Transfer histogram of the specified reference image to selected images.
#@cli : Argument 'color channels' is the same as with command 'apply_channels'.
#@cli : Default value: 'nb_levels=256' and 'color_channels=all'.
#@cli : $ image.jpg 100,100,1,3,"u([256,200,100])" +transfer_histogram[0] [1]
transfer_histogram : check ${"is_image_arg $1"}" && ${2=256}>0" skip "${3=0}"
v - mode="$3"
if {isval("$3")} if {isint("$3")}
mode=${arg\ 1+$3,all,rgba,rgb,rgb_r,rgb_g,rgb_b,rgba_a,\
lrgb,lrgb_r,lrgb_g,lrgb_b,\
ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
lab_l,lab_ab,lab_a,lab_b,\
lch_ch,lch_c,lch_h,\
hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
yiq_y,yiq_iq}
fi fi
v + e[^-1] "Transfer histogram of image $1 to image$?, with $2 levels on channels '"$mode"'." v -
if {['$mode']!='all'} repeat $! pass$1
w0,h0,d0,s0={$>,[w,h,d,s]}
w1,h1,d1,s1={-1,[w,h,d,s]}
to_colormode[$>] {s}
a[$>,-1] x
ac_arg="+z "$w0",0,0,100%,"{[$h1,$d1]-1}" r.. "$w0,$h0,$d0",100%,0,0 _transfer_histogram $2 rm."
apply_channels[$>] {``$ac_arg},$mode,0
r[$>] $w0,$h0,$d0,$s0,0
done
else repeat $! pass$1 _transfer_histogram[$>,-1] $2 done rm.
fi v +
_transfer_histogram :
repeat {min(s#0,s#1)}
sh $> im,iM={[min(im#0,im#1),max(iM#0,iM#1)]}
equalize.. $1
+histogram_cumul. $1,1,$im,$iM *. {$iM-$im} +. $im rm..
index.. .,0,0 *.. {($iM-$im)/$1} +.. $im
rm[-2,-1]
done
#@cli transfer_rgb : [target],_gamma>=0,_regularization>=0,_luminosity_constraints>=0,_rgb_resolution>=0,_is_constraints={ 0 | 1 }
#@cli : Transfer colors from selected source images to selected reference image (given as argument).
#@cli : 'gamma' determines the importance of color occurrences in the matching process (0=none to 1=huge).
#@cli : 'regularization' determines the number of guided filter iterations to remove quantization effects.
#@cli : 'luminosity_constraints' tells if luminosity constraints must be applied on non-confident matched colors.
#@cli : 'is_constraints' tells if additional hard color constraints must be set (opens an interactive window).
#@cli : Default values: 'gamma=0.3','regularization=8', 'luminosity_constraints=0.1', 'rgb_resolution=64' and 'is_constraints=0'.
#@cli : $ sample pencils,wall +transfer_rgb[0] [1],0,0.01
transfer_rgb : check "${2=0.3}>=0 && ${3=8}>=0 && ${4=0.15}>=0 && ${5=64}>=0 && isint(${6=0})"
e[^-1] "Transfer colors of image $1 to image$?."
v - sigma=1.5
repeat $! pass$1 0 l[$>,-1]
nm_source={0,b} nm_target={1,b}
nm[0] source nm[1] target
+_transfer_rgb[source,target] $2,$sigma,$5
nm.. fsource nm. ftarget
n[fsource,ftarget] 0,255
if $6
h0={2*{*,v}/3} ws0={source,max(1,w*$h0/h)} wt0={target,max(1,w*$h0/h)}
w1={2*{*,u}/3} hs1={source,max(1,h*$w1/w)} ht1={target,max(1,h*$w1/w)}
if {abs($ws0+$wt0-$w1)<abs($hs1+$ht1-$h0)}
+r2dy[source,target] $h0 +b[-2,-1] 0.5% a[-4,-3] x a[-2,-1] x
else
+r2dx[source,target] $w1 +b[-2,-1] 0.5% a[-4,-3] y a[-2,-1] y
fi
if {w>$w1} r2dx[-2,-1] $w1 fi
if {h>$h0} r2dy[-2,-1] $h0 fi
nm.. visu nm. both
w[visu] -1,-1
N=0 do
w[] -1,-1,"[G'MIC] Add Color Guide (Constraint ""#"{1+$N}")"
+select[$visu] 1 if {i==-1} rm. break fi
line[$visu] {i[0]},{i[1]},{i[3]},{i[4]},1,0xF0F0F0F0,0
line[$visu] {i[0]},{i[1]},{i[3]},{i[4]},1,0x0F0F0F0F,255
circle[$visu] {i[0]},{i[1]},5,1,0,0,0 circle[$visu] {i[0]},{i[1]},3,1,255,0,0
circle[$visu] {i[3]},{i[4]},5,1,0,0,0 circle[$visu] {i[3]},{i[4]},3,1,0,255,0
s. y,2 rows[-2,-1] 0,1 a[-2,-1] x permute. xczy
+warp[$both] .,0,0 rm..
*. {($5-1)/255} s. x,2
-. .. *. -1 a[-2,-1] c
N+=1
while {*}
if $N a[-$N--1] x permute. xczy nm. constraints fi
rm[$visu,$both] w 0
fi
if $constraints
+pointcloud. 0 r. ...,...,...,3,0 +compose_channels. + a[-2,-1] c
displacement[fsource] [ftarget],0.001,5,0,10000,1,. rm[ftarget,constraints,-1]
else
displacement[fsource] [ftarget],0.005 rm[ftarget]
fi
nm[fsource] displacement
+_transfer_rgb[target] 0,$sigma,{displacement,w}
warp. [displacement],1,1,1 c. 0,100% nm. fconfidence
+map_clut[source] . nm. confidence
[displacement],[displacement],[displacement],1,x +f. y +f. z a[-3--1] c *. {255/(w-1)} +. 1
+_transfer_rgb[target] 0,0,{w} *.. .
warp[-2,-1] [displacement],1,0,1
distance. 1 *. -1 watershed.. . rm. -. 1
nm. clut
b[clut] $sigma%
if {$4>0}
^[fconfidence] {$4/10} *[fconfidence] -1 +[fconfidence] 1
+f[fconfidence] x +f. y +f. z a[-3--1] c *. {255/(w-1)}
rgb2hsv[clut,-1] channels. 100%
j[clut] .,0,0,0,2,1,[fconfidence] rm.
hsv2rgb[clut]
fi
+map_clut[source] [clut] nm. res_noregul
if {!$3}
nm[res_noregul] res
else
l[source,res_noregul]
rgb2ycbcr
+-[1] [0] repeat $3 guided. [0],5,5 done +. [0] c. 0,255
ycbcr2rgb
endl
nm. res
j[res] [res_noregul],0,0,0,0,1,[confidence]
rm[res_noregul]
fi
k[res]
endl done v +
_transfer_rgb : v - l[] check "${1=0}>=0 && ${2=1.5}>=0 && ${3=128}>0" gamma=$1 smoothness=$2 res=$3 onfail noarg gamma=0 smoothness=1.5 res=128 endl v +
e[^-1] "Convert image$? as 3D volumetric scalar functions for color matching, with gamma "$gamma", smoothness "$smoothness" and resolution "$res"."
v - to_rgb repeat $! l[$>]
b 0.3%
r {w*h},3,1,1,-1 * {($res-1)/255}
pointcloud 1,$res,$res,$res f 'if(i,i^$gamma,0)' b $smoothness% n 0,1
endl done v +
#@cli xyz2lab : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from XYZ to Lab.
#@cli : Default value: 'illuminant=1'.
xyz2lab : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from XYZ to Lab, using the D"{arg(1+$illu,50,65)}" illuminant."
v - to_color
f "
begin(
lab(x) = (24389*x>216?cbrt(x):(24389*x/27 + 16)/116);
D65 = [ 0.4124564, 0.3575761, 0.1804375,
0.2126729, 0.7151522, 0.0721750,
0.0193339, 0.1191920, 0.9503041 ];
D50 = [ 0.43603516, 0.38511658, 0.14305115,
0.22248840, 0.71690369, 0.06060791,
0.01391602, 0.09706116, 0.71392822 ];
white = ("$illu"?D65:D50)*[ 1,1,1 ];
);
fX = lab(R/white[0]);
fY = lab(G/white[1]);
fZ = lab(B/white[2]);
[ cut(116*fY - 16,0,100), 500*(fX - fY), 200*(fY - fZ) ];
"
v +
#@cli xyz2rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from XYZ to RGB.
#@cli : Default value: 'illuminant=1'.
xyz2rgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from XYZ to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v -
if $illu
mix_rgb {[3.2404542,-1.5371385,-0.4985314,\
-0.9692660,1.8760108,0.0415560,\
0.0556434,-0.2040259,1.0572252]*255}
else
mix_rgb {[3.134274799724,-1.617275708956,-0.490724283042,\
-0.978795575994,1.916161689117,0.033453331711,\
0.071976988401,-0.228984974402,1.405718224383]*255}
fi
c 0,255 v +
#@cli xyz82rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from XYZ8 to RGB.
#@cli : Default value: 'illuminant=1'.
xyz82rgb : skip "${1=,}"
v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
e[^-1] "Convert color representation of image$? from XYZ8 to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
v - repeat $!
sh[$>] 0 /. 255 rm.
sh[$>] 1 /. 255 rm.
sh[$>] 2 /. 231.8182 rm.
done xyz2rgb $illu v +
#@cli ycbcr2rgb
#@cli : Convert color representation of selected images from YCbCr to RGB.
ycbcr2rgb :
e[^-1] "Convert color representation of image$? from YCbCr to RGB."
v - repeat $!
sh[$>] 0 -. 16 rm.
sh[$>] 1,2 -. 128 rm.
sh[$>] 0,2 mix_rgb. 298,0,409,\
298,-100,-208,\
298,516,0
+. 128 /. 256 c. 0,255 rm.
done v +
#@cli yiq2rgb
#@cli : Convert color representation of selected images from YIQ to RGB.
yiq2rgb :
e[^-1] "Convert color representation of image$? from YIQ to RGB."
v -
mix_rgb 1,0.9563,0.6210,\
1,-0.2721,-0.6474,\
1,-1.1070,1.7046
c 0,255 v +
#@cli yiq82rgb
#@cli : Convert color representation of selected images from YIQ8 to RGB.
yiq82rgb :
e[^-1] "Convert color representation of image$? from YIQ8 to RGB."
v - repeat $!
sh[$>] 1 /. 0.8393238012481239 -. 151.908 rm.
sh[$>] 2 /. 0.9567690472081104 -. 133.261 rm.
done
mix_rgb 1,0.9563,0.6210,\
1,-0.2721,-0.6474,\
1,-1.1070,1.7046
c 0,255 v +
#@cli yuv2rgb
#@cli : Convert color representation of selected images from YUV to RGB.
yuv2rgb :
e[^-1] "Convert color representation of image$? from YUV to RGB."
v -
mix_rgb {[1,0,1.13983,\
1,-0.39465,-0.5806,\
1,2.03211,0]*255}
c 0,255 v +
#@cli yuv82rgb
#@cli : Convert selected images from YUV8 to RGB color bases.
yuv82rgb :
e[^-1] "Convert color representation of image$? from YUV8 to RGB."
v - repeat $!
sh[$>] 0 /. 255 rm.
sh[$>] 1 /. 289.773 -. 0.44 rm.
sh[$>] 2 /. 205.645 -. 0.62 rm.
done yuv2rgb v +
#@cli :: Geometry Manipulation
#@cli a : eq. to 'append' : (+)
#@cli append : [image],axis,_centering : axis,_centering : (+)
#@cli : Append specified image to selected images, or all selected images together, along specified axis.
#@cli : (eq. to 'a').\n
#@cli : 'axis' can be { x | y | z | c }.
#@cli : Usual 'centering' values are { 0=left-justified | 0.5=centered | 1=right-justified }.
#@cli : Default value: 'centering=0'.
#@cli : $ image.jpg split y,10 reverse append y
#@cli : $ image.jpg repeat 5 +rows[0] 0,{10+18*$>}% done remove[0] append x,0.5
#@cli : $ image.jpg append[0] [0],y
#@cli append_tiles : _M>=0,_N>=0,0<=_centering_x<=1,0<=_centering_y<=1
#@cli : Append MxN selected tiles as new images.
#@cli : If 'N' is set to 0, number of rows is estimated automatically.
#@cli : If 'M' is set to 0, number of columns is estimated automatically.
#@cli : If 'M' and 'N' are both set to '0', auto-mode is used.
#@cli : If 'M' or 'N' is set to 0, only a single image is produced.
#@cli : 'centering_x' and 'centering_y' tells about the centering of tiles when they have different sizes.
#@cli : Default values: 'M=0', 'N=0', 'centering_x=centering_y=0.5'.
#@cli : $ image.jpg split xy,4 append_tiles ,
append_tiles : check "isint(${1=0}) && isint(${2=0}) && ${3=0.5}>=0 && $3<=1 && ${4=$3}>=0 && $4<=1"
if {!$!} e[0--3] "Append image$? as a 0x0-tiled image." return fi
if {!$1&&!$2}
v - N={int(sqrt($!))} M={round($!/$N,1,1)}
v + e[0--3] "Append image$? as a "${M}x${N}"-tiled image (auto-mode)." v -
MN={$M*$N} if {$!%$MN} {$MN-($!%$MN)} s. x fi
elif {!$2}
v - M=$1 N={round($!/$1,1,1)}
v + e[0--3] "Append image$? as a "${M}x${N}"-tiled image." v -
if {$M>$!} v + warn[0--3] "Missing images for having one row in a "${M}x${N}"-tiled image." return fi
if {$!%$M} {$M-($!%$M)} s. x fi
elif {!$1}
v - M={round($!/$2,1,1)} N=$2
v + e[0--3] "Append image$? as a "${M}x${N}"-tiled image." v -
if {$N>$!} v + warn[0--3] "Missing images for having one column in a "${M}x${N}"-tiled image." return fi
if {$!%$M} {$M-($!%$M)} s. x fi
else
e[0--3] "Append image$?, as $1x$2-tiled images." v -
M=$1 N=$2
fi
MN={$M*$N}
repeat {int($!/$MN)} l[$>-{$>+$MN-1}]
$MN,1,1,2 repeat $MN point. $>,0,0,1,{$>,w},{$>,h} done r. $M,$N,1,2,-1
s. c l.. s y max endl l. s x max endl
i=0 repeat $N,y repeat $M r[$i] {-2,@$>},{@$y},100%,100%,0,0,$3,$4 i+=1 done done
rm[-2,-1]
repeat {int($!/$M)} a[$>-{$>+$M-1}] x done
repeat {int($!/$N)} a[$>-{$>+$N-1}] y done
endl done
v +
#@cli apply_scales : "command",number_of_scales>0,_min_scale[%]>=0,_max_scale[%]>=0,_scale_gamma>0,_interpolation
#@cli : Apply specified command on different scales of selected images.
#@cli : 'interpolation' can be { 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : Default value: 'min_scale=25%', 'max_scale=100%' and 'interpolation=3'.
#@cli : $ image.jpg apply_scales "blur 5 sharpen 1000",4
apply_scales : skip "${1=}" check "isint($2) && $2>0 && ${3=25%}>=0 && ${4=100%}>=0 && ${5=1}>0 && isint(${6=3}) && $6>=0"
v - s0="no" s1="nearest-neighbor" s2="average" s3="linear" s4="grid" s5="bicubic" s6="lanczos" v +
e[^-1] "Apply command '$1' on image$? for $2 scales ($3 -> $4) and "${s{min(6,$6)}}" interpolation."
v - repeat $! l[$<] nm={0,n}
scale0={if(${"is_percent $3"},$3*max(w,h,d),$3)}
scale1={if(${"is_percent $4"},$4*max(w,h,d),$4)}
repeat $2
scale={$scale0+($scale1-$scale0)*($>/max(1,$2-1))^$5}
w={0,w==1?1:max(1,round($scale*w/max(w,h,d)))}
h={0,h==1?1:max(1,round($scale*h/max(w,h,d)))}
d={0,d==1?1:max(1,round($scale*d/max(w,h,d)))}
+r[0] $w,$h,$d,100%,$6
if {narg("$1")} l. $1 endl fi
done
rm[0] nm $nm
endl done v +
#@cli autocrop : value1,value2,... : (no arg) : (+)
#@cli : Autocrop selected images by specified vector-valued intensity.
#@cli : If no arguments are provided, cropping value is guessed.
#@cli : $ 400,400,1,3 fill_color 64,128,255 ellipse 50%,50%,120,120,0,1,255 +autocrop
#@cli autocrop_components : _threshold[%],_min_area[%]>=0,_is_high_connectivity={ 0 | 1 },_output_type={ 0=crop | 1=segmentation | 2=coordinates }
#@cli : Autocrop and extract connected components in selected images, according to a mask given as the last channel of
#@cli : each of the selected image (e.g. alpha-channel).
#@cli : Default values: 'threshold=0%', 'min_area=0.1%', 'is_high_connectivity=0' and 'output_type=1'.
#@cli : $ 256,256 noise 0.1,2 eq 1 dilate_circ 20 label_fg 0,1 normalize 0,255 +neq 0 *[-1] 255 append c +autocrop_components ,
autocrop_components : skip ${1=0%} check "${2=0.1%}>=0 && isbool(${3=0}) && isint(${4=1}) && $4>=0 && $4<=2"
e[^-1] "Autocrop connected components from image$?, with threshold $1, minimal area $2, "${arg\ 1+$3,low,high}" connectivity "\
"and output type set to '"${arg\ 1+$4,crop,segmentation,coordinates}"'.\n"
v - repeat $! l[$>]
min_area={max(1,round(if(${is_percent\ $2},$2*w*h,$2)))}
+channels 100% >. $1 area_fg. 0,$3 >=. $min_area
+area. 0,1 <. $min_area -|[-2,-1] label_fg. 0,1
N={iM} repeat {iM}
n={1+$>}
v + e[] "\r  > "$n/$N v -
rprogress {100*$n/$N}
+==[1] $n +*[0,-1] rm..
if {$4==0} coords=${autocrop_coords.\ auto} rm. +z[0] $coords
elif {$4==1} autocrop.
else coords=${autocrop_coords.\ auto} rm. ($coords) y.
fi
done
rm[0,1]
if {!$!} 0 fi
if {$4==2} a x fi
endl done v +
#@cli autocrop_seq : value1,value2,... | auto
#@cli : Autocrop selected images using the crop geometry of the last one by specified vector-valued intensity,
#@cli : or by automatic guessing the cropping value.
#@cli : Default value: auto mode.
#@cli : $ image.jpg +fill[-1] 0 ellipse[-1] 50%,50%,30%,20%,0,1,1 autocrop_seq 0
autocrop_seq : skip ${1=auto}
e[^-1] "Auto-crop image$? using crop geometry of last image by vector '$*'."
if {!$!} return fi
v -
if {$!==1} _autocrop$is_auto ${1--1} v + return fi
coords=${autocrop_coords.\ ${1--1}}
x0={arg(1,$coords)} y0={arg(2,$coords)} z0={arg(3,$coords)}
x1={arg(4,$coords)} y1={arg(5,$coords)} z1={arg(6,$coords)}
if {$x0>$x1" || "$y0>$y1" || "$z0>$z1} i[0--2] 0 rm[1--1:2]
else z $x0,$y0,$z0,$x1,$y1,$z1
fi
v +
#@cli channels : { [image0] | c0[%] },_{ [image1] | c1[%] } : (+)
#@cli : Keep only specified channels of selected images.
#@cli : Dirichlet boundary is used when specified channels are out of range.
#@cli : $ image.jpg channels 0,1
#@cli : $ image.jpg luminance channels 0,2
#@cli columns : { [image0] | x0[%] },_{ [image1] | x1[%] } : (+)
#@cli : Keep only specified columns of selected images.
#@cli : Dirichlet boundary is used when specified columns are out of range.
#@cli : $ image.jpg columns -25%,50%
#@cli z : eq. to 'crop'. : (+)
#@cli crop : x0[%],x1[%],_boundary_conditions : x0[%],y0[%],x1[%],y1[%],_boundary_conditions : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%],_boundary_conditions : x0[%],y0[%],z0[%],c0[%],x1[%],y1[%],z1[%],c1[%],_boundary_conditions : (no arg) : (+)
#@cli : Crop selected images with specified region coordinates.
#@cli : (eq. to 'z').\n
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : In interactive mode, the chosen crop coordinates are returned in the status.
#@cli : Default value: 'boundary_conditions=0'.
#@cli : $ image.jpg +crop -230,-230,280,280,1 crop[0] -230,-230,280,280,0
#@cli : $ image.jpg crop 25%,25%,75%,75%
#@cli diagonal
#@cli : Transform selected vectors as diagonal matrices.
#@cli : $ 1,10,1,1,'y' +diagonal
diagonal :
e[^-1] "Transform vector$? as diagonal matrix."
v - y repeat $! r[$>] {$>,h+1},100%,1,1,0 r[$>] {$>,h},100%,1,1,-1 done v +
downsize_aliased : check "${1=50}>=0 && $1<=100"
if {$1==100} return elif {!$1} r 1,1,1,100%,2 return fi
N={ceil(1+100/$1)}
repeat $! l[$>]
split_opacity
if {$!==1} continue fi
+dilate.. $N +==.. 0
j[0] ..,0,0,0,0,1,. rm[-2,-1]
a c
r $1%,$1%,$1%,100%,2
endl done
#@cli elevate : _depth,_is_plain={ 0 | 1 },_is_colored={ 0 | 1 }
#@cli : Elevate selected 2D images into 3D volumes.
#@cli : Default values: 'depth=64', 'is_plain=1' and 'is_colored=1'.
elevate : check "${1=64}>0" skip ${2=1},${3=1}
e[^-1] "Elevate 2D image$? into $1-slices volume(s)."
v - r 100%,100%,1,100%
repeat $! l[$>] nm={0,n}
+norm 100%,100%,$1,{if($3,{0,s},1)}
m={-2,im} d={-2,iM-$m}
repeat $1
if $2 +>=[1] {$m+$d*($>+1)/$1}
else +ir[1] {$m+$d*$>/$1},{$m+$d*($>+1)/$1}
fi
r. 100%,100%,1,.. if $3 *. [0] fi
j.. .,0,0,$> rm.
done
rm[0,1] nm $nm endl done v +
#@cli expand_x : size_x>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the x-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg expand_x 30,0
expand_x : check "$1>=0 && ${2=1}>=0 && $2<=3"
e[^-1] "Expand image$? along the x-axis with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! r[$>] {$>,w+2*$1},100%,100%,100%,0,$2,0.5,0.5,0.5 done v +
#@cli expand_xy : size>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the xy-axes.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg expand_xy 30,0
expand_xy : check "$1>=0 && ${2=1}>=0 && $2<=3"
e[^-1] "Expand image$? along the xy-axes with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! r[$>] {$>,w+2*$1},{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 done v +
#@cli expand_xyz : size>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the xyz-axes.
#@cli : Default value: 'boundary_conditions=1'.
expand_xyz : check "$1>=0 && ${2=1}>=0 && $2<=3"
e[^-1] "Expand image$? along the xyz-axes with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! r[$>] {$>,w+2*$1},{$>,h+2*$1},{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 done v +
#@cli expand_y : size_y>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the y-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg expand_y 30,0
expand_y : check "$1>=0 && ${2=1}>=0 && $2<=3"
e[^-1] "Expand image$? along the y-axis with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! r[$>] 100%,{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 done v +
#@cli expand_z : size_z>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the z-axis.
#@cli : Default value: 'boundary_conditions=1'.
expand_z : check "$1>=0 && ${2=1}>=0 && $2<=3"
e[^-1] "Expand image$? along the z-axis with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! r[$>] 100%,100%,{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 done v +
#@cli extract_region : [label_image],_extract_xyz_coordinates={ 0 | 1 },_label_1,...,_label_M
#@cli : Extract all pixels of selected images whose corresponding label in '[label_image]' is equal to 'label_m',
#@cli : and output them as M column images.
#@cli : Default value: 'extract_xyz_coordinates=0'.
#@cli : $ image.jpg +blur 3 quantize. 4,0 +extract_region[0] [1],0,1,3
extract_region : check ${"is_image_arg $1"}" && isval(${2=0})"
if {$#<3} e[0--3] "Extract pixels of image$? for labels [] in image $1, with"${"arg 1+!!$2,out"}" coordinates -> no labels provided, ignoring." return fi
e[^-1] "Extract pixels of image$? for labels {${3--1}} in image $1, with"${"arg 1+!!$2,out"}" coordinates."
v - pass$1 mv. 0 repeat {$!-1} l[0,{1+$<}]
1,16,1,{s+($2?3:0)} if {$#>3} .x{$#-3} fi
f[0] ">"${-math_lib}"
begin(
const N = iM + 1;
R = [ ${3--1} ];
hash = vectorN(0);
for (k = 0, k<size(R), ++k, hash[R[k]] = k + 2);
);
(ind = hash[i])>0?(
$2?dar_insert(#ind,[ I(#1),x,y,z ]):dar_insert(#ind,I(#1));
); i;
end(for (k = 2, k<l, ++k, resize(#k,1,dar_size(#k),1,-100,0)))"
rm[1]
endl done rm[0] v +
#@cli montage : "_layout_code",_montage_mode={ 0<=centering<=1 | 2<=scale+2<=3 },_output_mode={ 0=single layer | 1=multiple layers },"_processing_command"
#@cli : Create a single image montage from selected images, according to specified layout code :
#@cli : - 'X' to assemble all images using an automatically estimated layout.
#@cli : - 'H' to assemble all images horizontally.
#@cli : - 'V' to assemble all images vertically.
#@cli : - 'A' to assemble all images as an horizontal array.
#@cli : - 'B' to assemble all images as a vertical array.
#@cli : - 'Ha:b' to assemble two blocks 'a' and 'b' horizontally.
#@cli : - 'Va:b' to assemble two blocks 'a' and 'b' vertically.
#@cli : - 'Ra' to rotate a block 'a' by 90 deg. ('RRa' for 180 deg. and 'RRRa' for 270 deg.).
#@cli : - 'Ma' to mirror a block 'a' along the X-axis ('MRRa' for the Y-axis).
#@cli : A block 'a' can be an image index (treated periodically) or a nested layout expression 'Hb:c','Vb:c','Rb' or 'Mb' itself.
#@cli : For example, layout code 'H0:V1:2' creates an image where image [0] is on the left, and images [1] and [2] vertically packed on the right.
#@cli : Default values: 'layout_code=X', 'montage_mode=2', output_mode='0' and 'processing_command=""'.
#@cli : $ image.jpg sample ? +plasma[0] shape_cupid 256 normalize 0,255 frame 3,3,0 frame 10,10,255 to_rgb +montage A +montage[^-1] H1:V0:VH2:1H0:3
montage : check "isval(${2=2}) && $2>=0 && $2<=3" skip "${1=X}",${3=0},"${4=}"
if {$2<=1} e[0--3] "Create aligned montage from image$?, with layout code '$1' and centering $2."
else e[0--3] "Create scaled montage from image$?, with layout code '$1' and scale "{$2-2}"."
fi
v - to_colormode 0
if {lowercase('"$1"')=='x'} +l
repeat $! nm[$>] $> done
repeat {$!-1}
if {{-2,w>h}" && "w>h} mode=V
elif {{-2,h>w}" && "h>w} mode=H
elif {{-2,w>h}" && "h>w}
if {{-2,h/w}<(w/h)} mode=V else mode=H fi
else
if {{-2,w/h}<(h/w)} mode=H else mode=V fi
fi
name=$mode{-2,n}:{n}
montage[-2,-1] $mode,$2
mv. 0 nm[0] $name
done
layout={0,n}
rm endl montage $layout,$2,$3,"$4"
else
N=$!
l[] _scode="$1" _mode=$2
if {lowercase('"$1"')=='h'} if {$N>1} {$N-1},1,1,1,-1 $N,1,1,1,x a x y else v + return fi
elif {lowercase('"$1"')=='v'} if {$N>1} {$N-1},1,1,1,-2 $N,1,1,1,x a x y else v + return fi
elif {s=lowercase('"$1"');s=='a'||s=='b'}
if {$N<2} v + return fi
nr={round(sqrt($N))} nc={round($N/$nr,1,1)}
if {lowercase('"$1"')=='b'} n=$nr nr=$nc nc=$n fi
$N,1,1,1,x s x,-{round(w/$nr,1,1)} repeat $! l[$>] if {w>1} i[0] {w-1},1,1,1,-1 a x fi endl done a x
if {$nr>1} i[0] {$nr-1},1,1,1,-2 a x fi y
else
({'"$1"'}) f 'if(i==72||i==104,-1,if(i==86||i==118,-2,if(i==82||i==114,-3,if(i==77||i==109,-4,if(i>=48&&i<=57,i-48,-5)))))'
s +,-1 s +,-2 s +,-3 s +,-4 s +,-5
repeat $! l[$>] if {im>=0} ++. 48 =.. {t} rm. rows 0 fi endl done a y discard -5
fi
f 'if(i<0,i,i%$N)'
endl
if {$!==$N} rm v + return fi
nm[^-1] 0 repeat {h} c={i[$>]} if {$c>=0} if {$c,n} i.. [$c] i={$!-2} =. $i,0,$> ref$i=$c else nm[$c] 1 ref$c=$c fi fi done
_code={^} _lcode={narg($_code)} rm.
N=$! repeat $N ($>,0,0,{$>,w},{$>,h},0,0,0) done
l[$N--1] _p=1 k[${-_montage}] w={i[3]} h={i[4]} f 'if(i(0,y)<0,-1,i)' discard -1 r 8,{h/8},1,1,-1
onfail error[0--3] "Too many input images."
endl
if {narg("$4")} m "__montage : $4 k[0]"
else
m "__montage : if {$""7%2} mirror x fi if {$""8%2} mirror y fi rotate {90*$""6} r {max(1,round($""4,1,1))},{max(1,round($""5,1,1))},1,100%,3"
fi
s=${max_s[^-1]}
repeat {h}
i={i(0,$>)} xi={i(1,$>)} yi={i(2,$>)} wi={i(3,$>)} hi={i(4,$>)} ai={i(5,$>)} mxi={i(6,$>)} myi={i(7,$>)}
if {$3||!$>} i.. $w,$h,1,$s fi
__montage[$i] ${ref$i},$xi,$yi,{max(1,$wi)},{max(1,$hi)},$ai,$mxi,$myi
j.. [$i],$xi,$yi
done
uncommand __montage
rm[0-{$N-1},-1]
fi
nm "[Montage '$1']"
v +
_montage :
if {$_p>$_lcode} v + error "Command 'montage': Incomplete layout code '"$_scode"'." fi
c={arg($_p,$_code)}
if {$c>=0} _p+=1 u $c
elif {$c==-4}
_p+=1 l=${-_montage} f[$l] 'a=i(5,y)%2;if((x==7&&a)||(x==6&&!a),!i,if(x==1,i(3,0)-i(3,y)-i,i))' u $l
elif {$c==-3}
_p+=1 l=${-_montage} l[$l] s x +[2] [4] rv[1,2] *[1] -1 +[1] {4,@0} rv[3,4] +[5] 1 a x endl u $l
else
_p+=1
l=${-_montage} lw={$l,@3} lh={$l,@4}
r=${-_montage} rw={$r,@3} rh={$r,@4}
if {$c==-1}
if {$_mode<2}
h={max($lh,$rh)} +[$l] '0,0,{($h-$lh)*min(1,$_mode)},0,0,0,0,0' +[$r] '0,$lw,{($h-$rh)*min(1,$_mode)},0,0,0,0,0'
else
h={($_mode-2)*max($lh,$rh)+(3-$_mode)*min($lh,$rh)}
lf={$h/$lh} rf={$h/$rh} lw={$lw*$lf} rw={$rw*$rf}
*[$l] '1,$lf,$lf,$lf,$lf,1,1,1' *[$r] '1,$rf,$rf,$rf,$rf,1,1,1' +[$r] '0,$lw,0,0,0,0,0,0'
fi
i[$l] (-1,0,0,{$lw+$rw},$h,0,0,0) a[$l,{$l+1}] y a[$l] [$r],y r[$r] 1,1,1,1,0
else
if {$_mode<2}
w={max($lw,$rw)} +[$l] '0,{($w-$lw)*min(1,$_mode)},0,0,0,0,0,0' +[$r] '0,{($w-$rw)*min(1,$_mode)},$lh,0,0,0,0,0'
else
w={($_mode-2)*max($lw,$rw)+(3-$_mode)*min($lw,$rw)}
lf={$w/$lw} rf={$w/$rw} lh={$lh*$lf} rh={$rh*$rf}
*[$l] '1,$lf,$lf,$lf,$lf,1,1,1' *[$r] '1,$rf,$rf,$rf,$rf,1,1,1' +[$r] '0,0,$lh,0,0,0,0,0'
fi
i[$l] (-1,0,0,$w,{$lh+$rh},0,0,0) a[$l,{$l+1}] y a[$l] [$r],y r[$r] 1,1,1,1,0
fi
u $l
fi
#@cli mirror : { x | y | z }...{ x | y | z } : (+)
#@cli : Mirror selected images along specified axes.
#@cli : $ image.jpg +mirror y +mirror[0] c
#@cli : $ image.jpg +mirror x +mirror y append_tiles 2,2
#@cli permute : permutation_string : (+)
#@cli : Permute selected image axes by specified permutation.
#@cli : 'permutation' is a combination of the character set {x|y|z|c},
#@cli : e.g. 'xycz', 'cxyz', ...
#@cli : $ image.jpg permute yxzc
#@cli r : eq. to 'resize'. : (+)
#@cli resize : [image],_interpolation,_boundary_conditions,_ax,_ay,_az,_ac : {[image_w] | width>0[%]},_{[image_h] | height>0[%]},_{[image_d] | depth>0[%]},_{[image_s] | spectrum>0[%]},_interpolation,_boundary_conditions,_ax,_ay,_az,_ac : (no arg) : (+)
#@cli : Resize selected images with specified geometry.
#@cli : (eq. to 'r').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0 or 4'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : Default values: 'interpolation=1', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg (0,1;0,1^0,0;1,1^1,1;1,1) resize[-1] [-2],3 mul[-2] [-1]
#@cli : $ image.jpg +resize[-1] 256,128,1,3,2 +resize[-1] 120%,120%,1,3,0,1,0.5,0.5 +resize[-1] 120%,120%,1,3,0,0,0.2,0.2 +resize[-1] [0],[0],1,3,4
#@cli resize_mn : width[%]>=0,_height[%]>=0,_depth[%]>=0,_B_value,_C_value
#@cli : Resize selected images with Mitchell-Netravali filter (cubic).
#@cli : For details about the method, see: https://de.wikipedia.org/wiki/Mitchell-Netravali-Filter
#@cli : Default values: 'height=100%', 'depth=100%', 'B=0.3333' and 'C=0.3333'.
#@cli : $ image.jpg resize2dx 32 resize_mn 800%,800%
resize_mn : check "${2=100%}>=0 && ${3=100%}>=0" skip "${4=0.333},${5=0.333}"
e[^-1] "Resize image$? to $1x$2x$3 using Mitchell-Netravali filter (B=$4, C=$5)."
v -
lib="const B = $4; const C = $5; const boundary = 1; const interp = 0;
mn(P0,P1,P2,P3,d) = ( ( (-B/6-C)*P0 + (-3*B/2-C+2)*P1 + (3*B/2+C-2)*P2 + (B/6+C)*P3 )*d^3
+ ( (B/2+2*C)*P0 + (2*B+C-3)*P1 + (-5*B/2-2*C+3)*P2 -C*P3)*d^2
+ ( (-B/2-C)*P0 + (B/2+C)*P2)*d
+ B/6*P0 + (-B/3+1)*P1 + B/6*P2);"
repeat $! l[$>] nm={n}
nw={${"is_percent $1"}?max(1,round($1*w)):round($1)}
nh={${"is_percent $2"}?max(1,round($2*h)):round($2)}
nd={${"is_percent $3"}?max(1,round($3*d)):round($3)}
if {!$nw" || "!$nh" || "!$nd} rm 0
elif {!w} rm $nw,$nh,$nd,1
else
if {w==1||$nw<w} r $nw,100%,100%,100%,{w==1?1:2}
elif {$nw>w} $nw,100%,100%,100%,${lib}"X = x*(w#-1-1)/(w-1); d = X - int(X); P0 = I(#-1,X-1); P1 = I(#-1,X); P2 = I(#-1,X+1); P3 = I(#-1,X+2); mn(P0,P1,P2,P3,d);" k.
fi
if {h==1||$nh<h} r 100%,$nh,100%,100%,{h==1?1:2}
elif {$nh!=h} 100%,$nh,100%,100%,${lib}"Y = y*(h#-1-1)/(h-1); d = Y - int(Y); P0 = I(#-1,x,Y-1); P1 = I(#-1,x,Y); P2 = I(#-1,x,Y+1); P3 = I(#-1,x,Y+2); mn(P0,P1,P2,P3,d);" k.
fi
if {d==1||$nd<d} r 100%,100%,$nd,100%,{d==1?1:2}
elif {$nd!=d} 100%,100%,$nd,100%,${lib}"Z = z*(d#-1-1)/(d-1); d = Z - int(Z); P0 = I(#-1,x,y,Z-1); P1 = I(#-1,x,y,Z); P2 = I(#-1,x,y,Z+1); P3 = I(#-1,x,y,Z+2); mn(P0,P1,P2,P3,d);" k.
fi
fi
nm $nm
endl done v +
#@cli resize_pow2 : _interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images so that each dimension is a power of 2.
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=0', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg +resize_pow2[-1] 0
resize_pow2 : check "isint(${1=0}) && $1>=-1 && $1<=6" skip ${2=0},${3=0},${4=0},${5=0},${6=0}
e[^-1] "Resize image$? so that each dimension is a power of 2."
v - repeat $!
r[$>] {$>,2^(round(log2(w),1,1))},{$>,2^(round(log2(h),1,1))},{$>,2^(round(log2(d),1,1))},100%,${1-6}
done v +
#@cli rr2d : eq. to 'resize_ratio2d'.
rr2d :
v - _gmic_s="$?" v +
_resize_ratio2d $*
#@cli resize_ratio2d : width>0,height>0,_mode={ 0=inside | 1=outside | 2=padded },0=<_interpolation<=6
#@cli : Resize selected images while preserving their aspect ratio.
#@cli : (eq. to 'rr2d').
#@cli : Default values: 'mode=0' and 'interpolation=6'.
resize_ratio2d :
v - _gmic_s="$?" v +
_$0 $*
_resize_ratio2d : check "$1>0 && $2>0 && ${3=0}>=0 && $3<=2 && ${4=6}>=0 && $4<=6"
e[0--3] "Resize 2D image"$_gmic_s" to $1x$2 with ratio-"${arg\ 1+$3,inside,outside,padded}\
" mode and interpolation type $4."
v - repeat $!
ratio={$>,if($3==1,max($1/w,$2/h),min($1/w,$2/h))}
r[$>] {$>,w*$ratio},{$>,h*$ratio},100%,100%,$4
done
if {$3==2} r $1,$2,100%,100%,0,0,0.5,0.5 fi
v +
#@cli r2dx : eq. to 'resize2dx'.
r2dx :
v - _gmic_s="$?" v +
_resize2dx $*
#@cli resize2dx : width[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the x-axis, preserving 2D ratio.
#@cli : (eq. to 'r2dx').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg +resize2dx 100,2 append x
resize2dx :
v - _gmic_s="$?" v +
_$0 $*
_resize2dx : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
e[0--3] "Resize 2D image"$_gmic_s" to $1 pixels along the x-axis, preserving 2D ratio."
v - repeat $! l[$>]
size={if(${is_percent\ $1},$1*w,$1)}
r {max(1,$size)},{max(1,h*$size/w)},100%,100%,${2-7}
endl done v +
#@cli r2dy : eq. to 'resize2dy'.
r2dy :
v - _gmic_s="$?" v +
_resize2dy $*
#@cli resize2dy : height[%]>=0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the y-axis, preserving 2D ratio.
#@cli : (eq. to 'r2dy').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg +resize2dy 100,2 append x
resize2dy :
v - _gmic_s="$?" v +
_$0 $*
_resize2dy : check "$1>=0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
e[0--3] "Resize 2D image"$_gmic_s" to $1 pixels along the y-axis, preserving 2D ratio."
v - repeat $! l[$>]
size={if(${is_percent\ $1},$1*h,$1)}
r {max(1,w*$size/h)},{max(1,$size)},100%,100%,${2-7}
endl done v +
#@cli r3dx : eq. to 'resize3dx'.
r3dx :
v - _gmic_s="$?" v +
_resize3dx $*
#@cli resize3dx : width[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the x-axis, preserving 3D ratio.
#@cli : (eq. to 'r3dx').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dx :
v - _gmic_s="$?" v +
_$0 $*
_resize3dx : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the x-axis, preserving 3D ratio."
v - repeat $! l[$>]
size={if(${is_percent\ $1},$1*w,$1)}
r {max(1,$size)},{max(1,h*$size/w)},{max(1,d*$size/w)},100%,${2-7}
endl done v +
#@cli r3dy : eq. to 'resize3dy'.
r3dy :
v - _gmic_s="$?" v +
_resize3dy $*
#@cli resize3dy : height[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the y-axis, preserving 3D ratio.
#@cli : (eq. to 'r3dy').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dy :
v - _gmic_s="$?" v +
_$0 $*
_resize3dy : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the y-axis, preserving 3D ratio."
v - repeat $! l[$>]
size={if(${is_percent\ $1},$1*h,$1)}
r {max(1,w*$size/h)},{max(1,$size)},{max(1,d*$size/h)},100%,${2-7}
endl done v +
#@cli r3dz : eq. to 'resize3dz'.
r3dz :
v - _gmic_s="$?" v +
_resize3dz $*
#@cli resize3dz : depth[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the z-axis, preserving 3D ratio.
#@cli : (eq. to 'r3dz').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dz :
v - _gmic_s="$?" v +
_$0 $*
_resize3dz : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the z-axis, preserving 3D ratio."
v - repeat $! l[$>]
size={if(${is_percent\ $1},$1*d,$1)}
r[$>] {max(1,w*$size/d)},{max(1,h*$size/d)},{max(1,$size)},100%,${2-7}
endl done v +
#@cli rotate : angle,_interpolation,_boundary_conditions,_center_x[%],_center_y[%] : u,v,w,angle,interpolation,boundary_conditions,_center_x[%],_center_y[%],_center_z[%] : (+)
#@cli : Rotate selected images with specified angle (in deg.), and optionally 3D axis (u,v,w).
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : When a rotation center (cx,cy,_cz) is specified, the size of the image is preserved.
#@cli : Default values: 'interpolation=1', 'boundary_conditions=0' and 'center_x=center_y=(undefined)'.
#@cli : $ image.jpg +rotate -25,1,2,50%,50% rotate[0] 25
#@cli rotate_tileable : angle,_max_size_factor>=0
#@cli : Rotate selected images by specified angle and make them tileable.
#@cli : If resulting size of an image is too big, the image is replaced by a 1x1 image.
#@cli : Default values: 'max_size_factor=8'.
rotate_tileable : check ${2=8}>=0
e[^-1] "Rotate image$? with angle $1 deg. and make them tileable."
v -
angle={$1%360}
if {$angle>=270} rotate 270 angle-=270
elif {$angle>=180} rotate 180 angle-=180
elif {$angle>=90} rotate 90 angle-=90
fi
(0,1;1,8;1,7;1,6;1,5;1,4;1,5;1,3;2,5;1,2;2,5;3,5;2,3;3,4;4,5;1,1;5,4;7,5;3,2;8,5;9,5;2,1;3,1;4,1;5,1;6,1;7,1;8,1)
s. x,2 +/[-2,-1] atan. *. {180/pi}
($angle) index. .. rm..
p={-3,@{^}} q={-2,@{^}} rm[-3--1]
if {!$p||!$q} v + return fi
repeat $! l[$>]
theta={atan2($p,$q)}
gcd=${gcd" "{h*$q},{w*$p}}
pw={h*$q/$gcd}
nw={round($pw*w/cos($theta))}
gcd=${gcd" "{h*$p},{w*$q}}
qh={w*$q/$gcd}
nh={round($qh*h/cos($theta))}
if {!$2" || "($nw<$2*w" && "$nh<$2*h)}
r {1.5*$nw},{1.5*$nh},1,100%,0,2
rotate {$theta*180/pi},1,2,50%,50%
r $nw,$nh,1,100%,0,2,0.5,0.5
else v + error[0--4] "Command '$0': Invalid image dimension "({w},{h},{d},{s}).
fi
endl done v +
#@cli rows : { [image0] | y0[%] },_{ [image1] | y1[%] } : (+)
#@cli : Keep only specified rows of selected images.
#@cli : Dirichlet boundary conditions are used when specified rows are out of range.
#@cli : $ image.jpg rows -25%,50%
#@cli scale2x
#@cli : Resize selected images using the Scale2x algorithm.
#@cli : $ image.jpg threshold 50% resize 50%,50% +scale2x
scale2x :
e[^-1] "Double xy-dimensions of image$?, using Scale2x algorithm."
v - repeat $! l[$>]
r 200%,200%
f "dx=x&1;dy=y&1;A=j(0,-2,0,0,0,1);B=j(2,0,0,0,0,1);C=j(-2,0,0,0,0,1);D=j(0,2,0,0,0,1);"\
"!dy*(!dx*if(C==A&&C!=D&&A!=B,A,i) + dx*if(A==B&&A!=C&&B!=D,B,i)) + dy*(dx*if(B==D&&B!=A&&D!=C,D,i) + !dx*if(D==C&&D!=B&&C!=A,C,i))"
endl done v +
#@cli scale3x
#@cli : Resize selected images using the Scale3x algorithm.
#@cli : $ image.jpg threshold 50% resize 33%,33% +scale3x
scale3x :
e[^-1] "Triple xy-dimensions of image$?, using Scale3x algorithm."
v - repeat $! l[$>]
r 300%,300%
f "dx=x%3;dy=y%3;c0=!dx;c1=(dx==1);c2=(dx==2);"\
"A=j(-3,-3,0,0,0,1);B=j(0,-3,0,0,0,1);C=j(3,-3,0,0,0,1);"\
"D=j(-3,0,0,0,0,1);F=j(3,0,0,0,0,1);"\
"G=j(-3,3,0,0,0,1);H=j(0,3,0,0,0,1);I=j(3,3,0,0,0,1);"\
"!dy*(c0*if(D==B&&D!=H&&B!=F,D,i) + c1*if((D==B&&D!=H&&B!=F&&i!=C)||(B==F&&B!=D&&F!=H&&i!=A),B,i) + c2*if(B==F&&B!=D&&F!=H,F,i)) + "\
"(dy==1)*(c0*if((H==D&&H!=F&&D!=B&&i!=A)||(D==B&&D!=H&&B!=F&&i!=G),D,i) + c1*i + c2*if((B==F&&B!=D&&F!=H&&i!=I)||(F==H&&F!=B&&H!=D&&i!=C),F,i)) + "\
"(dy==2)*(c0*if(H==D&&H!=F&&D!=B,D,i) + c1*if((F==H&&F!=B&&H!=D&&i!=G)||(H==D&&H!=F&&D!=B&&i!=I),H,i) + c2*if(F==H&&F!=B&&H!=D,F,i))"
endl done v +
#@cli scale_dcci2x : _edge_threshold>=0,_exponent>0,_extend_1px={ 0=false | 1=true }
#@cli : Double image size using directional cubic convolution interpolation,
#@cli : as described in https://en.wikipedia.org/wiki/Directional_Cubic_Convolution_Interpolation.
#@cli : Default values: 'edge_threshold=1.15', 'exponent=5' and 'extend_1px=0'.
#@cli : $ image.jpg +scale_dcci2x ,
scale_dcci2x : check "${1=1.15}>=0 && ${2=5}>=0" skip ${3=0}
e[^-1] "Double xy-dimensions of image$?, using DCCI2x algorithm."
v - repeat $! l[$>]
r {2*w-(!$3)},{2*h-(!$3)},1,100%,4
f "begin(
const threshold = $1;
const exponent = $2;
interpolation = 0;
boundary = 1;
j1(x,y) = P[7*y + x + 24];
j2(x,y) = P[7*x - y + 24];
interp(k) = -k#(-3,-3) + 9*k#(-1,-1) + 9*k#(1,1) - k#(3,3);
d(k) = sum(abs([
k#(-1,-3) - k#(-3,-1), k#(1,-3) - k#(-1,-1), k#(3,-3) - k#(1,-1),
k#(-1,-1) - k#(-3,1), k#(1,-1) - k#(-1,1), k#(3,-1) - k#(1,1),
k#(-1,1) - k#(-3,3), k#(1,1) - k#(-1,3), k#(3,1) - k#(1,3)
]));
);
if (!((x*y)%2),i,
P = crop(x - 3,y - 3,0,c,7,7,1,1);
d1 = d(j1);
d2 = d(j2);
ratio = (1 + d1)/(1 + d2);
value = ratio>threshold ? interp(j1):
ratio<(1/threshold) ? interp(j2):
(w1 = 1/(1 + d1^exponent); w2 = 1/(1 + d2^exponent); (interp(j1)*w1 + interp(j2)*w2)/(w1 + w2));
value/=16)"
f "begin(
const threshold = $1;
const exponent = $2;
interpolation = 0;
boundary = 1;
j1(x,y) = P[7*y + x + 24];
j2(x,y) = P[7*x - y + 24];
interp(k) = -k#(0,-3) + 9*k#(0,-1) + 9*k#(0,1) - k#(0,3);
d(k) = sum(abs([
k#(-1,-2) - k#(1,-2),
k#(-2,-1) - k#(0,-1), k#(0,-1) - k#(2,-1),
k#(-3,0) - k#(-1,0), k#(-1,0) - k#(1,0), k#(1,0) - k#(3,0),
k#(-2,1) - k#(0,1), k#(0,1) - k#(2,1),
k#(-1,2) - k#(1,2)
]));
);
if ((x%2) + (y%2)!=1,i,
P = crop(x - 3,y - 3,0,c,7,7,1,1);
d1 = d(j1);
d2 = d(j2);
ratio = (1 + d1)/(1 + d2);
value = ratio>threshold ? interp(j1) :
ratio<(1/threshold) ? interp(j2) :
(w1 = 1/(1 + d1^exponent); w2 = 1/(1 + d2^exponent); (interp(j1)*w1 + interp(j2)*w2)/(w1 + w2));
value/=16)"
endl done v +
scale_dcci2x_old : check "${1=1.15}>=0 && ${2=5}>=0" skip ${3=0}
e[^-1] "Double xy-dimensions of image$?, using DCCI2x algorithm."
v - repeat $! l[$>]
a={-1/16} b={9/16} whd={w},{h},{d} s={s}
(0,-1,0;1,0,0;0,0,0) +convolve[0] [1] mirror[1] x +convolve[0] [1] rm[1] abs[^0]
3,3,1,1,1 convolve[-3,-2] . rm. r[-2,-1] $whd,1,2 r[-2,-1] $whd,$s
($a,$b,$b,$a,0) diagonal. +convolve[0] . mirror.. x shift.. -1,0 +convolve[0] .. rm...
++[1,2] 1 /[-2,-1]
_scale_dcci2x_smooth[-5,-4] ...,..,$2 _scale_dcci2x_mask[-4--1] $1
+g[0] x,-1 +g[0] y,1 +g[1] xy,-1 abs[-4--1]
(1,1,0;1,1,0;0,0,0) convolve[-5] . rm. (1,1,1) convolve[-4] . rm.
(1;1;1) convolve... . rm. (0,1,1;0,1,1;0,0,0) convolve.. . rm.
+[-3,-1] +[-3,-1] r[-2,-1] $whd,1,2 r[-2,-1] $whd,$s
($a;$b;$b;$a;0) +convolve[0] . rm.. (0,$a,$b,$b,$a) +convolve[1] . rm..
++[2,3] 1 /[-2,-1]
_scale_dcci2x_smooth[-5,-4] ...,..,$2 _scale_dcci2x_mask[-4--1] $1
+g[0] x,1 +g[0] y,-1 +g[1] xy,-1 abs[-4--1]
(1;1;1) convolve[-5] . rm. (1,1,0;1,1,0;0,0,0) convolve[-4] . rm.
(0,0,0;1,1,0;1,1,0) convolve... . rm. (1,1,1) convolve.. . rm.
+[-3,-1] +[-3,-1] r[-2,-1] $whd,1,2 r[-2,-1] $whd,$s
(0;$a;$b;$b;$a) +convolve[1] . rm.. ($a,$b,$b,$a,0) +convolve[0] . rm..
++[3,4] 1 /[-2,-1]
_scale_dcci2x_smooth[-5,-4] ...,..,$2 _scale_dcci2x_mask[-4--1] $1
r2dx 200%,4 shift[1] 1,1 shift[2] 0,1 shift[3] 1 +
if {!$3} r {w-1},{h-1},100%,100%,0 fi
endl done v +
_scale_dcci2x_smooth : skip ${3=5}
^[0,1] $3 +[0,1] 1 ++[0,1] /[0,1] . rm.
pass$1 pass$2 *[0,-2] *[1,-1] +[0,1]
_scale_dcci2x_mask : skip ${1=1.15}
+<. {1/$1} >.. $1 *[-4] .. *... .
or[-2,-1] not. *[-4,-1] +[-3--1]
#@cli seamcarve : _width[%]>=0,_height[%]>=0,_is_priority_channel={ 0 | 1 },_is_antialiasing={ 0 | 1 },_maximum_seams[%]>=0
#@cli : Resize selected images with specified 2D geometry, using the seam-carving algorithm.
#@cli : Default values: 'height=100%', 'is_priority_channel=0', 'is_antialiasing=1' and 'maximum_seams=25%'.
#@cli : $ image.jpg seamcarve 60%
seamcarve : check "${2=100%}>=0 && ${5=25%}>=0" skip ${3=0},${4=1}
e[^-1] "Resize image$? to $1x$2 using seam-carving algorithm, "${arg\ 1+!$3,with,without}" priority channel, "${arg\ 1+!$4,with,without}" anti-aliasing and maximum seams $5."
v - repeat $! l[$>]
nw={max(1,round(if(${is_percent\ $1},$1*w,$1)))}
nh={max(1,round(if(${is_percent\ $2},$2*h,$2)))}
if {$nw!=w} _seamcarve $nw,$3,$4,$5 fi
if {$nh!=h} transpose _seamcarve $nh,$3,$4,$5 transpose fi
endl done v +
_seamcarve :
do
max_seams={max(1,round(if(${is_percent\ $4},$4*w,$4)))}
ssms={max(min(round($1-w),w),1-w)}
sms={min($max_seams,abs($ssms))}
if $2 s[0] c,{1-s} /. 256 fi
+gradient[0] a[-2,-1] c abs. compose_channels. + n. 0,1
if $2 +. .. a[0,1] c fi
if $3 100%,1,1,1,x r. [0],[0] a[0,-1] c fi
.
repeat {h}
+rows. {$<+1} erode. 3
j.. .,0,$<,0,0,-1 rm.
done
100%,100% +rows[1] 0
nm[1] grad nm[2] low nm[3] seam nm[4] top
repeat {0,h-1} nr={$>+1}
+rows[low] $nr
+*[4,5] +shift[4] 1 *. [5] +shift[5] 1 *. [4]
+[-2,-1] j[5] [4] a[-3--1] c
f. ">if(c,i,max(j(-1)+j(0,0,0,1),j(-2)+j(0,0,0,2)))"
s. c shift... 1 +.. ... shift... 1 +[-3,-1]
>[-2,-1] f. "<if(j(1)<0,1,-i)"
j[seam] .,0,$>
a[-2,-1] c f. "j(i,0,0,-1)" channels. 1
+rows[grad] $nr +[top,-1]
done
max={iM*2} repeat $sms =. $max,{xm} done
j[grad] .,0,100% rm[low,top] a[-2,-1] c
f. "<if(c,i,j(j(0,0,0,1),1,0,0,0,1))" channels. 0
+[0] 0.1 !=. $max
w={w} h={h} s={0,s}
if {$ssms<0} * discard 0 r {$w-$sms},$h,1,$s,-1
elif {$ssms>0}
-. 2 s[0] c
repeat $s if {$><($s-1)} . fi a[$>,-1] c done
permute cxyz a c discard -1 f "if(i<0,j(0,-1),i)"
r {$w+$sms},$h,1,$s,-1
fi
if $3
s c,{1-s} g. x,1 round !=. 1
(0.5,0.5) +convolve[0] . rm..
j[0] .,0,0,0,0,1,[1] rm[-2,-1]
fi
rprogress {a=w/$1;if(a<1,a*100,100/a)}
while {w!=$1}
#@cli shift : vx[%],_vy[%],_vz[%],_vc[%],_boundary_conditions,_interpolation={ 0=nearest_neighbor | 1=linear } : (+)
#@cli : Shift selected images by specified displacement vector.
#@cli : Displacement vector can be non-integer in which case linear interpolation of the shift is computed.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'boundary_conditions=0' and 'interpolation=0'.
#@cli : $ image.jpg +shift[0] 50%,50%,0,0,0 +shift[0] 50%,50%,0,0,1 +shift[0] 50%,50%,0,0,2
#@cli shrink_x : size_x>=0
#@cli : Shrink selected images along the x-axis.
#@cli : $ image.jpg shrink_x 30
shrink_x : check "$1>=0"
e[^-1] "Shrink image$? along the x-axis with size $1."
v - repeat $! z[$>] $1,{$>,w-$1-1} done v +
#@cli shrink_xy : size>=0
#@cli : Shrink selected images along the xy-axes.
#@cli : $ image.jpg shrink_xy 30
shrink_xy : check "$1>=0"
e[^-1] "Shrink image$? along the xy-axes with size $1."
v - repeat $! z[$>] $1,$1,{$>,w-$1-1},{$>,h-$1-1} done v +
#@cli shrink_xyz : size>=0
#@cli : Shrink selected images along the xyz-axes.
shrink_xyz : check "$1>=0"
e[^-1] "Shrink image$? along the xyz-axes with size $1."
v - repeat $! z[$>] $1,$1,$1,{$>,w-$1-1},{$>,h-$1-1},{$>,d-$1-1} done v +
#@cli shrink_y : size_y>=0
#@cli : Shrink selected images along the y-axis.
#@cli : $ image.jpg shrink_y 30
shrink_y : check "$1>=0"
e[^-1] "Shrink image$? along the y-axis with size $1."
v - repeat $! z[$>] 0,$1,100%,{$>,h-$1-1} done v +
#@cli shrink_z : size_z>=0
#@cli : Shrink selected images along the z-axis.
shrink_z : check "$1>=0"
e[^-1] "Shrink image$? along the z-axis with size $1."
v - repeat $! z[$>] 0,0,$1,100%,100%,{$>,d-$1-1} done v +
#@cli slices : { [image0] | z0[%] },_{ [image1] | z1[%] } : (+)
#@cli : Keep only specified slices of selected images.
#@cli : Dirichlet boundary conditions are used when specified slices are out of range.
#@cli sort : _ordering={ + | - },_axis={ x | y | z | c } : (+)
#@cli : Sort pixel values of selected images.
#@cli : If 'axis' is specified, the sorting is done according to the data of the first column/row/slice/channel
#@cli : of selected images.
#@cli : Default values: 'ordering=+' and 'axis=(undefined)'.
#@cli : $ 64 rand 0,100 +sort display_graph 400,300,3
#@cli s : eq. to 'split'. : (+)
#@cli split : { x | y | z | c }...{ x | y | z | c },_split_mode : keep_splitting_values={ + | - },_{ x | y | z | c }...{ x | y | z | c },value1,_value2,... : (no arg) : (+)
#@cli : Split selected images along specified axes, or regarding to a sequence of scalar values (optionally along specified axes too).
#@cli : (eq. to 's').\n
#@cli : 'split_mode' can be { 0=split according to constant values | >0=split in N parts | <0=split in parts of size -N }.
#@cli : Default value: 'split_mode=-1'.
#@cli : $ image.jpg split c
#@cli : $ image.jpg split y,3
#@cli : $ image.jpg split x,-128
#@cli : $ 1,20,1,1,"1,2,3,4" +split -,2,3 append[1--1] y
#@cli : $ (1,2,2,3,3,3,4,4,4,4) +split x,0 append[1--1] y
#@cli split_tiles : M!=0,_N!=0,_is_homogeneous={ 0 | 1 }
#@cli : Split selected images as a MxN array of tiles.
#@cli : If M or N is negative, it stands for the tile size instead.
#@cli : Default values: 'N=M' and 'is_homogeneous=0'.
#@cli : $ image.jpg +local split_tiles 5,4 blur 3,0 sharpen 700 append_tiles 4,5 endlocal
split_tiles : skip ${2=$1},${3=0}
if $3 e[^-1] "Split image$? as a $1x$2 array of homogeneous tiles."
else e[^-1] "Split image$? as a $1x$2 array of tiles."
fi
v - repeat $! l[$<] s y,$2 s x,$1 if $3 r [0],[0],100%,100%,0 fi endl done v +
#@cli undistort : -1<=_amplitude<=1,_aspect_ratio,_zoom,_center_x[%],_center_y[%],_boundary_conditions
#@cli : Correct barrel/pincushion distortions occurring with wide-angle lens.
#@cli : References:
#@cli : [1] Zhang Z. (1999). Flexible camera calibration by viewing a plane from unknown orientation.
#@cli : [2] Andrew W. Fitzgibbon (2001). Simultaneous linear estimation of multiple view geometry and lens distortion.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default values: 'amplitude=0.25', 'aspect_ratio=0', 'zoom=0', 'center_x=center_y=50%'  and 'boundary_conditions=0'.
undistort : check "${1=0.1}>=-1 && $1<=1 && ${6=0}>=0 && $6<=3" skip ${2=0},${3=0},${4=50%},${5=50%}
e[^-1] "Undistort barrel/pincushion effect in image$?, with amplitude $1, aspect ratio $2, zoom factor $3, center ($4,$5) and "${"arg 1+$6,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! l[$>]
center_x={${"is_percent $4"}?w*$4:$4}
center_y={${"is_percent $5"}?h*$5:$5}
f "
const interpolation = 1;
const boundary = $6;
const center_x = "$center_x";
const center_y = "$center_y";
const alpha = cut($1,-0.999,0.999);
const ratio = $2>=0?1+$2:1/(1-$2);
const zoom = $3>=0?1+$3:1/(1-$3);
const M = max(w,h);
x = 2*(x - center_x)/(zoom*ratio*M);
y = 2*(y - center_y)/(zoom*M);
r = norm(x,y);
nr = r/(1 - alpha*r^2);
if (r>0,
nx = nr/r*x; ny = nr/r*y,
nx = x; ny = y
);
x = 0.5*nx*ratio*M + center_x;
y = 0.5*ny*M + center_y;
I(x,y)"
endl done v +
#@cli y : eq. to 'unroll'. : (+)
#@cli unroll : _axis={ x | y | z | c } : (+)
#@cli : Unroll selected images along specified axis.
#@cli : (eq. to 'y').
#@cli : Default value: 'axis=y'.
#@cli : $ (1,2,3;4,5,6;7,8,9) +unroll y
#@cli upscale_smart : width[%],_height[%],_depth,_smoothness>=0,_anisotropy=[0,1],sharpening>=0
#@cli : Upscale selected images with an edge-preserving algorithm.
#@cli : Default values: 'height=100%', 'depth=100%', 'smoothness=2', 'anisotropy=0.4' and 'sharpening=10'.
#@cli : $ image.jpg resize2dy 100 +upscale_smart 500%,500% append x
upscale_smart : skip ${2=100%},${3=100%} check "${4=2}>=0 && ${5=0.4}>=0 && $5<=1 && ${6=10}>=0"
e[^-1] "Upscale image$? to $1x$2x$3, with smoothness $4, anisotropy $5 and sharpening $6."
v - repeat $! l[$>]
w={w} h={h}
+r. $1,$2,$3,1,0
if {w<$w" && "h<$h}
rm. r. $1,$2,$3,100%,2
else
rm. +diffusiontensors 0,$5,1.2,1.2
r[-2,-1] $1,$2,$3,100%,5
smooth.. .,$4 rm.
ac "sharpen. $6,10",ycbcr_y
fi
endl done v +
#@cli warp : [warping_field],_mode,_interpolation,_boundary_conditions,_nb_frames>0 : (+)
#@cli : Warp selected images with specified displacement field.
#@cli : 'mode' can be { 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=forward-relative }.
#@cli : 'interpolation' can be { 0=nearest-neighbor | 1=linear | 2=cubic }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default values: 'mode=0', 'interpolation=1', 'boundary_conditions=1' and 'nb_frames=1'.
#@cli : $ image.jpg 100%,100%,1,2,'X=x/w-0.5;Y=y/h-0.5;R=(X*X+Y*Y)^0.5;A=atan2(Y,X);130*R*if(c==0,cos(4*A),sin(8*A))' warp[-2] [-1],1,1,0 quiver[-1] [-1],10,1,1,1,100
#@cli : $$
#@cli warp_patch : [warping_field],patch_width>=1,_patch_height>=1,_patch_depth>=1,_std_factor>0,_boundary_conditions.
#@cli : Patch-warp selected images, with specified 2D or 3D displacement field (in backward-absolute mode).
#@cli : Argument 'std_factor' sets the std of the gaussian weights for the patch overlap, equal to 'std = std_factor*patch_size'.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default values: 'std_factor=0.3' and 'boundary_conditions=3'.
warp_patch : check ${is_image_arg\ $1}" && isint(${2=3}) && $2>=1 && isint(${3=$2}) && $3>=1 && isint(${4=1}) && $4>=1 && isval(${5=0.3}) && $5>0 && isint(${6=3}) && $6>=0 && $6<=3"
e[^-1] "Patch-warp image$? with backward-absolute displacement field $1, using $2x$3x$4 patches, std factor $5 and "${"arg 1+$6,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - if {$2<=1} pass$1 warp[^-1] .,0 rm. v + return fi
repeat $! pass$1 l[$>,-1]
[0],[0],[0],1,1 a[0,-1] c
100%,100%,100%,{0,s}
if {1,s>=3}
eval[1] ">
begin(
const pw = $2;
const ph = $3;
const pd = $4;
const stdf = $5;
const boundary = $6;
const pw1 = int(pw/2);
const pw2 = pw - pw1 - 1;
const ph1 = int(ph/2);
const ph2 = ph - ph1 - 1;
const pd1 = int(pd/2);
const pd2 = pd - pd1 - 1;
const pwhd = pw*ph*pd;
if (stdf<5,
weights = vectorpwhd();
offw = 0;
for (zw = -pd1, zw<=pd2, ++zw,
for (yw = -ph1, yw<=ph2, ++yw,
for (xw = -pw1, xw<=pw2, ++xw,
weights[offw++] = exp(-xw^2/(2*(stdf*pw)^2) - yw^2/(2*(stdf*ph)^2) - zw^2/(2*(stdf*pd)^2));
);
);
);
);
);
u = i(x,y,z,0);
v = i(x,y,z,1);
w = i(x,y,z,2);
patch = crop(#0,u - pw1, v - ph1,w - pd1,pw,ph,pd,boundary);
stdf<5?
draw(#2,patch,x - pw1,y - ph1,z - pd1,0,pw,ph,pd,s#0,-1,weights):
draw(#2,patch,x - pw1,y - ph1,z - pd1,0,pw,ph,pd,s#0,-1)"
else
eval[1] ">
begin(
const pw = $2;
const ph = $3;
const stdf = $5;
const boundary = $6;
const pw1 = int(pw/2);
const pw2 = pw - pw1 - 1;
const ph1 = int(ph/2);
const ph2 = ph - ph1 - 1;
const pwh = pw*ph;
if (stdf<5,
weights = vectorpwh();
offw = 0;
for (yw = -ph1, yw<=ph2, ++yw,
for (xw = -pw1, xw<=pw2, ++xw,
weights[offw++] = exp(-xw^2/(2*(stdf*pw)^2) - yw^2/(2*(stdf*ph)^2));
);
);
);
);
u = i(x,y,z,0);
v = i(x,y,z,1);
patch = crop(#0,u - pw1, v - ph1,pw,ph,boundary);
stdf<5?
draw(#2,patch,x - pw1,y - ph1,0,0,pw,ph,1,s#0,-1,weights):
draw(#2,patch,x - pw1,y - ph1,0,0,pw,ph,1,s#0,-1)"
fi
s. c,-{0,s-1} /[-2,-1] k.
endl done v +
#@cli :: Filtering
#@cli bandpass : _min_freq[%],_max_freq[%]
#@cli : Apply bandpass filter to selected images.
#@cli : Default values: 'min_freq=0' and 'max_freq=20%'.
#@cli : $ image.jpg bandpass 1%,3%
#@cli : $$
bandpass : skip ${1=0},${2=20%}
e[^-1] "Apply bandpass filter [$1,$2] to image$?."
v - repeat $! l[$>]
100%,100%,100% f. "sqrt((x/w-0.5)^2 + (y/h-0.5)^2 + (z/d-0.5)^2)"
n. 0,1 ir. $1,$2 shift. {int(w/2)},{int(h/2)},{int(d/2)},0,2
fft.. *... . *[-2,-1] ifft rm.
endl done v +
#@cli bilateral : [guide],std_deviation_s[%]>=0,std_deviation_r[%]>=0,_sampling_s>=0,_sampling_r>=0 : std_deviation_s[%]>=0,std_deviation_r[%]>=0,_sampling_s>=0,_sampling_r>=0 : (+)
#@cli : Blur selected images by anisotropic (eventually joint/cross) bilateral filtering.
#@cli : If a guide image is provided, it is used for drive the smoothing filter.
#@cli : A guide image must be of the same xyz-size as the selected images.
#@cli : Set 'sampling' arguments to '0' for automatic adjustment.
#@cli : $ image.jpg repeat 5 bilateral 10,10 done
#@cli b : eq. to 'blur'. : (+)
#@cli blur : std_deviation>=0[%],_boundary_conditions,_kernel : axes,std_deviation>=0[%],_boundary_conditions,_kernel : (+)
#@cli : Blur selected images by a quasi-gaussian or gaussian filter (recursive implementation).
#@cli : (eq. to 'b').\n
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann } and 'kernel' can be { 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@cli : Specifying one axis multiple times apply also the blur multiple times.
#@cli : Default values: 'boundary_conditions=1' and 'kernel=0'.
#@cli : $ image.jpg +blur 5,0 +blur[0] 5,1
#@cli : $ image.jpg +blur y,10%
#@cli : $$
#@cli blur_angular : amplitude[%],_center_x[%],_center_y[%]
#@cli : Apply angular blur on selected images.
#@cli : Default values: 'center_x=center_y=50%'.
#@cli : $ image.jpg blur_angular 2%
#@cli : $$
blur_angular : skip ${2=50%},${3=50%}
e[^-1] "Apply angular blur on image$?, with amplitude $1 and center point ($2,$3)."
v - euclidean2polar $2,$3,1.3,1
repeat $! l[$>] 1,100% =. 1,50%,50% b. y,$1 convolve_fft.. . rm. endl done
polar2euclidean $2,$3,1.3,1 v +
#@cli blur_bloom : _amplitude>=0,_ratio>=0,_nb_iter>=0,_blend_operator={ + | max | min },_kernel={ 0=quasi-gaussian (faster) | 1=gaussian | 2=box | 3=triangle | 4=quadratic },_normalize_scales={ 0 | 1 },_axes
#@cli : Apply a bloom filter that blend multiple blur filters of different radii,
#@cli : resulting in a larger but sharper glare than a simple blur.
#@cli : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@cli : Specifying one axis multiple times apply also the blur multiple times.
#@cli : Reference: Masaki Kawase, "Practical Implementation of High Dynamic Range Rendering", GDC 2004.
#@cli : Default values: 'amplitude=1', 'ratio=2', 'nb_iter=5', 'blend_operator=+', 'kernel=0','normalize_scales=0' and 'axes=(all)'
#@cli : $ image.jpg blur_bloom ,
blur_bloom : check "${1=1}>=0 && ${2=2}>=0 && isint(${3=5}) && $3>=0 && isint(${5=0}) && $5>=0 && $5<=4 && isval(${6=0})" skip ${4=+},${7=}
e[^-1] "Apply bloom effect on image$?, with amplitude $1, ratio $2, $3 iterations, blend operator '$4' and "${"arg 1+!$6,\"\",\"no \""}"scale normalization."
v -
if {narg("$7")} axes=$7, fi
m "_bloom0 : b "$axes"$""1"
m "_bloom1 : b "$axes"$""1,1,1"
m "_bloom2 : boxfilter "$axes"{1+2*$""1},0,1"
m "_bloom3 : boxfilter "$axes"{1+2*$""1},0,1,2"
m "_bloom4 : boxfilter "$axes"{1+2*$""1},0,1,3"
repeat $! l[$>] nm={n} mM={[im,iM]}
[0] repeat $3 sigma={$1*($2^$>)} +_bloom$5[0] $sigma
if $6 n. $mM fi
-$4[1,-1]
done
n. $mM k. nm $nm
endl done
uncommand _bloom0,_bloom1,_bloom2,_bloom3,_bloom4
v +
#@cli blur_linear : amplitude1[%],_amplitude2[%],_angle,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Apply linear blur on selected images, with specified angle and amplitudes.
#@cli : Default values: 'amplitude2=0', 'angle=0' and 'boundary_conditions=1'.
#@cli : $ image.jpg blur_linear 10,0,45
#@cli : $$
blur_linear : skip ${2=0},${3=0},${4=1}
e[^-1] "Apply linear blur on image$?, with angle $3 deg. and amplitudes ($1,$2)."
v -
std1={if(${is_percent\ $1},$1*max(w,h),$1)}
std2={if(${is_percent\ $2},$2*max(w,h),$2)}
stdM={round(1.25*max($std1,$std2))}
if {$stdM<=0} v + return fi
repeat $! l[$>]
expand_xy $stdM,{$4!=0}
{2*$stdM},{2*$stdM} gaussian. $1,$2,$3 normalize_sum.
convolve_fft[0] [1] rm. shrink_xy $stdM
endl done v +
#@cli blur_radial : amplitude[%],_center_x[%],_center_y[%]
#@cli : Apply radial blur on selected images.
#@cli : Default values: 'center_x=center_y=50%'.
#@cli : $ image.jpg blur_radial 2%
#@cli : $$
blur_radial : skip ${2=50%},${3=50%}
e[^-1] "Apply radial blur on image$?, with amplitude $1 and center point ($2,$3)."
v - euclidean2polar $2,$3,5,1 blur_x $1 polar2euclidean $2,$3,5,1 v +
#@cli blur_selective : sigma>=0,_edges>0,_nb_scales>0
#@cli : Blur selected images using selective gaussian scales.
#@cli : Default values: 'sigma=5', 'edges=0.5' and 'nb_scales=5'.
#@cli : $ image.jpg noise 20 cut 0,255 +local[-1] repeat 4 blur_selective , done endlocal
#@cli : $$
blur_selective : check "${1=5}>=0 && ${2=0.5}>=0 && isint(${3=5}) && $3>0"
e[^-1] "Blur image$? using $3 selective gaussian scales, with sigma $1 and edges $2."
v - repeat $! l[$>] nm={0,n}
+gradient_norm +. 1 ^. {-max(0.01,$2)} quantize. {$3+1},0,1 min. {$3-1} r. ..
repeat $3 +==. $> *. ... +[-2,-1] b.. {$1/($3+1)} done
rm.. nm $nm endl done v +
#@cli blur_x : amplitude[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the x-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +blur_x 6
#@cli : $$
blur_x : skip ${2=1}
e[^-1] "Blur image$? along the x-axis, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
v - deriche $1,0,x,$2 v +
#@cli blur_xy : amplitude_x[%],amplitude_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the X and Y axes.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +blur_xy 6
#@cli : $$
blur_xy : skip ${2=$1},${3=1}
e[^-1] "Blur image$? along the xy-axes, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
v - deriche $1,0,x,$3 deriche $2,0,y,$3 v +
#@cli blur_xyz : amplitude_x[%],amplitude_y[%],amplitude_z,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the X, Y and Z axes.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $$
blur_xyz : skip ${4=1}
e[^-1] "Blur image$? along the xyz-axes, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
v - deriche $1,0,x,$4 deriche $2,0,y,$4 deriche $3,0,z,$4 v +
#@cli blur_y : amplitude[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the y-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +blur_y 6
#@cli : $$
blur_y : skip ${2=1}
e[^-1] "Blur image$? along the y-axis, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
v - deriche $1,0,y,$2 v +
#@cli blur_z : amplitude[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the z-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $$
blur_z : skip ${2=1}
e[^-1] "Blur image$? along the z-axis, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
v - deriche $1,0,z,$2 v +
#@cli boxfilter : size>=0[%],_order,_boundary_conditions,_nb_iter>=0 : axes,size>=0[%],_order,_boundary_conditions,_nb_iter>=0 : (+)
#@cli : Blur selected images by a box filter of specified size (fast recursive implementation).
#@cli : 'order' can be { 0=smooth | 1=1st-derivative | 2=2nd-derivative }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@cli : Specifying one axis multiple times apply also the blur multiple times.
#@cli : Default values: 'order=0', 'boundary_conditions=1' and 'nb_iter=1'.
#@cli : $ image.jpg +boxfilter 5%
#@cli : $ image.jpg +boxfilter y,3,1
#@cli bump2normal
#@cli : Convert selected bumpmaps to normalmaps.
#@cli : $ 300,300 circle 50%,50%,128,1,1 blur 5% bump2normal
bump2normal :
e[^-1] "Convert bumpmap$? to normalmap."
v - repeat $! l[$>]
channels 0 g xy,1 +f. 1 a c orientation
* 127 + 128 round c 0,255
endl done v +
#@cli compose_freq
#@cli : Compose selected low and high frequency parts into new images.
#@cli : $ image.jpg split_freq 2% mirror[-1] x compose_freq
compose_freq :
e[^-1] "Compose low and high frequency part$? into new images."
v - repeat {int($!/2)} +[$>,{$>+1}] done v +
#@cli convolve : [mask],_boundary_conditions,_is_normalized={ 0 | 1 } : (+)
#@cli : Convolve selected images by specified mask.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg (0,1,0;1,-4,1;0,1,0) convolve[-2] [-1] keep[-2]
#@cli : $ image.jpg (0,1,0) resize[-1] 130,1,1,1,3 +convolve[0] [1]
#@cli : $$
#@cli convolve_fft : [mask]
#@cli : Convolve selected images with specified mask, in the fourier domain.
#@cli : $ image.jpg 100%,100% gaussian[-1] 20,1,45 +convolve_fft[0] [1]
convolve_fft : check ${is_image_arg\ $1}
e[^-1] "Convolve image$? with mask $1, in the fourier domain."
v - repeat $! pass$1 0 l[$>,-1]
w2={0,int(w/2)} h2={0,int(h/2)} d2={0,int(d/2)}
r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 shift[1] -$w2,-$h2,-$d2,0,2
fft[0] fft[2]
+*[-4] . +*[-4] ... +[-2,-1]
*[-5,-3] *[-3,-2] -[-3,-2]
ifft rm.
endl done v +
#@cli correlate : [mask],_boundary_conditions,_is_normalized={ 0 | 1 } : (+)
#@cli : Correlate selected images by specified mask.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg (0,1,0;1,-4,1;0,1,0) correlate[-2] [-1] keep[-2]
#@cli : $ image.jpg +crop 40%,40%,60%,60% +correlate[0] [-1],0,1
#@cli cross_correlation : [mask]
#@cli : Compute cross-correlation of selected images with specified mask.
#@cli : $ image.jpg +shift -30,-20 +cross_correlation[0] [1]
cross_correlation : check ${is_image_arg\ $1}
e[^-1] "Compute cross-correlation of image$? with mask $1."
v - repeat $! pass$1 0 l[$>,-1]
norm fft.. fft. [-2,-1] *.. [-5] *. [-6]
-[-2,-1] *[-5,-3] *[-3,-2] +[-3,-2] ifft rm.
endl done v +
#@cli curvature
#@cli : Compute isophote curvatures on selected images.
#@cli : $ image.jpg blur 10 curvature
curvature :
e[^-1] "Compute isophote curvatures on image$?."
v - repeat $! l[$>]
if {d==1}
+g xy,0 hessian... xxxyyy
*... .. *[-4] . *[-4] -2
+[-4,-3] *... ..
sqr[-2,-1] *[-4] . +[-4,-3]
+[-2,-1] +. 0.1 ^. 1.5 /
else
+inn +gradient_norm.. laplacian...
-[-3,-2] +. 0.1 /[-2,-1]
+inn. laplacian.. -
fi
endl done v +
#@cli dct : _{ x | y | z }...{ x | y | z } : (no arg)
#@cli : Compute the discrete cosine transform of selected images,
#@cli : optionally along the specified axes only.
#@cli : Default values: (no arg)
#@cli : $ image.jpg +dct +idct[-1] abs[-2] +[-2] 1 log[-2]
#@cli : $$ _dct-and-idct
dct : skip ${1=0}
v - ({'"$1"'})
is_axes={im>=_'x'" && "iM<=_'z'}
if $is_axes
v + e[0--3] "Compute discrete cosine transform of image$? along axes '$1'." v -
repeat {w}
axis={i[$>]}
if {$axis==_'x'} repeat {$!-1} l[$>] if {w>1} _dct fi endl done
elif {$axis==_'y'} repeat {$!-1} l[$>] if {h>1} permute yxzc _dct permute yxzc fi endl done
elif {$axis==_'z'} repeat {$!-1} l[$>] if {d>1} permute zxyc _dct permute yzxc fi endl done
fi
done
else
rm.
v + e[0--3] "Compute discrete cosine transform of image$?." v -
noarg
repeat $! l[$>]
if {w>1} _dct fi
if {h>1} permute yxzc _dct permute yxzc fi
if {d>1} permute zxyc _dct permute yzxc fi
endl done
fi
v +
_dct :
is_odd={w%2}
if $is_odd r {w+1},100%,100%,100%,0,1 fi
s x l[1--1:2] a x mirror x endl mv[1] $! a x
fft x
100%,1,1,1,2*cos(-x*pi/(2*w)) *[0,2]
100%,1,1,1,2*sin(-x*pi/(2*w)) *[1,2]
-
if $is_odd r {w-1},100%,100%,100%,0 fi
+z[0] 0,0 /. {sqrt(2)} j.. .,0,0,0 rm. * {sqrt(2/w)}
#@cli deblur : amplitude[%]>=0,_nb_iter>=0,_dt>=0,_regul>=0,_regul_type={ 0=Tikhonov | 1=meancurv. | 2=TV }
#@cli : Deblur image using a regularized Jansson-Van Cittert algorithm.
#@cli : Default values: 'nb_iter=10', 'dt=20', 'regul=0.7' and 'regul_type=1'.
#@cli : $ image.jpg blur 3 +deblur 3,40,20,0.01
deblur : check "${2=10}>=0 && ${3=20}>=0 && ${4=0.7}>=0" skip ${5=1}
e[^-1] "Deblur image$? with a regularized Jansson-Van Cittert algorithm, with sigma $1, $2 iterations, time step $3 and regularization $4." v -
repeat $! l[$>] nm={0,n}
[0]
repeat $2
if {$5>=2} +curvature.
elif {$5>=1} +iee.
else +laplacian.
fi
*. $4
+b.. $1 -. [-4]
-[-2,-1]
*. {$3/(0.0001+max(abs(im),abs(iM)))}
+[-2,-1]
done
rm..
nm $nm endl done v +
#@cli deblur_goldmeinel : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg +blur 1 +deblur_goldmeinel[-1] 1
deblur_goldmeinel : check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" skip ${4=1}
e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${arg\ 1+!$4,"",quasi-}"gaussian kernel."
v - repeat $! l[$>]
[0] repeat $2
+b. $1,1,$4 +/[0,-1] rm.. ^. $3 *[-1,-2]
done rm[0]
endl done v +
#@cli deblur_richardsonlucy : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur selected images using Richardson-Lucy algorithm.
#@cli : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@cli : $ image.jpg +blur 1 +deblur_richardsonlucy[-1] 1
deblur_richardsonlucy : check "$1>=0 && ${2=50}>=0" skip ${3=1}
e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${arg\ 1+!$3,"",quasi-}"gaussian kernel."
v - repeat $! l[$>]
[0] repeat $2
+b. $1,1,{$3!=0} max. 1e-6 +/[0,-1] rm.. b. $1,1,{$3!=0} *[-1,-2]
done rm[0]
endl done v +
#@cli deconvolve_fft :  [kernel],_regularization>=0
#@cli : Deconvolve selected images by specified mask in the fourier space.
#@cli : Default value: 'regularization>=0'.
#@cli : $ image.jpg +gaussian 5 +convolve_fft[0] [1] +deconvolve_fft[-1] [1]
deconvolve_fft : check ${is_image_arg\ $1}" && ${2=.001}>=0"
e[^-1] "Deconvolve image$? with mask $1 and regularization $2, in the fourier domain."
v - repeat $! pass$1 0 l[$>,-1]
w2={0,int(w/2)} h2={0,int(h/2)} d2={0,int(d/2)}
r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 shift[1] -$w2,-$h2,-$d2,0,2
fft[0] fft[2]
+l[-1,-2] sqr + + $2 endl
+*[-4] ...
+*[-6] ...
-[-2,-1]
*[-6,-4]
*[-4,-3]
+[-4,-3]
/. .. /[-3,-2]
ifft rm.
endl done v +
#@cli deinterlace : _method={ 0 | 1 }
#@cli : Deinterlace selected images ('method' can be { 0=standard or 1=motion-compensated }).
#@cli : Default value: 'method=0'.
#@cli : $ image.jpg +rotate 3,1,1,50%,50% resize 100%,50% resize 100%,200%,1,3,4 shift[-1] 0,1 add +deinterlace 1
deinterlace : skip ${1=0}
e[^-1] "Deinterlace image$? with "${arg\ 1+!$1,motion-compensated,standard}" method."
v - repeat $! l[$>]
wh={w},{h}
s y a[0--1:2] y a[^0] y r.. .,0 r 100%,200%,1,100%,5
if {$1!=0} +displacement. ..,0.05 warp... .,1,1,1 rm. fi
+ / 2 c 0,255 r $wh
endl done v +
#@cli denoise : std_deviation_s>=0,_std_deviation_p>=0,_patch_size>0,_lookup_size>0,_smoothness,_fast_approx={ 0 | 1 } : (+)
#@cli : Denoise selected images by non-local patch averaging.
#@cli : Default values: 'std_deviation_p=10', 'patch_size=5', 'lookup_size=6' and 'smoothness=1'.
#@cli : $ image.jpg +denoise 5,5,8
#@cli denoise_haar : _threshold>=0,_nb_scales>=0,_cycle_spinning>0
#@cli : Denoise selected images using haar-wavelet thresholding with cycle spinning.
#@cli : Set 'nb_scales==0' to automatically determine the optimal number of scales.
#@cli : Default values: 'threshold=1.4', 'nb_scale=0' and 'cycle_spinning=10'.
#@cli : $ image.jpg noise 20 cut 0,255 +denoise_haar[-1] 0.8
denoise_haar : check "${1=1.4}>=0 && isint(${2=0}) && $2>=0 && isint(${3=10}) && $3>0"
e[^-1] "Denoise image$? using haar-wavelet thresholding, with threshold $1, "\
${arg\ 1+($2>0),auto,$2}" scales and $3 spinning cycles."
v - repeat $! l[$>] nm={0,n}
nb_scales={min(if($2,$2,32),int(log2(min(w,h))-1))}
w={w} h={h} d={d} sigma=${-std_noise}
r {round(w,2^($nb_scales+1),1)},{round(h,2^($nb_scales+1),1)},{if(d==1,1,round(d,2^($nb_scales+1),1))},100%,0,0
+f 0
repeat $3
dx={round(u(0,{4*$nb_scales}))}
dy={round(u(0,{4*$nb_scales}))}
dz={if($d==1,0,round(u(0,{4*$nb_scales})))}
+shift[0] $dx,$dy,$dz,0,2
haar. $nb_scales
threshold. {$1*$sigma},1
ihaar. $nb_scales
shift. {-$dx},{-$dy},{-$dz},0,2
+[-2,-1]
done
rm[0] / $3 r $w,$h,$d,100%,0
nm $nm endl done v +
#@cli denoise_patchpca : _strength>=0,_patch_size>0,_lookup_size>0,_spatial_sampling>0
#@cli : Denoise selected images using the patch-pca algorithm.
#@cli : Default values: 'patch_size=7', 'lookup_size=11', 'details=1.8' and 'spatial_sampling=5'.
#@cli : $ image.jpg +noise 20 cut[-1] 0,255 +denoise_patchpca[-1] ,
denoise_patchpca : check "${1=1.8} && $1>=0 && isint(${2=7}) && $2>0 && isint(${3=11}) && $3>0 && isint(${4=5}) && $4>0"
e[^-1] "Denoise image$? using patch-pca, with strength $1, patch size $2, lookup size $3 and spatial sampling $4."
v - repeat $! l[$>] nm={n}
N2={$2*$2} M2={$3*$3} stdnoise=${-std_noise}
100%,100%,1,100% nm. aggreg
100%,100% nm. weights
f[0] "*
begin(
n1 = int($2/2); n2 = $2 - n1 - 1;
m1 = int($3/2); m2 = $3 - m1 - 1;
patch(x,y) = crop(x-n1,y-n1,0,c,$2,$2,1,1,1);
ngauss(x) = exp(-x*x/(2*n1*n1));
zero = vector"$N2"(0);
mask = vector"$N2"(0);
for (l = 0; q = -n1, q<=n2, ++q,
for (p = -n1, p<=n2, ++p, mask[l++] = ngauss(p)*ngauss(q)
)
)
);
if (!(x%$4) && !(y%$4),
X = patch(x,y);
M = vector"{$N2*$N2}"(0);
for (q = -m1, q<=m2, ++q,
for (p = -m1, p<=m2, ++p,
Xk = patch(x + p,y + q) - X;
M += mul(Xk,Xk,"$N2");
)
);
M/="$M2";
eig = eig(M);
lambda = sqrt(abs(eig[0,"$N2"]));
for (k = 0, k<size(lambda) && lambda[k]>=$1*"$stdnoise", ++k);
Qt = eig["$N2","{$N2*$N2}"];
Q = transp(Qt,"$N2");
for (q = -m1, q<=m2, ++q,
for (p = -m1, p<=m2, ++p,
pY = Qt*(patch(x + p,y + q) - X);
copy(pY[k],zero[0],size(pY) - k);
(Y = Q*pY)+=X;
draw(#"$aggreg",Y,x + p - n1,y + q - n1,0,c,$2,$2,1,1,-1,mask);
draw(#"$weights",mask,x + p - n1,y + q - n1,0,c,$2,$2,1,1,-1);
)
);
0);0"
max[weights] 0.01 /[aggreg,weights] k[aggreg] nm $nm
endl done v +
#@cli deriche : std_deviation>=0[%],order={ 0 | 1 | 2 },axis={ x | y | z | c },_boundary_conditions : (+)
#@cli : Apply Deriche recursive filter on selected images, along specified axis and with
#@cli : specified standard deviation, order and boundary conditions.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg deriche 3,1,x
#@cli : $ image.jpg +deriche 30,0,x deriche[-2] 30,0,y add
#@cli : $$
#@cli dilate : size>=0 : size_x>=0,size_y>=0,size_z>=0 : [kernel],_boundary_conditions,_is_real={ 0=binary-mode | 1=real-mode } : (+)
#@cli : Dilate selected images by a rectangular or the specified structuring element.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_z=1', 'boundary_conditions=1' and 'is_real=0'.
#@cli : $ image.jpg +dilate 10
#@cli dilate_circ : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply circular dilation of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +dilate_circ 7
dilate_circ : check $1>=0 skip ${2=1},${3=0}
e[^-1] "Apply circular dilation of image$? by size $1, boundary conditions $2 and is_normalized $3."
if {$1<2} return fi
v - shape_circle $1 dilate[^-1] .,$2,$3 rm. v +
#@cli dilate_oct : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply octagonal dilation of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +dilate_oct 7
dilate_oct : check $1>=0 skip ${2=1},${3=0}
e[^-1] "Apply octagonal dilation of image$? by size $1, boundary conditions $2 and is_normalized $3."
if {$1<2} return fi
v -
if {$1&1} ss={$1} else ss={$1+1} fi
i[0] (0,1,0;1,1,1;0,1,0) i[1] (1,1,1;1,1,1;1,1,1)
repeat {$!-2}
r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
q={round(($ss-1)/(1+sqrt(2))/2)}
if {$r>0} repeat $r dilate. [0],$2,$3 done fi
if {$q>0} repeat $q dilate. [1],$2,$3 done fi
mv. 2 done rm[0,1] v +
_kr_circle :
if {$1%2==0} 2,2,1,1,1 else 1,1,1,1,1 fi r. $1,$1,1,1,0,0,0.5,0.5
distance. 1 round. 0.5 ir. 0,{$1/2}
_jf_circle :
{round($1)},{round($1)}
center={0.5*(w-1)}
f. 'sqrt((x-$center)^2+(y-$center)^2)'
if {!(w%2)}
round. 0.0001,-1
t1={sqrt(((round($1)-1)/2)^2+0.25)}
t2={sqrt(((round($1)+1)/2)^2+0.25)}
k={$1-round($1)+0.5}
t={$t1+($t2-$t1)*$k}
ir. 0,$t
else ir. 0,{$1/2-0.25}
fi
#@cli dilate_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary_conditions
#@cli : Dilate selected images in the (X,Y,Z,I) space.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary_conditions=1'.
dilate_threshold : check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
e[^-1] "Dilate image$? with mask $1x$2x$3, threshold $4 and "${arg\ $5,dirichlet,neumann}" boundary conditions."
v - l[]
dx1={int($1/2)} dx2={$1-$dx1-1}
dy1={int($2/2)} dy2={$2-$dy1-1}
dz1={int($3/2)} dz2={$3-$dz1-1}
(-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) r $1,$2,$3,1,3 a c round r {w*h*d},3,1,1,-1 transpose.
i.. 1,100%,1,1,254 1,100%,1,1,255 a x
({'{^}'}) rm.. replace_str "254,","(v=j(" replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,-1e20))" list={t}
rm
endl
f 'max($list)'
v +
#@cli divergence
#@cli : Compute divergence of selected vector fields.
#@cli : $ image.jpg luminance +gradient append[-2,-1] c divergence[-1]
divergence :
e[^-1] "Compute divergence of vector field$?."
v - repeat $! l[$>]
if {s==1} g x,0
elif {s==2} s c g.. x,0 g. y,0 +
elif {s==3} s c g... x,0 g.. y,0 g. z,0 +
else v + error[] "Command '$0': Cannot compute divergence of image ["$>"] (has "{s}">3 channels)."
fi
endl done v +
#@cli dog : _sigma1>=0[%],_sigma2>=0[%]
#@cli : Compute difference of gaussian on selected images.
#@cli : Default values: 'sigma1=2%' and 'sigma2=3%'.
#@cli : $ image.jpg dog 2,3
dog : check "${1=2%}>=0 && ${2=3%}>=0"
e[^-1] "Compute difference of gaussian on image$?, with standard deviations $1 and $2."
v - repeat $! l[$>]
[0] parallel "b[0] $1","b[1] $2" - abs
endl done v +
#@cli diffusiontensors : _sharpness>=0,0<=_anisotropy<=1,_alpha[%],_sigma[%],is_sqrt={ 0 | 1 }
#@cli : Compute the diffusion tensors of selected images for edge-preserving smoothing algorithms.
#@cli : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1' and 'is_sqrt=0'.
#@cli : $ image.jpg diffusiontensors 0.8 abs pow 0.2
#@cli : $$
diffusiontensors : check "${1=0.7}>=0 && ${2=0.3}>=0 && $2<=1" skip ${3=0.6},${4=1.1},${5=0}
e[^-1] "Compute diffusion tensors for image$?, with sharpness $1, anisotropy $2, alpha $3 and sigma $4."
v -
p1={if($5,0.5,1)*max($1,1e-2)}
p2={$p1/(1e-7+1-$2)}
b $3 n 0,255 structuretensors 0 b $4
repeat $! l[$>]
eigen max.. 0
if {s==2} s.. c +[-3,-2] +.. 1 +^.. -$p1 ^... -$p2 a[-3,-1] c
else s.. c +[-4--2] +.. 1 +^.. -$p1 r. 100%,100%,100%,2 ^... -$p2 a[-3,-1] c
fi
eigen2tensor
endl done v +
#@cli edges : _threshold[%]>=0
#@cli : Estimate contours of selected images.
#@cli : Default value: 'edges=15%'
#@cli : $ image.jpg +edges 15%
edges : skip ${1=15%}
e[^-1] "Estimate image contours of image$?, with threshold $1."
v - gradient_norm b 0.5 >= $1 distance 0 equalize negate c 30%,70% n 0,1 v +
#@cli erode : size>=0 : size_x>=0,size_y>=0,_size_z>=0 : [kernel],_boundary_conditions,_is_real={ 0=binary-mode | 1=real-mode } : (+)
#@cli : Erode selected images by a rectangular or the specified structuring element.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_z=1', 'boundary_conditions=1' and 'is_real=0'.
#@cli : $ image.jpg +erode 10
#@cli erode_circ : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply circular erosion of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +erode_circ 7
erode_circ : check $1>=0 skip ${2=1},${3=0}
e[^-1] "Apply circular erosion of image$? by size $1, boundary conditions $2 and is_normalized $3."
if {$1<2} return fi
v - shape_circle $1 erode[^-1] .,$2,$3 rm. v +
#@cli erode_oct : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply octagonal erosion of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +erode_oct 7
erode_oct : check $1>=0 skip ${2=1},${3=0}
e[^-1] "Apply octagonal erosion of image$? by size $1, boundary conditions $2 and is_normalized $3."
if {$1<2} return fi
v -
if {$1&1} ss={$1} else ss={$1+1} fi
i[0] (0,1,0;1,1,1;0,1,0) i[1] (1,1,1;1,1,1;1,1,1)
repeat {$!-2}
r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
q={round(($ss-1)/(1+sqrt(2))/2)}
if {$r>0} repeat $r erode. [0],$2,$3 done fi
if {$q>0} repeat $q erode. [1],$2,$3 done fi
mv. 2 done rm[0,1] v +
#@cli erode_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary_conditions
#@cli : Erode selected images in the (X,Y,Z,I) space.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary_conditions=1'.
erode_threshold : check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
e[^-1] "Erode image$? with mask $1x$2x$3, threshold $4 and "${arg\ $5,dirichlet,neumann}" boundary conditions."
v - l[]
dx1={int($1/2)} dx2={$1-$dx1-1}
dy1={int($2/2)} dy2={$2-$dy1-1}
dz1={int($3/2)} dz2={$3-$dz1-1}
(-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) r $1,$2,$3,1,3 a c round r {w*h*d},3,1,1,-1 transpose.
i.. 1,100%,1,1,254 1,100%,1,1,255 a x
({'{^}'}) rm.. replace_str "254,","(v=j(" replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,1e20))" list={t}
rm
endl
f 'min($list)'
v +
#@cli fft : _{ x | y | z }...{ x | y | z } : (+)
#@cli : Compute the direct fourier transform (real and imaginary parts) of selected images,
#@cli : optionally along the specified axes only.
#@cli : $ image.jpg luminance +fft append[-2,-1] c norm[-1] log[-1] shift[-1] 50%,50%,0,0,2
#@cli : $ image.jpg w2={int(w/2)} h2={int(h/2)} fft shift $w2,$h2,0,0,2 ellipse $w2,$h2,30,30,0,1,0 shift -$w2,-$h2,0,0,2 ifft remove[-1]
#@cli : $$
#@cli g : eq. to 'gradient'. : (+)
#@cli gradient : { x | y | z }...{ x | y | z },_scheme : (no arg) : (+)
#@cli : Compute the gradient components (first derivatives) of selected images.
#@cli : (eq. to 'g').\n
#@cli : 'scheme' can be { -1=backward | 0=centered | 1=forward | 2=sobel | 3=rotation-invariant (default) | 4=deriche | 5=vanvliet }.
#@cli : (no arg) compute all significant 2D/3D components.
#@cli : Default value: 'scheme=3'.
#@cli : $ image.jpg gradient
#@cli : $$
#@cli gradient_norm
#@cli : Compute gradient norm of selected images.
#@cli : $ image.jpg gradient_norm equalize
#@cli : $$
gradient_norm :
e[^-1] "Compute gradient norm of image$?."
v - repeat $! l[$>]
+g x sqr.
+g.. y sqr. +[-2,-1]
g.. z sqr.. +[-2,-1]
s={s} s. c +[-$s--1] sqrt.
endl done v +
#@cli gradient_orientation : _dimension={1,2,3}
#@cli : Compute N-d gradient orientation of selected images.
#@cli : Default value: 'dimension=3'.
#@cli : $ image.jpg +gradient_orientation 2
gradient_orientation : check "${1=3}==1 || $1==2 || $1==3"
e[^-1] "Compute $1-d gradient orientation of image$?."
v - repeat $! l[$<]
if {$1==1} g x +abs. +. 1e-8 -/
elif {$1==2} g xy +sqr +[-2,-1] +. 1e-8 sqrt. /... . /[-2,-1]
else g xyz +sqr +[-3--1] +. 1e-8 sqrt. /[-4,-3] . /[-2,-1]
fi
endl done v +
#@cli guided : [guide],radius[%]>=0,regularization[%]>=0 : radius[%]>=0,regularization[%]>=0 : (+)
#@cli : Blur selected images by guided image filtering.
#@cli : If a guide image is provided, it is used to drive the smoothing process.
#@cli : A guide image must be of the same xyz-size as the selected images.
#@cli : This command implements the filtering algorithm described in:
#@cli : He, Kaiming; Sun, Jian; Tang, Xiaoou, "Guided Image Filtering," Pattern Analysis and Machine Intelligence,
#@cli : IEEE Transactions on , vol.35, no.6, pp.1397,1409, June 2013
#@cli : $ image.jpg +guided 5,400
#@cli haar : scale>0
#@cli : Compute the direct haar multiscale wavelet transform of selected images.
#@cli : $$
haar : check "isint(${1=1}) && $1>=0"
e[^-1] "Compute haar transform of image$? with $1 scales."
v - repeat $! l[$>]
_haar
repeat {$1-1}
w={max(0,round(w/2^(1+$>))-1)}
h={max(0,round(h/2^(1+$>))-1)}
d={max(0,round(d/2^(1+$>))-1)}
+z 0,0,0,$w,$h,$d _haar. j.. . rm.
done
endl done v +
_haar :
_haar_x _haar_y _haar_z
_haar_x :
if {w<=1} return fi
if {w%2} v + error[0--6] "Command 'haar': Invalid image width="{w}" (is not even)." fi
+shift -1 r 50% +-[1] [0] +[0,1] / {sqrt(2)} a x
_haar_y :
if {h<=1} return fi
if {h%2} v + error[0--6] "Command 'haar': Invalid image height="{h}" (is not even)." fi
+shift 0,-1 r 100%,50% +-[1] [0] +[0,1] / {sqrt(2)} a y
_haar_z :
if {d<=1} return fi
if {d%2} v + error[0--6] "Command 'haar': Invalid image depth="{h}" (is not even)." fi
+shift 0,0,-1 r 100%,100%,50% +-[1] [0] +[0,1] / {sqrt(2)} a z
#@cli heat_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the heat flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@cli : $ image.jpg +heat_flow 20
heat_flow : skip ${1=10},${2=30},${3=0}
e[^-1] "Apply $1 iterations of the heat flow on image$?, with time step $2."
v - pde_flow $1,$2,laplacian,$3 v +
#@cli hessian : { xx | xy | xz | yy | yz | zz }...{ xx | xy | xz | yy | yz | zz } : (no arg) : (+)
#@cli : Compute the hessian components (second derivatives) of selected images.
#@cli : (no arg) compute all significant components.
#@cli : $ image.jpg hessian
#@cli idct : _{ x | y | z }...{ x | y | z } : (no arg)
#@cli : Compute the inverse discrete cosine transform of selected images,
#@cli : optionally along the specified axes only.
#@cli : Default values: (no arg)
#@cli : $$ _dct-and-idct
idct : skip ${1=0}
v - ({'"$1"'})
is_axes={im>=_'x'" && "iM<=_'z'}
if $is_axes
v + e[0--3] "Compute inverse discrete cosine transform of image$? along axes '$1'." v -
repeat {w}
axis={i[$>]}
if {$axis==_'x'} repeat {$!-1} l[$>] if {w>1} _idct fi endl done
elif {$axis==_'y'} repeat {$!-1} l[$>] if {h>1} permute yxzc _idct permute yxzc fi endl done
elif {$axis==_'z'} repeat {$!-1} l[$>] if {d>1} permute zxyc _idct permute yzxc fi endl done
fi
done
else
rm.
v + e[0--3] "Compute inverse discrete cosine transform of image$?." v -
noarg
repeat $! l[$>]
if {w>1} _idct fi
if {h>1} permute yxzc _idct permute yxzc fi
if {d>1} permute zxyc _idct permute yzxc fi
endl done
fi
v +
_idct :
is_odd={w%2}
/ {sqrt(2/w)} +z[0] 0,0 *. {sqrt(2)} j.. .,0,0,0 rm.
if $is_odd r {w+1},100%,100%,100%,0,0 fi
+mirror x shift. 1 *. -1
100%,1,1,1,cos(x*pi/(2*w))
100%,1,1,1,sin(x*pi/(2*w))
+*[0,3] +*[1,2] +[-2,-1]
*[0,2] *[1,2] -[0,1]
ifft x k[0] / 2
s x,2 mirror. x
r[0] 200%,100%,1,100%,4,0,0
r[1] 200%,100%,1,100%,4,0,1
+
if $is_odd r {w-1},100%,100%,100%,0 fi
#@cli iee
#@cli : Compute gradient-orthogonal-directed 2nd derivative of image(s).
#@cli : $ image.jpg iee
iee :
e[^-1] "Compute gradient-orthogonal-directed 2nd derivative of image$?."
v - repeat $! l[$>]
if {d==1}
+g xy,0 hessian... xxxyyy
*... .. *[-4] . *[-4] -2
+[-4,-3] *... ..
sqr[-2,-1] *[-4] . +[-4,-3]
+[-2,-1] +. 1e-8 /
else
+inn laplacian.. -
fi
endl done v +
#@cli ifft : _{ x | y | z }...{ x | y | z } : (+)
#@cli : Compute the inverse fourier transform (real and imaginary parts) of selected images.
#@cli : optionally along the specified axes only.
#@cli : $$ _fft
#@cli ihaar : scale>0
#@cli : Compute the inverse haar multiscale wavelet transform of selected images.
ihaar : check "isint(${1=1}) && $1>=0"
e[^-1] "Compute inverse haar transform of image$? with $1 scales."
v - repeat $! l[$>]
repeat {$1-1}
w={max(0,round(w/2^(1+$<))-1)}
h={max(0,round(h/2^(1+$<))-1)}
d={max(0,round(d/2^(1+$<))-1)}
+z 0,0,0,$w,$h,$d _ihaar. j.. . rm.
done
_ihaar
endl done v +
_ihaar :
_ihaar_x _ihaar_y _ihaar_z
_ihaar_x :
if {w<=1} return fi
if {w%2} v + error[0--6] "Command 'ihaar': Invalid image width="{w}" (is not even)." fi
s x,2 r 200% (-1,1) *[-2,-1] + / {sqrt(2)}
_ihaar_y :
if {h<=1} return fi
if {h%2} v + error "Command 'ihaar': Invalid image height="{h}" (is not even)." fi
s y,2 r 100%,200% (-1;1) r. {-2,w} *[-2,-1] + / {sqrt(2)}
_ihaar_z :
if {d<=1} return fi
if {d%2} v + error "Command 'ihaar': Invalid image depth="{h}" (is not even)." fi
s z,2 r 100%,100%,200% (-1/1) r. {-2,w},{-2,h} *[-2,-1] + / {sqrt(2)}
#@cli ilaplacian : { nb_iterations>0 | 0 },_time_step>0,_[initial_estimate]
#@cli : Invert selected Laplacian images.
#@cli : If given 'nb_iterations' is '0', inversion is done in Fourier space (single iteration),
#@cli : otherwise, by applying 'nb_iterations' of a Laplacian-inversion PDE flow (with specified 'time_step').
#@cli : Note that the resulting inversions are just estimation of possible/approximated solutions.
#@cli : Default values: 'nb_iterations=0','time_step=10' and '[initial_estimated]=(undefined)'.
#@cli : $ image.jpg +laplacian +ilaplacian[-1] 0
ilaplacian : check "${1=0}>=0 && ${2=10}>0" skip "${3=}"
v - is_estimate=${"is_image_arg $3"} nb_iter={round($1)}
if {!$nb_iter}
if $is_estimate
v + e[0--4] "Invert Laplacian image$? in Fourier space, with initial estimate $3." v -
pass$3 1 ia=${-average_colors} rm.
else
v + e[0--4] "Invert Laplacian image$? in Fourier space." v -
ia=0
fi
repeat $! l[$>]
fft 100%,100%,1,1,"2*(cos(x*2*pi/w) + cos(y*2*pi/h)) - 4" =. 1
/[-3,-2] . rm.
= 0 ifft rm.
endl done + 'begin(S=resize([$ia],s,0));S'
else
if $is_estimate
v + e[0--4] "Invert Laplacian image$? using $1 iterations of PDE flow, with time step $2 and initial estimate $3." v -
repeat $! pass$3 0 l[$>,-1]
repeat $1 +laplacian. -. ... *. {$2/max(abs(im),abs(iM))} +[^0] done k.
endl done
else
v + e[0--4] "Invert Laplacian image$? using $1 iterations of PDE flow, with time step $2." v -
repeat $! l[$>] +f 0
repeat $1 +laplacian. -. ... *. {$2/max(abs(im),abs(iM))} +[^0] done k.
endl done
fi
fi
v +
#@cli inn
#@cli : Compute gradient-directed 2nd derivative of image(s).
#@cli : $ image.jpg inn
inn :
e[^-1] "Compute gradient-directed 2nd derivative of image$?."
v - repeat $! l[$>]
if {d==1}
+g xy,0 hessian... xxxyyy
*[-5] .. *[-4] . *[-4] 2
+[-5,-4] *[-4] ..
sqr[-2,-1] *... . +[-4,-3]
+[-2,-1] +. 1e-8 /
else
+g xyz,0 hessian[-4] xxxyxzyyyzzz
*[-9] ... *[-8] .. *[-8] 2 *[-7] . *[-7] 2
+[-9--7] *[-7] ...
*[-6] .. *[-5] . *[-5] 2
+[-6,-5] *[-5] .. +[-6,-5]
sqr[-3--1] *[-4] . +[-5,-4]
+[-3--1] +. 1e-8 /
fi
endl done v +
#@cli inpaint : [mask] : [mask],0,_fast_method : [mask],_patch_size>=1,_lookup_size>=1,_lookup_factor>=0,_lookup_increment!=0,_blend_size>=0,0<=_blend_threshold<=1,_blend_decay>=0,_blend_scales>=1,_is_blend_outer={ 0 | 1 } : (+)
#@cli : Inpaint selected images by specified mask.
#@cli : If no patch size (or 0) is specified, inpainting is done using a fast average or median algorithm.
#@cli : Otherwise, it used a patch-based reconstruction method, that can be very time consuming.
#@cli : 'fast_method' can be { 0=low-connectivity average | 1=high-connectivity average | 2=low-connectivity median | 3=high-connectivity median }.
#@cli : Default values: 'patch_size=0', 'fast_method=1', 'lookup_size=22', 'lookup_factor=0.5', 'lookup_increment=1', 'blend_size=0', 'blend_threshold=0', 'blend_decay=0.05', 'blend_scales=10' and 'is_blend_outer=1'.
#@cli : $ image.jpg 100%,100% ellipse 50%,50%,30,30,0,1,255 ellipse 20%,20%,30,10,0,1,255 +inpaint[-2] [-1] remove[-2]
#@cli : $ image.jpg 100%,100% circle 30%,30%,30,1,255,0,255 circle 70%,70%,50,1,255,0,255 +inpaint[0] [1],5,15,0.5,1,9,0 remove[1]
#@cli inpaint_diffusion : [mask],_nb_scales[%]>=0,_diffusion_type={ 0=isotropic | 1=delaunay-guided | 2=edge-guided | 3=mask-guided },_diffusion_iter>=0
#@cli : Inpaint selected images by specified mask using a multiscale transport-diffusion algorithm.
#@cli : If 'diffusion type==3', non-zero values of the mask (e.g. a distance function) are used to guide the diffusion process.
#@cli : Default values: 'nb_scales=75%', 'diffusion_type=1' and 'diffusion_iter=20'.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 +inpaint_diffusion[0] [1]
inpaint_diffusion : check ${is_image_arg\ $1}" && ${2=75%}>=0 && isint(${3=1}) && $3>=0 && $3<=3 && ${4=20}>=0"
v - s0="isotropic" s1="delaunay-guided" s2="edge-guided" s3="mask-guided"
v + e[^-1] "Inpaint image$? by mask $1, using a multiscale diffusion algorithm with $2 scales and $4 iterations of "${s$3}" diffusion." v -
repeat $! nm={n} pass$1 l[$>,-1]
nb_scalesM={ceil(log2(max(w,h,d)))}
nb_scales={round(${"is_percent $2"}?$nb_scalesM*$2:$2)}
nb_scales={max(1,min($nb_scales,$nb_scalesM))}
nb_iter={max(5,$4)}
repeat $nb_scales
{0,"S = 2^"$<"; round([ max(1,w/S), max(1,h/S), max(1,d/S), s ])"}
100%,100%,100%
eval[1] "const wl1 = w#-1 - 1;    const hl1 = h#-1 - 1;    const dl1 = d#-1 - 1;
const w1 = max(1,w - 1); const h1 = max(1,h - 1); const d1 = max(1,d - 1);
!i?(
X = round(x*wl1/w1); Y = round(y*hl1/h1); Z = round(z*dl1/d1);
I(#-2,X,Y,Z) += I(#0,x,y,z);
++i(#-1,X,Y,Z)
);I"
+max. 1 /[-3,-1] !=. 0
if {!$>}
im={-2,im} +-.. {$im-1} *. ..
+distance.. 1 *. -1 watershed.. . rm.
+. {$im-1} mv. -3
fi
if {$>>0" || "$nb_scales==1}
r... ..,3
if {$3==0}
repeat $nb_iter j... ..,0,0,0,0,1,. b... 0.5 done
elif {$3==1}
+distance. 1 100%,100%,100%,{d==1?2:3}
eval.. "*
const boundary = 1;
maxabs(a,b) = (abs(a)>abs(b)?a:b);
ix = maxabs(j(1) - i,i - j(-1));
iy = maxabs(j(0,1) - i,i - j(0,-1));
d>1?(
iz = maxabs(j(0,0,1) - i,i - j(0,0,-1));
copy(I(#-1),[ ix,iy,iz ],3,whd);
):copy(I(#-1),[ ix,iy ],2,whd)"
rm.. orientation.
repeat {$nb_iter}
j[-4] ...,0,0,0,0,1,..
+warp[-4] .,1,2,1 *.. -1 warp[-5] ..,1,2,1 +[-5,-1] /[-4] 2
done rm.
elif {$3==2}
repeat $nb_iter
+diffusiontensors... 0,1,1.5,0.5
j[-4] ...,0,0,0,0,1,..
smooth[-4] .,1,10,0 rm.
done
else
+r[1] .,2 g. a[-{d==1?2:3}--1] c orientation.
repeat $nb_iter
j[-4] ...,0,0,0,0,1,..
+warp[-4] .,1,2,1 *.. -1 warp[-5] ..,1,2,1 +[-5,-1] /[-4] 2
done rm.
fi
j... ..,0,0,0,0,1,.
fi
rm[-2,-1]
done
nm. $nm rv[0,-1] rm.
endl rm. done v +
#@cli inpaint_flow : [mask],_nb_global_iter>=0,_nb_local_iter>=0,_dt>0,_alpha>=0,_sigma>=0
#@cli : Apply iteration of the inpainting flow on selected images.
#@cli : Default values: 'nb_global_iter=4', 'nb_global_iter=15', 'dt=10', 'alpha=1' and 'sigma=3'.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 inpaint_flow[0] [1]
inpaint_flow : check ${is_image_arg\ $1}" && ${2=10}>=0 && ${3=100}>=0 && ${4=5}>0 && ${5=1}>=0 && ${6=3}>=0"
e[^-1] "Apply $2x$3 iterations of the inpainting flow on image$?, with mask $1, time step $4, alpha $5 and sigma $6."
v - repeat $! pass$1 0 l[$>,-1]
r. [0],[0],[0],1,0 inpaint.. [1]
repeat $2
progress {100*$>/($2-1)}
+diffusiontensors.. 0,1,$5,$6,0 *. .. smooth... .,$3,$4,0 rm.
done
progress 100
endl rm. done v +
#@cli inpaint_holes : maximal_area[%]>=0,_tolerance>=0,_is_high_connectivity={ 0 | 1 }
#@cli : Inpaint all connected regions having an area less than specified value.
#@cli : Default values: 'maximal_area=4', 'tolerance=0' and 'is_high_connectivity=0'.
#@cli : $ image.jpg noise 5%,2 +inpaint_holes 8,40
inpaint_holes : check "${1=4}>=0 && ${2=0}>=0" skip ${3=0}
e[^-1] "Inpaint holes with area less than $1 pixels in image$?, with tolerance $2 and "${arg\ 1+!$3,high,low}" connectivity."
v - repeat $! l[$>]
100%,100%,100%
area={if(${is_percent\ $1},$1*w*h*d,$1)}
repeat {0,s} sh[0] $> +area. $2,$3 <=. $1 -|[1,-1] rm. done
if {im} k[0] whd={w},{h},{d} r 1,1,1,100%,2 r $whd,100%
else inpaint[0] [1],0,{2*!$2+!!$3} k[0] fi
endl done v +
#@cli inpaint_morpho : [mask]
#@cli : Inpaint selected images by specified mask using morphological operators.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 +inpaint_morpho[0] [1]
inpaint_morpho : check ${is_image_arg\ $1}
e[^-1] "Inpaint image$? by mask $1, using morphological operators."
v - repeat $! pass$1 0 l[$>,-1]
nm={0,n} im={0,im} iM={0,iM} im1={$im-1} iM1={$iM+1}
channels. 0 ==. 0
+f[0] $im1 j. [0],0,0,0,0,1,..
do
+dilate. 3
replace.. $im1,$iM1
erode.. 3
replace.. $iM1,$im1
+[-2,-1] /. 2
j. ...,0,0,0,0,1,..
while {im==$im1}
k. nm $nm
endl done v +
#@cli inpaint_matchpatch : [mask],_nb_scales={ 0=auto | >0 },_patch_size>0,_nb_iterations_per_scale>0,_blend_size>=0,_allow_outer_blending={ 0 | 1 },_is_already_initialized={ 0 | 1 }
#@cli : Inpaint selected images by specified binary mask, using a multi-scale matchpatch algorithm.
#@cli : Default values: 'nb_scales=0', 'patch_size=9', 'nb_iterations_per_scale=10', 'blend_size=5', 'allow_outer_blending=1' and 'is_already_initialized=0'.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 +inpaint_matchpatch[0] [1]
inpaint_matchpatch : check ${is_image_arg\ $1}"&& ${2=0}>=0 && isint(${3=9}) && $3>0 && isint(${4=10}) && $4>0 && isint(${5=5}) && $5>=0" skip ${6=1},${7=0}
e[^-1] "Inpaint image$? with mask $1, using a multiscale patch-matching algorithm with "${"v - if $2 u \"$2 \" else u auto- fi v +"}\
"scales, $3x$3 patches, $4 iterations per scale and blending size $5."
v - repeat $! pass$1 0 l[$>,-1]
nm={0,n} nm img,mask
nb_scales={max(1,round(if($2,$2,log2(min(w,h)/16)),1,1))}
visu_size=${fitscreen[]" "{0,w},{0,h},1,25%,50%}
slices[img] 0 r[mask] [img],[img],1,1,0 !=[mask] 0
if {!$7} inpaint_diffusion[img] [mask],75% fi
im={img,im} -[img] $im
first_iter=1 iter=0
repeat $nb_scales
scale={100*(0.5^$<)}
v + e[] "> Process scale "{1+$>}"/"$nb_scales" -> "$scale% v -
progress {100*$>/max(1,$nb_scales-1)}
+r[img,mask] $scale%,$scale%,1,100%,2 nm[-2,-1] scaled_img,scaled_mask
>=[scaled_mask] 0.95
if {scaled_mask,!iM} rm[scaled_img,scaled_mask] continue fi
+f[scaled_img] -4096 +j[scaled_img] .,0,0,0,0,1,[scaled_mask] rm.. nm. scaled_reference
coef={0.5^($nb_scales-$iter)}
patch_size={v=round(max(min($3,5),$3*$coef));v+(1-(v%2))}
patch_size={min(w,h,$patch_size)}
blend_size={v=if($5,round(max(3,$5*$coef)));v+(1-(v%2))}
iter+=1
==[scaled_mask] 0
if $first_iter
100%,100%,1,1,x +f. y mv[scaled_mask] $! a[-3--1] c
matchpatch[scaled_img] [scaled_reference],$patch_size,$patch_size,1,4,4,0,0,.
rm[scaled_reference,-1]
nm. correspondence
first_iter=0
else
*[correspondence] 2 r[correspondence] 200%,200%,1,2 r[correspondence] [scaled_img],[scaled_img],1,2,0,1
100%,100%,1,1,x +f. y a[-2,-1] c
f[scaled_mask] "*if(i,1,
upc = i(#"$correspondence",x-1,y,0,0); vpc = i(#"$correspondence",x-1,y,0,1);
ucp = i(#"$correspondence",x,y-1,0,0); vcp = i(#"$correspondence",x,y-1,0,1);
ucc = i(#"$correspondence",x,y,0,0); vcc = i(#"$correspondence",x,y,0,1);
i(#-1,x,y,0,0) = (ucc==upc && vcc==vpc)?upc + 1:ucc;
i(#-1,x,y,0,1) = (ucc==ucp && vcc==vcp)?vcp + 1:vcc;
0)"
rm[correspondence] nm. correspondence
a[correspondence] [scaled_mask],c
nbs1={max(1,$nb_scales-1)}
nb_iter={round(max(1,$4*(($<+1)/$nbs1)^2))}
repeat $nb_iter
_inpaint_matchpatch[scaled_img] [correspondence],[scaled_mask],$blend_size,$6
+matchpatch[scaled_img] [scaled_reference],$patch_size,$patch_size,1,4,4,0,0,[correspondence]
j[correspondence] . rm.
if {*1} w1[scaled_img] $visu_size,0 fi
if {*2} w2[correspondence] $visu_size,1 fi
done
rm[scaled_img,scaled_mask,scaled_reference] channels[correspondence] 0,1
fi
done
progress 100
if $correspondence
==[mask] 0
_inpaint_matchpatch[img] [correspondence],[mask],$5,$6
rm[correspondence]
fi
+[img] $im
endl rm[mask] done v +
_inpaint_matchpatch :
pass$1 1 pass$2 {!$3" || "!$4}
if {!$3}
warp[0] [1],0,0,1
else
if $4 erode. $3 fi
f[0] "*begin(
boundary = 1;
const patch_size = $3;
const p2 = int(patch_size/2);
const p1 = patch_size - p2 - 1;
avg = resize([0],s#0);
wpq = resize([0],patch_size^2);
g = 0;
for (q = -p1, q<=p2, ++q,
for (p = -p1, p<=p2, ++p,
wpq[g++] = exp(-(p^2 + q^2)/(2*(0.3*patch_size)^2));
);
);
);
if (i#2,I,
g = 0;
avg = 0;
norm = 0;
for (q = -p1, q<=p2, ++q,
for (p = -p1, p<=p2, ++p,
U = I(#1,x + p,y + q);
w = wpq[g++];
norm+=w;
avg+=w*I(#0,U[0,2] - [p,q]);
);
);
avg/norm)"
fi
k[0]
_inpaint_warping2d :
repeat $! l[$>]
100%,100%,100%,2,"> begin(const S = s#0; zero0 = vectorS(); zero1 = [0,0]; N = 0); I(#-1)==zero0?zero1:[++N,1]"
s. c distance. 1 *. -1
watershed.. . rm.
repeat 2
f.. ">i?I:(
nP = vectors();
const sP = size(nP);
r = i(#-1);
(P = J(-1,-1))[0] && j(#-1,-1,-1)==r?(nP[0] = ++P[0]; nP[1] = ++P[1]; sP>2?copy(nP[2],P[2],sP-2)):
(P = J(0,-1))[0] && j(#-1,0,-1)==r  ?(nP[0] = P[0];   nP[1] = ++P[1]; sP>2?copy(nP[2],P[2],sP-2)):
(P = J(1,-1))[0] && j(#-1,1,-1)==r  ?(nP[0] = --P[0]; nP[1] = ++P[1]; sP>2?copy(nP[2],P[2],sP-2)):
(P = J(-1,0))[0] && j(#-1,-1,0)==r  ?(nP[0] = ++P[0]; nP[1] = P[1]; sP>2?copy(nP[2],P[2],sP-2));
nP)"
f.. "<i?I:(
nP = vectors();
const sP = size(nP);
r = i(#-1);
(P = J(1,1))[0] && j(#-1,1,1)==r  ?(nP[0] = --P[0]; nP[1] = --P[1]; sP>2?copy(nP[2],P[2],sP-2)):
(P = J(0,1))[0] && j(#-1,0,1)==r  ?(nP[0] = P[0];   nP[1] = --P[1]; sP>2?copy(nP[2],P[2],sP-2)):
(P = J(-1,1))[0] && j(#-1,-1,1)==r?(nP[0] = ++P[0]; nP[1] = --P[1]; sP>2?copy(nP[2],P[2],sP-2)):
(P = J(1,0))[0] && j(#-1,1,0)==r  ?(nP[0] = --P[0]; nP[1] = P[1]; sP>2?copy(nP[2],P[2],sP-2));
nP)"
done
rm.
endl done
#@cli kuwahara : size>0
#@cli : Apply Kuwahara filter of specified size on selected images.
#@cli : $ image.jpg +kuwahara 5
kuwahara : check $1>0
e[^-1] "Apply Kuwahara filter of size $1 on image$?."
v - repeat $! l[$>]
s={s}
+dilate $1 compose_channels. min
+erode[0] $1 compose_channels. max
-[-2,-1]
$1,1,1,1,{1/$1} convolve[0] . transpose. convolve[0] . rm.
p={int($1/2)}
a[-2,-1] c
f "v1=i(x-"$p",y-"$p",0,"$s",0,1); \
v2=i(x+"$p",y-"$p",0,"$s",0,1); \
v3=i(x-"$p",y+"$p",0,"$s",0,1); \
v4=i(x+"$p",y+"$p",0,"$s",0,1); \
vm=min(v1,v2,v3,v4); \
if(c>="$s",i, \
if(vm==v1,i(x-"$p",y-"$p",0,c,0,1),
if(vm==v2,i(x+"$p",y-"$p",0,c,0,1),
if(vm==v3,i(x-"$p",y+"$p",0,c,0,1),
i(x+"$p",y+"$p",0,c,0,1)))))"
channels 0,{s-2}
endl done v +
#@cli laplacian
#@cli : Compute Laplacian of selected images.
#@cli : $ image.jpg laplacian
laplacian :
e[^-1] "Compute Laplacian of image$?."
v - repeat $! l[$>]
hessian ${arg\ 1+(d==1),xxyyzz,xxyy} +
endl done v +
#@cli lic : _amplitude>0,_channels>0
#@cli : Render LIC representation of selected vector fields.
#@cli : Default values: 'amplitude=30' and 'channels=1'.
#@cli : $ 400,400,1,2,'if(c==0,x-w/2,y-h/2)' +lic 200,3 quiver[-2] [-2],10,1,1,1,255
lic : skip ${1=30},${2=1}
e[^-1] "Render LIC representation of 2D vector field$?, with amplitude $1 and $2 channel(s)."
v - repeat $! l[$>] nm={0,n}
channels 0,1 / {max(abs(im),abs(iM))} vector2tensor
100%,100%,100%,$2 rand. 0,255 smooth. ..,$1 rm..
equalize
nm $nm endl done v +
#@cli map_tones : _threshold>=0,_gamma>=0,_smoothness>=0,nb_iter>=0
#@cli : Apply tone mapping operator on selected images, based on Poisson equation.
#@cli : Default values: 'threshold=0.1', 'gamma=0.8', 'smoothness=0.5' and 'nb_iter=30'.
#@cli : $ image.jpg +map_tones ,
map_tones : skip ${1=0.1},${2=0.8},${3=0.5},${4=30}
e[^-1] "Apply tone mapping operator on image$?, with threshold $1, gamma $2, smoothness $3 and $4 iterations."
v - repeat $! l[$>]
+l s c repeat $! l[$>]
g xy,1 a c +norm orientation..
m={im} M={iM} b. $3 n. $m,$M
*. 'alpha=$1*iM;(alpha/(1e-10+i))*(i/(1e-10+alpha))^$2'
* s c g.. x,-1 g. y,-1 +
endl done a c * 0.25 endl
repeat $4 +laplacian.. *. 0.25 +. ... -. .. *. 800 +[-3,-1] /.. 801 c.. 0,255 done rm.
endl done  v +
#@cli map_tones_fast : _radius[%]>=0,_power>=0
#@cli : Apply fast tone mapping operator on selected images.
#@cli : Default values: 'radius=3%' and 'power=0.3'.
#@cli : $ image.jpg +map_tones_fast ,
map_tones_fast : check "${1=3%}>=0 && ${2=0.3}>=0"
e[^-1] "Apply fast tone mapping operator on image$?, with radius $1 and power $2."
v - repeat $! l[$>]
+luminance b. $1 n 0,1
+*. 2 -. 1 abs. *. {$2*log(10)} exp.
<=.. 0.5 r. ...
+*... -1 +. 1 ^. .. *. -1 +. 1 *. ...
^[-4,-2] ==.. 0 *[-3,-2] +
endl done n 0,255 v +
#@cli meancurvature_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the mean curvature flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@cli : $ image.jpg +meancurvature_flow 20
meancurvature_flow : skip ${1=10},${2=30},${3=0}
e[^-1] "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
v - pde_flow $1,$2,iee,$3 v +
#@cli median : size>=0,_threshold>0 : (+)
#@cli : Apply (opt. thresholded) median filter on selected images with structuring element size x size.
#@cli : $ image.jpg +median 5
#@cli nlmeans : [guide],_patch_radius>0,_spatial_bandwidth>0,_tonal_bandwidth>0,_patch_measure_command : _patch_radius>0,_spatial_bandwidth>0,_tonal_bandwidth>0,_patch_measure_command
#@cli : Apply non local means denoising of Buades et al, 2005. on selected images.
#@cli : The patch is a gaussian function of 'std _patch_radius'.
#@cli : The spatial kernel is a rectangle of radius 'spatial_bandwidth'.
#@cli : The tonal kernel is exponential (exp(-d^2/_tonal_bandwidth^2))
#@cli : with d the euclidiean distance between image patches.
#@cli : Default values: 'patch_radius=4', 'spatial_bandwidth=4', 'tonal_bandwidth=10' and 'patch_measure_command=-norm'.
#@cli : $ image.jpg +noise 10 nlmeans[-1] 4,4,{0.6*${-std_noise}}
nlmeans:
v -
if ${"is_image_arg $1"}
check "${2=4}>0 && ${3=4}>0 && ${4=10}>0" skip "${5=-norm}"
e[^-1] "Apply non-local means denoising on image$?, with guide $1, patch size $2, spatial bandwidth $3, tonal bandwidth $4 and patch measure command '$5'."
pass$1 0 l. $5 k[0] endl
repeat {$!-1} l[$>,-1]
100%,100%,100%,100%,{-1.0/($4*$4)}
nlmeans_core[0] [1],[2],$2,$3 rm.
endl done
rm.
else
check "${1=4}>0 && ${2=4}>0 && ${3=10}>0" skip "${4=-norm}"
e[^-1] "Apply non-local means denoising on image$?, with patch size $1, spatial bandwidth $2, tonal bandwidth $3 and patch measure command '$4'."
repeat $! l[$>]
+l $4 k[0] endl
100%,100%,100%,100%,{-1.0/($3*$3)}
nlmeans_core[0] [1],[2],$1,$2 k[0]
endl done
fi v +
#@cli nlmeans_core: _reference_image,_scaling_map,_patch_radius>0,_spatial_bandwidth>0
#@cli : Apply non local means denoising using a image for weight and a map for scaling
nlmeans_core : check ${is_image_arg\ $1}" && "${is_image_arg\ $2}" && $3>0 && $4>0"
e[^-1] "Apply non-local means denoising using weight images $1, scaling map $2, patch size $3 and spatial bandwidth $4."
v - pass$1 0 pass$2 0
repeat {$!-2} l[$>,-1,-2]
100%,100%,100%,{0,s},0 100%,100%,100%,{1,s},0 100%,100%,100%,{1,s},0
if {{0,d}==1}
repeat {2*$4+1} j={$>-$4} repeat {2*$4+1} i={$>-$4}
if {$i!=0||$j!=0}
+shift[0,1] $i,$j,0,0,2 -[7] [1]
sqr[7] b[7] $3 *[7] [2] exp[7]
*[6] [7] max[5] [7] +[4,7] +[3,6]
fi
done done
else
repeat {2*$4+1} k={$>-$4} repeat {2*$4+1} j={$>-$4} repeat {2*$4+1} i={$>-$4}
if {$i!=0||$j!=0||$k!=0}
+shift[0,1] $i,$j,0,0,2 -[7] [1]
sqr[7] b[7] $3 *[7] [2] exp[7]
*[6] [7] max[5] [7] +[4,7] +[3,6]
fi
done done done
fi
max[5] 1e-6 rm[1,2]
*[0] [3] +[1,0] +[1,2]
/
endl done v +
#@cli normalize_local : _amplitude>=0,_radius>0,_n_smooth>=0[%],_a_smooth>=0[%],_is_cut={ 0 | 1 },_min=0,_max=255
#@cli : Normalize selected images locally.
#@cli : Default values: 'amplitude=3', 'radius=16', 'n_smooth=4%', 'a_smooth=2%', 'is_cut=1', 'min=0' and 'max=255'.
#@cli : $ image.jpg normalize_local 8,10
normalize_local :
check "${1=3}>=0 && ${2=16}>0 && isbool(${5=1})" skip ${3=4%},${4=2%},${6=0},${7=255}
e[^-1] "Normalize image$? locally, with amplitude $1, radius $2, neighborhood smoothness $3 and average smoothness $4."
v - repeat $! l[$>]
+l erode {2*$2+1} s c min endl
+l.. dilate {2*$2+1} s c max endl
+b... $4 b[-3,-2] $3
+-.. ... +. 0.01 -[-5] [-4] /[-5,-1]
*[-3,-2] {$1+1} *. -$1 +... . +[-2,-1]
if $5 max.. $6 min. $7 fi
-. .. *[-3,-1] +
if $5 c $6,$7 fi
endl done v +
#@cli normalized_cross_correlation : [mask]
#@cli : Compute normalized cross-correlation of selected images with specified mask.
#@cli : $ image.jpg +shift -30,-20 +normalized_cross_correlation[0] [1]
normalized_cross_correlation : check ${is_image_arg\ $1}
e[^-1] "Compute normalized cross-correlation of image$? with mask $1."
v - pass$1 0 norm repeat {$!-1} . l[$>,-1]
fft.. fft. [-2,-1] *.. [-5] *. [-6]
-[-2,-1] *[-5,-3] *[-3,-2] +[-3,-2] [-2,-1] a[-2,-1] c norm.
/... . /[-2,-1] ifft rm.
endl done rm. v +
#@cli peronamalik_flow : K_factor>0,_nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the Perona-Malik flow on selected images.
#@cli : Default values: 'K_factor=20', 'nb_iter=5', 'dt=5' and 'keep_sequence=0'.
#@cli : $ image.jpg +heat_flow 20
peronamalik_flow : check "${1=20}>0 && ${2=5}>=0" skip ${3=5},${4=0}
e[^-1] "Apply $2 iterations of the Perona-Malik flow on image$?, with K factor $1 and time step $3."
v -
m "_peronamalik_flow :
+gradient xy,0 a[-2,-1] c norm. b. 0.8 /. $1 sqr. *. -1 exp. a[-2,-1] c
f. '\"s1=s-1;
C=i(x,y,z,s-1);
if(c>=s1,0,
(C+i(x+1,y,z,s-1,0,1))*(j(1,0,0,0,0,1)-i) -
(C+i(x-1,y,z,s-1,0,1))*(i-j(-1,0,0,0,0,1)) +
(C+i(x,y+1,z,s-1,0,1))*(j(0,1,0,0,0,1)-i) -
(C+i(x,y-1,z,s-1,0,1))*(i-j(0,-1,0,0,0,1)))\"'"
pde_flow $2,$3,_peronamalik_flow,$4
uncommand _peronamalik_flow
v +
#@cli phase_correlation : [destination]
#@cli : Estimate translation vector between selected source images and specified destination.
#@cli : $ image.jpg +shift -30,-20 +phase_correlation[0] [1] unroll[-1] y
phase_correlation : check ${is_image_arg\ $1}
e[^-1] "Estimate shift between source image$? and destination $1."
v - repeat $! pass$1
normalized_cross_correlation[$>] . rm.
l[$>]
({[xM,yM,zM,cM]}) *. 2 s. x rm.
if {{-3,^}>{-4,w}} -... {-4,w} -... {-4,w} fi
if {{-2,^}>{-4,h}} -.. {-4,h} -.. {-4,h} fi
if {{^}>{-4,d}} -. {-4,d} -. {-4,d} fi
a[-3--1] c rm.. / 2 * -1
nm [phase\ correlation]
endl done v +
#@cli pde_flow : _nb_iter>=0,_dt,_velocity_command,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of a generic PDE flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30', 'velocity_command=laplacian' and 'keep_sequence=0'.
#@cli : $ image.jpg +pde_flow 20
pde_flow : skip ${1=10},${2=30},${3=laplacian},${4=0}
e[^-1] "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
v - repeat $! l[$<]
repeat $1
+$3. *. {$2/(0.01+max(abs(im),abs(iM)))}
if $4 +. .. else +[-2,-1] fi
done
if $4 rm[0] fi
a x
endl done
if $4 s x,$1 fi v +
#@cli periodize_poisson
#@cli : Periodize selected images using a Poisson solver in Fourier space.
#@cli : $ image.jpg +periodize_poisson array 2,2,2
periodize_poisson :
e[^-1] "Periodize image$? using Poisson solver in Fourier space."
v - repeat $! l[$>]
s c repeat $! l[$>]
mM={[im,iM]} sum={0,ia}
laplacian ilaplacian 0 + $sum c $mM
endl done a c
endl done v +
#@cli red_eye : 0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1
#@cli : Attenuate red-eye effect in selected images.
#@cli : Default values: 'threshold=75', 'smoothness=3.5' and 'attenuation=0.1'.
#@cli : $ image.jpg +red_eye ,
red_eye : skip ${1=75},${2=3.5},${3=0.1}
e[^-1] "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
v - to_rgb rgb2ycbcr repeat $! l[$>]
s c -. 128 +>=. $1% b. $2 sqrt. *. -1 +. 1
n. $3,1 *[-2,-1] +. 128 a c ycbcr2rgb
endl done v +
#@cli remove_hotpixels : _mask_size>0, _threshold[%]>0
#@cli : Remove hot pixels in selected images.
#@cli : Default values: 'mask_size=3' and 'threshold=10%'.
#@cli : $ image.jpg noise 10,2 +remove_hotpixels ,
remove_hotpixels : check ${1=3}>0 skip ${2=10%}
e[^-1] "Remove hot pixels in image$?, with mask size $1 and threshold $2."
v - repeat $! l[$>]
+median $1 +- abs. >=. $2
*.. . ==. 0 *[-3,-1] +
endl done v +
#@cli remove_pixels : number_of_pixels[%]>=0
#@cli : Remove specified number of pixels (i.e. set them to 0) from the set of non-zero pixels in selected images.
#@cli : $ image.jpg +remove_pixels 50%
remove_pixels : check "$1>=0"
e[^-1] "Remove $1 of the non-zero pixels in image$?."
v - repeat $! l[$>]
+norm !=. 0
N={is}
n={round(if(${"is_percent $1"},$N*$1,$1))}
if {$n<=0} rm.
elif {$n>=$N} rm. f 0
elif {$n>int($N/2)}
remove_pixels. {$N-$n} ==. 0 *
else
d={d} r 100%,{d*h},1,100%,-1
100%,1,1,1,x 1,{-2,h},1,1,y +[-2,-1] 1 r[-2,-1] ..,.
*[-2,-1] ... rm...
y[-2,-1] a[-2,-1] x discard. y,0
do
1,100%,1,1 rand. 0,{h} <=. {$n*1.25}
if {is>=$n} break else rm. fi
while 1
r. 2 *[-2,-1] discard. y,0
i.. 1,100% rand.. 0,1 a[-2,-1] x sort. +,y
rows. 0,{$n-1} -. 1 z. 1,3
i.. ({'CImg3d'},{h},{h})
1,100%,1,1,1 1,100%,1,1,y a[-2,-1] x
3,100% 1,100%,1,1,1 y[-5--1] a[-5--1] y
if {0,s<=3} j3d.. .,0,0,0,1,0,0,0,0
else [0],[0],1,1,1 j3d. ..,0,0,0,1,0,0,0,0 *[0,-1]
fi
rm.
r 100%,{h/$d},$d,100%,-1
fi
endl done v +
#@cli rolling_guidance : std_deviation_s[%]>=0,std_deviation_r[%]>=0,_precision>=0
#@cli : Apply the rolling guidance filter on selected image.
#@cli : Rolling guidance filter is a fast image abstraction filter, described in:
#@cli : "Rolling Guidance Filter", Qi Zhang Xiaoyong, Shen Li, Xu Jiaya Jia, ECCV'2014.
#@cli : Default values: 'std_deviation_s=4', 'std_deviation_r=10' and 'precision=0.5'.
#@cli : $ image.jpg +rolling_guidance , +-
rolling_guidance : check "${1=4}>=0 && ${2=10}>=0 && ${3=0.5}>=0"
e[^-1] "Apply rolling guidance filter on image$?, with standard deviations ($1,$2) and precision $3."
v - precision={2^-$3}
repeat $! l[$>]
+b $1
repeat 100
if {c>1} +norm. +bilateral... .,$1,$2 rm..
else +bilateral.. .,$1,$2
fi
-.. . std={-2,sqrt(iv)} rm..
if {$std<$precision} break fi
done
k.
endl done v +
#@cli sharpen : amplitude>=0 : amplitude>=0,edge>=0,_alpha,_sigma : (+)
#@cli : Sharpen selected images by inverse diffusion or shock filters methods.
#@cli : 'edge' must be specified to enable shock-filter method.
#@cli : Default values: 'alpha=0' and 'sigma=0'.
#@cli : $ image.jpg sharpen 300
#@cli : $ image.jpg blur 5 sharpen 300,1
#@cli smooth : amplitude[%]>=0,_sharpness>=0,0<=_anisotropy<=1,_alpha[%],_sigma[%],_dl>0,_da>0,_precision>0,interpolation,_fast_approx={ 0 | 1 } : nb_iterations>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dt>0,0 : [tensor_field],_amplitude>=0,_dl>0,_da>0,_precision>0,_interpolation,_fast_approx={ 0 | 1 } : [tensor_field],_nb_iters>=0,_dt>0,0 : (+)
#@cli : Smooth selected images anisotropically using diffusion PDE's, with specified field of
#@cli : diffusion tensors.
#@cli : 'interpolation' can be { 0=nearest | 1=linear | 2=runge-kutta }.
#@cli : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1', 'dl=0.8', 'da=30', 'precision=2', 'interpolation=0' and 'fast_approx=1'.
#@cli : $ image.jpg repeat 3 smooth 40,0,1,1,2 done
#@cli : $ image.jpg 100%,100%,1,2 rand[-1] -100,100 repeat 2 smooth[-1] 100,0.2,1,4,4 done warp[0] [-1],1,1
#@cli : $$
#@cli split_freq : smoothness>0[%]
#@cli : Split selected images into low and high frequency parts.
#@cli : $ image.jpg split_freq 2%
split_freq :
e[^-1] "Split image$? into low and high frequency parts, with smoothness $1."
v - repeat $! l[$>] +b $1 -[0] [1] rv endl done v +
#@cli solve_poisson : "laplacian_command",_nb_iterations>=0,_time_step>0,_nb_scales>=0
#@cli : Solve Poisson equation so that applying 'laplacian[n]' is close to the result of 'laplacian_command[n]'.
#@cli : Solving is performed using a multi-scale gradient descent algorithm.
#@cli : If 'nb_scales=0', the number of scales is automatically determined.
#@cli : Default values: 'nb_iterations=60', 'dt=5' and 'nb_scales=0'.
#@cli : $ image.jpg command "foo : gradient x" +solve_poisson foo +foo[0] +laplacian[1]
solve_poisson : check "${2=60}>=0 && ${3=5}>0 && ${4=0}>=0"
e[^-1] "Solve Poisson equation for image$?, for laplacian command '$1', with $2 iterations, time step $3 and "${arg\ 1+($4==0),$4,auto}" scales."
v - repeat $! l[$>]
[0]
repeat {if($4,$4,int(max(log2(max(w,h))-1,1)))}
f={2^$<}
r[1] {0,max(1,w/$f)},{0,max(1,h/$f)},1,100%,3
+r[0] [1],2 l. -$1 k[0] endl
repeat $2 +laplacian.. -. .. *. {$3/max(1e-8,abs(im),abs(iM))} +[-3,-1] done
rm.
done
rm[0]
endl done v +
#@cli split_details : _nb_scales>0,_base_scale[%]>=0,_detail_scale[%]>=0
#@cli : Split selected images into 'nb_scales' detail scales.
#@cli : If 'base_scale'=='detail_scale'==0, the image decomposition is done with 'a trous' wavelets.
#@cli : Otherwise, it uses laplacian pyramids with linear standard deviations.
#@cli : Default values: 'nb_scales=4', 'base_scale=0' and 'detail_scale=0'.
#@cli : $ image.jpg split_details ,
split_details : check "isint(${1=4}) && $1>0 && ${2=0}>=0 && ${3=0}>=0"
if {($2)==0" && "($3)==0}
e[^-1] "Split image$? using $1 spatial scales and 'a trous' wavelets."
v - repeat $! l[$<]
repeat {$1-1}
+f. "begin(interpolation = 0; boundary = 1; d = 2^"$>"; d2 = d*2);
i(x - d2) + i(x + d2) + 4*i(x - d) + 4*i(x + d) + 6*i;"
/. 16
if {h>1}
f. "begin(interpolation = 0; boundary = 1; d = 2^"$>"; d2 = d*2);
i(x,y - d2) + i(x,y + d2) + 4*i(x,y - d) + 4*i(x,y + d) + 6*i;"
/. 16
fi
if {d>1}
f. "begin(interpolation = 0; boundary = 1; d = 2^"$>"; d2 = d*2);
i(x,y,z - d2) + i(x,y,z + d2) + 4*i(x,y,z - d) + 4*i(x,y,z + d) + 6*i;"
/. 16
fi
-.. .
done rv
endl done v +
else
e[^-1] "Split image$? using $1 spatial scales with base scale $2 and detail scale $3."
v - repeat $! l[$<]
ss={max(0.3,if(${is_percent\ $2},$2*max(w,h),$2))}
se={max(0.3,if(${is_percent\ $3},$3*max(w,h),$3))}
ds={$se-$ss}
repeat {$1-1} +b. {$ss+$>*$ds/max(1,$1-2)} -.. . rv[-2,-1] done
endl done v +
fi
#@cli structuretensors : _scheme={ 0=centered | 1=forward/backward } : (+)
#@cli : Compute the structure tensor field of selected images.
#@cli : Default value: 'scheme=1'.
#@cli : $ image.jpg structuretensors abs pow 0.2
#@cli : $$
#@cli solidify : _smoothness[%]>=0,_diffusion_type={ 0=isotropic | 1=delaunay-oriented | 2=edge-oriented },_diffusion_iter>=0
#@cli : Solidify selected transparent images.
#@cli : Default values: 'smoothness=75%', 'diffusion_type=1' and 'diffusion_iter=20'.
#@cli : $ image.jpg 100%,100% circle[-1] 50%,50%,25%,1,255 append c +solidify , display_rgba
solidify : check "${1=75%}>=0 && isint(${2=1}) && $2>=0 && $2<=2 && ${3=20}>=0"
v - s0="isotropic" s1="delaunay-oriented" s2="edge-oriented"
v + e[^-1] "Solidify transparent image$? with smoothness $1 and $3 iterations of "${s$2}" diffusion." v -
repeat $! l[$>] split_opacity
if {$!>1} <=. 128 inpaint_diffusion.. [1],${1-3} rm. c 0,255 fi
endl done v +
#@cli syntexturize : _width[%]>0,_height[%]>0
#@cli : Resynthetize 'width'x'height' versions of selected micro-textures by phase randomization.
#@cli : The texture synthesis algorithm is a straightforward implementation of the method described in :
#@cli : http://www.ipol.im/pub/art/2011/ggm_rpn/
#@cli : Default values: 'width=height=100%'.
#@cli : $ image.jpg crop 2,282,50,328 +syntexturize 320,320
syntexturize : check "${1=100%}>0 && ${2=$1}>0"
e[^-1] "Resynthetize $1x$2 versions of texture$? by phase randomization."
v - repeat $! l[$>]
mM={[im,iM]} repeat {s} sh. $> sum$>={is} var$>={iv} rm. done
nw={if(${is_percent\ $1},$1*w,$1)}
nh={if(${is_percent\ $2},$2*h,$2)}
repeat {s} sum$>*={$nw*$nh/(w*h)} done
if {$nw>w||$nh>h}
periodize_poisson
100%,100% rectangle. 5,5,{w-6},{h-6},1,1 b. 2 n. 0,1
$nw,$nh,1,{-2,s} fc. ${average_colors...}
j. ...,{(w-{-2,w})/2},{(h-{-2,h})/2},0,0,1,..
rm[-3,-2]
else
r $nw,$nh,1,100%,0,0,0.5,0.5
periodize_poisson
fi
fft
100%,100% rand. {-pi},{pi}
=. 0
if {!(w%2)} =. {(u<0.5)*pi},{int(w/2)} fi
if {!(h%2)} =. {(u<0.5)*pi},0,{int(h/2)} fi
if {!(h%2)&&!(h%2)} =. {(u<0.5)*pi},{int(w/2)},{int(h/2)} fi
+sin. cos..
+*[-4,-1] +*[-4,-3] +[-2,-1]
*[-5,-3] *[-3,-2] -[-3,-2]
repeat {s} =.. ${sum$>},0,0,0,$> =. 0,0,0,0,$> done
ifft rm.
repeat {s} sh. $> avg={ia} -. $avg *. {sqrt(${var$>}/if(iv,iv,1))} +. $avg rm. done
c $mM
endl done v +
#@cli syntexturize_matchpatch : _width[%]>0,_height[%]>0,_nb_scales>=0,_patch_size>0,_blending_size>=0,_precision>=0
#@cli : Resynthetize 'width'x'height' versions of selected micro-textures using a patch-matching algorithm.
#@cli : If 'nbscales==0', the number of scales used is estimated from the image size.
#@cli : Default values: 'width=height=100%', 'nb_scales=0', 'patch_size=7', 'blending_size=5' and 'precision=1'.
#@cli : $ image.jpg crop 25%,25%,75%,75% syntexturize_matchpatch 512,512
syntexturize_matchpatch : check "${1=100%}>0 && ${2=$1}>0 && isint(${3=0}) && $3>=0 && isint(${4=7}) && $4>0 && ${5=5}>=0 && ${6=1}>=0"
e[^-1] "Resynthetize $1x$2 version(s) of texture$? using a patch-matching algorithm with "${"v - if $3 u \"$3 \" else u auto- fi v +"}"scales, $4x$4 patches, blending size $5 and precision $6."
v - repeat $! l[$>]
nb_scales={round(if($3,$3,log2(min(w,h)/16)),1,1)}
width={if(${"is_percent $1"},round(w*$1,1,1),$1)}
height={if(${"is_percent $2"},round(h*$2,1,1),$2)}
repeat $nb_scales
scale={100*(0.5^$<)}
+r[0] $scale%,$scale%,1,3,2
if {!$>}
{1+round(w*$width/{0,w},1,1)},{1+round(h*$height/{0,h},1,1)},1,1
noise. 0.2,2 ==. 1 +distance. 1 *. -1
label_fg.. 0 watershed.. . rm.
100%,100%,1,1,x +f. y a[-2,-1] c channels. 0,2
+blend. ..,shapeaverage -.. . rm.
channels. 0,1
{-2,iM+1} rand. 0,{-4,w} +rand. 0,{-4,h} a[-2,-1] c
map... . rm. +[-2,-1] round.
s. c %.. {-3,w} %. {-3,h} a[-2,-1] c
else
rv[-2,-1] channels. 0,1
*. 2 r. 200%,200%,1,2,1
f. "*upc = i(x - 1,y,0,0);
vpc = i(x - 1,y,0,1);
ucp = i(x,y - 1,0,0);
vcp = i(x,y - 1,0,1);
ucc = i(x,y,0,0);
vcc = i(x,y,0,1);
if (ucc==upc && vcc==vpc && c==0, upc + 1,
if (ucc==ucp && vcc==vcp && c==1, vcp + 1,i))"
fi
psize={-2,min(w,h,$4)}
repeat {1+$6*$<}
psynth={int(max(3,$5*$scale%))}
+warp_patch.. .,$psynth
matchpatch. ...,$psize,$psize,1,4,4,0,0,.. rm..
done
rm..
done
warp_patch.. .,$5
rm. r $width,$height,1,100%,0,0,0.5,0.5
endl done v +
_syntexturize_matchpatch : check ${is_image_arg\ $1}" && isint(${2=3}) && $2>=0"
if {$2<=1} pass$1 warp[^-1] .,0 rm.
else repeat $! pass$1 l[$>,-1]
[1],[1],1,[0]
f. "*begin(
boundary = 1;
const patch_size = $2;
const p2 = int(patch_size/2);
const p1 = patch_size - p2 - 1;
avg = resize([0],s#0);
wpq = resize([0],patch_size^2);
g = 0;
for (q = -p1, q<=p2, ++q,
for (p = -p1, p<=p2, ++p,
wpq[g++] = exp(-(p^2 + q^2)/(2*(0.3*patch_size)^2));
);
);
);
g = 0;
avg = 0;
norm = 0;
for (q = -p1, q<=p2, ++q,
for (p = -p1, p<=p2, ++p,
U = I(#1,x + p,y + q);
w = wpq[g++];
avg+=w*I(#0,U - [p,q]);
norm+=w;
);
);
avg/norm"
k.
endl done fi
#@cli tv_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the total variation flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@cli : $ image.jpg +tv_flow 40
tv_flow : skip ${1=10},${2=30},${3=0}
e[^-1] "Apply $1 iterations of the total variation flow on image$?, with time step $2."
v - pde_flow $1,$2,curvature,$3 v +
#@cli unsharp : radius[%]>=0,_amount>=0,_threshold[%]>=0
#@cli : Apply unsharp mask on selected images.
#@cli : Default values: 'amount=2' and 'threshold=0'.
#@cli : $ image.jpg blur 3 +unsharp 1.5,15 cut 0,255
unsharp : check "${2=2}>=0" skip ${3=0}
e[^-1] "Apply unsharp mask on image$?, with radius $1, amount $2 and threshold $3."
v - repeat $!
+b[$>] $1 -. [$>]
if $3 +norm. >=. $3 *[-2,-1] fi
*. $2 -[$>,-1]
done v +
#@cli unsharp_octave : _nb_scales>0,_radius[%]>=0,_amount>=0,threshold[%]>=0
#@cli : Apply octave sharpening on selected images.
#@cli : Default values: 'nb_scales=4', 'radius=1', 'amount=2' and 'threshold=0'.
#@cli : $ image.jpg blur 3 +unsharp_octave 4,5,15 cut 0,255
unsharp_octave : check "${1=4}>0 && ${3=2}>=0" skip ${2=1},${4=0}
e[^-1] "Apply octave sharpening on image$?, with $1 scales, radius $2, amount $3 and threshold $4."
v - repeat $! l[$>] nm={0,n}
+f 0 weight=0
repeat $1
+unsharp[0] {$2*2^-$<},$3,$4 *. {2^-$>}
weight+={2^-$>}
+[1,-1]
done
rm[0] / $weight
nm $nm endl done v +
#@cli vanvliet : std_deviation>=0[%],order={ 0 | 1 | 2 | 3 },axis={ x | y | z | c },_boundary_conditions : (+)
#@cli : Apply Vanvliet recursive filter on selected images, along specified axis and with
#@cli : specified standard deviation, order and boundary conditions.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +vanvliet 3,1,x
#@cli : $ image.jpg +vanvliet 30,0,x vanvliet[-2] 30,0,y add
#@cli voronoi
#@cli : Compute the discrete Voronoi diagram of non-zero pixels in selected images.
#@cli : $ 400,400 noise 0.2,2 eq 1 +label_fg 0 voronoi[-1] +gradient[-1] xy,1 append[-2,-1] c norm[-1] ==[-1] 0 map[-2] 2,2 mul[-2,-1] normalize[-2] 0,255 dilate_circ[-2] 4 reverse max
voronoi :
e[^-1] "Compute the discrete Voronoi diagram of non-zero pixels in image$?."
v - repeat $! l[$>] s c repeat $! l[$>]
+!=. 0 distance. 1 *. -1
watershed.. . rm.
endl done a c endl done v +
#@cli watermark_fourier : text,_size>0
#@cli : Add a textual watermark in the frequency domain of selected images.
#@cli : Default value: 'size=33'.
#@cli : $ image.jpg +watermark_fourier "Watermarked!" +display_fft remove[-3,-1] normalize 0,255 append[-4,-2] y append[-2,-1] y
watermark_fourier : check ${2=33}>0
e[^-1] "Add textual watermark '$1' with size $2 in the frequency domain of image$?."
v - i[0] 0 t[0] "$1",0,0,$2,1,1 >=[0] 0.5 autocrop[0] 0
repeat {$!-1} w2={int(w/2)} h2={int(h/2)}
fft.
shift[-2,-1] $w2,$h2,0,0,2
[0],[0],1,{s}
j[-3,-2] .,3,3,0,0,1,[0]
mirror[0] x
j[-3,-2] .,{{-2,w}-2-{0,w}},3,0,0,1,[0]
mirror[0] y
j[-3,-2] .,{{-2,w}-2-{0,w}},{{-2,h}-2-{0,h}},0,0,1,[0]
mirror[0] x
j[-3,-2] .,3,{{-2,h}-2-{0,h}},0,0,1,[0]
mirror[0] y
rm.
shift[-2,-1] -$w2,-$h2,0,0,2
ifft[-2,-1] rm.
mv. 1 done
rm[0] v +
#@cli watershed : [priority_image],_is_high_connectivity={ 0 | 1 } : (+)
#@cli : Compute the watershed transform of selected images.
#@cli : Default value: 'is_high_connectivity=1'.
#@cli : $ 400,400 noise 0.2,2 eq 1 +distance 1 mul[-1] -1 label[-2] watershed[-2] [-1] mod[-2] 256 map[-2] 0 reverse
#@cli :: Features Extraction
#@cli area : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@cli : Compute area of connected components in selected images.
#@cli : Default values: 'is_high_connectivity=0'.
#@cli : $ image.jpg luminance stencil[-1] 1 +area 0
#@cli : $$
area : check "$1>=0" skip ${2=0}
e[^-1] "Compute area of connected components in image$?, with tolerance $1 and "${arg\ 1+!$2,high,low}" connectivity."
v - repeat $! l[$>] s c
repeat $! label[$>] $1,$2 nb={$>,1+iM} +histogram[$>] $nb,0,{$nb-1} map[$>] . rm. done
a c endl done v +
#@cli area_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@cli : Compute area of connected components for non-zero values in selected images.
#@cli : Similar to 'area' except that 0-valued pixels are not considered.
#@cli : Default values: 'is_high_connectivity=0'.
#@cli : $ image.jpg luminance stencil[-1] 1 +area_fg 0
area_fg : check "$1>=0" skip ${2=0}
e[^-1] "Compute area of foreground connected components in image$?, with tolerance $1 and "${arg\ 1+!$2,high,low}" connectivity."
v - repeat $! l[$>] s c
repeat $! label_fg[$>] $1,$2 nb={$>,1+iM} +histogram[$>] $nb,0,{$nb-1} =. 0 map[$>] . rm. done
a c endl done v +
#@cli at_line : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%]
#@cli : Retrieve pixels of the selected images belonging to the specified line (x0,y0,z0)-(x1,y1,z1).
#@cli : $ image.jpg +at_line 0,0,0,100%,100%,0
at_line : check ${7=100%}>=0
e[^-1] "Retrieve pixels of image$?, belonging to line ($1,$2,$3)-($4,$5,$6)."
v - repeat $! l[$>]
x0={if(${is_percent\ $1},(w-1)*$1,$1)}
y0={if(${is_percent\ $2},(h-1)*$2,$2)}
z0={if(${is_percent\ $3},(d-1)*$3,$3)}
x1={if(${is_percent\ $4},(w-1)*$4,$4)}
y1={if(${is_percent\ $5},(h-1)*$5,$5)}
z1={if(${is_percent\ $6},(d-1)*$6,$6)}
($x0,$x1^$y0,$y1^$z0,$z1)
r. {1+max(abs($x1-$x0),abs($y1-$y0),abs($z1-$z0))},1,1,3,3
round. 1 warp[0] .,0,0,0 rm.
endl done v +
#@cli at_quadrangle : x0[%],y0[%],x1[%],y1[%],x2[%],y2[%],x3[%],y3[%],_interpolation,_boundary_conditions : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%],x2[%],y2[%],z2[%],x3[%],y3[%],z3[%],_interpolation,_boundary_conditions
#@cli : Retrieve pixels of the selected images belonging to the specified 2D or 3D quadrangle.
#@cli : 'interpolation' can be { 0=nearest-neighbor | 1=linear | 2=cubic }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : $ image.jpg params=5%,5%,95%,5%,60%,95%,40%,95% +at_quadrangle $params polygon.. 4,$params,0.5,255
at_quadrangle : check "$#>=8 && $#<=14 && $#!=11"
_at_quadrangle{$#<12?2:3} $*
_at_quadrangle2 : check "${9=1}>=0 && $9<=2 && ${10=0}>=0 && $10<=3"
repeat $! l[$>]
x0={round(${"is_percent $1"}?(w-1)*$1:$1)}
y0={round(${"is_percent $2"}?(h-1)*$2:$2)}
x1={round(${"is_percent $3"}?(w-1)*$3:$3)}
y1={round(${"is_percent $4"}?(h-1)*$4:$4)}
x2={round(${"is_percent $5"}?(w-1)*$5:$5)}
y2={round(${"is_percent $6"}?(h-1)*$6:$6)}
x3={round(${"is_percent $7"}?(w-1)*$7:$7)}
y3={round(${"is_percent $8"}?(h-1)*$8:$8)}
($x0,$x1;$x3,$x2^$y0,$y1;$y3,$y2)
r. {P0=[$x0,$y0];P1=[$x1,$y1];P2=[$x2,$y2];P3=[$x3,$y3];1+round([max(norm(P1-P0),norm(P3-P2)),max(norm(P3-P0),norm(P2-P1))])},1,2,3
warp.. .,0,$9,$10 rm.
endl done
_at_quadrangle3 : check "${13=1}>=0 && $13<=2 && ${14=0}>=0 && $14<=3"
repeat $! l[$>]
x0={round(${"is_percent $1"}?(w-1)*$1:$1)}
y0={round(${"is_percent $2"}?(h-1)*$2:$2)}
z0={round(${"is_percent $3"}?(h-1)*$3:$3)}
x1={round(${"is_percent $4"}?(w-1)*$4:$4)}
y1={round(${"is_percent $5"}?(h-1)*$5:$5)}
z1={round(${"is_percent $6"}?(h-1)*$6:$6)}
x2={round(${"is_percent $7"}?(w-1)*$7:$7)}
y2={round(${"is_percent $8"}?(h-1)*$8:$8)}
z2={round(${"is_percent $9"}?(h-1)*$9:$9)}
x3={round(${"is_percent $10"}?(w-1)*$10:$10)}
y3={round(${"is_percent $11"}?(h-1)*$11:$11)}
z3={round(${"is_percent $12"}?(h-1)*$12:$12)}
($x0,$x1;$x3,$x2^$y0,$y1;$y3,$y2^$z0,$z1;$z3,$z2)
r. {P0=[$x0,$y0,$z0];P1=[$x1,$y1,$z1];P2=[$x2,$y2,$z2];P3=[$x3,$y3,$z2];1+round([max(norm(P1-P0),norm(P3-P2)),max(norm(P3-P0),norm(P2-P1))])},1,3,3
warp.. .,0,$13,$14 rm.
endl done
#@cli barycenter
#@cli : Compute the barycenter vector of pixel values.
#@cli : $ 256,256 ellipse 50%,50%,20%,20%,0,1,1 deform 20 +barycenter +ellipse[-2] {@0,1},5,5,0,10
barycenter :
e[^-1] "Compute the barycenter vector of pixel values of image$?."
v - norm repeat $! l[$>] nm={0,b}
sum={is}
if {$sum>0}
if {d>1} +* 'z' z={is} rm. else z=0 fi
if {h>1} +* 'y' y={is} rm. else y=0 fi
* 'x' x={is} rm.
({$x/$sum};{$y/$sum};{$z/$sum})
else ({w/2},{h/2},{d/2}) rm..
fi
nm "[barycenter of '"$nm"']" endl done v +
#@cli delaunay
#@cli : Generate discrete 2D Delaunay triangulation of non-zero pixels in selected images.
#@cli : Input images must be scalar.
#@cli : Each pixel of the output image is a triplet (a,b,c) meaning the pixel belongs to
#@cli : the Delaunay triangle 'ABC' where 'a','b','c' are the labels of the pixels 'A','B','C'.
#@cli : $ 400,400 rand 32,255 100%,100% noise. 0.4,2 eq. 1 mul +delaunay
#@cli : $ image.jpg b 1% 100%,100% noise. 0.8,2 eq. 1 mul +delaunay channels 0,2
delaunay :
e[^-1] "Generate discrete 2D Delaunay triangulation of non-zero pixels in image$?."
v - repeat $! l[$>]
+slices 0 norm. !=. 0 {is+1},1,1,2 +f.. ">begin(p = 0); i?(I[#-1,++p] = [x,y]; p):0"
distance... 1 *... -1 watershed. ... rm...
100%,100%,1,3
_delaunay 1,0,0,1 _delaunay -1,0,0,-1 _delaunay -1,0,0,1 _delaunay 0,-1,1,0 rm..
s. c +warp[0] [1],0,0 point. 0,0 map[-4--2] . rm. a[-3--1] c
k.
endl done v +
_delaunay :
f.. "*
const boundary = 1;
p0 = i;
p1 = j($1,$2);
p2 = j($3,$4);
if (p0!=p1 && p0!=p2 && p1!=p2,
P0 = I[#-3,p0];
P1 = I[#-3,p1];
P2 = I[#-3,p2];
polygon(#-1,3,P0,P1,P2,1,[p0,p1,p2]);
); i"
#@cli detect_skin : 0<=tolerance<=1,_skin_x,_skin_y,_skin_radius>=0
#@cli : Detect skin in selected color images and output an appartenance probability map.
#@cli : Detection is performed using CbCr chromaticity data of skin pixels.
#@cli : If arguments 'skin_x', 'skin_y' and 'skin_radius' are provided, skin pixels are learnt
#@cli : from the sample pixels inside the circle located at ('skin_x','skin_y') with radius 'skin_radius'.
#@cli : Default value: 'tolerance=0.5' and 'skin_x=skiny=radius=-1'.
detect_skin : check "${1=0.5}>=0 && $1<=1" skip ${2=-1},${3=-1},${4=-1}
if {$2<0||$3<=0||$4<=0}
e[0--3] "Detect skin in image$?, using tolerance $1."
v -
m0=120.9292108800069
m1=142.5745272918084
A=0.09749985486268997
B=0.06388871371746063
C=0.05250053107738495
to_rgb srgb2rgb rgb2ycbcr channels 1,2
repeat $! l[$>]
whd={w},{h},{d} r {w*h*d},2,1,1,-1
s y -[0] $m0 -[1] $m1 a y
i[0] ($A,$B;$B,$C) +m* rm[0]
* s y + *. {$1-1} exp.
r $whd,1,-1
endl done
else
e[0--3] "Detect skin in image$?, using tolerance $1 and target circle at ($2,$3) with radius $4."
v -
to_rgb srgb2rgb rgb2ycbcr channels 1,2
repeat $! l[$>]
100%,100% circle[1] $2,$3,$4,1,1 +f[1] 'if(i,y,-1)' f[1] 'if(i,x,-1)' discard[1,2] -1 a[1,2] c
+warp[0] [1],0,0 rm[1]
s[1] c
m0={1,ia} -[1] $m0
m1={2,ia} -[2] $m1
M={h} a[1,2] x +transpose[1] rv[1,2] m*[1,2] /[1] $M invert[1]
rv whd={w},{h},{d} r[1] {w*h*d},2,1,1,-1
s[1] y -[1] $m0 -[2] $m1 a[1,2] y +m* rm[0]
* s y + *. {$1-1} exp.
r $whd,1,-1
endl done
fi
v +
#@cli displacement : [source_image],_smoothness,_precision>=0,_nb_scales>=0,_iteration_max>=0,is_backward={ 0 | 1 },_[guide] : (+)
#@cli : Estimate displacement field between specified source and selected target images.
#@cli : If 'smoothness>=0', regularization type is set to isotropic, else to anisotropic.
#@cli : If 'nbscales==0', the number of scales used is estimated from the image size.
#@cli : Default values: 'smoothness=0.1', 'precision=5', 'nb_scales=0', 'iteration_max=10000', 'is_backward=1' and '[guide]=(unused)'.
#@cli : $ image.jpg +rotate 3,1,0,50%,50% +displacement[-1] [-2] quiver[-1] [-1],15,1,1,1,{1.5*iM}
#@cli distance : isovalue[%],_metric : isovalue[%],[metric],_method : (+)
#@cli : Compute the unsigned distance function to specified isovalue, opt. according to a custom metric.
#@cli : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean | 3=squared-euclidean }.
#@cli : 'method' can be { 0=fast-marching | 1=low-connectivity dijkstra | 2=high-connectivity dijkstra | 3=1+return path | 4=2+return path }.
#@cli : Default value: 'metric=2' and 'method=0'.
#@cli : $ image.jpg threshold 20% distance 0 pow 0.3
#@cli : $ 400,400 set 1,50%,50% +distance[0] 1,2 +distance[0] 1,1 distance[0] 1,0 mod 32 threshold 16 append c
#@cli : $$
#@cli fftpolar
#@cli : Compute fourier transform of selected images, as centered magnitude/phase images.
#@cli : $ image.jpg fftpolar ellipse 50%,50%,10,10,0,1,0 ifftpolar
fftpolar :
e[^-1] "Compute fourier transform of image$?, as centered magnitude/phase images."
v - repeat $! l[$<]
fft complex2polar shift {-round(w/2)},{-round(h/2)},{-round(d/2)},0,2
endl done v +
#@cli histogram : _nb_levels>0[%],_value0[%],_value1[%] : (+)
#@cli : Compute the histogram of selected images.
#@cli : If value range is set, the histogram is estimated only for pixels in the specified
#@cli : value range. Argument 'value1' must be specified if 'value0' is set.
#@cli : Default values: 'nb_levels=256', 'value0=0%' and 'value1=100%'.
#@cli : $ image.jpg +histogram 64 display_graph[-1] 400,300,3
#@cli histogram_nd : nb_levels>0[%],_value0[%],_value1[%]
#@cli : Compute the 1D,2D or 3D histogram of selected multi-channels images (having 1,2 or 3 channels).
#@cli : If value range is set, the histogram is estimated only for pixels in the specified
#@cli : value range.
#@cli : Default values: 'value0=0%' and 'value1=100%'.
#@cli : $ image.jpg channels 0,1 +histogram_nd 256
histogram_nd : check $1>0 skip ${2=0%},${3=100%}
e[^-1] "Compute histogram of multi-channels image$?, using $1 levels in range [$1,$2]."
v -
percent_nblevels=${"is_percent $1"}
percent_min=${"is_percent $2"}
percent_max=${"is_percent $3"}
repeat $! l[$>] s={s}
r {w*h*d},{min(3,s)},1,1,-1
vmin=$2 vmax=$3
if {$percent_min||$percent_max}
im={im} iM={iM}
vmin={if($percent_min,$im+($iM-$im)*$2,$2)}
vmax={if($percent_max,$im+($iM-$im)*$3,$3)}
fi
dv={$vmax-$vmin}
nb_levels={max(1,round(if($percent_nblevels,$1*(1+$vmax-$vmin),$1)))}
f 'if(i>=$vmin&&i<=$vmax,if(i==$vmax,$nb_levels-1,int((i-$vmin)*$nb_levels/($vmax-$vmin))),-1)'
pointcloud 1,$nb_levels,{if($s>1,$nb_levels,1)},{if($s>2,$nb_levels,1)}
endl done v +
#@cli histogram_cumul : _nb_levels>0,_is_normalized={ 0 | 1 },_val0[%],_val1[%]
#@cli : Compute cumulative histogram of selected images.
#@cli : Default values: 'nb_levels=256', 'is_normalized=0', 'val0=0%' and 'val1=100%'.
#@cli : $ image.jpg +histogram_cumul 256 histogram[0] 256 display_graph 400,300,3
histogram_cumul : check ${1=256}>0 skip ${2=0},${3=0%},${4=100%}
arg 1+!$2,"normalized ",""
e[^-1] "Compute "${}"cumulative histogram of image$?, using $1 levels."
v - histogram $1,$3,$4 cumulate if $2 repeat $! /[$>] {$>,iM} done fi v +
#@cli histogram_pointwise : nb_levels>0[%],_value0[%],_value1[%]
#@cli : Compute the histogram of each vector-valued point of selected images.
#@cli : If value range is set, the histogram is estimated only for values in the specified
#@cli : value range.
#@cli : Default values: 'value0=0%' and 'value1=100%'.
histogram_pointwise : skip ${2=0%},${3=100%}
e[^-1] "Compute the pointwise histogram of vector-valued points in image$?, with $1 levels."
v - repeat $! l[$>] nm={0,n}
nb_levels={round(if(${is_percent\ $1},(iM-im)*$1,$1))}
value0={if(${is_percent\ $2},im+(iM-im)*$2,$2)}
value1={if(${is_percent\ $3},im+(iM-im)*$3,$3)}
- $value0 * {$nb_levels/max(1,abs($value1-$value0))} c 0,{$nb_levels-1} round
w={w} h={h} d={d} r {w*h*d},{s},1,1,-1
i.. (0,{w-1}) r.. .,.,1,1,3 round..
r[-2,-1] 300%,100%,1,1,4 shift. 1 +[-2,-1] y.
i.. ({'CImg3d'},{h/3},{h/3})
(1,0;1,{h/3-1}) r. 2,{-2,h/3},1,1,3 round.
3,100%,1,1,1 1,100%,1,1,-1 y[-5,-3,-2] a[-5--1] y
{$w*$h*$d},$nb_levels j3d. ..,0,0,0,1,0,0,0 rm..
r $w,$h,$d,$nb_levels,-1
nm $nm endl done v +
#@cli hough : _width>0,_height>0,gradient_norm_voting={ 0 | 1 }
#@cli : Compute hough transform (theta,rho) of selected images.
#@cli : Default values: 'width=512', 'height=width' and 'gradient_norm_voting=1'.
#@cli : $ image.jpg +blur 1.5 hough[-1] 400,400 blur[-1] 0.5 add[-1] 1 log[-1]
hough : check "${1=512}>0 && ${2=$1}>0" skip ${3=1}
e[^-1] "Compute $1x$2 hough transform of image$?, "${arg\ 1+!$3,with,without}" gradient norm voting."
v - slices 50% luminance repeat $! l[$>] nm={0,n}
rhomax={sqrt(w^2+h^2)/2}
g (0,{w-1}) (0;{{-2,h}-1}) r[-2,-1] {-3,w},{-3,h},1,1,3 -.. {w/2} -. {h/2}
complex2polar[-4--1] -. ... polar2complex[-2,-1] rm.
+<. 0 *. {pi} +[-3,-1] abs. %.. {2*pi}
*. {$2/$rhomax} *.. {0.5*$1/pi}
y[-3--1] x {w} mv[-4] $! if {!$3} f. 1 fi
a y pointcloud 1 r $1,$2,1,1,0
nm $nm endl done v +
#@cli ifftpolar
#@cli : Compute inverse fourier transform of selected images, from centered magnitude/phase images.
ifftpolar :
e[^-1] "Compute inverse fourier transform of image$?, from centered magnitude/phase images."
v - repeat {int($!/2)} l[$>,{$>+1}]
shift {round(w/2)},{round(h/2)},{round(d/2)},0,2 polar2complex ifft rm.
endl done v +
#@cli isophotes : _nb_levels>0
#@cli : Render isophotes of selected images on a transparent background.
#@cli : Default value: 'nb_levels=64'
#@cli : $ image.jpg blur 2 isophotes 6 dilate_circ 5 display_rgba
isophotes : skip ${1=64}
e[^-1] "Render isophote maps from images$?, with $1 levels."
v - to_rgba repeat $! l[$>]
+luminance repeat $1 +isoline3d[1] {$>*255/($1-1)} done rm[1] +3d[^0] col3d. 1
[0],[0] j3d. ..,0,0,0,1,0,0,0 rm.. *
endl done v +
#@cli label : _tolerance>=0,is_high_connectivity={ 0 | 1 } : (+)
#@cli : Label connected components in selected images.
#@cli : Default values: 'tolerance=0' and 'is_high_connectivity=0'.
#@cli : $ image.jpg luminance threshold 60% label normalize 0,255 map 0
#@cli : $ 400,400 set 1,50%,50% distance 1 mod 16 threshold 8 label mod 255 map 2
#@cli : $$
#@cli label_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@cli : Label connected components for non-zero values (foreground) in selected images.
#@cli : Similar to 'label' except that 0-valued pixels are not labeled.
#@cli : Default value: 'is_high_connectivity=0'.
label_fg : check "$1>=0" skip ${2=0}
e[^-1] "Label foreground connected components on image [1], with tolerance $1 and "${arg\ 1+!$2,high,low}" connectivity."
v - repeat $! l[$>]
if {d>1} +z -1,-1,-1,{w-1},{h-1},{d-1} label. $1,$2 z. 1,1,1,{w-1},{h-1},{d-1}
else +z -1,-1,{w-1},{h-1} label. $1,$2 z. 1,1,{w-1},{h-1}
fi
!=.. 0 * +histogram {1+iM} =. 0
>. 0 cumulate. map.. . rm.
endl done v +
#@cli max_patch : _patch_size>=1
#@cli : Return locations of maximal values in local patch-based neighborhood of given size for selected images.
#@cli : Default value: 'patch_size=16'.
#@cli : $ image.jpg norm +max_patch 16
max_patch : check "isint(${1=16}) && $1>=1"
e[^-1] "Return locations of maximal values in local patch neighborhood of size $1, in image$?."
v - repeat $! +dilate[$>] $1 ==[$>,-1] done v +
#@cli min_patch : _patch_size>=1
#@cli : Return locations of minimal values in local patch-based neighborhood of given size for selected images.
#@cli : Default value: 'patch_size=16'.
#@cli : $ image.jpg norm +min_patch 16
min_patch : check "isint(${1=16}) && $1>=1"
e[^-1] "Return locations of minimal values in local patch neighborhood of size $1, in image$?."
v - repeat $! +erode[$>] $1 ==[$>,-1] done v +
#@cli minimal_path : x0[%]>=0,y0[%]>=0,z0[%]>=0,x1[%]>=0,y1[%]>=0,z1[%]>=0,_is_high_connectivity={ 0 | 1 }
#@cli : Compute minimal path between two points on selected potential maps.
#@cli : Default value: 'is_high_connectivity=0'.
#@cli : $ image.jpg +gradient_norm fill[-1] 1/(1+i) minimal_path[-1] 0,0,0,100%,100%,0 pointcloud[-1] 0 *[-1] 280 to_rgb[-1] resize[-1] [-2],0 or
minimal_path : check "$1>=0 && $2>=0 && $3>=0" skip ${7=0}
e[^-1] "Compute minimal path between points ($1,$2,$3) and ($4,$5,$6) for potential map$?, with "${arg\ 1+$7,low,high}" connectivity."
v - repeat $! l[$>] nm={0,n}
- {im} + {iM/100}
100%,100% = 1,${4-6} distance. 1,[0],{if($7,4,3)} k.
x={round(if(${is_percent\ $1},$1*(w-1),$1))}
y={round(if(${is_percent\ $2},$2*(h-1),$2))}
z={round(if(${is_percent\ $3},$3*(d-1),$3))}
($x;$y;$z)
do
p={0,i($x,$y,$z)}
if {$p&1} x-=1
elif {$p&2} x+=1
fi
if {$p&4} y-=1
elif {$p&8} y+=1
fi
if {$p&16} z-=1
elif {$p&32} z+=1
fi
($x;$y;$z)
while $p
rm[0,-1] a x
nm $nm endl done v +
#@cli mse : : (+)
#@cli : Compute MSE (Mean-Squared Error) matrix between selected images.
#@cli : $ image.jpg +noise 30 +noise[0] 35 +noise[0] 38 cut. 0,255 mse
#@cli patches : patch_width>0,patch_height>0,patch_depth>0,x0,y0,z0,_x1,_y1,_z1,...,_xN,_yN,_zN
#@cli : Extract N+1 patches from selected images, centered at specified locations.
#@cli : $ image.jpg +patches 64,64,1,153,124,0,184,240,0,217,126,0,275,38,0
patches : check "isint($1) && $1>0 && isint($2) && $2>0 && isint($3) && $3>0"
e[^-1] "Extract $1x$2x$3 patches from image$?, at locations (${4--1})."
v -
(${4--1}) r. 3,{w/3},1,1,-1 permute. yzcx N={w}
H={int(sqrt(w))} W={round(w/$H,1,1)} r. {$W*$H},1,1,3,0 r. $W,$H,1,3,-1
r. {w*$1},{h*$2},{d*$3}
$1,$2,$3,1,x-{int($1/2)} +f. y-{int($2/2)} +f. z-{int($3/2)} a[-3--1] c r. ..,0,2 +[-2,-1]
repeat {$!-1} warp[$>] .,0,0,0 done rm.
repeat $! l[$<] s y,$H s x,$W k[0-{$N-1}] endl done
v +
#@cli matchpatch : [patch_image],patch_width>=1,_patch_height>=1,_patch_depth>=1,_nb_iterations>=0,_nb_randoms>=0,_occ_penalization,_output_score={ 0 | 1 },_[guide] : (+)
#@cli : Estimate correspondence map between selected images and specified patch image, using
#@cli : a patch-matching algorithm.
#@cli : Each pixel of the returned correspondence map gives the location (p,q) of the closest patch in
#@cli : the specified patch image. If 'output_score=1', the third channel also gives the corresponding
#@cli : matching score for each patch as well.
#@cli : Default values: 'patch_height=patch_width', 'patch_depth=1', 'nb_iterations=5', 'nb_randoms=5', 'occ_penalization=0', 'output_score=0' and 'guide=(undefined)'.
#@cli : $ image.jpg sample ? to_rgb +matchpatch[0] [1],3 +warp[-2] [-1],0
#@cli plot2value
#@cli : Retrieve values from selected 2D graph plots.
#@cli : $ 400,300,1,1,'if(y>300*abs(cos(x/10+2*u)),1,0)' +plot2value +display_graph[-1] 400,300
plot2value :
e[^-1] "Retrieve values from 2D graph plot$?."
v - repeat $! l[$>]
s c >= 50%
repeat $! l[$>] (1,{w}) r[1] [0],3 * histogram {w},1,{w} endl done
a c
endl done v +
#@cli pointcloud : _type = { -X=-X-opacity | 0=binary | 1=cumulative | 2=label | 3=retrieve coordinates },_width,_height>0,_depth>0
#@cli : Render a set of point coordinates, as a point cloud in a 1D/2D or 3D binary image
#@cli : (or do the reverse, i.e. retrieve coordinates of non-zero points from a rendered point cloud).
#@cli : Input point coordinates can be a NxMx1x1, Nx1x1xM or 1xNx1xM image, where 'N' is the number of points,
#@cli : and M the point coordinates.
#@cli : If 'M'>3, the 3-to-M components sets the (M-3)-dimensional color at each point.
#@cli : Parameters 'width','height' and 'depth' are related to the size of the final image :
#@cli :   - If set to 0, the size is automatically set along the specified axis.
#@cli :   - If set to N>0, the size along the specified axis is N.
#@cli :   - If set to N<0, the size along the specified axis is at most N.
#@cli : Points with coordinates that are negative or higher than specified ('width','height','depth')
#@cli : are not plotted.
#@cli : Default values: 'type=0' and 'max_width=max_height=max_depth=0'.
#@cli : $ 3000,2 rand 0,400 +pointcloud 0 dilate[-1] 3
#@cli : $ 3000,2 rand 0,400 {w} {w},3 rand[-1] 0,255 append y +pointcloud 0 dilate[-1] 3
pointcloud : check "${1=0}<=3 && ${2=0}>=0 && ${3=0}>=0 && ${4=0}>=0"
e[^-1] "Convert image$? to point clouds, in "${arg\ 2+($1>=0)*$1-($1<0),{-$1}-opacity,binary,cumulative,labeling}" mode,"\
"with dimensions $2x$3x$4."
v - repeat $! l[$>] nm={0,n}
if {$1!=3}
if {"d>1 || (w>1 && h>1 && s>1)"} v + error "Command '$0': Invalid input image "{w}x{h}x{d}x{s}". Should be NxMx1x1, Nx1x1xM or 1xNx1xM." fi
if {"w>1 && h>1 && s==1"} r 100%,1,1,{h},-1
elif {"w==1 && h>1 && s>1"} r {h},1,1,{s},-1
fi
if {s<3} channels 0,2 fi
if {s<4} 100%,1,1,1,1 a[-2,-1] c fi
sh. 0   round. siz_x={!$2?iM+1:$2}
sh.. 1  round. siz_y={!$3?iM+1:$3}
sh... 2 round. siz_z={!$4?iM+1:$4}
rm[-3--1]
$siz_x,$siz_y,$siz_z,{$1!=2?s-3:1}
if {$1<0}
f.. ">V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) = (1+$1)*I(#-1,P) - $1*C; V"
elif {$1==0}
f.. ">V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) = C; V"
elif {$1==1}
f.. ">V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) += C; V"
else
f.. ">begin(l = 0); V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) = ++l; V"
fi
else
16,1,1,{s+3}
f.. ">
begin(N = 0; zero = vectors(0));
I!=zero?I[#-1,N++] = [ x,y,z,I ];
N>=w(#-1)?resize(#-1,1.5*w(#-1),1,1,s#-1,0);
end(resize(#-1,N,1,1,s#-1,0));
I"
fi
k. nm $nm endl done v +
#@cli psnr : _max_value
#@cli : Compute PSNR (Peak Signal-to-Noise Ratio) matrix between selected images.
#@cli : Default value: 'max_value=255'.
#@cli : $ image.jpg +noise 30 +noise[0] 35 +noise[0] 38 cut[-1] 0,255 psnr 255 replace_inf 0
psnr : skip "${1=}"
if {isval("$1")}
e[0--3] "Compute the "$!x$!" matrix of PSNR values, from image$? with maximum value $1."
v - mse log10 - {log10(($1)^2)}
else
e[0--3] "Compute the "$!x$!" matrix of PSNR values, from image$?."
v - noarg
if {$!}
$! repeat {$!-1} =. {$>,iM},$> done
mse[^-1] sqr. log10 -.. 'max(i[#-1,x],i[#-1,y])' rm.
fi
fi
* -10 nm [PSNR] v +
#@cli segment_watershed : _threshold>=0
#@cli : Apply watershed segmentation on selected images.
#@cli : Default values: 'threshold=2'.
#@cli : $ image.jpg segment_watershed 2
segment_watershed : check "${1=2}>=0"
e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
v - repeat $! l[$>]
min={im}
+ {1+$min} +gradient_norm
+f. "i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && (d<=1?1:i<j(0,0,1) && i<j(0,0,-1))"
*[-3,-1] *. -1 watershed.. . rm.
- {1+$min}
endl done v +
#@cli shape2bump : _resolution>=0,0<=_weight_avg_max_avg<=1,_dilation,_smoothness>=0
#@cli : Estimate bumpmap from binary shape in selected images.
#@cli : Default value: 'resolution=256', 'weight_avg_max=0.75', 'dilation=0' and 'smoothness=100'.
shape2bump : check "isint(${1=256}) && $1>=0 && ${2=0.75}>=0 && $2<=1 && isval(${3=0}) && ${4=100}>=0"
e[^-1] "Estimate bumpmap from binary shape in image$?, using "${"v - if $1 u \"resolution $1\" else u \"full resolution\" fi v +"}", avg/max weight $2, dilation $3 and smoothness $4."
v - repeat $!
+l[$>]
norm > 0
siz={[w,h]}
distance 0 + $3
+f. "const boundary = 1; (i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"
is_resized=0
if {$1" && "max(w,h)>$1} rr2d $1,$1,0,2 gt. 0 thinning. 1 *.. {$1/max($siz)} is_resized=1 fi
+f. 0 .x2
f[1] "*if (i,
r = i(#0,x,y);
ir = floor(r);
r2 = r^2;
for (q = -ir, q<=ir, ++q,
Y = y + q;
for (p = -ir, p<=ir, ++p,
X = x + p;
dist = norm(p,q);
if (dist<r,
elev = sqrt(r2 - dist^2);
i(#2,X,Y) = max(i(#2,X,Y),elev);
if ($2<1, i(#3,X,Y) += elev; ++i(#4,X,Y));
);
)
);
); i"
if {$2<1} M={-3,iM} max. 1 /[-2,-1] n. 0,$M j. ..,0,0,0,0,$2
else rm[-2,-1]
fi
k.
if $is_resized *. {max([$siz]/[w,h])} r $siz,1,1,5 c 0,100% fi
endl
if $4 M={iM} (1^0^1) r. [0],[0] !=[0] 0 *. [0] smooth.. .,$4,0.1,0 rm. b. 0.5 n. 0,$M fi
k.
done v +
#@cli skeleton : _boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Compute skeleton of binary shapes using distance transform and constrained thinning.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg threshold 50% +skeleton 0
skeleton : check "!isval(${1=1}) || ($1>=0 && $1<=1)"
v -
if {isval($1)} bc=$1 else bc=1 noarg fi
v + e[^-1] "Compute skeleton of binary image$? with "${"arg 1+"$bc",dirichlet,neumann"}" boundary conditions." v -
repeat $! l[$>] s c repeat $! l[$>]
1,16,1,2
1,16,1,2
+distance[0] 0
f. "const boundary = 1; (i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"
f[0] ">"${-math_lib}"const boundary = "$bc"; i && (!j(-1) || !j(1) || !j(0,-1) || !j(0,1))?dar_insert(#1,[x,y]); i;"
eval ${-math_lib}"
const boundary = "$bc";
is_removable = [ 0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0 ];
dotm = [ 128,64,32,16,0,8,4,2,1 ];
is_removed = 1;
while (is_removed,
is_removed = 0;
N = dar_size(#1);
for (n = 0, n<N, ++n,
xc = i(#1,0,n,0,0);
yc = i(#1,0,n,0,1);
icc = i(#0,xc,yc);
(icc && !i(#3,xc,yc))?(
xp = xc - 1; yp = yc - 1;
xn = xc + 1; yn = yc + 1;
V = crop(#0,xp,yp,3,3);
val = dot(dotm,V>0);
is_removable[val]?(
i(#0,xc,yc) = 0;
is_removed = 1;
V[3]==1?(dar_insert(#2,[xp,yc]); i(#0,xp,yc) = 2);
V[5]==1?(dar_insert(#2,[xn,yc]); i(#0,xn,yc) = 2);
V[1]==1?(dar_insert(#2,[xc,yp]); i(#0,xc,yp) = 2);
V[7]==1?(dar_insert(#2,[xc,yn]); i(#0,xc,yn) = 2);
):(dar_insert(#2,[xc,yc]); i(#0,xc,yc) = 2);
)
);
resize(#1,1,h(#2),1,2,0);
copy(i(#1),i(#2),2*h(#2));
i[#2,h(#2)-1] = 0;
);"
k[0] > 0 thinning
endl done a c endl done v +
skeleton_v236 : check ${1=0}>=0
e[^-1] "Compute skeleton of binary image$?."
v - distance 0 b $1 sharpen 1e10 >= 100%
repeat $! +erode[$>] 2 -[$>,-1] done v +
#@cli slic : size>0,_regularity>=0,_nb_iterations>0
#@cli : Segment selected 2D images with superpixels, using the SLIC algorithm (Simple Linear Iterative Clustering).
#@cli : Scalar images of increasingly labeled pixels are returned.
#@cli : Reference paper: Achanta, R., Shaji, A., Smith, K., Lucchi, A., Fua, P., & Ssstrunk, S. (2010). Slic superpixels (No. EPFL-REPORT-149300).
#@cli : Default values: 'size=16', 'regularity=10' and 'nb_iterations=10'.
#@cli : $ image.jpg +srgb2lab slic[-1] 16 +blend shapeaverage f[-2] "j(1,0)==i && j(0,1)==i" *[-1] [-2]
slic : check "${1=16}>0 && ${2=10}>=0 && ${3=10}>0"
e[^-1] "Segment image$? using SLIC superpixels, with size $1, regularity $2 and $3 iterations."
v -
S,m,nb_iter=${1-3}
repeat $! l[$>] slices 50%
{[max(1,round(w/$S)),max(1,round(h/$S))]},1,2,"round(([x,y]+=0.5)*="$S")"
if {$S>=3}
+b[0] 0.7 g. xy,1 a[-2,-1] c norm.
f.. "
const n = round("$S"/3);
const n1 = int(n/2);
pos = argmin(crop(#-1,i0 - n1,i1 - n1,n,n,1));
dxy = [pos%n,int(pos/n)] - n1;
[ cut(i0 + dxy[0],0,w#0-1), cut(i1 + dxy[1],0,h#0-1) ]"
rm.
fi
r. {wh},1,1,2,-1
100%,1,1,{0,s},"I(#0,I#1)" a[-2,-1] c
[0],[0],1,2 f.. "I(#-1,i0,i1) = [ x + 1,1 ];I" s. c distance. 1 *. -1 watershed.. . rm. channels. 0,1
repeat $nb_iter
sh[2] 1 f. inf rm.
f[1] "
const m = "$m";
const S = "$S";
k = x;
xk = i0;
yk = i1;
Ik = (I)[2,s#0];
x0 = max(xk - S,0);
x1 = min(xk + S,w#0 - 1);
y0 = max(yk - S,0);
y1 = min(yk + S,h#0 - 1);
for (y = y0, y<=y1, ++y,
for (x = x0, x<=x1, ++x,
delta_c = norm(I(#0,x,y) - Ik);
delta_s = norm(x - xk, y - yk);
delta = delta_c + m/S*delta_s;
if (delta<i(#-1,x,y,0,1),
I(#-1,x,y) = [ k,delta ];
);
)
);
I"
f[1] 0 channels[1] 0,{-2,s}
f[2] "I[#1,i0]+=[ x,y,I#0,1 ];I"
s[1] c,-{1,s-1} max[2] 1 /[1,2]
done
k[2] channels 0 label. 0,0
+area 0,0 <. {$S^2/8}
{0,iM+1},1,1,1,x
f[0] ">
const boundary = 1;
if (i[#-1,i]>=0,
N = [ j(-1,0),j(0,-1),j(1,0),j(0,1) ];
for (k = 0, k<size(N), ++k,
if (N[k]!=i,
i[#-1,i] = i[#-1,i]==i || i[#-1,i]==N[k]?N[k]:-1
);
);
);
i"
f. "i<0?0:1" +map[0] . rm.. or[-2,-1]
+[0] 1 100%,100% j[0] .,0,0,0,0,1,.. rm.
distance. 0 *. -1 watershed.. . rm.
label. 0,0
endl done v +
#@cli ssd_patch : [patch],_use_fourier={ 0 | 1 },_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Compute fields of SSD between selected images and specified patch.
#@cli : Argument 'boundary_conditions' is valid only when 'use_fourier=0'.
#@cli : Default value: 'use_fourier=0' and 'boundary_conditions=0'.
#@cli : $ image.jpg +crop 20%,20%,35%,35% +ssd_patch[0] [1],0,0
ssd_patch : check ${is_image_arg\ $1} skip ${2=0},${3=0}
e[^-1] "Compute field of SSD between image$? and patch $1 using "${arg\ 1+!$2,fourier,spatial}" mode."
v - repeat $! pass$1 0 l[$>,-1]
r 100%,100%,100%,${-max_s} s c
repeat {$!/2} l[$>,{-1-$<}]
+sqr[1] val={is} rm.
+sqr[0] +f[1] 1
if $2
convolve_fft.. . rm.
mirror[1] xyz convolve_fft[0] [1] rm[1]
else
correlate.. .,$3 rm.
correlate[0] [1],$3 rm[1]
fi
*[0] -2 +[0,1] + $val
endl done +
endl done v +
#@cli thinning : _boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Compute skeleton of binary shapes using morphological thinning
#@cli : (beware, this is a quite slow iterative process)
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg threshold 50% +thinning
thinning : check "!isval(${1=1}) || ($1>=0 && $1<=1)"
v -
if {isval($1)} bc=$1 else bc=1 noarg fi
v + e[^-1] "Apply morphological thinning to binary image$? with "${"arg 1+"$bc",dirichlet,neumann"}" boundary conditions." v -
repeat $! l[$>] s c repeat $! l[$>]
1,16,1,2
1,16,1,2
1,16,1,2
f[0] ">"${-math_lib}"const boundary = "$bc"; i && (!j(-1) || !j(1) || !j(0,-1) || !j(0,1))?dar_insert(#1,[x,y]); i;"
eval ${-math_lib}"
const boundary = "$bc";
hm_and = [ 231,189,231,189,122,91,94,218 ];
hm_eq = [ 7,148,224,41,18,80,72,10 ];
dotm = [ 128,64,32,16,0,8,4,2,1 ];
is_removed = vector8(0);
ind = 1;
nind = 3;
it = 0;
do (
N = dar_size(#ind);
it8 = it%8;
is_removed[it8] = 0;
for (n = 0, n<N, ++n,
xc = i(#ind,0,n,0,0);
yc = i(#ind,0,n,0,1);
icc = i(#0,xc,yc);
icc?(
xp = xc - 1; yp = yc - 1;
xn = xc + 1; yn = yc + 1;
V = crop(#0,xp,yp,3,3);
val = dot(dotm,V>0);
(val & hm_and[it8])==hm_eq[it8]?(
dar_insert(#2,[xc,yc]);
is_removed[it8] = 1;
V[3]==1?(dar_insert(#nind,[xp,yc]); i(#0,xp,yc) = 2);
V[5]==1?(dar_insert(#nind,[xn,yc]); i(#0,xn,yc) = 2);
V[1]==1?(dar_insert(#nind,[xc,yp]); i(#0,xc,yp) = 2);
V[7]==1?(dar_insert(#nind,[xc,yn]); i(#0,xc,yn) = 2);
):(dar_insert(#nind,[xc,yc]); i(#0,xc,yc) = 2);
);
);
N = dar_size(#nind);
for (n = 0, n<N, ++n, i(#0,i[#nind,n],i[#nind,n + h(#nind)]) = 1);
_tmp = ind; ind = nind; nind = _tmp;
i[#nind,h(#nind)-1] = 0;
N = dar_size(#2);
for (n = 0, n<N, ++n, i(#0,I[#2,n]) = 0);
i[#2,h(#2)-1] = 0;
++it;
_(while), max(is_removed)
);"
k[0]
endl done a c endl done v +
#@cli tones : N>0
#@cli : Get N tones masks from selected images.
#@cli : $ image.jpg +tones 3
tones : check $1>0
e[^-1] "Get $1 tones masks from image$?."
v - norm n 0,{$1-1} round 1 repeat $! l[$<]
repeat {$1-1} +==[0] {1+$>} done ==[0] 0
endl done v +
#@cli topographic_map : _nb_levels>0,_smoothness
#@cli : Render selected images as topographic maps.
#@cli : Default values: 'nb_levels=16' and 'smoothness=2'.
#@cli : $ image.jpg topographic_map 10
topographic_map : check "isint(${1=16}) && $1>0" skip ${2=2}
e[^-1] "Render topographic maps from image$?, with $1 levels and smoothness $2."
v - repeat $! l[$>]
+b $2 isophotes. $1 compose_channels. + ==. 0 blend shapeaverage0
endl done v +
#@cli tsp : _precision>=0
#@cli : Try to solve the 'travelling salesman' problem, using a combination of greedy search and 2-opt algorithms.
#@cli : Selected images must have dimensions Nx1x1xC to represent N cities each with C-dimensional coordinates.
#@cli : This command re-order the selected data along the x-axis so that the point sequence becomes a shortest path.
#@cli : Default values: 'precision=256'.
#@cli : $ 256,1,1,2 rand 0,512 tsp , 512,512,1,3 repeat {0,w} circle[-1] {0,I[$>]},2,1,255,255,255 line[-1] {0,boundary=2;[I[$>],I[$>+1]]},1,255,128,0 done keep[-1]
tsp : check "${1=256}>=0"
e[^-1] "Try to solve the 'travelling salesman' problem for pointcloud$?, with precision $1."
v - repeat $! l[$>] n={n}
if {h>1" || "d>1} error[0--4] "Selected image '"{n}"' has invalid dimensions ("{[w,h,d,s]}")." fi
eval "
is_used = vectorw(0);
next = vectorw(-1);
n_initial = n_current = round(u(0,w-1));
do (
is_used[n_current] = 1;
P_current = I[n_current];
n_next = -1; dmin = inf;
for (n = 0, n<w, ++n,
if (!is_used[n],
d = norm(I[n] - P_current);
if (d<dmin, dmin = d; n_next = n);
);
);
if (n_next<0, next[n_current] = n_initial; break());
next[n_current] = n_next;
n_current = n_next;
_(while), 1
);
resize(#-1,w,1,1,s+1,0);
copy(i(0,0,0,s),next,w)"
100%,1,1,{s-1},">begin(ind = 0); val = I[#0,ind]; ind = val[s]; val" rm..
eval "
is_improved = 1;
while (is_improved,
is_improved = 0;
nb_try = $1*w;
for (try = 0, try<nb_try, ++try,
r = round(max(8,0.5*w*(try/nb_try)^0.25));
i = round(u(0,w-1));
ni = (i+1)%w;
pi = (i-1)%w;
do (j = (i + round(u(-r,r)))%w; _(while), j==i || j==ni || j==pi);
nj = (j+1)%w;
P_i = I[i];
P_ni = I[ni];
P_j = I[j];
P_nj = I[nj];
dist_ini = norm(P_ni - P_i);
dist_jnj = norm(P_nj - P_j);
dist_ij = norm(P_j - P_i);
dist_ninj = norm(P_nj - P_ni);
if (dist_ij + dist_ninj<dist_ini + dist_jnj,
mi = (min(i,j) + 1)%w;
mj = max(i,j);
oi = min(mi,mj);
oj = max(mi,mj);
delta = oj - oi + 1;
for (c = 0, c<s, ++c, copy(i(oi,0,0,c),i(oj,0,0,c),delta,1,-1));
is_improved = 1;
);
);
)"
nm $n
endl done v +
#@cli variance_patch : _patch_size>=1
#@cli : Compute variance of each images patch centered at (x,y), in selected images.
#@cli : Default value: 'patch_size=16'
#@cli : $ image.jpg +variance_patch
variance_patch : check "isint(${1=16}) && $1>=1"
e[^-1] "Compute variance of image patches in image$?, with patch size $1."
v -
$1,$1,1,1,1 normalize_sum.
repeat {$!-1} l[$>,-1]
+sqr[0] convolve[0,2] [1]
sqr[0] rv[0,2] -[0,2] max[0] 0
endl done rm. v +
#@cli :: Image Drawing
#@cli arrow : x0[%],y0[%],x1[%],y1[%],_thickness[%]>=0,_head_length[%]>=0,_head_thickness[%]>=0,_opacity,_pattern,_color1,...
#@cli : Draw specified arrow on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the arrow is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'thickness=1%', 'head_length=10%', 'head_thickness=3%', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ 400,400,1,3 repeat 100 arrow 50%,50%,{u(100)}%,{u(100)}%,3,20,10,0.3,${-RGB} done
arrow : check "${5=1%}>=0 && ${6=10%}>=0 && ${7=3%}" skip ${8=1}
e[^-1] "Draw arrow in image$?, from ($1,$2) to ($3,$4), with thickness $5, head length $6, head_thickness $7 and opacity $8."
v - repeat $! l[$>]
polygon. 7,{"
x0 = "${"is_percent $1"}"?(w-1)*$1:$1;
y0 = "${"is_percent $2"}"?(h-1)*$2:$2;
x1 = "${"is_percent $3"}"?(w-1)*$3:$3;
y1 = "${"is_percent $4"}"?(h-1)*$4:$4;
p0 = [x0,y0];
dp = [x1,y1]-=p0;
l = norm2(dp);
t = "${"is_percent $5"}"?l*$5:$5;
hl = "${"is_percent $6"}"?l*$6:$6;
ht = "${"is_percent $7"}"?l*$7:$7;
lmhl = l - hl;
X = mul([0,-t,lmhl,-t,lmhl,-ht,l,0,lmhl,ht,lmhl,t,0,t],rot(-180*atan2(dp[1],dp[0])/pi),2);
X+=[p0,p0,p0,p0,p0,p0,p0]"},${8--1}
endl done v +
#@cli axes : x0,x1,y0,y1,_font_height>=0,_opacity,_pattern,_color1,...
#@cli : Draw xy-axes on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : To draw only one x-axis at row Y, set both 'y0' and 'y1' to Y.
#@cli : To draw only one y-axis at column X, set both 'x0' and 'x1' to X.
#@cli : Default values: 'font_height=14', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ 400,400,1,3,255 axes -1,1,1,-1
axes : check "isint(${5=14}) && $5>=0 && ${6=1}>=0" skip ${7=0},${8=0}
if ${"is_pattern \"$7\""}
e[0--3] "Draw xy-axes on image$?, with x-range ($1,$2), y-range ($3,$4), font height $5, opacity $6, pattern $7 and color (${8--1})."
v - pattern=$7 color=${8--1}
else
e[0--3] "Draw xy-axes on image$?, with x-range ($1,$2), y-range ($3,$4), font height $5, opacity $6 and color (${7--1})."
v - pattern=0xFFFFFFFF color=${7--1}
fi
if {!$5" || "!$6} v + return fi
mx={min($1,$2)} Mx={max($1,$2)}
my={min($3,$4)} My={max($3,$4)}
repeat $! l[$>]
w1={0,w-1} h1={0,h-1}
if {$1!=$2} u=${"_axes[] $1,$2,{0.3*w/$5}"} offx={arg(1,$u)} deltax={arg(2,$u)} fi
if {$3!=$4} u=${"_axes[] $3,$4,{0.3*h/$5}"} offy={arg(1,$u)} deltay={arg(2,$u)} fi
is_0x=0
if {$3==$4} y0=$3 else y0={v=-($my)*$h1/($My-$my);if($4>=$3,v,$h1-v)} fi
sty={if($y0>$h1-$5,-1,1)}
if {$1!=$2" && "$y0>=0" && "$y0<=$h1}
line 0,$y0,$w1,$y0,$6,$pattern,$color
4,4,1,1,x<=y +mirror. y rows. 1,3 a[-2,-1] y .,.,1,[0] fc. $color
if {$2>=$1} j[0] .,{$w1-3},{$y0-3},0,0,$6,..
else mirror.. x j[0] .,0,{$y0-3},0,0,$6,..
fi
rm[-2,-1]
i=0 do
val={_$offx+$i*$deltax} i+=1
if {$val>=$mx" && "$val<=$Mx}
x={v=($val-$mx)*$w1/($Mx-$mx);if($2>=$1,v,$w1-v)}
line $x,{$y0-1},$x,{$y0+1},$6,$pattern,$color
if $val
0 t. $val,0,0,$5,1,1 100%,100%,1,[0] fc. $color
j[0] .,{max(0,min($w1-w,$x-w/2))},{if($sty>0,$y0+3,$y0-h-3)},0,0,$6,.. rm[-2,-1]
else is_0x=1
fi
fi
while {$val<$Mx}
fi
is_0y=0
if {$1==$2} x0=$1 else x0={v=-($mx)*$w1/($Mx-$mx);if($2>=$1,v,$w1-v)} fi
stx={if($x0>$w1-$5,-1,1)}
if {$3!=$4" && "$x0>=0" && "$x0<=$w1}
line $x0,0,$x0,$h1,$6,$pattern,$color
4,4,1,1,x>=y +mirror. x z. 1,3 a[-2,-1] x .,.,1,[0] fc. $color
if {$4>=$3} j[0] .,{$x0-3},{$h1-3},0,0,$6,..
else mirror.. y j[0] .,{$x0-3},0,0,0,$6,..
fi
rm[-2,-1]
i=0 do
val={_$offy+$i*$deltay} i+=1
if {$val>=$my" && "$val<=$My}
y={v=($val-$my)*$h1/($My-$my);if($4>=$3,v,$h1-v)}
line {$x0-1},$y,{$x0+1},$y,$6,$pattern,$color
if $val
0 t. $val,0,0,$5,1,1 100%,100%,1,[0] fc. $color
j[0] .,{if($stx>0,$x0+6,$x0-w-6)},{max(0,min($h1-h,$y-h/2))},0,0,$6,.. rm[-2,-1]
else is_0y=1
fi
fi
while {$val<$My}
fi
if {$is_0x" || "$is_0y}
0 t. 0,0,0,$5,1,1 100%,100%,1,[0] fc. $color
j[0] .,{if($stx>0,$x0+6,$x0-w-6)},{if($sty>0,$y0+3,$y0-h-3)},0,0,$6,.. rm[-2,-1]
fi
endl done
v +
_axes :
n={max(1,round($3))}
d={abs($2-$1)/($n-1)}
s={10^round(log10($d))}
m={round(min($1,$2),$s,-1)}
M={round(max($1,$2),$s,1)}
do N={1+round(($M-$m)/$s,1,1)} s={2*$s} while {$N>$n}
u $m,{$s/2}
#@cli ball : _size>0, _R,_G,_B,0<=_specular_light<=8,0<=_specular_size<=8,_shadow>=0
#@cli : Input a 2D RGBA colored ball sprite.
#@cli : Default values: 'size=64', 'R=255', 'G=R', 'B=R', 'specular_light=0.8', 'specular_size=1' and 'shading=1.5'.
#@cli : $ repeat 9 ball {1.5^($>+2)},${-RGB} done append x
ball : check "${1=64}>0 && ${5=0.8}>=0 && $5<=8 && ${6=1}>=0 && $6<=8 && ${7=1.5}>=0" skip ${2=255},${3=$2},${4=$3}
e[^-1] "Input $1x$1 ball with color (${2-4}), specular light $5, specular size $6 and shadow factor $7."
v - l[]
{2*$1},{2*$1} = 1,65%,30% distance 1 * -1
+n 0,1 ^[1] $7 *[1] 1.4 +*[1] $3 +*[1] $4 *[1] $2 a[^0] c
>=[0] {100-10*$6}% b[0] {3*$6}% n[0] 0,{$5*255} rv + c 0,255
100%,100% circle[1] 50%,50%,34%,1,1 *[0] [1] *. 255 a c
r $1,$1,1,4,2
endl v +
chromeball64x64 :
base642img[] "MiB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KNjQgNjQgMSAyICMzMzY0CnicxZl5VJNnvsfT0mM7ntPp9N7paefe6ZzOmWlnemfGmTpzer0dO1WRnQCBQPZ9TwhhDQkYwyKQAAlbEjZBthgRRBahFamAggp1KS7QIgKyk7DIpoCQd54XtComyPLH/f7xvn/k/Xyf3/N7n+X35EUgLOqN9z/DHcqtaW69cqEmK8z7s3csP2ZZO/7ILGzpHhwaHBzoHxgA9/vt55M8fvPaxuh37NOu9AyNjBpNY+PjE+OmkYGuOzfb73XURu1589X0zx2PXu8ZMo0Dbnh41DQxMT5mHO7vam/v7O5sUH35Cgebvyiaf+g3jRuHB/oGjeMPpqamHkyMDvb3g3iG+7tvnjm8a71e/Af+5PXOYdPo4MCwaWr24cO5ubnZ2ekHY6PDgwNDRtNQT9u3mRirqXztt5Laa10jo0N9fcaZ+UWghflHwGBudnpywjTUNzjcd/faN3kBH1vGX98VWdd6b2B4oKt3fH7JbF5+vDC/ADQPm0xPTRr779/vuNZUdUzyT0t9eON/5Webb3f8eOdqW9/Eo2XI/Gh6auYxbAMMHsIO48OD/TcvnCvNltjbvIz/I/RMXVPTlaa6xrauwbG55eU5wAObpZmJialpoJnpSZCZ63WV+rRgxzfW9n0Xr/RsZVX1mdOV9a237o3OLT+amJw3Q9DS3IRxdNQ4NmYcn4YN7l8+U5ybIDq4pgsf4fPrjhcWFhScqL54vWt0Zn5++sHcotkMLc1OjptGR4yjw6MPZqbBu+yoLyvURfjueQF/z1V98YRGo8vWV128PTTzeGlpeWkZtA5B5sVHczNTD4CmZ+Zmp8b6Oy7XFB9NDOV+8hz+1j7Jt9+kKVIyC0433DItmiHzCvtEZvPSit/j+bnpsYGbF6tL8tIiRfRn4+C1PzGKWwuVCRm5xWevDS5CVmRemp0Y6m1rqCrOT1eKBS4/peA/XZKu1mkVKVn5ZQ0/TJmt8dDSeO8PNy6fK9fnZqllIu4fnuA2u4VnO0rU8WmZheUN9x5ZxaHFwatN9bVnSgtzstKOBAkIO1b595007W25CQkpmUUwb7V981T3pXM1VWXFBUcztcpQIWfX6rj9G6nqXotGmZCUDvjO2cWFhWXL/OTdK9/WlJ8yFORkalXhIt5qAL/4l/hSz8UUhVKlKyiv7xibmRibsxzDo77vL56tKDXk52TqUuQiAetTmP/USXm1pzFZoVADvuHOkGlocGzJIr881tlaV1kC+KwMXZS/gI0Er+DNL7zUV+9d1CgUqvTC8gsdIyO9vabHljMwP3S7sbr0eN7R7KN5sf4CLu2XIHv7MXFX7rZmg/jTCysutBuNvT2j81Yy+OBea22ZIe9YblFpPOAZuxGIXQd9ws/fbTMoFIm6/NPfXu8Z6e8bsZIAEMCtxqoSvf54WbUK5pEIm332nsJTP7RXqRSJaTkl3zS13e3pG5mxnABoebKrpe5MWXllXXUc4JnEn73tZo+kpH9/u+FofGJSpr6ytvlGR49VHloytrfW19bVXy6RifgcJuXXv8E6OKIP1d9oOa1JUGtyT5yuvXyza8gqDz0e6/zuUvOVCxkhfjwOk/znv1Id7d0Z+ZcvNeiTEsEELK6qb7kzMG2Vh5ZMP95ovXIqOsCXx2aQ93zFdbZz8ZKX19bX5CSqtbmG01+f/+6u0eokBKNo4PZ3X6cG+/G5LDrZ1t3fzdbBjZqgLz97KkOdmlVUUl7deKN7fNHqNFgauX0+O9zfl8dh0chIfCjazs4ZxY07WlxWlKXRZBcYSmsab9wzPlxcsmzxeKhFHx0oFHDZTBoJxZARHA46ItG86IxCg/5Yhi47/3hpdX1L293eQdP0/Mse5ocdlUlhAQKQPTqV6MmNYSDt7J3d0dzIjAKDoSA3J6/wRGlV9dfnGi5dvdU1MDa9ZjbO99bnxAGey2bQyHiUUCVEO9k5unp4sw9r8/XHiwoLi/T6E8XFJWUV1bUXWm/c6TbNLS4/DWN5prvpZDrMc1gMKgmHZGskZHdHeyekhxctVJVTdBzIcBy20RtOlFR8Xdf43Z2eQePk9KPHy0vzk73f158u0MaGBwhA78lErAMxK5qHQdo7OiM90ARfeVoewE+A5oEMer3hZFnVuebrt37s6ukb6Ou80VRbebIgKzkmPIDPolNJeMy/XHJVEgba2cEJGHhhqP6RqcdAwydLTpVXlJWcMBiKSyrONjRdam48X1dzSl+QBy8d8VHSAB6LRiHhvP/+xVHNkQCKm5PjioEPjuYXrtTmFukNJWWnSk8CA8PJU2WlhsLcrAxtilqVmJAQHxd9ONSfx6BRyVj0xx+mZKkihBgXJydnFzcPT28snswSSaMTkjOOFR4HPSgqKsjNTE2Ii4mOlB+WyQ7LwfWQNNiPS6fRKViv99+JyNaqZCwvV8C7url7on2weBKFwRUGS+VH4hRKpTI2SiYVBwXCCgoODgkJDg4KFAk4DCabhkHtQHDS0zPigyhebq6urkg3d5SXNwZHIJKpNPAAl8fj8/krFz5fIPAV+MISCAQ8LpvN51N99iMQX4J9QxslJPt4uiNh3tMLhIDDE0kUKpVGpzOYLBaLvSIOEHxnsZhMFs8vwI/s80cE4r9CFGk6VbiAjPP2RHl4oFBeXmhvDHAgEElkMmxCg22eiQ7E5PmFSPwIaHgPJUmOJCVGifl08Dp90F5eIABvHwwWi3tqQQEmK6I9EZ3FFYllMi7uILz+/40TEBkXJfXns8GIIOJxGB9v72cGRBKRBExgARtgRaMzuQJ/SUS0mIb9aGXzxzOE4TIJWE/4YErCrxW4AAEcTyAQSLBWcAqVQgX54Pj6B4VHxcoFBORqFfQ5nswPDPL35cLpFfBXXOg0Gtzac4JRFofL9w2UhMuiFTEhVPyTQvAtNAbDEAj5bI6vn5/IPyAwQOQH+/B4XM5q5tnwKwAo+DU4TB4dHaOIk7II7k+LsD97uLmTWWwGnSMQ+geGhIaKxWCYgMESFBTgD8tPKBSKwA8SqVQep1QqYqOlXCLuw6f1h42DowMSR6WQaWy+UBQUKpWAB8ElFHYSiyVhEnCXyCIjo6JiVMlqRbRczCUTv3pWP/3C1fagiw/INoXJEwiD4KclUglMAwupTA4GvTwyVhGfqErVpSnB7GGTSd4/e64A+/jg/v0O7j44YMDhCQNDACgGAx0oRCyVRUYdiYlVqlN1uvRMTZxUxKURiPj/fqEA3PPVflsndx8Chc7h8EXB0jAgqXjFAPBH4hLUKdrMLF1aYmQwj0HCk6l/ebH+tLHbe8DBHUOiMUCeRSHhh+UR0dERMqBDkXHxquRUjS5dl5oYLRawqAQsjbMXsUav79t7wBlNoIM3xfUNORyjUCYmJ6mTU5ISkmBUk5qckhgVyqdRiBgMU2T7cgX/+sEvv3JGE+nwdBNKY1O06ZnpWm16SoIqJS01Me5IpCyYSyHgfbywfMna6nlV/2e31xlLptEoZDpfHJWoyy3ILyjIzdKoosOCgvxYVCyYFyhPilj+hSUa6BOXvUgKk4rxROMYAWFH1FpNSnJ8ZFiwL5OC9/ZCodAoT4JYEfuJFRyBeNfDwZnEpHq7ubhj6Twhn8nkMYk+aA83Dx8Sm0OlsMK12ohPreJAn5FcPMg0vJu9vbMXDuPh5unuam9r6+BJF/n5R6Tk5aei3loPRyB22vliUHgqztV23wEHuwOObo62SAyJzpfEZxflpBI/WJ+G9ZZdmIxL9EG5OhzYb4ckEJnCUHmMUp2uVXj/6tX0iv6Hmp6nUYaHHkrUKmLjlOq0rOwU6u4dG6RX9ME+ukydW1FZXl6kCafs+91mWKCdu7Hqijvj8JY9dadajf3w1cgzvUutWVhbdnQl/XOD9J9y5iwXTp2itzdAF1s+PKxoTPoKh7eTXwr8RZlo6+H7e9anYTX82hptE7FO6M80ibKM7yzfCA1kllvC32veIA5U+PL5/722jeMWDHY2bgaHoGNr+JLN4RAU/gIeulkcMiOfwz9/xaixJNOzcfDmzc3jEHTmJ/7QVnAI8n6CfzC7Nb7vyZ9pmVvDIUi4OnK2kLwnAaysiJFbxSEInsw2A1vnLwF+39ZxCALLcvp2eAkCsY3wIagJ8fvt4NDCTuy2eGifent8YMX2eN2mlq2XdXZwe/w2m4d6/r/5DW1Z6/DbDKClZXt8RfH2eHXE9nim2/b43e9tC596HbGlveepKhGIbSWACgq2beAL74IF+PrW+TJ4/2BtnbeH+R19W8VbVvfPgK3yzk/Kh+6t4c1P6wfUlvCF3T8VIKVb4ROe1U+/7N88fu3549CXm64hJv+AeF6CTeILTmsK0NhN4WYmYq02Y2DmvIQjEHLrH37WBk+1gCMQRCtfHdZq0s4ijkD8tXMj+P2PrODg+JXx6u3kzLpH8C+urU93e69HA9ng2q3TfbwNfIFGOFda7sUF0kZP8L8S1K05Ay80hP52g/CqdnzOTa1o6QFqqdb57dlp7bl/A5UFagkxIDQ1IDEgMSAjNTIKeJxz941i0M/Iz03VTykpTs4ozS3Qd0ktzi7JL9BPzigCiscXF2SkFqXqFeSlMwAAcSYQbQ=="
s. c +apply_gamma.. 0.05 b. 3 n. 0,150 n... 0,1 i[-4] 100%,100%,1,3 fc[-4] ${1-3} *[-4,-3] +[-3,-1] c.. 0,255 a[-2,-1] c
#@cli chessboard : size1>0,_size2>0,_offset1,_offset2,_angle,_opacity,_color1,...,_color2,...
#@cli : Draw chessboard on selected images.
#@cli : Default values: 'size2=size1', 'offset1=offset2=0', 'angle=0', 'opacity=1', 'color1=0' and 'color2=255'.
#@cli : $ image.jpg chessboard 32,32,0,0,25,0.3,255,128,0,0,128,255
chessboard : check "$1>0 && ${2=$1}>0" skip ${3=0},${4=0},${5=0},${6=1},${7=0},${8=255}
e[^-1] "Draw chessboard on image$?, with sizes ($1,$2), offsets ($3,$4), angle $5 deg., opacity $6 and colors (${7--1})."
v - i[0] (${7--1}) r[0] {{0,w}/2},1,1,2,-1 permute[0] cyzx
repeat {$!-1}
w={w} h={h} theta={$5*pi/180}
($3,{$3+$w-1};$3,{$3+$w-1}^$4,$4;{$4+$h-1},{$4+$h-1}) r. $w,$h,1,2,3
r. {$w*$h},2,1,1,-1
i.. ({cos($theta)},{-sin($theta)};{sin($theta)},{cos($theta)}) m*[-2,-1]
r. $w,$h,1,2,-1
%. {$1+$2} >=. $1 s. c xor[-2,-1] map. [0] r. 100%,100%,1,..
j.. .,0,0,0,0,$6 rm.
mv. 1 done rm[0] v +
#@cli cie1931
#@cli : Draw CIE-1931 chromaticity diagram on selected images.
#@cli : $ 500,400,1,3 cie1931
cie1931 :
e[^-1] "Draw CIE-1931 chromaticity diagram on image$?."
v -
(67.5;73.5;109.5;103.5;51.5;100.5;37;36)
(280,420,0;171,829,0;158,820,0;153,816,0;147,811,0;140,804,0;132,794,0;121,776,0;106,747,0;88,701,0;\
65,633,0;42,539,0;20,421,0;5,295,0;0,179,0;4,115,0;10,83,0;16,61,0;25,38,0;35,21,0;47,10,0;58,3,0;\
71,0,0;92,1,0;111,7,0;151,28,0;189,52,0;226,79,0;262,109,0;298,141,0;334,175,0;370,209,0;405,244,0;\
441,279,0;475,313,0;509,347,0;731,568,0)
xM=731 yM=829
2,{h-1},1,1,3,0 1,{h},1,1,'y' ++. 1 %. {h} +[-2,-1] 1 a[-3--1] x
3,{h},1,1,160 1,{h},1,1,1
y[-4--2] a[-5--1] y mv. 0
xR=636 yR=504 xG=297 yG=234 xB=147 yB=774
512,512,1,3 triangle_shade. 0,0,{w-1},0,0,{h-1},""255,0,0,""0,255,0,""0,0,255 rgb2srgb.
+compose_channels. max +. 1e-8 /[-2,-1] *. 255
i.. (67.5;73.5;109.5;103.5;51.5;100.5;3;1;$xR;$yR;-0.01;$xG;$yG;-0.01;$xB;$yB;-0.01;9;0;1;2;0;0;511;0;0;511;-128;512;512;3)
y. (1) a[-3--1] y mv. 1
repeat {$!-2}
to_rgb. fc. 255,255,255 grid. 10%,10%,0,0,0.3,0xCCCCCCCC,1,0
100%,100%,1,3
+*3d[0,1] {(w-8)/$xM},{(h-32)/$yM}
j3d... .,2,30,0,1,2
+!=... 0 distance. 1 *. -1 watershed[-4] . rm. /... 1.5
j3d... .,2,30,0,1,2
p3d. 1 p3d. 2 col3d. 128 j3d... .,2,30,0,1,1 rm.
{-2,w},{-2,h} j3d. ..,2,30,0,1,2 rm..
+erode. 4 -. .. ==. 0 *[-3,-1]
a[-2,-1] c blend[-2,-1] alpha
100%,100%,1,1,255 axes. 0,0.75,0.85,0,14,1 +erode. 3 negate. to_rgb..
j... ..,0,0,0,0,1,.,400 rm[-2,-1]
mv. 2 done rm[0,1] v +
#@cli circle : x[%],y[%],R[%],_opacity,_pattern,_color1,...
#@cli : Draw specified colored circle on selected images.
#@cli : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the circle is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 300 circle {u(100)}%,{u(100)}%,{u(30)},0.3,${-RGB} done circle 50%,50%,100,0.7,255
circle : skip ${4=1},${5=0},${6=0}
if ${"is_pattern \"$5\""}
e[0--3] "Draw outlined circle at ($1,$2) with radius $3 on image$?, with opacity $4, pattern $5 and color (${6--1})."
else
e[0--3] "Draw filled circle at ($1,$2) with radius $3 on image$?, with opacity $4 and color (${5--1})."
fi
v - ellipse $1,$2,$3,$3,0,${4--1} v +
#@cli close_binary : 0<=_endpoint_rate<=100,_endpoint_connectivity>=0,_spline_distmax>=0,_segment_distmax>=0,0<=_spline_anglemax<=180,_spline_roundness>=0,_area_min>=0,_allow_self_intersection={ 0 | 1 }
#@cli : Automatically close open shapes in binary images (defining white strokes on black background).
#@cli : Default values: 'endpoint_rate=75', 'endpoint_connectivity=2', 'spline_distmax=80', 'segment_distmax=20', 'spline_anglemax=90', 'spline_roundness=1','area_min=100', 'allow_self_intersection=1'.
close_binary :
check "${1=75}>=0 && $1<=100 && ${2=2}>=0 && ${3=80}>=0 && ${4=20}>=0 && ${5=90}>=0 && $5<=180 && ${6=1}>=0 && ${7=100}>=0 && isval(${8=1})"
e[^-1] "Close open shapes in binary image$?, with endpoint rate $1, endpoint connectivity $2, spline max distance $3, segment max distance $4, spline max angle $5, "\
"spline roundness $6, area min $7 and self intersections "${"arg 1+!$8,allowed,\"not allowed\""}"."
v -
endpoint_threshold={100-$1}
endpoint_connectivity={round($2)}
spline_distmax=$3
segment_distmax=$4
spline_anglemax=$5
spline_roundness=$6
area_min=$7
allow_self_intersections={!!$8}
_edgel_lib="
begin(
pn = [ 0,1,1,1,-1,0,-1,1,0,-1,-1,-1,1,0,1,-1 ];
pp = [ 0,-1,1,-1,1,0,1,1,0,1,-1,1,-1,0,-1,-1 ];
);
next(img,p) = (
p0 = p#[0,2] + pn[4*p#[2],2];
p1 = p#[0,2] + pn[4*p#[2] + 2,2];
case = !!i(#img,p0[0],p0[1],0,0) + 2*!!i(#img,p1[0],p1[1],0,0);
!case?[ p[0],p[1],(p[2]+1)%4 ]:case==1?[ p0[0],p0[1],p[2] ]:[ p1[0],p1[1],(p[2]-1)%4 ];
);
previous(img,p) = (
p0 = p#[0,2] + pp[4*p#[2],2];
p1 = p#[0,2] + pp[4*p#[2] + 2,2];
case = !!i(#img,p0[0],p0[1],0,0) + 2*!!i(#img,p1[0],p1[1],0,0);
!case?[ p[0],p[1],(p[2]-1)%4 ]:case==1?[ p0[0],p0[1],p[2] ]:[ p1[0],p1[1],(p[2]+1)%4 ];
);
next2(img,p) = (
p0 = p#[0,2] + pn[4*p#[2],2];
p1 = p#[0,2] + pn[4*p#[2] + 2,2];
case = !(i(#img,p0[0],p0[1],0,0)&3) + 2*!(i(#img,p1[0],p1[1],0,0)&3);
case==1?[ p0[0],p0[1],p[2] ]:case==3?[ p1[0],p1[1],(p[2]-1)%4 ]:[ p[0],p[1],(p[2]+1)%4 ];
);
next3(img,p) = (
p0 = p#[0,2] + pn[4*p#[2],2];
p1 = p#[0,2] + pn[4*p#[2] + 2,2];
val1 = i(#img,p0[0],p0[1],0,0);
val2 = i(#img,p1[0],p1[1],0,0);
case = (val1==1 || val1==2) + 2*(val2==1 || val2==2);
case==1?[ p0[0],p0[1],p[2] ]:case==3?[ p1[0],p1[1],(p[2]-1)%4 ]:[ p[0],p[1],(p[2]+1)%4 ];
);
vec(p) = (
ang = i(p[0],p[1],0,p[2])*pi/180;
[ cos(ang), sin(ang) ];
);"
repeat $! l[$>] nm={n}
slices 50% channels 0 > 0
nm. strokes
i[e_normals] 100%,100%,1,4,"
N = crop(#"$strokes",x - 1,y - 1,0,0,3,3,1,1,1);
N[4]?[ N[5]?-2:0, N[7]?-2:90, N[3]?-2:180, N[1]?-2:270 ]:[-2,-2,-2,-2];
"
f[e_normals] $_edgel_lib"
const boundary = 1;
i<-1?-2:(
ppos = npos = pos = [ x,y,c ];
u = vec(pos);
for (t = 1, t<=5, ++t,
ppos = previous(#"$strokes",ppos);
npos = next(#"$strokes",npos);
if (ppos==npos, break());
w = exp(-t^2/30);
u+=w*vec(ppos);
u+=w*vec(npos);
);
ang = (atan2(u[1],u[0])*180/pi)%360;
)"
+f[e_normals] $_edgel_lib"
const boundary = 1;
i<-1?-2:(
pos = [ x,y,c ];
ppos = previous(#"$strokes",pos);
npos = next(#"$strokes",pos);
pu = vec(ppos);
nu = vec(npos);
du = (nu - pu)/2;
cr = cross([vec(pos),0],[du,0]);
norm(du)*sign(cr[2]);
)"
nm. e_curvatures
+f[e_curvatures] $_edgel_lib"
const boundary = 1;
i<-1?-2:(
ppos = npos = pos = [ x,y,c ];
val = i; sumw = 1;
for (t = 1, t<=5, ++t,
ppos = previous(#"$strokes",ppos);
npos = next(#"$strokes",npos);
if (ppos==npos, break());
w = exp(-t^2/30);
val+=w*i(ppos[0],ppos[1],0,ppos[2]);
val+=w*i(npos[0],npos[1],0,npos[2]);
sumw+=2*w;
);
val/sumw;
)"
nm. e_smooth_curvatures
+distance[strokes] 0
f. "
i<1-0.01||i>1+0.01?0:(
p = x; q = y; d = 1;
for (is_better = 1, is_better && d<32,
next_p = p;
next_q = q;
is_better = 0;
pp = p - 1;
np = p + 1;
pq = q - 1;
nq = q + 1;
(nd = i(pp,pq))>d?(d = nd; next_p = pp; next_q = pq; is_better = 1);
(nd = i(p, pq))>d?(d = nd; next_p = p;  next_q = pq; is_better = 1);
(nd = i(np,pq))>d?(d = nd; next_p = np; next_q = pq; is_better = 1);
(nd = i(pp,q))>d?(d = nd; next_p = pp; next_q = q; is_better = 1);
(nd = i(np,q))>d?(d = nd; next_p = np; next_q = q; is_better = 1);
(nd = i(pp,nq))>d?(d = nd; next_p = pp; next_q = nq; is_better = 1);
(nd = i(p, nq))>d?(d = nd; next_p = p;  next_q = nq; is_better = 1);
(nd = i(np,nq))>d?(d = nd; next_p = np; next_q = nq; is_better = 1);
p = next_p;
q = next_q;
);
d)"
nm. stroke_radii
compose_channels[e_smooth_curvatures] max nm[e_smooth_curvatures] smooth_curvatures
+compose_channels[e_curvatures] max nm. curvatures
f. "i(#"$smooth_curvatures")>=("$endpoint_threshold"%)/(max(1,i(#"$stroke_radii"))) || i>=max(0.25,"$endpoint_threshold"%)"
label_fg. 0,1 nm. keypoints
if {iM>0}
{iM},1,1,3,-1 nm. keycoords
f[keypoints] ">
ret = 0;
if (i,
j = i - 1;
old_max = I[#"$keycoords",j];
kappa = i(#"$smooth_curvatures");
if (kappa>old_max[2],
I[#"$keycoords",j] = [ x,y,kappa ];
i(#"$keypoints",old_max[0],old_max[1]) = 0;
ret = 1;
);
); ret"
channels[keycoords] 0,3
fi
rm[smooth_curvatures,stroke_radii,keypoints]
if {!narg($keycoords)}
rm[e_normals,e_curvatures] i[new_strokes] [strokes]
else
f[keycoords] "
P = (I)[0,2];
angles = I(#"$e_normals",P);
U = [ 0,0 ];
for (k = 0, k<size(angles), ++k,
if (angles[k]>=0,
w = max(1e-8,i(#"$e_curvatures",P[0],P[1],0,k))^2;
ang = angles[k]*pi/180;
U += w*[ cos(ang),sin(ang) ];
);
);
[ P,0,(atan2(U[1],U[0])*180/pi)%360 ]"
rm[e_normals,e_curvatures]
i[keypairs] 256,1,1,3
f[keycoords] ">
begin(ind = 0);
for (nx = x + 1, nx<w, ++nx,
const cosmin = cos("$spline_anglemax"*pi/180);
Ic = I[x];
In = I[nx];
S = Ic[0,2];
T = In[0,2];
angS = Ic[3]*pi/180;
angT = In[3]*pi/180;
NS = [ cos(angS),sin(angS) ];
NT = [ cos(angT),sin(angT) ];
ST = T - S;
dist = norm(ST);
cosN = dot(NS,-NT);
angN = acos(cosN)*180/pi;
quality = max(0,1 - dist/"$spline_distmax") * max(0,dot(NS,ST) - dot(NT,ST))/dist * max(0,cosN - cosmin);
if (quality>0,
if (ind>=w(#"$keypairs"), resize(#"$keypairs",2*ind,1,1,3,0));
I[#"$keypairs",ind++] = [ quality,x,nx ];
);
);
end(resize(#"$keypairs",ind,1,1,3,0));
I"
if {keypairs,w} sort[keypairs] -,x
else rm[keypairs]
fi
i[new_strokes] [strokes]
ind_strokes={$allow_self_intersections?$strokes:$new_strokes}
if {narg($keypairs)}
f[keypairs] ">"$_edgel_lib"
for_spline(code) = for (t = 0, t<=1, t+=dt,
t3 = t*(t2 = t*t);
P = round(mul([t3,t2,t,1],C,2));
code#;
dP = abs(mul([3*t2,2*t,1,0],C,2)) + 1e-8;
dt = min(dtmin,0.75/max(dP));
);
Ic = I;
indS = Ic[1];
indT = Ic[2];
if (i(#"$keycoords",indS,0,0,2)<"$endpoint_connectivity" && i(#"$keycoords",indT,0,0,2)<"$endpoint_connectivity",
S = I(#"$keycoords",indS)[0,2];
T = I(#"$keycoords",indT)[0,2];
angS = i(#"$keycoords",indS,0,0,3)*pi/180;
angT = i(#"$keycoords",indT,0,0,3)*pi/180;
ST = T - S;
dist = "$spline_roundness"*norm(ST);
NS = [ cos(angS),sin(angS) ];
NT = [ cos(angT),sin(angT) ];
tmax = max(abs(ST));
is_cond = 1;
C = mul([ 2,-2,1,1,-3,3,-2,-1,0,0,1,0,1,0,0,0 ],[ S,T,dist*NS,-dist*NT ],2);
dt = dtmin = 1/max(abs(T - S));
current_val = 1;
nb_switches = 0;
for_spline(
if (i(#"$ind_strokes",P,0,0)!=current_val, ++nb_switches; current_val=!current_val);
if (nb_switches>2, is_cond = 0; break())
);
if (is_cond,
const area_max_threshold = "$area_min";
const area_min_threshold = 5;
const max_edgels = 2*(area_max_threshold + 1);
if (area_max_threshold<=0,
for_spline(i(#"$new_strokes",P)=1);
,
for_spline(i(#"$new_strokes",P)|=2);
for_spline(
if (i(#"$new_strokes",P[0] + 1,P[1])==0,
edgels = area = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
if (i(#"$new_strokes",P[0],P[1] + 1)==0,
edgels = area = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
if (i(#"$new_strokes",P[0] - 1,P[1])==0,
edgels = area = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
if (i(#"$new_strokes",P[0],P[1] - 1)==0,
edgels = area = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
0);
for_spline(
if (i(#"$new_strokes",P[0] + 1,P[1])==4,
edgels = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
if (i(#"$new_strokes",P[0],P[1] + 1)==4,
edgels = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
if (i(#"$new_strokes",P[0] - 1,P[1])==4,
edgels = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
if (i(#"$new_strokes",P[0],P[1] - 1)==4,
edgels = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
0);
for_spline(i(#"$new_strokes",P) = is_cond?1:(i(#"$new_strokes",P)&1));
if (is_cond,
++i(#"$keycoords",indS,0,0,2);
++i(#"$keycoords",indT,0,0,2);
);
);
);
); I"
rm[keypairs]
fi
==[new_strokes] 0
f[keycoords] ">"$_edgel_lib"
for_segment(code) = for (t = 0, t<=tmax, ++t,
P = round(S + t*ST);
code#;
);
if (i(#"$keycoords",x,0,0,2)<"$endpoint_connectivity",
S = I(#"$keycoords",x)[0,2];
angS = i(#"$keycoords",x,0,0,3)*pi/180;
NS = [ cos(angS),sin(angS) ];
ST = round(NS*"$segment_distmax");
tmax = max(abs(ST));
ST/=tmax;
is_cond = 0;
current_val = 0;
nb_switches = 0;
for_segment(
if (i(#"$new_strokes",P,0,0)!=current_val, ++nb_switches; current_val=1 - current_val);
if (nb_switches==2,is_cond = 1; break(););
);
tmax = t;
if (is_cond,
const area_max_threshold = "$area_min";
const area_min_threshold = 5;
const max_edgels = 2*(area_max_threshold + 1);
if (area_max_threshold<=0,
for_segment(i(#"$new_strokes",P)=0);
,
for_segment(i(#"$new_strokes",P)|=4);
for_segment(
if (i(#"$new_strokes",P[0] + 1,P[1])==1,
edgels = area = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
if (i(#"$new_strokes",P[0],P[1] + 1)==1,
edgels = area = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
if (i(#"$new_strokes",P[0] - 1,P[1])==1,
edgels = area = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
if (i(#"$new_strokes",P[0],P[1] - 1)==1,
edgels = area = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
);
0);
for_segment(
if (i(#"$new_strokes",P[0] + 1,P[1])==2,
edgels = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
if (i(#"$new_strokes",P[0],P[1] + 1)==2,
edgels = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
if (i(#"$new_strokes",P[0] - 1,P[1])==2,
edgels = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
if (i(#"$new_strokes",P[0],P[1] - 1)==2,
edgels = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
);
0);
for_segment(i(#"$new_strokes",P) = is_cond?0:i(#"$new_strokes",P)&3);
if (is_cond, ++i(#"$keycoords",x,0,0,2));
);
);
); I"
==[new_strokes] 0
if {!0$_keep_keycoords} rm[keycoords] fi
fi
rm[strokes]
nm[new_strokes] $nm
endl done v +
#@cli ellipse : x[%],y[%],R[%],r[%],_angle,_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified colored ellipse on selected images.
#@cli : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the ellipse is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 300 ellipse {u(100)}%,{u(100)}%,{u(30)},{u(30)},{u(180)},0.3,${-RGB} done ellipse 50%,50%,100,100,0,0.7,255
#@cli flood : x[%],_y[%],_z[%],_tolerance>=0,_is_high_connectivity={ 0 | 1 },_opacity,_color1,... : (+)
#@cli : Flood-fill selected images using specified value and tolerance.
#@cli : Default values: 'y=z=0', 'tolerance=0', 'is_high_connectivity=0', 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg repeat 1000 flood {u(100)}%,{u(100)}%,0,20,0,1,${-RGB} done
#@cli gaussian : _sigma1[%],_sigma2[%],_angle
#@cli : Draw a centered gaussian on selected images, with specified standard deviations and orientation.
#@cli : Default values: 'sigma1=3', 'sigma2=sigma1' and 'angle=0'.
#@cli : $ 400,400 gaussian 100,30,45
#@cli : $$
gaussian : skip ${1=3},${2=$1},${3=0}
e[^-1] "Draw centered gaussian on image$? with standard deviations ($1,$2) and angle $3 deg."
v -
u={cos($3*pi/180)}
v={sin($3*pi/180)}
dmax={max(w,h)}
if {isval($1)} l1=$1 else l1={${1}10000*$dmax/100} fi
if {isval($2)} l2=$2 else l2={${2}10000*$dmax/100} fi
l1={1/(2*max(1/3,$l1)^2)}
l2={1/(2*max(1/3,$l2)^2)}
A={$l1*$u*$u+$l2*$v*$v}
B={($l1-$l2)*$u*$v}
C={$l1*$v*$v+$l2*$u*$u}
repeat $! l[$>] nm={0,n}
w={w} h={h} ds={d},{s} rm
$w,$h,1,1,'X=x-{($w-1)/2};Y=y-{($h-1)/2};$A*X*X+2*$B*X*Y+$C*Y*Y'
* -1 exp r $w,$h,$ds
nm $nm endl done v +
#@cli graph : [function_image],_plot_type,_vertex_type,_ymin,_ymax,_opacity,_pattern,_color1,... : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified function graph on selected images.
#@cli : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@cli : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : Default values: 'plot_type=1', 'vertex_type=1', 'ymin=ymax=0 (auto)', 'opacity=1', 'pattern=(undefined)'
#@cli : and 'color1=0'.
#@cli : $ image.jpg +rows 50% blur[-1] 3 split[-1] c div[0] 1.5 graph[0] [1],2,0,0,0,1,255,0,0 graph[0] [2],2,0,0,0,1,0,255,0 graph[0] [3],2,0,0,0,1,0,0,255 keep[0]
#@cli grid : size_x[%]>=0,size_y[%]>=0,_offset_x[%],_offset_y[%],_opacity,_pattern,_color1,...
#@cli : Draw xy-grid on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : Default values: 'offset_x=offset_y=0', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg grid 10%,10%,0,0,0.5,255
#@cli : $ 400,400,1,3,255 grid 10%,10%,0,0,0.3,0xCCCCCCCC,128,32,16
#@cli grid : size_x[%]>=0,size_y[%]>=0,_offset_x[%],_offset_y[%],_opacity,_pattern,_color1,...
#@cli : Draw xy-grid on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : Default values: 'offset_x=offset_y=0', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg grid 10%,10%,0,0,0.5,255
#@cli : $ 400,400,1,3,255 grid 10%,10%,0,0,0.3,0xCCCCCCCC,128,32,16
grid : check "$1>=0 && $2>=0" skip ${3=0},${4=0},${5=1},${6=0},${7=$6}
if ${"is_pattern \"$6\""}
e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, pattern $6 and color (${7--1})."
v - pattern=$6 color=${7--1}
else
e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, and color (${6--1})."
v - pattern=0xFFFFFFFF color=${6--1}
fi
if {$_prerelease>=190210}
eval "
is_percent(str) = (unref(_is_pct); _is_pct=['#str']; _is_pct[size(_is_pct) - 1]==_'%');
for (k = 0, k<l, ++k,
size = is_percent($1)?max(1,w#k*$1):$1;
size>=1?(
off = (is_percent($3)?size*$3:$3)%size;
for (x = off, x<w#k, x+=size, polygon(#k,-2,x,0,x,h - 1,$5,"$pattern","$color"));
);
size = is_percent($2)?max(1,h#k*$2):$2;
size>=1?(
off = (is_percent($4)?size*$4:$4)%size;
for (y = off, y<h#k, y+=size, polygon(#k,-2,0,y,w - 1,y,$5,"$pattern","$color"));
)
)"
else
is_percentsx=${is_percent\ $1} is_percentsy=${is_percent\ $2}
is_percentox=${is_percent\ $3} is_percentoy=${is_percent\ $4}
repeat $! l[$>]
w={w} h={h} s={s}
size={if($is_percentsx,max(1,w*$1),$1)}
if {$size>=1}
offset={if($is_percentox,$size*$3,$3)}
({'CImg3d'}) +. 0.5
1,{1+int($w/$size)},1,1,'y' *. $size +. {$offset%$size}
1,{h},1,1,{$h/2} a[-2,-1] x z. 0,2 n={h} i.. ($n;$n)
(1,0;1,{$n-1}) r. 2,$n,1,1,3 round.
(-128;1;$h;$s) 1,$h,1,$s line. 0,0,0,100%,1,$pattern,$color
if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 fi
(-128;1;$h;1) 1,$h,1,1 line. 0,0,0,100%,1,$pattern,1
if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 fi
y[^0] a[^0] y j3d[0] [1],0,0,0,$5,0,0,0 rm[1]
fi
size={if($is_percentsy,max(1,h*$2),$2)}
if {$size>=1}
offset={if($is_percentoy,$size*$4,$4)}
({'CImg3d'}) +. 0.5
1,{1+int($h/$size)},1,1,'y' *. $size +. {$offset%$size}
i.. 1,{h},1,1,{$w/2} a[-2,-1] x z. 0,2 n={h} i.. ($n;$n)
(1,0;1,{$n-1}) r. 2,$n,1,1,3 round.
(-128;$w;1;$s) $w,1,1,$s line. 0,0,100%,0,1,$pattern,$color
if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 fi
(-128;$w;1;1) $w,1,1,1 line. 0,0,100%,0,1,$pattern,1
if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 fi
y[^0] a[^0] y j3d.. .,0,0,0,$5,0,0,0 rm.
fi
endl done
fi
v +
#@cli j : eq. to 'image'. : (+)
#@cli image : [sprite],_x[%],_y[%],_z[%],_c[%],_opacity,_[sprite_mask],_max_opacity_mask : (+)
#@cli : Draw specified sprite image on selected images.
#@cli : (eq. to 'j').
#@cli : Default values: 'x=y=z=c=0', 'opacity=1', 'sprite_mask=(undefined)' and 'max_opacity_mask=1'.
#@cli : $ image.jpg +crop 40%,40%,60%,60% resize[-1] 200%,200%,1,3,5 frame[-1] 2,2,0 image[0] [-1],30%,30% keep[0]
#@cli line : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified colored line on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 500 line 50%,50%,{u(w)},{u(h)},0.5,${-RGB} done line 0,0,100%,100%,1,0xCCCCCCCC,255 line 100%,0,0,100%,1,0xCCCCCCCC,255
#@cli linethick : x0[%],y0[%],x1[%],y1[%],_thickness,_opacity,_color1
#@cli : Draw specified colored thick line on selected images.
#@cli : Default values: 'thickness=2', 'opacity=1' and 'color1=0'.
#@cli : $ 400,400,1,3 repeat 100 linethick {u([w,h,w,h,5])},0.5,${-RGB} done
linethick : check "${5=2}>=0 && isval(${6=1}) && isval(${7=0})"
e[^-1] "Draw thick line ($1,$2) - ($3,$4) on image$?, with thickness $5, opacity $6 and color (${7--1})."
v -
if {!$5} line ${1-4},${6--1}
else repeat $! l[$>]
x0={${"is_percent $1"}?(w-1)*$1:$1}
y0={${"is_percent $2"}?(h-1)*$2:$2}
x1={${"is_percent $3"}?(w-1)*$3:$3}
y1={${"is_percent $4"}?(h-1)*$4:$4}
coords={"
const th = "$5";
P0 = [ "$x0","$y0" ];
P1 = [ "$x1","$y1" ];
dP = P1 - P0;
n = [ -dP[1],dP[0] ]/max(1e-8,norm(dP))*th/2;
round([ P0 - n, P0 + n, P1 + n, P1 - n ]);
"}
polygon 4,$coords,${6--1}
endl done fi
v +
#@cli mandelbrot : z0r,z0i,z1r,z1i,_iteration_max>=0,_is_julia={ 0 | 1 },_c0r,_c0i,_opacity : (+)
#@cli : Draw mandelbrot/julia fractal on selected images.
#@cli : Default values: 'iteration_max=100', 'is_julia=0', 'c0r=c0i=0' and 'opacity=1'.
#@cli : $ 400,400 mandelbrot -2.5,-2,2,2,1024 map 0 +blur 2 elevation3d[-1] -0.2
#@cli marble : _image_weight,_pattern_weight,_angle,_amplitude,_sharpness>=0,_anisotropy>=0,_alpha,_sigma,_cut_low>=0,_cut_high>=0
#@cli : Render marble like pattern on selected images.
#@cli : Default values: 'image_weight=0.2', 'pattern_weight=0.1', 'angle=45', 'amplitude=0', 'sharpness=0.4', 'anisotropy=0.8',
#@cli : 'alpha=0.6', 'sigma=1.1' and 'cut_low=cut_high=0'.
#@cli : $ image.jpg +marble ,
marble : skip ${1=0.2},${2=0.1},${3=45},${4=0},${5=0.4},${6=0.8},${7=0.6},${8=1.1},${9=0%},${10=100%}
e[^-1] "Render marble like pattern on image$?, with image weight $1, pattern weight $2, angle $3 deg., amplitude $4, "\
"sharpness $5, anisotropy $6, alpha $7, sigma $8, and cut ($9,$10)."
v - sx={$2*sin($3*pi/180)} sy={$2*cos($3*pi/180)} f sin(x*$sx+y*$sy+i*$1)
if {$4} smooth $4,$5,$6,$7,$8 fi
c $9,$10 n 0,255
v +
#@cli maze : _width>0,_height>0,_cell_size>0
#@cli : Input maze with specified size.
#@cli : $ maze 30,20 negate normalize 0,255
maze : check "isint(${1=15}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=24}) && $3>0"
e[^-1] "Input $1x$2 maze."
v -
({round(u($1-1))},{round(u($2-1))})
$1,$2,1,1,15 +f. 0 a[-2,-1] c
_generate_maze $1,$2
_render_maze. $3 nm. [maze]
v +
_generate_maze :
do
x={-2,@-2} y={-2,@-1}
=. 1,$x,$y,0,1
is_candidate=0
up=-1 if {i($x,$y)&8" && "$y>0" && "!i($x,$y-1,0,1)} up=$x,{$y-1},8 is_candidate=1 fi
down=-1 if {i($x,$y)&4" && "$y<$2-1" && "!i($x,$y+1,0,1)} down=$x,{$y+1},4 is_candidate=1 fi
left=-1 if {i($x,$y)&2" && "$x>0" && "!i($x-1,$y,0,1)} left={$x-1},$y,2 is_candidate=1 fi
right=-1 if {i($x,$y)&1" && "$x<$1-1" && "!i($x+1,$y,0,1)} right={$x+1},$y,1 is_candidate=1 fi
if $is_candidate
($up,$down,$left,$right) discard. -1 r. 3,{h/3},1,1,-1 shift. 0,{round(u(4))},0,0,2 rows. 0,0 mv. -2
fi
if $is_candidate
if {{-2,@-1}==8}   =. {i($x,$y)&7},$x,$y =. {i($x,$y-1)&11},$x,{$y-1}
elif {{-2,@-1}==4} =. {i($x,$y)&11},$x,$y =. {i($x,$y+1)&7},$x,{$y+1}
elif {{-2,@-1}==2} =. {i($x,$y)&13},$x,$y =. {i($x-1,$y)&14},{$x-1},$y
else               =. {i($x,$y)&14},$x,$y =. {i($x+1,$y)&13},{$x+1},$y
fi
z.. 0,1 a[-3,-2] y
else
if {{-2,h}==1} break fi
rows.. 0,{{-2,h}-2}
fi
while 1
rm.. channels. 0
_render_maze :
i[0] $1,$1 i[1] [0]x15
line[8-15] 0,0,100%,0,1,1
line[4-7,12-15] 0,100%,100%,100%,1,1
line[2-3,6-7,10-11,14-15] 0,0,0,100%,1,1
line[1-15:2] 100%,0,100%,100%,1,1
a[0-15] x r. {w*$1},{h*$1} *. $1 channels. 0,1
$1,$1,1,1,x $1,$1,1,1,y a[-2,-1] c r. ..,..,1,2,0,2 +[-2,-1]
warp.. .,0,0,0 rm.
#@cli maze_mask : _cellsize>0
#@cli : Input maze according to size and shape of selected mask images.
#@cli : Mask may contain disconnected shapes.
#@cli : $ 0 text "G'MIC",0,0,53,1,1 dilate 3 autocrop 0 frame 1,1,0 maze_mask 8 dilate 3 negate mul 255
maze_mask : check "isint(${1=24}) && $1>0"
e[^-1] "Input masked maze from image$? with cell size $1."
v - compose_channels + >= 50% repeat $! l[$>]
do
+rand[0] 0,1 *. [0] ({[xM,yM]}) rm..
+flood[0] {^},0,0,0,1,2 >=. 2 +negate. *.. 15 a[-2,-1] c
flood[0] {-2,^},0,0,0,1,0
_generate_maze {w},{h}
while {0,iM}
rm[0] + _render_maze. $1 nm. [maze]
endl done v +
#@cli j3d : eq. to 'object3d'. : (+)
#@cli object3d : [object3d],_x[%],_y[%],_z,_opacity,_rendering_mode,_is_double_sided={ 0 | 1 },_is_zbuffer={ 0 | 1 },_focale,_light_x,_light_y,_light_z,_specular_lightness,_specular_shininess : (+)
#@cli : Draw specified 3D object on selected images.
#@cli : (eq. to 'j3d').\n
#@cli : 'rendering_mode' can be { 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@cli : Default values: 'x=y=z=0', 'opacity=1' and 'is_zbuffer=1'. All other arguments take their default values from the 3D environment variables.
#@cli : $ image.jpg torus3d 100,10 cone3d 30,-120 add3d[-2,-1] rotate3d. 1,1,0,60 object3d[0] [-1],50%,50% keep[0]
#@cli pack_sprites : _nb_scales>=0,0<=_min_scale<=100,_allow_rotation={ 0=0 deg. | 1=180 deg. | 2=90 deg. | 3=any },_spacing,_precision>=0,max_iterations>=0
#@cli : Try to randomly pack as many sprites as possible onto the 'empty' areas of an image.
#@cli : Sprites can be eventually rotated and scaled during the packing process.
#@cli : First selected image is the canvas that will be filled with the sprites.
#@cli : Its last channel must be a binary mask whose zero values represent potential locations for drawing the sprites.
#@cli : All other selected images represent the sprites considered for packing.
#@cli : Their last channel must be a binary mask that represents the sprite shape (i.e. a 8-connected component).
#@cli : The order of sprite packing follows the order of specified sprites in the image list.
#@cli : Sprite packing is done on random locations and iteratively with decreasing scales.
#@cli : 'nb_scales' sets the number of decreasing scales considered for all specified sprites to be packed.
#@cli : 'min_scale' (in %) sets the minimal size considered for packing (specified as a percentage of the original sprite size).
#@cli : 'spacing' can be positive or negative.
#@cli : 'precision' tells about the desired number of failed trials before ending the filling process.
#@cli : Default values: 'nb_scales=5', 'min_scale=25', 'allow_rotation=3', 'spacing=1', 'precision=7' and 'max_iterations=256'.
#@cli : $ 512,512,1,3,"min(255,y*c/2)" 100%,100% circle 50%,50%,100,1,255 append c image.jpg resize2dy[-1] 24 to_rgba pack_sprites 3,25
pack_sprites : check "isint(${1=5}) && $1>=0 && ${2=25}>=0 && $2<=100 && isint(${3=3}) && $3>=0 && $3<=3 && isint(${4=1}) && isint(${5=7}) && $5>=0 && isint(${6=256}) && $6>=0"
e[^-1] "Randomly pack image$? with $1 scales, minimum scale $2%, "${arg\ 1+$3,no,180\"\ \"deg.,90\"\ \"deg.,any}" rotation, spacing $4, precision $5 and $6 maximum iterations."
v - N={$!-1} is_first_time=1
repeat $! r[$>] 100%,100%,1,{$>,max(2,s)} done
repeat $1
rprogress {$>*100/$1}
nb_attempts=0
ratio={if($1>1,$2+(100-$2)*$</($1-1),100)}%
repeat $N +l[{1+$>}]
w={w*$ratio} h={h*$ratio}
if {$w<1||$h<1} rm
else r $w,$h,1,100%,2 sh. 100% !=. 0 area{1+$>}={is} rm.
fi
endl done
l[0,{$N+1}--1] repeat $6
ind={1+($>%$N)} area=${area$ind}
if {$3==0} [$ind]
elif {$3==1} +rotate[$ind] {round(u)*180}
elif {$3==2} +rotate[$ind] {round(u(3))*90}
else +rotate[$ind] {u*360} sh. 100% !=. 0 area={is} rm.
fi
+channels[0] 100% ==. 0
if {$4>1} erode. {2*$4-1}
elif {$4<1} dilate. {-2*$4+3}
fi
+rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
if $is_first_time noise. 0.1,2 ==. 1 fi
distance. 0 noise. 1,1
max_patch. {$ind,round(1.5*max(w,h))}
*. .. pointcloud3d.
if {$N>1} l.
s3d /[1] $N round[1] max[1] 1 n={1,@0}
r[2] 3,{{2,h}/3},1,1,-1
i[2] 1,{2,h} rand[2] 0,1 a[2,3] x sort[2] +,y z[2] 1,3 r[2] 3,$n,1,1 y[2]
r[3] 1,{2*$n},1,1,0 r[4] 1,{3*$n},1,1,0 r[5] 1,$n,1,1,0 a y
endl fi
n={@7}
if $n
s3d. rm[-2,-1]
if {$3==0}
[-6] i.. (-128;{w};{h};{s})
if {$n>1} 4,{$n-1},1,1,-128,0,0,0 fi
+channels.. 100% i.. (-128;{w};{h};{s})
if {$n>1} ... fi
elif {$3==1}
+rotate[-6] {round(u(1))*180} i.. (-128;{w};{h};{s})
if {$n>1} +rotate. 180 i.. (-128;{w};{h};{s}) fi
if {$n>2} 4,{$n-2},1,1,-128,0,0,0 1,100% rand. 0,1 round. 1 j.. .,1 rm. fi
+channels[-4] 100% i.. (-128;{w};{h};{s})
if {$n>1} +channels[-4] 100% i.. (-128;{w};{h};{s}) fi
if {$n>2} [-5] fi
else
+rotate[-6] {round(u(3))*90} i.. (-128;{w};{h};{s})
if {$n>1} +rotate. 90 i.. (-128;{w};{h};{s}) fi
if {$n>2} +rotate. 90 i.. (-128;{w};{h};{s}) fi
if {$n>3} +rotate. 90 i.. (-128;{w};{h};{s}) fi
if {$n>4} 4,{$n-4},1,1,-128,0,0,0 1,100% rand. 0,3 round. 1 j.. .,1 rm. fi
+channels[-8] 100% i.. (-128;{w};{h};{s})
if {$n>1} +channels[-8] 100% i.. (-128;{w};{h};{s}) fi
if {$n>2} +channels[-8] 100% i.. (-128;{w};{h};{s}) fi
if {$n>3} +channels[-8] 100% i.. (-128;{w};{h};{s}) fi
if {$n>4} [-9] fi
fi
y[{$N+3}--1] a[{$N+3}--1] y
fi
rm...
[0] sh. 100% f. 1 -. [-4]
j3d.. ...,0,0,0,1,2,0,0 rm[-3,-1]
sh. 100% area_fg. 0,1 ==. $area
*. ... rm... sh.. 0,{-2,s-2} *. .. rm.
if {iM} j[0] ..,0,0,0,0,1,. rm[-2,-1]
else
rm[-2,-1]
nb_attempts+=1
if {$nb_attempts>$5} break else continue fi
fi
done k[0] endl
done k[0] v +
#@cli piechart : label_height>=0,label_R,label_G,label_B,"label1",value1,R1,G1,B1,...,"labelN",valueN,RN,GN,BN
#@cli : Draw pie chart on selected (RGB) images.
#@cli : $ image.jpg piechart 25,0,0,0,"Red",55,255,0,0,"Green",40,0,255,0,"Blue",30,128,128,255,"Other",5,128,128,128
piechart : check $1>=0
e[^-1] "Draw pie chart on image$?, with label height $1 and color ($2,$3,$4)."
v - $=arg repeat $! l[$>]
ellipse 50%,50%,{w/2-1},{h/2-1},0,1,1
ellipse 50%,50%,{w/2-1},{h/2-1},0,1,0xFFFFFFFF
(${6--1:5}) normalize_sum.
theta=0
if {w>1} repeat {w}
xe={0.5*{-2,w}*(1+cos($theta))}
ye={0.5*{-2,h}*(1+sin($theta))}
line.. 50%,50%,$xe,$ye
theta-={2*pi*i($>)}
done fi
theta=0
repeat {w} if {i($>)}
ntheta={$theta-2*pi*i($>)}
xc={0.5*{-2,w}*(1+0.5*cos(0.5*($ntheta+$theta)))}
yc={0.5*{-2,h}*(1+0.5*sin(0.5*($ntheta+$theta)))}
xf={0.5*{-2,w}*(1+0.8*cos(0.5*($ntheta+$theta)))}
yf={0.5*{-2,h}*(1+0.8*sin(0.5*($ntheta+$theta)))}
flood.. $xf,$yf,0,0,0,1,${arg{7+5*$>}},${arg{8+5*$>}},${arg{9+5*$>}}
if {abs($ntheta-$theta)>0.1}
0 t. ${arg{5+5*$>}},0,0,$1,1,1
($2^$3^$4) r. ..,..,1,3 *. ..
j[-4] .,{$xc-w/2},{$yc-h/2},0,0,1,..
rm[-2,-1]
fi
theta=$ntheta
fi done
rm.
endl done v +
#@cli plasma : _alpha,_beta,_scale>=0 : (+)
#@cli : Draw a random colored plasma fractal on selected images.
#@cli : This command implements the so-called 'Diamond-Square' algorithm.
#@cli : Default values: 'alpha=1', 'beta=1' and 'scale=8'.
#@cli : $ 400,400,1,3 plasma
#@cli : $$
#@cli point : x[%],y[%],_z[%],_opacity,_color1,... : (+)
#@cli : Set specified colored pixel on selected images.
#@cli : Default values: 'z=0', 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg repeat 10000 point {u(100)}%,{u(100)}%,0,1,${-RGB} done
#@cli polka_dots : diameter>=0,_density,_offset1,_offset2,_angle,_aliasing,_shading,_opacity,_color,...
#@cli : Draw dots pattern on selected images.
#@cli : Default values: 'density=20', 'offset1=offset2=50', 'angle=0', 'aliasing=10', 'shading=1', 'opacity=1' and 'color=255'.
#@cli : $ image.jpg polka_dots 10,15,0,0,20,10,1,0.5,0,128,255
polka_dots : check $1>=0 skip ${2=20},${3=50},${4=50},${5=0},${6=10},${7=1},${8=1},${9=255}
e[^-1] "Draw polka dots on image$?, with diameter $1, density $2, angle $3 deg., shift ($4,$5), aliasing $6 and shading $7."
v - theta={$5*pi/180} ct={cos($theta)} st={sin($theta)} mid1={$1/2} mid2={$2/2}
i[0] (${9--1}) y[0] c
repeat {$!-1}
WH={max(w,h)}
100%,100%,100%,1,"xn = 100*x/"$WH"-$3; yn = 100*y/"$WH"-$4; \
xr = xn*"$ct"-yn*"$st"; yr = xn*"$st"+yn*"$ct"; \
xc = xr%$2-"$mid2"; yc = yr%$2-"$mid2"; \
"$mid1"-sqrt(xc*xc+yc*yc)"
*. $6 c. 0,$7 n. 0,$8 (${9--1}) y. c r. ..,..,..
j... .,0,0,0,0,1,.. rm[-2,-1]
mv. 1 done rm[0] v +
#@cli polygon : N>=1,x1[%],y1[%],...,xN[%],yN[%],_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified colored N-vertices polygon on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the polygon is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,0.3,0,255,0 polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,1,0xCCCCCCCC,255
#@cli : $ image.jpg 2,16,1,1,'u(if(x,{h},{w}))' polygon[-2] {h},{^},0.6,255,0,255 remove[-1]
#@cli quiver : [function_image],_sampling[%]>0,_factor>=0,_is_arrow={ 0 | 1 },_opacity,_color1,...
#@cli : Draw specified 2D vector/orientation field on selected images.
#@cli : Default values: 'sampling=5%', 'factor=1', 'is_arrow=1', 'opacity=1', 'pattern=(undefined)'
#@cli : and 'color1=0'.
#@cli : $ 100,100,1,2,'if(c==0,x-w/2,y-h/2)' 500,500,1,3,255 quiver[-1] [-2],10
#@cli : $ image.jpg +resize2dy 600 luminance[0] gradient[0] mul[1] -1 reverse[0,1] append[0,1] c blur[0] 8 orientation[0] quiver[1] [0],20,1,1,0.8,255
quiver : check ${"is_image_arg $1"}" && ${2=5%}>0 && ${3=1}>=0 && isbool(${4=1})" skip "${5=1},${6=0}"
e[^-1] "Draw 2D vector field $1 on image$?, with sampling $2, factor $3, arrows "${"arg 1+$4,disabled,enabled"}", opacity $5 and color (${6--1})."
v - pass$1 repeat {$!-1} l[$>,-1]
eval ${-math_lib}"
s_sampling = ['$2'];
sampling = s_sampling[size(s_sampling) - 1 ]==_'%'?min(w#0,h#0)*$2:$2;
vmax = max(abs(im),abs(iM));
vmax = vmax?vmax:1;
fact = $3*sampling/vmax;
for (y = sampling/2, y<h#0, y+=sampling,
for (x = sampling/2, x<w#0, x+=sampling,
X = round(x*w/w#0); Y = round(y*h/h#0);
u = i(X,Y,0,0)*fact; v = i(X,Y,0,1)*fact;
if ($4,
arrow(#0,[x,y],[x + u,y + v],45,sampling/4,$5,[${6--1}]),
polygon(#0,2,[x - 0.5*u,y - 0.5*v],[x + 0.5*u,y + 0.5*v],$5,[${6--1}]);
);
);
);
"
endl done rm. v +
#@cli rectangle : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,...
#@cli : Draw specified colored rectangle on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the rectangle is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 30 rectangle {u(100)}%,{u(100)}%,{u(100)}%,{u(100)}%,0.3,${-RGB} done
rectangle : skip ${5=1},${6=0},${7=$6}
if ${"is_pattern \"$5\""}
e[0--3] "Draw outlined rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${7--1})."
else
e[0--3] "Draw filled rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${6--1})."
fi
v - polygon 4,$1,$2,$3,$2,$3,$4,$1,$4,${5--1} v +
#@cli rorschach : 'smoothness[%]>=0','mirroring={ 0=none | 1=x | 2=y | 3=xy }
#@cli : Render rorschach-like inkblots on selected images.
#@cli : Default values: 'smoothness=5%' and 'mirroring=1'.
#@cli : $ 400,400 rorschach 3%
rorschach : check "${1=5%}>=0 && isint(${2=1}) && $2>=0 && $2<=3"
e[^-1] "Render rorschach-like inkblots on image$?, with smoothness $1 and "${arg\ 1+$2,no,x,y,xy}"-mirroring."
v -
if {$2==0}
rand -1,1 b $1 >= 0
elif {$2==1}
repeat $! l[$>]
w={w}
columns 0,{w/2-1} rand -1,1 b $1 >= 0
+mirror x if {$w%2} columns. 1,100% fi a x
endl done
elif {$2==2}
repeat $! l[$>]
h={h}
rows 0,{h/2-1} rand -1,1 b $1 >= 0
+mirror y if {$h%2} rows. 1,100% fi a y
endl done
elif {$2==3}
repeat $! l[$>]
w={w} h={h}
z 0,0,{w/2-1},{h/2-1} rand -1,1 b $1 >= 0
+mirror x if {$w%2} columns. 1,100% fi a x
+mirror y if {$h%2} rows. 1,100% fi a y
endl done
fi
v +
#@cli sierpinski : recursion_level>=0
#@cli : Draw Sierpinski triangle on selected images.
#@cli : Default value: 'recursion_level=7'.
#@cli : $ image.jpg sierpinski 7
sierpinski : check ${1=7}>=0 skip ${2=50},${3=0},${4=0},${5=100},${6=100},${7=100}
e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
v - _sierpinski ${2-7},$1  v +
_sierpinski :
if {$7<=0} polygon 3,$1%,$2%,$3%,$4%,$5%,$6%,1,255 return fi
_sierpinski $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},{$7-1}
_sierpinski {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},{$7-1}
_sierpinski {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},{$7-1}
#@cli spiralbw
#@cli : Draw (squared) spiral on selected images.
#@cli : $ 16,16 spiralbw
spiralbw :
e[^-1] "Draw (squared) black and white spiral on image$?."
v - channels 0
f "r=min(x,y,w-1-x,h-1-y); 2*r*(w+h-2*r-1) + if(min(x,h-1-y)>=min(w-1-x,y),x+y,2*(w+h-2-2*r)-x-y)"
v +
#@cli spline : x0[%],y0[%],u0[%],v0[%],x1[%],y1[%],u1[%],v1[%],_opacity,_color1,...
#@cli : Draw specified colored spline curve on selected images (cubic hermite spline).
#@cli : Default values: 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg repeat 30 spline {u(100)}%,{u(100)}%,{u(-600,600)},{u(-600,600)},{u(100)}%,{u(100)}%,{u(-600,600)},{u(-600,600)},0.6,255 done
spline : skip ${9=1},${10=0}
e[^-1] "Draw spline from ($1,$2) [$3,$4] to ($5,$6) [$7,$8] on image$?, with opacity $9 and color (${10--1})."
v -
repeat $! l[$>]
x0={if(${"is_percent $1"},$1*(w-1),$1)}
y0={if(${"is_percent $2"},$2*(h-1),$2)}
u0={if(${"is_percent $3"},$3*(w-1),$3)}
v0={if(${"is_percent $4"},$4*(h-1),$4)}
x1={if(${"is_percent $5"},$5*(w-1),$5)}
y1={if(${"is_percent $6"},$6*(h-1),$6)}
u1={if(${"is_percent $7"},$7*(w-1),$7)}
v1={if(${"is_percent $8"},$8*(h-1),$8)}
eval ${-math_lib}"spline(#0,["$x0","$y0"],["$u0","$v0"],["$x1","$y1"],["$u1","$v1"],$9,[${10--1}])"
endl done v +
#@cli tetraedron_shade : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,...,R3,G3,B3,...
#@cli : Draw tetraedron with interpolated colors on selected (volumetric) images.
tetraedron_shade :
e[^-1] "Draw tetraderon ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12) with interpolated colors in image$?."
v -
xm={round(min($1,$4,$7,$10),1,-1)} xM={round(max($1,$4,$7,$10),1,1)}
ym={round(min($2,$5,$8,$11),1,-1)} yM={round(max($2,$5,$8,$11),1,1)}
zm={round(min($3,$6,$9,$12),1,-1)} zM={round(max($3,$6,$9,$12),1,1)}
l[] (${1-3},1;${4-6},1;${7-9},1;${10-12},1) (${13--1}) r. {w/4},4,1,1,-1 s. x solve[^0] [0] rm[0] a c endl
f[^-1] "*
begin(
x0 = $1; y0 = $2; z0 = $3;
x1 = $4; y1 = $5; z1 = $6;
x2 = $7; y2 = $8; z2 = $9;
x3 = $10; y3 = $11; z3 = $12;
u01 = x1 - x0; v01 = y1 - y0; w01 = z1 - z0;
u02 = x2 - x0; v02 = y2 - y0; w02 = z2 - z0;
u03 = x3 - x0; v03 = y3 - y0; w03 = z3 - z0;
u12 = x2 - x1; v12 = y2 - y1; w12 = z2 - z1;
u13 = x3 - x1; v13 = y3 - y1; w13 = z3 - z1;
u23 = x3 - x2; v23 = y3 - y2; w23 = z3 - z2;
nx012 = v01*w02 - w01*v02; ny012 = w01*u02 - u01*w02; nz012 = u01*v02 - v01*u02;
if (nx012*u03 + ny012*v03 + nz012*w03<0, nx012*=-1; ny012*=-1; nz012*=-1);
nx013 = v01*w03 - w01*v03; ny013 = w01*u03 - u01*w03; nz013 = u01*v03 - v01*u03;
if (nx013*u02 + ny013*v02 + nz013*w02<0, nx013*=-1; ny013*=-1; nz013*=-1);
nx023 = v02*w03 - w02*v03; ny023 = w02*u03 - u02*w03; nz023 = u02*v03 - v02*u03;
if (nx023*u01 + ny023*v01 + nz023*w01<0, nx023*=-1; ny023*=-1; nz023*=-1);
nx123 = v12*w13 - w12*v13; ny123 = w12*u13 - u12*w13; nz123 = u12*v13 - v12*u13;
if (-nx123*u01 - ny123*v01 - nz123*w01<0, nx123*=-1; ny123*=-1; nz123*=-1);
);
if (x<"$xm" || x>"$xM" || y<"$ym" || y>"$yM" || z<"$zm" || z>"$zM",i,
dx0 = x - x0; dy0 = y - y0; dz0 = z - z0;
dx1 = x - x1; dy1 = y - y1; dz1 = z - z1;
is_in = dx0*nx012 + dy0*ny012 + dz0*nz012>=0 &&
dx0*nx013 + dy0*ny013 + dz0*nz013>=0 &&
dx0*nx023 + dy0*ny023 + dz0*nz023>=0 &&
dx1*nx123 + dy1*ny123 + dz1*nz123>=0;
is_in? i(#-1,0,0,0)*x + i(#-1,0,1,0)*y + i(#-1,0,2,0)*z + i(#-1,0,3,0) :i
)
"
rm.
v +
#@cli t : eq. to 'text'. : (+)
#@cli text : text,_x[%],_y[%],_font_height[%]>=0,_opacity,_color1,... : (+)
#@cli : Draw specified colored text string on selected images.
#@cli : (eq. to 't').\n
#@cli : Sizes '13' and '128' are special and correspond to binary fonts (no-antialiasing).
#@cli : Any other font size is rendered with anti-aliasing.
#@cli : Specifying an empty target image resizes it to new dimensions such that the image contains
#@cli : the entire text string.
#@cli : Default values: 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg resize2dy 600 y=0 repeat 30 text {2*$>}" : This is a nice text, isn't it ?",10,$y,{2*$>},0.9,255 y+={2*$>} done
#@cli : $ 0 text "G'MIC",0,0,23,1,255
#@cli to : eq. to 'text_outline'.
to : skip ${2=1%}
_text_outline "$1",${2--1}
#@cli text_outline : text,_x[%],_y[%],_font_height[%]>0,_outline>=0,_opacity,_color1,...
#@cli : Draw specified colored and outlined text string on selected images.
#@cli : Default values: 'x=y=1%', 'font_height=7.5%', 'outline=2', 'opacity=1' and 'color1=255'.
#@cli : $ image.jpg text_outline "Hi there!",10,10,63,3
text_outline : skip ${2=1%}
_text_outline "$1",${2--1}
_text_outline : skip ${3=1%},${4=7.5%},${5=2},${6=1},${7=255}
e[0--3] "Draw outlined text '$1' at position ($2,$3) on image$?, with font height $4, outline $5, opacity $6 and color ${7--1}."
v - if $5
repeat $! l[$>]
0 t. "$1",0,0,{-2,${"is_percent $4"}?h*$4:$4},1,${7--1},1 expand_xy. {1+$5},0
s. c,{-narg(${7--1})} dilate. {2*$5+1}
if {0,w} r[1] 100%,100%,1,{0,s},0,1 j[0] [1],$2,$3,0,0,$6,[2]
else rm[0] i[0] [0] fi
rm[-2,-1]
endl done
else t "$1",${2-4},${6--1}
fi v +
#@cli triangle_shade : x0,y0,x1,y1,x2,y2,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,...
#@cli : Draw triangle with interpolated colors on selected images.
#@cli : $ image.jpg triangle_shade 20,20,400,100,120,200,255,0,0,0,255,0,0,0,255
triangle_shade :
e[^-1] "Draw triangle ($1,$2)-($3,$4)-($5,$6) with interpolated colors on image$?."
v -
l[] ($1,$2,1;$3,$4,1;$5,$6,1) (${7--1}) r. {w/3},3,1,1,-1 s. x solve[^0] [0] rm[0] a c endl
invarea={(-$4*$5+$2*(-$3+$5)+$1*($2-$6)+$3*$6)^-1}
s1={$2*$5-$1*$6} s2={$6-$2} s3={$1-$5}
t1={$1*$4-$2*$3} t2={$2-$4} t3={$3-$1}
repeat {$!-1} l[$>,-1] repeat {0,s}
a={i(0,0,0,$>)} b={i(0,1,0,$>)} c={i(0,2,0,$>)}
sh[0] $>
f. "s = "$invarea"*("$s1" + "$s2"*x + "$s3"*y); t = "$invarea"*("$t1" + "$t2"*x + "$t3"*y); s>=0 && t>=0 && t+s<=1 ? "$a"*x+"$b"*y+"$c":i"
rm.
done endl done
rm. v +
#@cli truchet : _scale>0,_radius>=0,_pattern_type={ 0=straight | 1=curved }
#@cli : Fill selected images with random truchet patterns.
#@cli : Default values: 'scale=32', 'radius=5' and 'pattern_type=1'.
#@cli : $ 400,300 truchet ,
truchet : check "isint(${1=32}) && $1>0 && ${2=3}>=0" skip ${3=1}
e[^-1] "Render "${arg\ 1+!$3,curved,straight}" truchet patterns in image$?, with scale $1 and radius $2."
v - repeat $! l[$>] nm={0,n}
w={w} h={h} s={s} rm
$1,$1 = 1,0,0 = 1,100%,100% distance 1,{1+$3} M={int(iM/2)}
ir {$M-$2/2-($1%2)},{$M+$2/2} +mirror y a x
{round($w/$1,1,1)},{round($h/$1,1,1)} rand. 0,1 >=. 50% r. {w*$1},{h*$1} *. $1
channels. 0,1 (0,{$1-1}) r. $1,$1,1,1,3 +transpose. a[-2,-1] c r. ..,0,2 +[-2,-1]
warp.. . rm. >= 50% r $w,$h,1,1,0 r 100%,100%,1,$s
nm $nm endl done v +
#@cli turbulence : _radius>0,_octaves={1,2,3...,12},_alpha>0,_difference={-10,10},_mode={0,1,2,3}
#@cli : Render fractal noise or turbulence on selected images.
#@cli : Default values: 'radius=32', 'octaves=6', 'alpha=3', 'difference=0' and 'mode=0'.
#@cli : $ 400,400,1,3 turbulence 16
#@cli : $$
turbulence : check "${1=32}>0 && ${2=6}>0" skip ${3=3},${4=0},${5=0}
e[^-1] "Render fractal noise or turbulence on image$?, with radius $1, octaves $2, damping per octave $3, difference $4 and mode $5."
v - repeat $! l[$>] nm={0,n}
if {$4} . fi
f. 0 +noise. 10,0 b. $1,0
if {$5==0||$5==1} -. {ia} abs.
elif {$5==3||$5==4} ^. 2
elif {$5==5} ^. 3
fi
repeat {$2-1}
+noise.. 10,0 b. {$1/2^$>},0
if {$5==0} -. {ia} abs.
elif {$5==4} ^. 2
elif {$5==5} ^. 3
fi
*.. $3 +[-2--1]
done
n. 0,255
rm..
if {$4} *. $4 mv.. 2 - n. 0,255 fi
nm $nm endl done v +
#@cli yinyang
#@cli : Draw a yin-yang symbol on selected images.
#@cli : $ 400,400 yinyang
yinyang :
e[^-1] "Draw yin-yang symbol on image$?."
v - f 0 repeat $! l[$>]
s={s} channels 0
r={round(0.95*min(w,h)/4)}
+line 50%,0,50%,50%,1,2 ellipse. 50%,{h/2-$r},$r,$r,0,1,2
line. 50%,50%,50%,100%,1,1 ellipse. 50%,{h/2+$r},$r,$r,0,1,1
flood. {w/2-$r},50%,0,0,0,1,2
flood. {w/2+$r},50%,0,0,0,1,1
ellipse.. 50%,50%,{2*$r},{2*$r},0,1,1
*
ellipse. 50%,{h/2-$r},{$r/3},{$r/3},0,1,1
ellipse. 50%,{h/2+$r},{$r/3},{$r/3},0,1,2
r 100%,100%,1,$s
endl done v +
#@cli :: Matrix Computation
#@cli dijkstra : starting_node>=0,ending_node>=0 : (+)
#@cli : Compute minimal distances and paths from specified adjacency matrices by the Dijkstra algorithm.
#@cli eigen : (+)
#@cli : Compute the eigenvalues and eigenvectors of selected symmetric matrices or matrix fields.
#@cli : If one selected image has 3 or 6 channels, it is regarded as a field of 2x2 or 3x3 symmetric matrices,
#@cli : whose eigen elements are computed at each point of the field.
#@cli : $ (1,0,0;0,2,0;0,0,3) +eigen
#@cli : $ image.jpg structuretensors blur 2 eigen split[0] c
#@cli : $$
#@cli invert : (+)
#@cli : Compute the inverse of the selected matrices.
#@cli : $ (0,1,0;0,0,1;1,0,0) +invert
#@cli solve : [image] : (+)
#@cli : Solve linear system AX = B for selected B-matrices and specified A-matrix.
#@cli : If the system is under- or over-determined, the least square solution is returned.
#@cli : $ (0,1,0;1,0,0;0,0,1) (1;2;3) +solve[-1] [-2]
#@cli svd : (+)
#@cli : Compute SVD decomposition of selected matrices.
#@cli : $ 10,10,1,1,'if(x==y,x+u(-0.2,0.2),0)' +svd
#@cli transpose
#@cli : Transpose selected matrices.
#@cli : $ image.jpg +transpose
transpose :
e[^-1] "Transpose image$?."
v - permute yxzc v +
#@cli trisolve : [image] : (+)
#@cli : Solve tridiagonal system AX = B for selected B-vectors and specified tridiagonal A-matrix.
#@cli : Tridiagonal matrix must be stored as a 3 column vector, where 2nd column contains the
#@cli : diagonal coefficients, while 1st and 3rd columns contain the left and right coefficients.
#@cli : $ (0,0,1;1,0,0;0,1,0) (1;2;3) +trisolve[-1] [-2]
#@cli :: 3D Rendering
#@cli +3d : eq. to 'add3d'. : (+)
#@cli add3d : tx,_ty,_tz : [object3d] : (no arg) : (+)
#@cli : Shift selected 3D objects with specified displacement vector, or merge them with specified
#@cli : 3D object, or merge all selected 3D objects together.
#@cli : (eq. to '+3d').
#@cli : Default values: 'ty=tz=0'.
#@cli : $ sphere3d 10 repeat 5 +add3d[-1] 10,{u(-10,10)},0 color3d[-1] ${-RGB} done add3d
#@cli : $ repeat 20 torus3d 15,2 color3d[-1] ${-RGB} mul3d[-1] 0.5,1 if {$>%2} rotate3d[-1] 0,1,0,90 fi add3d[-1] 70 add3d rotate3d[-1] 0,0,1,18 done double3d 0
#@cli animate3d : _width>0,_height>0,_angle_dx,_angle_dy,_angle_dz,_zoom_factor>=0,_filename
#@cli : Animate selected 3D objects in a window.
#@cli : If argument 'filename' is provided, each frame of the animation is saved as a numbered filename.
#@cli : Default values: 'width=640', 'height=480', 'angle_dx=0', 'angle_dy=1', 'angle_dz=0', 'zoom_factor=1' and 'filename=(undefined)'.
animate3d : skip ${1=640},${2=480},${3=0},${4=1},${5=0},"${7=""}" check ${6=1}>=0
e[^-1] "Animate 3D object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
v - is_multi={$!>1} repeat $! +l[$>]
n3d *3d {$6*min($1,$2)/1.5} c3d
ax=0 ay=0 az=0 frame=0 vfact=1
do
+r3d 1,0,0,$ax r3d. 0,1,0,$ay r3d. 0,0,1,$az
ax+=$3 ay+=$4 az+=$5
$1,$2,1,3,-1 j3d. ..,50%,50%,0,1
if {narg("$7")}
to_rgba. replace_color. 0,0,-1,-1,-1,255,64,64,64,0
if $is_multi filename=${filename\ "$7",$>,$frame} else filename=${filename\ "$7",$frame} fi
o. $filename frame+=1
else
replace. -1,64
fi
w. {$vfact*w},{$vfact*h},0,0,-1,-1,{0,n} wait 20 k[0]
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-D}} vfact=1.5 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-C}} vfact={1/1.5} fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-R}} vfact=1 fi
while {{*}" && "!{*,ESC}" && "!{*,Q}} rm w 0
endl done v +
#@cli apply_camera3d : pos_x,pos_y,pos_z,target_x,target_y,target_z,up_x,up_y,up_z
#@cli : Apply 3D camera matrix to selected 3D objects.
#@cli : Default values: 'target_x=0', 'target_y=0', 'target_z=0', 'up_x=0', 'up_y=-1' and 'up_z=0'.
apply_camera3d : skip ${4=0},${5=0},${6=0},${7=0},${8=-1},${9=0}
e[^-1] "Apply 3D camera matrix to 3D object$?, with camera position ($1,$2,$3), target position ($4,$5,$6) and up-vector ($7,$8,$9)."
v -
({$4-$1}^{$5-$2}^{$6-$3})
($7^$8^$9)
orientation[-2,-1]
_cross3d {-2,^},{^}
_cross3d {^},{-3,^}
rm... y[-3--1] x mv[-2,-1] -3
a[-3--1] y z. 0,3
-3d[^-1] $1,$2,$3 pose3d[^-1] {^} rm. -3d 0,0,800
v +
_cross3d :
({$2*$6-$3*$5}^{$3*$4-$1*$6}^{$1*$5-$2*$4}) orientation. y.
#@cli apply_matrix3d : a11,a12,a13,...,a31,a32,a33
#@cli : Apply specified 3D rotation matrix to selected 3D objects.
#@cli : $ torus3d 10,1 +apply_matrix3d {mul(rot(1,0,1,-15),[1,0,0,0,2,0,0,0,8],3)} double3d 0
apply_matrix3d :
e[^-1] "Apply 3x3 matrix (${1-3};${4-6};${7-9}) to 3D object$?."
v - repeat $! l[$>]
nbp={i[6]} sh 8,{8+3*$nbp-1},0,0 r. 3,$nbp,1,1,-1 3,3,1,1,$* transpose. m*[-2,-1] rm.
endl done v +
#@cli array3d : size_x>=1,_size_y>=1,_size_z>=1,_offset_x[%],_offset_y[%],_offset_y[%]
#@cli : Duplicate a 3D object along the X,Y and Z axes.
#@cli : Default values: 'size_y=1', 'size_z=1' and 'offset_x=offset_y=offset_z=100%'.
#@cli : $ torus3d 10,1 +array3d 5,5,5,110%,110%,300%
array3d : check "isint($1) && $1>0 && isint(${2=1}) && $2>0 && isint(${3=1}) && $3>0" skip ${4=100%},${5=100%},${6=100%}
e[^-1] "Duplicate 3D object$? along X,Y,Z axes with factors ($1,$2,$3) and offsets ($4,$5,$6)."
v - repeat $! l[$>]
+rows 8,{8+3*i[6]} r. 3,{h/3},1,1,-1 s. x,3
dx={-3,if(${is_percent\ $4},$4*(iM-im),$4)}
dy={-2,if(${is_percent\ $5},$5*(iM-im),$5)}
dz={if(${is_percent\ $6},$6*(iM-im),$6)}
rm[-3--1]
off=0 repeat {int(log2($1))}
++3d. {2^$>*$dx} +3d. ..
if {!($1&(2^$>))} rm.. else +3d.. $off off+={2^$>*$dx} fi
done +3d. $off +3d
off=0 repeat {int(log2($2))}
++3d. 0,{2^$>*$dy} +3d. ..
if {!($2&(2^$>))} rm.. else +3d.. 0,$off off+={2^$>*$dy} fi
done +3d. 0,$off +3d
off=0 repeat {int(log2($3))}
++3d. 0,0,{2^$>*$dz} +3d. ..
if {!($3&(2^$>))} rm.. else +3d.. 0,0,$off off+={2^$>*$dz} fi
done +3d. 0,0,$off +3d
endl done v +
#@cli arrow3d : x0,y0,z0,x1,y1,z1,_radius[%]>=0,_head_length[%]>=0,_head_radius[%]>=0
#@cli : Input 3D arrow with specified starting and ending 3D points.
#@cli : Default values: 'radius=5%', 'head_length=25%' and 'head_radius=15%'.
#@cli : $ repeat 10 a={$>*2*pi/10} arrow3d 0,0,0,{cos($a)},{sin($a)},-0.5 done +3d
arrow3d : check "${7=5%}>=0 && ${8=25%}>=0 && ${9=15%}>=0"
e[^-1] "Input 3D arrow, from (${1-3}) to (${4-6}), with radius $7, head length $8 and head radius $9."
v -
L={sqrt(($4-$1)^2+($5-$2)^2+($6-$3)^2)}
R={if(${is_percent\ $7},$7*$L,$7)}
l={if(${is_percent\ $8},$8*$L,$8)}
r={if(${is_percent\ $9},$9*$L,$9)}
L-=$l cylinder3d $R,$L cone3d $r,$l +3d. 0,0,$L +3d[-2,-1]
({$4-$1}^{$5-$2}^{$6-$3}) (0.01^-0.02^0.03) orientation[-2,-1]
_cross3d {-2,^},{^} _cross3d {^},{-3,^} rm... y[-3--1] x mv[-2,-1] -3
a[-3--1] y
s3d.. r[-5] 3,{-5,h/3},1,1,-1 m*[-5,-1]
y[-4] a[-6--1] y +3d. ${1-3} rv3d.
v +
#@cli axes3d : _size_x,_size_y,_size_z,_font_size>0,_label_x,_label_y,_label_z
#@cli : Input 3D axes with specified sizes along the x,y and z orientations.
#@cli : Default values: 'size_x=size_y=size_z=1', 'font_size=23', 'label_x=X', 'label_y=Y' and 'label_z=Z'.
#@cli : $ axes3d ,
axes3d : check ${4=23}>0 skip ${1=1},${2=$1},${3=$2},"${5=X},${6=Y},${7=Z}"
e[^-1] "Input 3D axes with sizes ($1,$2,$3)."
v - l[]
m={max(abs($1),abs($2),abs($3))/40} m2={2*$m} m3={1.2*$m2}
_axes3d "O",$4 -3d. $m3,$m3,$m3
if $1
line3d 0,0,0,$1,0,0
cone3d $m,{2*$m},16 r3d. 0,1,0,90 +3d. {$1-$m2},0,0
_axes3d "$5",$4 +3d. {$1+$m3},0,0
fi
if $2
line3d 0,0,0,0,$2,0
cone3d $m,{2*$m},16 r3d. 1,0,0,-90 +3d. 0,{$2-$m2},0
_axes3d "$6",$4 +3d. 0,{$2+$m3},0
fi
if $3
line3d 0,0,0,0,0,$3
cone3d $m,{2*$m},16 +3d. 0,0,{$3-$m2}
_axes3d "$7",$4 +3d. 0,0,{$3+$m3}
fi
+3d nm [3d\ axes]
endl v +
_axes3d :
0 t. "$1",2,0,$2,1,1 +dilate. 3 *.. 255 r.. 100%,100%,1,3
i... (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};3)
i.. (-128;{w};{h};1) y[-3,-1] a[-4--1] y
#@cli box3d : _size_x,_size_y,_size_z
#@cli : Input 3D box at (0,0,0), with specified geometry.
#@cli : Default values: 'size_x=1' and 'size_z=size_y=size_x'.
#@cli : $ box3d 100,40,30 +primitives3d 1 color3d[-2] ${-RGB}
box3d : skip ${1=1},${2=$1},${3=$2}
e[^-1] "Input 3D box, with size ($1,$2,$3)."
v -
1,86,1,1,\
67.5,73.5,109.5,103.5,51.5,100.5,8,6,\
0,0,0,$1,0,0,$1,$2,0,0,$2,0,\
0,0,$3,$1,0,$3,$1,$2,$3,0,$2,$3,\
4,0,3,2,1,4,4,5,6,7,4,0,1,5,4,4,3,7,6,2,4,0,4,7,3,4,1,2,6,5,\
200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,\
1,1,1,1,1,1
nm. [3D\ box]
v +
#@cli c3d : eq. to 'center3d'.
c3d :
_center3d
#@cli center3d
#@cli : Center selected 3D objects at (0,0,0).
#@cli : (eq. to 'c3d').
#@cli : $ repeat 100 circle3d {u(100)},{u(100)},{u(100)},2 done add3d color3d[-1] 255,0,0 +center3d color3d[-1] 0,255,0 add3d
center3d :
_$0
_center3d :
e[0--3] "Center 3D object$?."
v - check3d 0 repeat $! l[$>]
if {i[6]}
s3d r[2] 3,{2,h/3},1,1,-1 s[2] x
-[2] {2,(iM+im)/2} -[3] {3,(iM+im)/2} -[4] {4,(iM+im)/2}
a[2-4] x y[2] a y
fi
endl done v +
#@cli circle3d : _x0,_y0,_z0,_radius>=0
#@cli : Input 3D circle at specified coordinates.
#@cli : Default values: 'x0=y0=z0=0' and 'radius=1'.
#@cli : $ repeat 500 a={$>*pi/250} circle3d {cos(3*$a)},{sin(2*$a)},0,{$a/50} color3d[-1] ${-RGB},0.4 done add3d
circle3d : skip ${1=0},${2=0},${3=0},${4=1}
e[^-1] "Input 3D circle at position ($1,$2,$3) with radius $4."
v -
r={$4/sqrt(3)}
1,24,1,1,\
67.5,73.5,109.5,103.5,51.5,100.5,2,1,\
{$1-$r},{$2-$r},{$3-$r},\
{$1+$r},{$2+$r},{$3+$r},\
5,0,1,0,0,0,200,200,200,1
nm. [3D\ circle]
v +
#@cli circles3d : _radius>=0,_is_filled={ 0 | 1 }
#@cli : Convert specified 3D objects to sets of 3D circles with specified radius.
#@cli : Default values: 'radius=1' and 'is_filled=1'.
#@cli : $ image.jpg luminance resize2dy 40 threshold 50% * 255 pointcloud3d color3d[-1] 255,255,255 circles3d 0.7
circles3d : check ${1=1}>=0 skip ${2=1}
e[^-1] "Convert 3D object$? to sets of 3D "${arg\ 1+$2,wireframe,filled}" circles with radius $1."
v - p3d 0 repeat $! l[$>]
nbv={@6} nbp={@7}
if {$nbv&&$nbp}
-3d {$1/2},0,0 ++3d $1,0,0 +3d nbp2={@7}
s3d =[1] $nbp,0,1
r[3] 2,$nbp2,1,1,-1 columns[3] 1,1 s[3] y,2 i[3] 1,$nbp,1,1,5
i[6] 1,$nbp,1,1,{!$2} a[3-6] x columns[3] 0,5
y[3]
rows[4] 0,{3*$nbp-1} rows[5] 0,{$nbp-1} a y
fi
endl done v +
#@cli col3d : eq. to 'color3d'. : (+)
#@cli color3d : R,_G,_B,_opacity : (+)
#@cli : Set color and opacity of selected 3D objects.
#@cli : (eq. to 'col3d').
#@cli : Default value: 'B=G=R' and 'opacity=(undefined)'.
#@cli : $ torus3d 100,10 double3d 0 repeat 7 +rotate3d[-1] 1,0,0,20 color3d[-1] ${-RGB} done add3d
#@cli colorcube3d
#@cli : Input 3D color cube.
#@cli : $ colorcube3d mode3d 2 +primitives3d 1
colorcube3d :
e[^-1] "Input 3D RGB-color cube."
v -
(67.5;73.5;109.5;103.5;51.5;100.5;8;6)
(0;0;0;\
255;0;0;\
255;255;0;\
0;255;0;\
0;0;255;\
255;0;255;\
255;255;255;\
0;255;255)
(12;0;3;2;1;0;0;0;63;63;63;63;0;\
12;1;2;6;5;0;0;0;63;63;63;63;0;\
12;0;4;7;3;0;0;63;0;63;63;0;63;\
12;4;5;6;7;0;0;63;0;63;63;0;63;\
12;0;1;5;4;0;0;63;0;63;63;0;63;\
12;3;7;6;2;0;0;0;63;63;63;63;0)
(0,255;0,255^0,0;255,255^0,0;0,0)
(255,255;255,255^0,0;255,255^0,255;0,255)
(0,0;0,0^0,0;255,255^0,255;0,255)
(0,255;0,255^0,0;255,255^255,255;255,255)
(0,255;0,255^0,0;0,0^0,0;255,255)
(0,255;0,255^255,255;255,255^0,0;255,255)
r[-6--1] 64,64,1,3,3 round[-6--1] y[-6--1] i[-7--2] (-128;64;64;3)
(1;1;1;1;1;1)
a[-16--1] y nm. [3D\ colorcube]
v +
#@cli cone3d : _radius,_height,_nb_subdivisions>0
#@cli : Input 3D cone at (0,0,0), with specified geometry.
#@cli : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@cli : $ cone3d 10,40 +primitives3d 1 color3d[-2] ${-RGB}
cone3d : check ${3=24}>0 skip ${1=1},${2=1}
e[^-1] "Input 3D cone, with radius $1, height $2 and $3 subdivisions."
v -
(67.5;73.5;109.5;103.5;51.5;100.5)
({$3+2};{2*$3})
(0,0,0;0,0,$2)
(0;{2*pi}) r. 1,{$3+1},1,1,3 rows. 0,{$3-1} +sin. cos.. *[-2,-1] $1 a[-2,-1] x z. 0,2 a[-2,-1] y
1,$3,1,1,'y' +shift. 0,-1 +[-2,-1] 2
2,$3,1,1,3,0 .. [-4] a[-3--1] x
i[-4] 2,$3,1,1,3,1 a[-4--2] x
a[-2,-1] y
3,{h},1,1,200
1,{h},1,1,1
y[-4--2] a[-6--1] y nm. [3D\ cone]
v +
#@cli cubes3d : _size>=0
#@cli : Convert specified 3D objects to sets of 3D cubes with specified size.
#@cli : Default value: 'size=1'.
#@cli : $ image.jpg luminance resize2dy 40 threshold 50% * 255 pointcloud3d color3d[-1] 255,255,255 cubes3d 1
cubes3d : check ${1=1}>=0
e[^-1] "Convert 3D object$? to sets of 3D cubes with size $1."
v - p3d 0 repeat $! l[$>]
nbv={@6} nbp={@7}
if {$nbv&&$nbp}
s3d
l[1] = {8*i[0]} = {6*i[1]},0,1 endl
l[2] r 3,{h/3},1,1,-1
half={$1/2}
- '$half,0,0' ++ '$1,0,0' a x
- '0,$half,0' ++ '0,$1,0' a x
- '0,0,$half' ++ '0,0,$1' a x
endl
l[3] r 2,{h/2},1,1,-1
z 1,1 * 8 r 4,100% i[0] 1,100%,1,1,4 a x [-1]x5 a x
+ '"0,0,2,3,1, 0,4,5,7,6, 0,0,1,5,4, 0,2,6,7,3, 0,0,4,6,2, 0,1,3,7,5"'
endl
l[4] r 3,{h/3},1,1,-1 r 18,100%,1,1,0,2 endl r[5] 6,100%
y a y
fi
endl done v +
#@cli cup3d : _resolution>0
#@cli : Input 3D cup object.
#@cli : $ cup3d ,
cup3d : check ${1=128}>0
e[^-1] "Input 3D cup, with resolution $1."
v -
100,200
ellipse. 0%,0%,40%,40%,0,1,1
ellipse. 0,0,35%,35%,0,1,0
polygon. 4,0,45%,8%,45%,20%,90%,0,90%,1,1
ellipse. 0%,100%,30%,10%,0,1,1 b. 0.1%
lathe3d. $1,2 nm. [3D\ cup]
v +
#@cli cylinder3d : _radius,_height,_nb_subdivisions>0
#@cli : Input 3D cylinder at (0,0,0), with specified geometry.
#@cli : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@cli : $ cylinder3d 10,40 +primitives3d 1 color3d[-2] ${-RGB}
cylinder3d : check ${3=24}>0 skip ${1=1},${2=1}
e[^-1] "Input 3D cylinder, with radius $1, height $2 and $3 subdivisions."
v -
(67.5;73.5;109.5;103.5;51.5;100.5)
({2*$3+2};{3*$3})
(0,0,0;0,0,$2)
(0;{2*pi}) r. 1,{$3+1},1,1,3 rows. 0,{$3-1} +sin. cos.. *[-2,-1] $1 a[-2,-1] x
+z. 0,2 1,$3,1,1,$2 a[-3,-1] x
a[-3--1] y
1,$3,1,1,'y' +shift. 0,-1 +[-2,-1] 2
2,$3,1,1,3,1 ... ... a[-3--1] x
2,$3,1,1,3,0 ... [-5] +[-2,-1] $3 a[-3--1] x
++[-4,-3] $3 i[-7] 1,$3,1,1,4 rv[-6,-5] a[-7--5,-2,-1] x
3,{3*$3},1,1,200
1,{h},1,1,1
y[-6--2] a[-8--1] y nm. [3D\ cylinder]
v +
#@cli delaunay3d
#@cli : Generate 3D delaunay triangulations from selected images.
#@cli : One assumes that the selected input images are binary images containing the set of points to mesh.
#@cli : The output 3D object is a mesh composed of non-oriented triangles.
#@cli : $ 500,500 noise 0.05,2 eq 1 * 255 +delaunay3d color3d[1] 255,128,0 dilate_circ[0] 5 to_rgb[0] +object3d[0] [1],0,0,0,1,1 max[-1] [0]
delaunay3d :
e[^-1] "Generate 3D delaunay triangulation from image$?."
v - repeat $! l[$>]
channels 0 != 0
whd={w},{h},{d} +r 1,{w*h*d},1,1,-1 cumulate. *. .. r. $whd,1,-1
+distance[0] 1 *[2] -1 watershed[1] [2] rm[2]
r[1] 100%,100%,100%,3
if {d>1}
+_delaunay3d[1] 1,0,0,0,0,1 +_delaunay3d[1] -1,0,0,0,0,-1
+_delaunay3d[1] 0,1,0,0,0,1 +_delaunay3d[1] 0,-1,0,0,0,-1
fi
+_delaunay3d[1] 1,0,0,0,1,0 _delaunay3d[1] -1,0,0,0,-1,0
a[^0] x transpose. -. 1
pointcloud3d[0]
s3d[0] rm[3-5] i.. 1,100%,1,1,3 a[-2,-1] x
3,100%,1,1,200 1,100%,1,1,1 =[1] {h},0,1 y a y
endl done v +
_delaunay3d :
f. "A=j($1,$2,$3,0,0,1); B=j($4,$5,$6,0,0,1);
if(i!=A && i!=B && A!=B, kth(1+c,i,A,B),0)"
discard. 0 r. {h/3},3,1,1,-1
#@cli distribution3d
#@cli : Get 3D color distribution of selected images.
#@cli : $ image.jpg distribution3d colorcube3d primitives3d[-1] 1 add3d
distribution3d :
e[^-1] "Get 3D color distribution of image$?."
v - to_rgb permute "cxyz" y
repeat $! l[$>]
nbp={round(h/3)}
i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
$nbp;$nbp)
1,$nbp,1,1,1 +f. y a[-2,-1] x y.
..
1,$nbp,1,1,1
a y nm. [3D\ distribution]
endl done v +
#@cli /3d : eq. to 'div3d'. : (+)
#@cli div3d : factor : factor_x,factor_y,_factor_z : (+)
#@cli : Scale selected 3D objects isotropically or anisotropically, with the inverse of specified
#@cli : factors.
#@cli : (eq. to '/3d').
#@cli : Default value: 'factor_z=0'.
#@cli : $ torus3d 5,2 repeat 5 +add3d[-1] 12,0,0 div3d[-1] 1.2 color3d[-1] ${-RGB} done add3d
#@cli db3d : eq. to 'double3d'. : (+)
#@cli double3d : _is_double_sided={ 0 | 1 } : (+)
#@cli : Enable/disable double-sided mode for 3D rendering.
#@cli : (eq. to 'db3d').
#@cli : Default value: 'is_double_sided=1'.
#@cli : $ mode3d 1 repeat 2 torus3d 100,30 rotate3d[-1] 1,1,0,60 double3d $> snapshot3d[-1] 400 done
#@cli elevation3d : z-factor : [elevation_map] : 'formula' : (no arg) : (+)
#@cli : Build 3D elevation of selected images, with a specified elevation map.
#@cli : When invoked with (no arg) or 'z-factor', the elevation map is computed as the pointwise L2 norm of the
#@cli : pixel values. Otherwise, the elevation map is taken from the specified image or formula.
#@cli : $ image.jpg blur 5 elevation3d 0.5
#@cli : $ 128,128,1,3,u(255) plasma 10,3 blur 4 sharpen 10000 elevation3d[-1] 'X=(x-64)/6;Y=(y-64)/6;-100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'
#@cli empty3d
#@cli : Input empty 3D object.
#@cli : $ empty3d
empty3d :
e[^-1] "Input empty 3D object."
v - (67.5;73.5;109.5;103.5;51.5;100.5;0;0) nm. [3D\ empty] v +
#@cli extrude3d : _depth>0,_resolution>0,_smoothness[%]>=0
#@cli : Generate extruded 3D object from selected binary XY-profiles.
#@cli : Default values: 'depth=16', 'resolution=1024' and 'smoothness=0.5%'.
#@cli : $ image.jpg threshold 50% extrude3d 16
extrude3d : check "${1=16}>0 && ${2=1024}>0 && ${3=0.5%}>=0"
e[^-1] "Generate extruded 3D object from XY-profile$?, with depth $1, resolution $2 and smoothness $3."
v - norm n 0,1 autocrop 0 repeat $! l[$>] nm={0,n}
wr={round(max(1,if(w>h,min($2,w),min($2,h)*w/h)))}
hr={round(max(1,if(w>h,min($2,w)*h/w,min($2,h))))}
fact={$1/max(w/$wr,h/$hr)}
b $3,0 r $wr,$hr,1,1,2 expand_xyz 1,0
isosurface3d 50% *3d 1,1,$fact rv3d
nm $nm endl done v +
#@cli f3d : eq. to 'focale3d'. : (+)
#@cli focale3d : focale : (+)
#@cli : Set 3D focale.
#@cli : (eq. to 'f3d').\n
#@cli : Set 'focale' to 0 to enable parallel projection (instead of perspective).
#@cli : Set negative 'focale' will disable 3D sprite zooming.
#@cli : Default value: 'focale=700'.
#@cli : $ repeat 5 torus3d 100,30 rotate3d[-1] 1,1,0,60 focale3d {$<*90} snapshot3d[-1] 400 done remove[0]
#@cli gaussians3d : _size>0,_opacity
#@cli : Convert selected 3D objects into set of 3D gaussian-shaped sprites.
#@cli : $ image.jpg r2dy 32 distribution3d gaussians3d 20 colorcube3d primitives3d[-1] 1 +3d
gaussians3d : check "${1=32}>0" skip ${2=0.3}
e[^-1] "Convert 3D object$? into sets of gaussian-shaped 3D sprites, with size $1 and opacity $2."
v - p3d 2 p3d 0 repeat $! l[$>] nm={0,n} s3d
nbv={h} rm. (-128;$1;$1;1)
$1,$1 gaussian. 35%,35%,0 c. 30%,100% n. 0,$2 y. a[-2,-1] y
if {$nbv>1} 4,{$nbv-1},1,1,-128,0,0,0 y[-2,-1] a[-2,-1] y fi
a y
nm $nm endl done v +
#@cli gmic3d
#@cli : Input a 3D G'MIC logo.
#@cli : $ gmic3d +primitives3d 1
gmic3d :
e[^-1] "Input 3D G\47MIC logo."
v -
text3d G,60,20,2 col3d. 16,64,255
text3d \',60,20,2 +3d. 40 col3d. 64,128,255
text3d M,60,20,2 +3d. 50 col3d. 96,196,255
text3d I,60,20,2 +3d. 90 col3d. 64,128,255
text3d C,60,20,2 +3d. 100 col3d. 16,64,255
sphere3d 8 +3d. 102,-3,20 col3d. 192,128,255
+3d[-6--1] c3d.
repeat 30
box3d {min(3+$</2,10)} col3d. {30*$>},{20+80*$>},{10*$>},0.5
r3d. 1,1,1,{$>*12}
+3d. {80*cos(0.5+1.02*$>*12*pi/180)},{30*sin(0.8+$>*12*pi/180)},{2*$>-60}
done
+3d[-30--1] +3d. 0,5,30 +3d[-2--1] nm. [3d\ gmic]
v +
#@cli gyroid3d : _resolution>0,_zoom
#@cli : Input 3D gyroid at (0,0,0), with specified resolution.
#@cli : Default values: 'resolution=32' and 'zoom=5'.
#@cli : $ gyroid3d 48 +primitives3d 1
gyroid3d : check ${1=32}>0 skip ${2=5}
e[^-1] "Input 3D gyroid, with resolution $1 and range $2."
v -
isosurface3d "'0.49*(\
cos( 2*x + y + z - pi) + cos( 2*x - y + z - pi)\
+ cos(- 2*x + y - z - pi) + cos(- 2*x - y - z - pi)\
+ cos( x + 2*y + z - pi) + cos( x + 2*y - z - pi)\
+ cos(- x - 2*y + z - pi) + cos(- x - 2*y - z - pi)\
+ cos( x + y + 2*z - pi) + cos(- x + y + 2*z - pi)\
+ cos( x - y - 2*z - pi) + cos(- x - y - 2*z - pi)\
+ cos(- 2*x + y + z) + cos( 2*x + y - z)\
+ cos(- 2*x - y + z) + cos( 2*x - y - z)\
+ cos(- x + 2*y + z) + cos( x - 2*y + z)\
+ cos(- x + 2*y - z) + cos( x - 2*y - z)\
+ cos( x - y + 2*z) + cos( x + y - 2*z)\
+ cos(- x - y + 2*z) + cos(- x + y - 2*z)\
) + 0.27*( \
cos(- 2*x + 2*y - pi) + cos( 2*x - 2*y - pi)\
+ cos( 2*x + 2*y - pi) + cos(- 2*x - 2*y - pi)\
+ cos(- 2*y + 2*z - pi) + cos( 2*y - 2*z - pi)\
+ cos( 2*y + 2*z - pi) + cos(- 2*y - 2*z - pi)\
+ cos(- 2*z + 2*x - pi) + cos( 2*z - 2*x - pi)\
+ cos( 2*z + 2*x - pi) + cos(- 2*z - 2*x - pi)\
) - 0.69'",0,{-$2},{-$2},{-$2},$2,$2,$2,$1,$1,$1
c3d. n3d. nm. [3D\ gyroid]
v +
#@cli histogram3d
#@cli : Get 3D color histogram of selected images.
#@cli : $ image.jpg histogram3d colorcube3d primitives3d[-1] 1 add3d
histogram3d :
e[^-1] "Get 3D color histogram of image$?."
v - to_rgb repeat $! l[$>]
r {w*h},3,1,1,-1 pointcloud 1 n 0,255 map 3 pointcloud3d nm "[3D histogram]"
endl done v +
#@cli image6cube3d
#@cli : Generate 3D mapped cubes from 6-sets of selected images.
#@cli : $ image.jpg animate flower,"30,0","30,5",6 image6cube3d
image6cube3d :
e[^-1] "Generate 3D mapped cubes from image$?."
v - M={max(${-max_wh})} r $M,$M,1,3 imageplane3d n3d c3d
repeat {int($!/6)} l[$>-{$>+5}]
+3d[0] 0,0,-0.5
r3d[1] 0,1,0,90 +3d[1] -0.5,0,0
r3d[2] 0,1,0,180 +3d[2] 0,0,0.5
r3d[3] 0,1,0,270 +3d[3] 0.5,0,0
r3d[4] 1,0,0,90 +3d[4] 0,0.5,0
r3d[5] 1,0,0,270 +3d[5] 0,-0.5,0
+3d nm "[3D image cube]"
endl done v +
#@cli imageblocks3d : _maximum_elevation,_smoothness[%]>=0
#@cli : Generate 3D blocks from selected images.
#@cli : Transparency of selected images is taken into account.
#@cli : Default values: 'maximum_elevation=10' and 'smoothness=0'.
#@cli : $ image.jpg resize2dy 32 imageblocks3d -20 mode3d 3
imageblocks3d : check ${2=0}>=0 skip ${1=10},${3=0}
e[^-1] "Generate 3D blocks from image$?, with maximum elevation $1 and smoothness $2."
v - repeat $! l[$>]
w={w} h={h}
split_opacity to_rgb[0] is_opacity={$!==2}
l[] box3d 1,1,0
repeat {$w-1} ++3d. 1,0,0 done +3d
repeat {$h-1} ++3d. 0,1,0 done +3d
endl
s3d.
+norm[0] b. $2
y. n. 0,$1
r[-5] 24,{-5,round(w*h/24)},1,1,-1
if {$1<0} j[-5] .,2 j[-5] .,5 j[-5] .,8 j[-5] .,11
else j[-5] .,14 j[-5] .,17 j[-5] .,20 j[-5] .,23
fi
rm. y[-4]
rm.. r[0] {0,wh},1,1,100%,-1 permute[0] cxyz r[0] 600%,100%,1,1,0,2 y[0] mv[0] -1
if $is_opacity rm. mv[0] $! /. 255 y. r. 6,100%,1,1 y. fi
a y
endl done v +
#@cli imagecube3d
#@cli : Generate 3D mapped cubes from selected images.
#@cli : $ image.jpg imagecube3d
imagecube3d :
e[^-1] "Generate 3D mapped cubes from image$?."
v - slices 50% to_rgb repeat $! l[$>] nm={0,n}
i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
8;6;\
-0.5;-0.5;-0.5;\
0.5;-0.5;-0.5;\
0.5;0.5;-0.5;\
-0.5;0.5;-0.5;\
-0.5;-0.5;0.5;\
0.5;-0.5;0.5;\
0.5;0.5;0.5;\
-0.5;0.5;0.5;\
12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\
12;1;2;6;5;0;0;0;{h};{w};{h};{w};0;\
12;5;6;7;4;0;0;0;{h};{w};{h};{w};0;\
12;4;7;3;0;0;0;0;{h};{w};{h};{w};0;\
12;4;0;1;5;0;0;0;{h};{w};{h};{w};0;\
12;3;7;6;2;0;0;0;{h};{w};{h};{w};0;\
-128;{w};{h};{s})
y.
(-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1;1)
a y
nm $nm endl done v +
#@cli imageplane3d
#@cli : Generate 3D mapped planes from selected images.
#@cli : $ image.jpg imageplane3d
imageplane3d :
e[^-1] "Generate 3D mapped planes from image$?."
v - slices 50% to_color repeat $! l[$>] nm={0,n}
i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
4;1;\
0;0;0;\
{w};0;0;\
{w};{h};0;\
{0};{h};0;\
12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\
-128;{w};{h};{s})
y.
(1)
a y
nm $nm endl done v +
#@cli imagepyramid3d
#@cli : Generate 3D mapped pyramids from selected images.
#@cli : $ image.jpg imagepyramid3d
imagepyramid3d :
e[^-1] "Generate 3D mapped pyramids from image$?."
v - to_rgb repeat $! l[$>] nm={0,n}
w2={w/2}
i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
5;5;\
-0.5;-0.5;-0.5;\
0.5;-0.5;-0.5;\
0.5;0.5;-0.5;\
-0.5;0.5;-0.5;\
0;0;0.5;\
12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\
9;0;4;3;0;{h};$w2;0;{w};{h};\
9;1;4;0;0;{h};$w2;0;{w};{h};\
9;2;4;1;0;{h};$w2;0;{w};{h};\
9;3;4;2;0;{h};$w2;0;{w};{h};\
-128;{w};{h};{s})
y.
(-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1)
a y
nm $nm endl done v +
#@cli imagerubik3d : _xy_tiles>=1,0<=xy_shift<=100,0<=z_shift<=100
#@cli : Generate 3D mapped rubik's cubes from selected images.
#@cli : Default values: 'xy_tiles=3', 'xy_shift=5' and 'z_shift=5'.
#@cli : $ image.jpg imagerubik3d ,
imagerubik3d : check "${1=3}>=1 && ${2=5}>=0 && $2<=100 && ${3=5}>=0 && $3<=100"
e[^-1] "Generate 3D mapped rubik\47s cubes from image$? with $1 xy-tiles, xy-shift $2 and z-shift $3."
v - repeat $! l[$>] nm={0,n}
({'CImg3d'}) +. 0.5
(8,5)
(0,0,0;\
100,0,0;\
100,100,0;\
0,100,0;\
$2,$2,{-$3};\
{100-$2},$2,{-$3};\
{100-$2},{100-$2},{-$3};\
$2,{100-$2},{-$3})
(4,4,7,6,5;\
4,0,4,5,1;\
4,3,2,6,7;\
4,0,3,7,4;\
4,1,5,6,2)
3,5,1,1,200
1,5,1,1,1
y[-6--1] a[-6--1] y
repeat {$1-1} ++3d. 100 done +3d[-$1--1]
repeat {$1-1} ++3d. 0,100 done +3d[-$1--1]
t3d. .. rm..
/3d. $1 -3d. 50,50,50
+r3d. 0,1,0,-90 +r3d. 0,1,0,-90 +r3d. 0,1,0,-90
+r3d. 0,0,1,-90 +r3d. 0,0,1,180
+3d
nm $nm endl done v +
#@cli imagesphere3d : _resolution1>=3,_resolution2>=3
#@cli : Generate 3D mapped sphere from selected images.
#@cli : Default values: 'resolution1=32' and 'resolutions2=16'.
#@cli : $ image.jpg imagesphere3d 32,16
imagesphere3d : check "${1=32}>=3 && ${2=16}>=3"
e[^-1] "Generate 3D mapped sphere from image$?, with resolutions ($1,$2)."
v - to_rgb repeat $! l[$>] nm={0,n}
tw={w-1} th={h-1}
nbv={2+$1*($2-2)}
nbp={$1*($2-1)}
(67.5;73.5;109.5;103.5;51.5;100.5;\
$nbv;$nbp)
(0;0;1) (0;0;-1) (0,{2*pi};0,{2*pi}^0,0;{pi},{pi})
r. {$1+1},$2,1,2,3 z. 0,1,{w-2},{h-2} s. c
+sin. +sin... *[-2,-1] +cos.. sin... cos[-4] *[-4,-3]
a[-3--1] c permute. cxyz y. a[-3--1] y
repeat $1,v
tx0={$v*$tw/$1} tx1={($v+1)*$tw/$1} ty1={$th/($2-1)}
(9;0;{2+$v};{2+($v+1)%$1};{$tw/2};0;$tx0;$ty1;$tx1;$ty1)
repeat {$2-3},u
ty0=$ty1 ty1={($u+2)*$th/($2-1)} i0={2+$u*$1+$v} i1={2+$u*$1+($v+1)%$1}
(12;$i0;{$i0+$1};{$i1+$1};$i1;$tx0;$ty0;$tx0;$ty1;$tx1;$ty1;$tx1;$ty0)
done
(9;1;{2+$1*($2-3)+($v+1)%$1};{2+$1*($2-3)+$v};{$tw/2};$th;$tx1;$ty1;$tx0;$ty1)
done
a[-$nbp--1] y
mv[-4] $! i.. (-128;{w};{h};3) y. 1,{4*($nbp-1)},1,1,-128,0,0,0 1,$nbp,1,1,1 a y
nm $nm endl done v +
#@cli isoline3d : isovalue[%] : 'formula',value,_x0,_y0,_x1,_y1,_size_x>0[%],_size_y>0[%] : (+)
#@cli : Extract 3D isolines with specified value from selected images or from specified formula.
#@cli : Default values: 'x0=y0=-3', 'x1=y1=3' and 'size_x=size_y=256'.
#@cli : $ image.jpg blur 1 isoline3d 50%
#@cli : $ isoline3d 'X=x-w/2;Y=y-h/2;(X^2+Y^2)%20',10,-10,-10,10,10
#@cli isosurface3d : isovalue[%] : 'formula',value,_x0,_y0,_z0,_x1,_y1,_z1,_size_x>0[%],_size_y>0[%],_size_z>0[%] : (+)
#@cli : Extract 3D isosurfaces with specified value from selected images or from specified formula.
#@cli : Default values: 'x0=y0=z0=-3', 'x1=y1=z1=3' and 'size_x=size_y=size_z=32'.
#@cli : $ image.jpg resize2dy 128 luminance threshold 50% expand_z 2,0 blur 1 isosurface3d 50% mul3d 1,1,30
#@cli : $ isosurface3d 'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))',3
#@cli label3d : "text",font_height>=0,_opacity,_color1,...
#@cli : Generate 3D text label.
#@cli : Default values: 'font_height=13', 'opacity=1' and 'color=255,255,255'.
label3d : check ${2=13}>=0 skip ${3=1},${4=255},${5=$4},${6=$5}
e[^-1] "Generate 3D label '$1' with font height $2, opacity $3 and color (${4--1})."
v - l[] 0 t "$1",0,0,$2,1,${4--1},255 sprite3d endl v +
#@cli label_points3d : _label_size>0,_opacity
#@cli : Add a numbered label to all vertices of selected 3D objects.
#@cli : Default values: 'label_size=13' and 'opacity=0.8'.
#@cli : $ torus3d 100,40,6,6 label_points3d 23,1 mode3d 1
label_points3d : check ${1=13}>0 skip ${2=0.8}
e[^-1] "Label vertices of 3D object$?."
v - repeat $!
+p3d[$>] 0 l. s3d rm[-3--1]
nbp={-2,@0} =.. $nbp,0,1
(1,0;1,{$nbp-1}) r. 2,$nbp,1,1,3 r. 1,{2*h},1,1,-1
repeat $nbp
0 t. $>,0,0,$1,1,255,255,255 autocrop. 0
i.. (-128;{w};{h};3) y.
done
repeat $nbp
0 t. $>,0,0,$1,1,$2 autocrop. 0
i.. (-128;{w};{h};1) y.
done
a y
endl
+3d[$>,-1]
done v +
#@cli lathe3d : _resolution>0,_smoothness[%]>=0,_max_angle>=0
#@cli : Generate 3D object from selected binary XY-profiles.
#@cli : Default values: 'resolution=128', 'smoothness=0.5%' and 'max_angle=361'.
#@cli : $ 300,300 rand -1,1 blur 40 sign normalize 0,255 lathe3d ,
lathe3d : check "${1=128}>0 && ${2=0.5%}>=0 && ${3=361}>=0"
e[^-1] "Generate lathed 3D object from XY-profile$?, with resolution $1, smoothness $2 and maximum angle $3 deg."
v - tmax={($3-180)*pi/180} norm n 0,1 autocrop 0
repeat $! l[$>]
wr={max(1,w2=2*w;if(w2>h,min($1,w2),min($1,h)*w2/h))}
hr={max(1,w2=2*w;if(w2>h,min($1,w2)*h/w2,min($1,h)))}
rmax={sqrt(($wr)^2+($hr)^2)/2}
$wr,1,$wr,1,"xc = x - w/2; zc = z - d/2; t = atan2(zc,xc); if(t>"$tmax","$rmax",sqrt(xc*xc+zc*zc))"
*. {2*({-2,w}-1)/(w-1)} r. $wr,$hr,$wr
(0;{{-2,h}-1}) r. $wr,$hr,$wr,1,3 a[-2--1] c
warp.. .,0,1,0 rm.
expand_xyz 10,0 b $2 isosurface3d 50% rv3d
endl done v +
#@cli l3d : eq. to 'light3d'. : (+)
#@cli light3d : position_x,position_y,position_z : [texture] : (no arg) : (+)
#@cli : Set the light coordinates or the light texture for 3D rendering.
#@cli : (eq. to 'l3d').\n
#@cli : (no arg) resets the 3D light to default.
#@cli : $ torus3d 100,30 double3d 0 specs3d 1.2 repeat 5 light3d {$>*100},0,-300 +snapshot3d[0] 400 done remove[0]
#@cli line3d : x0,y0,z0,x1,y1,z1
#@cli : Input 3D line at specified coordinates.
#@cli : $ repeat 100 a={$>*pi/50} line3d 0,0,0,{cos(3*$a)},{sin(2*$a)},0 color3d. ${-RGB} done add3d
line3d :
e[^-1] "Input 3D line (${1-3})-(${4-6})."
v - 1,21,1,1,67.5,73.5,109.5,103.5,51.5,100.5,2,1,${1-6},2,0,1,200,200,200,1 nm. [3D\ line] v +
#@cli lissajous3d : resolution>1,a,A,b,B,c,C
#@cli : Input 3D lissajous curves (x(t)=sin(a*t+A*2*pi),y(t)=sin(b*t+B*2*pi),z(t)=sin(c*t+C*2*pi)).
#@cli : Default values: 'resolution=1024', 'a=2', 'A=0', 'b=1', 'B=0', 'c=0' and 'C=0'.
#@cli : $ lissajous3d ,
lissajous3d : check ${1=1024}>1 skip ${2=2},${3=0},${4=1},${5=0},${6=0},${7=0}
e[^-1] "Input 3D lissajous curve, with resolution $1, (a,A)=($2,$3), (b,B)=($4,$5) and (c,C)=($6,$7)."
v -
res={round($1)}
(67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
(0,{2*pi}) r. $res,1,1,1,3 [-1]x2
*... $2 +... {$3*2*pi} *.. $4 +.. {$5*2*pi} *. $6 +. {$7*2*pi}
a[-3--1] y sin. transpose. r. 1,{w*h},1,1,-1
1,{$res-1},1,1,2 (0;{$res-2}) r. 1,{$res-1},1,1,3 ++. 1 a[-3--1] x round. 1 r. 1,{w*h},1,1,-1
1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 a[-5--1] y nm. [3D\ lissajou]
v +
#@cli m3d : eq. to 'mode3d'. : (+)
#@cli mode3d : _mode : (+)
#@cli : Set static 3D rendering mode.
#@cli : (eq. to 'm3d').\n
#@cli : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.");
#@cli : Bounding-box mode ('mode==-1') is active only for the interactive 3D viewer.
#@cli : Default value: 'mode=4'.
#@cli : $ (0,1,2,3,4,5) double3d 0 repeat {w} torus3d 100,30 rotate3d[-1] 1,1,0,60 mode3d {0,@$>} snapshot3d[-1] 300 done remove[0]
#@cli md3d : eq. to 'moded3d'. : (+)
#@cli moded3d : _mode : (+)
#@cli : Set dynamic 3D rendering mode for interactive 3D viewer.
#@cli : (eq. to 'md3d').\n
#@cli : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@cli : Default value: 'mode=-1'.
#@cli *3d : eq. to 'mul3d'. : (+)
#@cli mul3d : factor : factor_x,factor_y,_factor_z : (+)
#@cli : Scale selected 3D objects isotropically or anisotropically, with specified factors.
#@cli : (eq. to '*3d').
#@cli : Default value: 'factor_z=0'.
#@cli : $ torus3d 5,2 repeat 5 +add3d[-1] 10,0,0 mul3d[-1] 1.2 color3d[-1] ${-RGB} done add3d
#@cli n3d : eq. to 'normalize3d'.
n3d :
_normalize3d
#@cli normalize3d
#@cli : Normalize selected 3D objects to unit size.
#@cli : (eq. to 'n3d').
#@cli : $ repeat 100 circle3d {u(3)},{u(3)},{u(3)},0.1 done add3d color3d[-1] 255,0,0 +normalize3d[-1] color3d[-1] 0,255,0 add3d
normalize3d :
_$0
_normalize3d :
e[0--3] "Normalize size of 3D object$?."
v - check3d 0 repeat $! l[$>]
if {i[6]}
s3d r[2] 3,{2,h/3},1,1,-1 s[2] x
factor={v=max({2,iM-im},{3,iM-im},{4,iM-im});if(v,v,1)}
a[2-4] x /[2] $factor y[2] a y
fi
endl done v +
#@cli o3d : eq. to 'opacity3d'. : (+)
#@cli opacity3d : _opacity : (+)
#@cli : Set opacity of selected 3D objects.
#@cli : (eq. to 'o3d').
#@cli : Default value: 'opacity=1'.
#@cli : $ torus3d 100,10 double3d 0 repeat 7 +rotate3d[-1] 1,0,0,20 opacity3d[-1] {u} done add3d
#@cli parametric3d : _x(a,b),_y(a,b),_z(a,b),_amin,_amax,_bmin,_bmax,_res_a>0,_res_b>0,_res_x>0,_res_y>0,_res_z>0,_smoothness>=0,_isovalue>=0
#@cli : Input 3D object from specified parametric surface (x(a,b),y(a,b),z(a,b)).
#@cli : Default values: 'x=(2+cos(b))*sin(a)', 'y=(2+cos(b))*cos(a)', 'c=sin(b)', 'amin=-pi', 'amax='pi', 'bmin=-pi', 'bmax='pi',
#@cli : 'res_a=512', 'res_b=res_a', 'res_x=64', 'res_y=res_x', 'res_z=res_y', 'smoothness=2%' and 'isovalue=10%'.
#@cli : $ parametric3d ,
parametric3d : skip "${1=(2+cos(b))*sin(a)}","${2=(2+cos(b))*cos(a)}","${3=sin(b)}"
skip ${4={-pi}},${5={pi}},${6={-pi}},${7={pi}}
check "${8=512}>0 && ${9=$8}>0 && ${10=64}>0 && ${11=$10}>0 && ${12=$11}>0 && \
${13=2%}>=0 && ${14=10%}>=0"
e[^-1] "Input 3D object from parametric surface ($1,$2,$3)."
v -
($4,$5;$4,$5^$6,$6;$7,$7) r. $8,$9,1,2,3 channels. 0,2
f. "a=i(x,y,0,0);b=i(x,y,0,1);if(c==0,$1,if(c==1,$2,$3))"
sh. 0 xmin={im} xmax={iM} n. 16,{$10-17} rm.
sh. 1 ymin={im} ymax={iM} n. 16,{$11-17} rm.
sh. 2 zmin={im} zmax={iM} n. 16,{$12-17} rm.
r. {w*h},3,1,1,-1
pointcloud. 1 r. $10,$11,$12,1,0 b. $13,0
isosurface3d. $14
c3d. n3d. *3d. {$xmax-$xmin},{$ymax-$ymin},{$zmax-$zmin} nm. [3D\ parametric]
v +
#@cli pca_patch3d : _patch_size>0,_M>0,_N>0,_normalize_input={ 0 | 1 },_normalize_output={ 0 | 1 },_lambda_xy
#@cli : Get 3D patch-pca representation of selected images.
#@cli : The 3D patch-pca is estimated from M patches on the input image, and displayed as a cloud of N 3D points.
#@cli : Default values: 'patch_size=7', 'M=1000', 'N=3000', 'normalize_input=1', 'normalize_output=0', and 'lambda_xy=0'.
#@cli : $ image.jpg pca_patch3d 7
pca_patch3d : check "isint(${1=7}) && $1>0 && isint(${2=1000}) && $2>0 && isint(${3=3000}) && $3>0" skip ${4=1},${5=0},${6=0}
e[^-1] "Get 3D patch-pca representation"${arg\ 1+($!>1),s,""}" of image$?, from $2 $1x$1 input patches, "\
"with $3 output patches, input normalization "${arg\ 1+!$4,enabled,disabled}", output normalization "\
${arg\ 1+!$5,enabled,disabled}" and lambda_xy $6."
v -
P1={int($1/2)}
P2={$1-$P1-1}
n 0,255 round 1
repeat $! l[$>] nm={0,n}
s={s}
1,$2 rand. 0,{0,w-1} +rand. 0,{0,h-1} +f. 0 a[-3--1] x round. 1 +patches[0] $1,$1,1,{^} y[2--1] a[2--1] x
z[1] 0,1 transpose[1] *[1] $6 a[1,2] y s[^0] x
++[^0] /. $2 -[1--2] . rm.
a[^0] x
if $4 l. s y / 'sqrt(1e-8+iv)' a y endl fi
+transpose. m*[-2,-1]
eigen. rows.. 0,2 columns. 0,2 transpose.
if $5 sqrt.. /.. {-2,iM} r.. . /. .. fi
rm..
repeat $3
x={round(u({0,w}))}
y={round(u({0,h}))}
({$6*$x};{$6*$y})
+z[0] {$x-$P1},{$y-$P1},{$x+$P2},{$y+$P2},1
y. a[-2,-1] y
done
+a[2--1] x m*[1,-1] transpose[1]
rows[2--1] 2,100%
if {$s!=3}
r[2--1] $1,$1,1,{min(3,$s)},-1
r[2--1] $1,$1,1,3,{if($s!=1,0,1)}
y[2--1]
fi
i[2--2] (-128;$1;$1;3) a[2--1] y
rm[0]
i[0] ({'CImg3d'})
i[1] ($3;$3)
i[3] 2,$3,1,1,if(x==0,1,y)
1,$3,1,1,1
y a[-6--1] y
nm $nm endl done v +
#@cli plane3d : _size_x,_size_y,_nb_subdivisions_x>0,_nb_subdisivions_y>0
#@cli : Input 3D plane at (0,0,0), with specified geometry.
#@cli : Default values: 'size_x=1', 'size_y=size_x' and 'nb_subdivisions_x=nb_subdivisions_y=24'.
#@cli : $ plane3d 50,30 +primitives3d 1 color3d[-2] ${-RGB}
plane3d : check "${3=24}>0 && ${4=24}>0" skip ${1=1},${2=$1}
e[^-1] "Input 3D plane, with size (${1,2}) and subdivisions (${3,4})."
v - {$3+1},{$4+1} elevation3d. 0 *3d. {$1/$3},{$2/$4} col3d. 200 nm. [3D\ plane] v +
#@cli point3d : x0,y0,z0
#@cli : Input 3D point at specified coordinates.
#@cli : $ repeat 1000 a={$>*pi/500} point3d {cos(3*$a)},{sin(2*$a)},0 color3d[-1] ${-RGB} done add3d
point3d :
e[^-1] "Input 3D point ($1,$2,$3)."
v - 1,17,1,1,67.5,73.5,109.5,103.5,51.5,100.5,1,1,${1-3},1,0,200,200,200,1 nm. [3D\ point] v +
#@cli pointcloud3d
#@cli : Convert selected planar or volumetric images to 3D point clouds.
#@cli : $ image.jpg luminance resize2dy 100 threshold 50% mul 255 pointcloud3d color3d[-1] 255,255,255
pointcloud3d :
e[^-1] "Convert image$? to 3D point cloud."
v - repeat $! l[$>] nm={0,n}
s z repeat $! l[$>]
+norm !=. 0
i.. (1,{w};1,{w}^1,1;{h},{h}) r.. .,.,1,2,3 *[-2,-1] round. permute. cxyz
l. s -,0 a y is_points=$! endl
if $is_points
-. 1 r. 2,{h/2},1,1,-1 permute. cyzx +warp.. .,0,0 rm...
permute.. cyzx i.. 1,{h},1,1,$> a[-3,-2] x
i... ({'CImg3d'}) i... ({h},{h})
i.. 1,{h},1,1,1 i.. 1,{h},1,1,y a[-3,-2] x
permute. cyzx
if {w==1} r. 3,{h},1,1
elif {w>3} i.. 4,{h},1,1,-128,1,1,{w} a[-2,-1] x
else r. 3,{h},1,1,0
fi
1,{h},1,1,1
y[-6--1] a[-6--1] y
else rm empty3d
fi
endl done
+3d
nm $nm endl done v +
#@cli pose3d : p1,...,p12
#@cli : Apply 3D pose matrix to selected 3D objects.
#@cli : $ torus3d 100,20 pose3d 0.152437,1.20666,-0.546366,0,-0.535962,0.559129,1.08531,0,1.21132,0.0955431,0.548966,0,0,0,-206,1 snapshot3d 400
pose3d :
e[^-1] "Apply 3D pose matrix [ $1,$2,$3,$4; $5,$6,$7,$8; $9,$10,$11,$12 ] to 3D object$?."
v - repeat $! l[$>] if ${-_is_3d}
s3d r[2] 3,{2,h/3},1,1,-1 i[3] 1,{2,h},1,1,1 a[2,3] x
i[3] ($1,$5,$9;$2,$6,$10;$3,$7,$11;$4,$8,$12) m*[2,3]
r[2] 1,{2,3*h},1,1,-1 a y
else v + error "Command '$0': Image ["{$!-$>-1}"] does not represent a 3D object."
fi endl done v +
#@cli p3d : eq. to 'primitives3d'. : (+)
p3d : check "isint($1) && $1>=0 && $1<=2"
_primitives3d $*
#@cli primitives3d : mode
#@cli : Convert primitives of selected 3D objects.
#@cli : (eq. to 'p3d').\n
#@cli : 'mode' can be { 0=points | 1=outlines | 2=non-textured }.
#@cli : $ sphere3d 30 primitives3d 1 torus3d 50,10 color3d[-1] ${-RGB} add3d
primitives3d : check "isint($1) && $1>=0 && $1<=2"
_$0 $*
_primitives3d :
e[0--3] "Convert primitives of 3D object$? to "${"arg 1+$1,points,outlines,non-textured"}"."
v - repeat $! l[$>]
s3d 1,64 .x2
eval "
const mode = $1;
get_RGBA(tx,ty,goto_next) = (
R = i[#4,pc];
R!=-128?(
G = i[#4,pc+1];
B = i[#4,pc+2];
goto_next?(pc+=3);
):(
W = i[#4,pc+1]; H = i[#4,pc+2]; S = i[#4,pc+3]; WH = W*H;
WH?(
off = pc + (ty%H)*W + (tx%W) + 4;
goto_next?(pc+=WH*S + 4);
):(
off = pcol[W];
i[#4,off]==-128?(
++off;
W = i[#4,off++]; H = i[#4,off++]; S = i[#4,off++]; WH = W*H;
off += (ty%H)*W + (tx%W);
):(WH=1);
goto_next?(pc+=4);
);
R = i[#4,off];
S==1?(G = B = R):(
G = i[#4,off + WH];
S==2?(B = 0):(
B = i[#4,off + 2*WH];
);
);
);
A = i[#5,po];
A==-128?(
W = i[#5,po+1]; H = i[#5,po+2]; S = i[#5,po+3]; WH = W*H;
WH?(
off = po + (ty%H)*W + (tx%W) + 4;
goto_next?(po+=WH*S + 4);
):(
off = popa[W];
i[#5,off]==-128?(
++off;
W = i[#5,off++]; H = i[#5,off++]; S = i[#5,off++]; WH = W*H;
off += (ty%H)*W + (tx%W);
);
goto_next?(po+=4);
);
A = i[#5,off];
);
);
copy_material(nb) = (
R = i[#4,pc++]; G = i[#4,pc++]; B = i[#4,pc++];
R!=-128?(
unref(data); data = [ R,G,B ];
for (k = 0, k<nb, ++k, copy(i[#-2,qc],data,3); qc+=3);
):(
W = G; H = B; S = i[#4,pc++]; WHS = W*H*S;
WHS?(
qc + WHS + 4*nb>=h(#-2)?resize(#-2,1,int(1.5*qc + WHS + 4*nb),1,1,0,0);
copy(i[#-2,qc],i[#4,pc-4],WHS+4);
pc+=WHS; qc+=WHS+4;
unref(data); data = [-128,nq,0,0];
for (k = 1, k<nb, ++k, copy(i[#-2,qc],data,4); qc+=4);
):(
unref(data); data = [-128,pref[W],0,0];
for (k = 0, k<nb, ++k, copy(i[#-2,qc],data,4); qc+=4);
);
);
A = i[#5,po++];
A!=-128?(
for (k = 0, k<nb, ++k, i[#-1,qo++] = A);
):(
W = i[#5,po++]; H = i[#5,po++]; S = i[#5,po++]; WHS = W*H*S;
WHS?(
qo + WHS + 4*nb>=h(#-1)?resize(#-1,1,int(1.5*qo + WHS + 4*nb),1,1,0,0);
copy(i[#-1,qo],i[#5,po-4],WHS+4);
po+=WHS; qo+=WHS+4;
unref(data); data = [-128,nq,0,0];
for (k = 1, k<nb, ++k, copy(i[#-1,qo],data,4); qo+=4);
):(
unref(data); data = [ -128,pref[W],0,0 ];
for (k = 0, k<nb, ++k, copy(i[#-1,qo],data,4); qo+=4);
);
);
);
add_point(ind,R,G,B,A) = (
copy(i[#-3,qp],[1,ind],2); qp+=2;
copy(i[#-2,qc],[R,G,B],3); qc+=3;
i[#-1,qo++] = A;
++nq;
);
add_segment(ind0,ind1,R,G,B,A) = (
copy(i[#-3,qp],[2,ind0,ind1],3); qp+=3;
copy(i[#-2,qc],[R,G,B],3); qc+=3;
i[#-1,qo++] = A;
++nq;
);
pcol = popa = pref = vector"{i[#1,1]}"();
for (pp = pc = po = qp = qc = qo = np = nq = 0, pp<h#3, ++np,
qp + 28>=h(#-3)?resize(#-3,1,int(1.5*qp + 28),1,1,0,0);
qc + 16>=h(#-2)?resize(#-2,1,int(1.5*qc + 16),1,1,0,0);
qo + 4>=h(#-1)?resize(#-1,1,int(1.5*qo + 4),1,1,0,0);
N = i[#3,pp++];
pcol[np] = pc;
popa[np] = po;
pref[np] = nq;
N==1?(
v0 = i[#3,pp++];
get_RGBA(0,0,1);
add_point(v0,R,G,B,A);
):N==2?(
v0 = i[#3,pp++]; v1 = i[#3,pp++];
get_RGBA(0,0,1);
mode==0?(
add_point(v0,R,G,B,A);
add_point(v1,R,G,B,A);
):(
add_segment(v0,v1,R,G,B,A);
);
):N==3?(
v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++];
get_RGBA(0,0,1);
mode==0?(
add_point(v0,R,G,B,A);
add_point(v1,R,G,B,A);
add_point(v2,R,G,B,A);
):mode==1?(
add_segment(v0,v1,R,G,B,A);
add_segment(v1,v2,R,G,B,A);
add_segment(v2,v0,R,G,B,A);
):(
copy(i[#-3,qp],i[#3,pp-4],4); qp+=4;
copy(i[#-2,qc],i[#4,pc-3],3); qc+=3;
i[#-1,qo++] = A;
++nq;
);
):N==4?(
v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++]; v3 = i[#3,pp++];
get_RGBA(0,0,1);
mode==0?(
add_point(v0,R,G,B,A);
add_point(v1,R,G,B,A);
add_point(v2,R,G,B,A);
add_point(v3,R,G,B,A);
):mode==1?(
add_segment(v0,v1,R,G,B,A);
add_segment(v1,v2,R,G,B,A);
add_segment(v2,v3,R,G,B,A);
add_segment(v3,v0,R,G,B,A);
):(
copy(i[#-3,qp],i[#3,pp-5],5); qp+=5;
copy(i[#-2,qc],i[#4,pc-3],3); qc+=3;
i[#-1,qo++] = A;
++nq;
);
):N==5?(
v0 = i[#3,pp++]; v1 = i[#3,pp++]; i[#3,pp++] = (mode==1); v2 = i[#3,pp++]; v3 = i[#3,pp++];
get_RGBA(0,0,1);
mode==0?(
x0 = i[#2,3*v0]; y0 = i[#2,3*v0+1]; z0 = i[#2,3*v0+2];
x1 = i[#2,3*v1]; y1 = i[#2,3*v1+1]; z1 = i[#2,3*v1+2];
copy(i[#2,3*v0],([ x0,y0,z0 ] + [ x1,y1,z1 ])/2,3);
add_point(v0,R,G,B,A);
):(
copy(i[#-3,qp],i[#3,pp-6],6); qp+=6;
copy(i[#-2,qc],i[#4,pc-3],3); qc+=3;
i[#-1,qo++] = A;
++nq;
);
):N==6?(
v0 = i[#3,pp++]; v1 = i[#3,pp++];
tx0 = i[#3,pp++]; ty0 = i[#3,pp++]; tx1 = i[#3,pp++]; ty1 = i[#3,pp++];
mode==0?(
get_RGBA(tx0,ty0,0); add_point(v0,R,G,B,A);
get_RGBA(tx1,ty1,1); add_point(v1,R,G,B,A);
):mode==1?(
copy(i[#-3,qp],i[#3,pp-7],7); qp+=7;
copy_material(1);
++nq;
):(
get_RGBA(tx0,ty0,0); R0 = R; G0 = G; B0 = B; A0 = A;
get_RGBA(tx1,ty1,1); (R0+=R)/=2; (G0+=G)/=2; (B0+=B)/=2; (A0+=A)/=2;
add_segment(v0,v1,R0,G0,B0,A0);
);
):N==9?(
v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++];
tx0 = i[#3,pp++]; ty0 = i[#3,pp++]; tx1 = i[#3,pp++]; ty1 = i[#3,pp++]; tx2 = i[#3,pp++]; ty2 = i[#3,pp++];
mode==0?(
get_RGBA(tx0,ty0,0); add_point(v0,R,G,B,A);
get_RGBA(tx1,ty1,0); add_point(v1,R,G,B,A);
get_RGBA(tx2,ty2,1); add_point(v2,R,G,B,A);
):mode==1?(
copy(i[#-3,qp],[ 6,v0,v1,tx0,ty0,tx1,ty1,
6,v1,v2,tx1,ty1,tx2,ty2,
6,v2,v0,tx2,ty2,tx0,ty0 ],21); qp+=21;
copy_material(3);
nq+=3;
):(
get_RGBA(tx0,ty0,0); R0 = R; G0 = G; B0 = B; A0 = A;
get_RGBA(tx1,ty1,0); R0+=R; G0+=G; B0+=B; A0+=A;
get_RGBA(tx2,ty2,2); (R0+=R)/=3; (G0+=G)/=3; (B0+=B)/=3; (A0+=A)/=3;
copy(i[#-3,qp],[ 3,v0,v1,v2 ],4); qp+=4;
copy(i[#-2,qc],[ R,G,B ],3); qc+=3;
i[#-1,qo++] = A;
++nq;
);
):N==12?(
v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++]; v3 = i[#3,pp++];
tx0 = i[#3,pp++]; ty0 = i[#3,pp++]; tx1 = i[#3,pp++]; ty1 = i[#3,pp++]; tx2 = i[#3,pp++]; ty2 = i[#3,pp++]; tx3 = i[#3,pp++]; ty3 = i[#3,pp++];
mode==0?(
get_RGBA(tx0,ty0,0); add_point(v0,R,G,B,A);
get_RGBA(tx1,ty1,0); add_point(v1,R,G,B,A);
get_RGBA(tx2,ty2,0); add_point(v2,R,G,B,A);
get_RGBA(tx3,ty3,1); add_point(v3,R,G,B,A);
):mode==1?(
copy(i[#-3,qp],[ 6,v0,v1,tx0,ty0,tx1,ty1,
6,v1,v2,tx1,ty1,tx2,ty2,
6,v2,v3,tx2,ty2,tx3,ty3,
6,v3,v0,tx3,ty3,tx0,ty0 ],28); qp+=28;
copy_material(4);
nq+=4;
):(
get_RGBA(tx0,ty0,0); R0 = R; G0 = G; B0 = B; A0 = A;
get_RGBA(tx1,ty1,0); R0+=R; G0+=G; B0+=B; A0+=A;
get_RGBA(tx2,ty2,0); R0+=R; G0+=G; B0+=B; A0+=A;
get_RGBA(tx3,ty3,2); (R0+=R)/=4; (G0+=G)/=4; (B0+=B)/=4; (A0+=A)/=4;
copy(i[#-3,qp],[ 4,v0,v1,v2,v3 ],5); qp+=5;
copy(i[#-2,qc],[ R,G,B ],3); qc+=3;
i[#-1,qo++] = A;
++nq;
);
);
);
resize(#-3,1,qp,1,1,0,0);
resize(#-2,1,qc,1,1,0,0);
resize(#-1,1,qo,1,1,0,0);
i[#1,1] = nq"
rm[3-5] a y
endl done v +
#@cli projections3d : _x[%],_y[%],_z[%],_is_bounding_box={ 0 | 1 }
#@cli : Generate 3D xy,xz,yz projection planes from specified volumetric images.
projections3d : skip ${1=50%},${2=50%},${3=50%},${4=1}
e[^-1] "Generate 3D xy,xz,yz projection planes from image$?."
v - n 0,255 repeat $! l[$>]
w={w} h={h} d={d}
x={if(${is_percent\ $1},$1*w,$1)}
y={if(${is_percent\ $2},$2*h,$2)}
z={if(${is_percent\ $3},$3*d,$3)}
+rows $2,$2 r. {w},{d},1,100%,-1
+columns.. $1,$1 permute. zyxc
slices... $3,$3 r[-3--1] 100%,100%,1,3
imageplane3d[-3--1]
r3d. 0,1,0,-90 r3d.. 1,0,0,90
+3d... 0,0,$z +3d.. 0,$y,0 +3d. $x,0,0
+3d[-3--1] o3d. 0.8
if $4 box3d $w,$h,$d p3d. 1 o3d. 0.4 +3d[-2,-1] fi
endl done v +
#@cli pyramid3d : width,height
#@cli : Input 3D pyramid at (0,0,0), with specified geometry.
#@cli : $ pyramid3d 100,-100 +primitives3d 1 color3d[-2] ${-RGB}
pyramid3d :
e[^-1] "Input new 3D pyramid, with width $1 and height $2."
v -
(67.5;73.5;109.5;103.5;51.5;100.5;\
5;5;\
{-$1/2};{-$1/2};{-$2/2};\
{$1/2};{-$1/2};{-$2/2};\
{$1/2};{$1/2};{-$2/2};\
{-$1/2};{$1/2};{-$2/2};\
0;0;{$2/2};\
4;0;3;2;1;\
3;0;4;3;\
3;1;4;0;\
3;2;4;1;\
3;3;4;2)
1,15,1,1,200 1,5,1,1,1 a[-3--1] y nm. [3D\ pyramid]
v +
#@cli quadrangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3
#@cli : Input 3D quadrangle at specified coordinates.
#@cli : $ quadrangle3d -10,-10,10,10,-10,10,10,10,10,-10,10,10 repeat 10 +rotate3d[-1] 0,1,0,30 color3d[-1] ${-RGB},0.6 done add3d mode3d 2
quadrangle3d :
e[^-1] "Input 3D quadrangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12)."
v - 1,29,1,1,67.5,73.5,109.5,103.5,51.5,100.5,4,1,${1-12},4,0,1,2,3,200,200,200,1 nm. [3D\ quadrangle] v +
#@cli random3d : nb_points>=0
#@cli : Input random 3D point cloud in [0,1]^3.
#@cli : $ random3d 100 circles3d 0.1 opacity3d 0.5
random3d : check "$1>=0"
e[^-1] "Input random 3D point cloud, with $1 points."
v -
if {$1<0.5} empty3d
else l[]
N={round($1)}
({'CImg3d'},$N,$N)
3,$N rand. 0,1
1,$N,1,1,1 1,$N,1,1,y a[-2,-1] x
3,$N,1,1,200 1,$N,1,1,1
y a y
endl fi
nm. [3D\ random\ pointcloud]
v +
#@cli rv3d : eq. to 'reverse3d'. : (+)
#@cli reverse3d : (+)
#@cli : Reverse primitive orientations of selected 3D objects.
#@cli : (eq. to 'rv3d').
#@cli : $ torus3d 100,40 double3d 0 +reverse3d
#@cli r3d : eq. to 'rotate3d'. : (+)
#@cli rotate3d : u,v,w,angle : (+)
#@cli : Rotate selected 3D objects around specified axis with specified angle (in deg.).
#@cli : (eq. to 'r3d').
#@cli : $ torus3d 100,10 double3d 0 repeat 7 +rotate3d[-1] 1,0,0,20 done add3d
#@cli rotation3d : u,v,w,angle
#@cli : Input 3x3 rotation matrix with specified axis and angle (in deg).
#@cli : $ rotation3d 1,0,0,0 rotation3d 1,0,0,90 rotation3d 1,0,0,180
rotation3d :
e[^-1] "Input 3D rotation matrix around axis ($1,$2,$3) with angle $4 deg."
v - 3,3,1,1,{"rot(${1-4})"} nm. [3D\ rotation] v +
#@cli sierpinski3d : _recursion_level>=0,_width,_height
#@cli : Input 3d Sierpinski pyramid.
#@cli : $ sierpinski3d 3,100,-100 +primitives3d 1 color3d[-2] ${-RGB}
sierpinski3d : check ${1=4}>=0 skip ${2=1},${3=1}
-e[^-1] "Input 3D Sierpinski pyramid of degree $1, with width $2 and height $3."
v - l[] _sierpinski3d {-$2/2},{-$2/2},{-$3/2},{$2/2},{-$2/2},{-$3/2},{$2/2},{$2/2},{-$3/2},{-$2/2},{$2/2},{-$3/2},0,0,{$3/2},$1 +3d endl
nm. [3D\ sierpinski] v +
_sierpinski3d :
if {$16<=0}
(67.5;73.5;109.5;103.5;51.5;100.5;\
5;5;\
$1;$2;$3;\
$4;$5;$6;\
$7;$8;$9;\
$10;$11;$12;\
$13;$14;$15;\
4;0;3;2;1;\
3;0;4;3;\
3;1;4;0;\
3;2;4;1;\
3;3;4;2)
1,15,1,1,200 1,5,1,1,1 a[-3--1] y
return fi
_sierpinski3d $1,$2,$3,\
{($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
{($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
{($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
{$16-1}
_sierpinski3d {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
$4,$5,$6,\
{($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
{($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
{$16-1}
_sierpinski3d {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
$7,$8,$9,\
{($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
{($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
{$16-1}
_sierpinski3d {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
{($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
$10,$11,$12,\
{($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
{$16-1}
_sierpinski3d {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
{($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
{($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
{($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
$13,$14,$15,\
{$16-1}
#@cli size3d
#@cli : Return bounding box size of the last selected 3D object.
size3d :
v - +rows. 8,{8+3*i[6]} r. 3,{h/3},1,1,-1 s. x,3
u {-3,iM-im},{-2,iM-im},{iM-im}
rm[-3--1] v +
#@cli skeleton3d : _metric,_frame_type={ 0=squares | 1=diamonds | 2=circles | 3=auto },_skeleton_opacity,_frame_opacity,_is_frame_wireframe={ 0 | 1 }
#@cli : Build 3D skeletal structure object from 2d binary shapes located in selected images.
#@cli : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean }.
#@cli : Default values: 'metric=2', 'bones_type=3', 'skeleton_opacity=1' and 'frame_opacity=0.1'.
#@cli : $ shape_cupid 480 +skeleton3d ,
skeleton3d : check "isint(${1=2}) && $1>=0 && $1<=2 && isint(${2=3}) && $2>=0 && $2<=3" skip ${3=1},${4=0.1},${5=1}
e[^-1] "Build 3D skeletal structure object from image$?, with "${arg\ 1+$1,chebyshev,manhattan,euclidean}" metric, "\
${arg\ 1+$2,squares,diamonds,circles,auto}" bones, skeleton opacity $3 and frame opacity $4 ."
v - repeat $! l[$>] channels 0
+distance 0,$1
+f. "(i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"
if $3 +slices. -1,0 isosurface3d. 0.5 o3d. $3 col3d. 255,0,0 fi
*[0-2] pointcloud3d[0]
if $4 l[0] s3d 1
n={1,@0}
if $n
r[2] 3,$n,1,1,-1 r[3] 2,$n,1,1,-1 r[4] 3,$n,1,1,-1
if {$2==0" || "($2==3" && "$1==0)}
=[1] {4*$n}
i[3] [2]x3 +z.. 0,1 z. 0,2 -[2] . +[4] .
s. x *.. -1 a[-3--1] x +[3] . -[5,-1] a[2-5] x
rm[3] 1,$n,1,1,4 +f. 4*y ++. 1 ++. 1 ++. 1 rv[-3,-1] a[-5--1] x mv. 3
elif {$2==1" || "($2==3" && "$1==1)}
=[1] {4*$n}
i[3] [2]x3 +z.. 0,0 z. 0,2 -[2] . +[4] .
shift. 1,0 -[3] . +[5,-1] a[2-5] x
rm[3] 1,$n,1,1,4 +f. 4*y ++. 1 ++. 1 ++. 1 rv[-3,-1] a[-5--1] x mv. 3
elif {$2==2" || "($2==3" && "$1==2)}
=[1] {2*$n}
+z[4] 0,0 z. 0,2 ++[2,-1] -[2,-2] a[2,-1] x
rm[3] 1,$n,1,1,5 +f. 2*y ++. 1 3,100% a[-4--1] x mv. 3
fi
y a y o3d $4 if $5 p3d 1 fi col3d 200
else rm empty3d fi
endl else rm[0] fi
+3d
endl done v +
#@cli snapshot3d : _size>0,_zoom>=0,_backgroundR,_backgroundG,_backgroundB,_backgroundA : [background_image],zoom>=0
#@cli : Take 2d snapshots of selected 3D objects.
#@cli : Set 'zoom' to 0 to disable object auto-scaling.
#@cli : Default values: 'size=512', 'zoom=1' and '[background_image]=(default)'.
#@cli : $ torus3d 100,20 rotate3d 1,1,0,60 snapshot3d 400,1.2,128,64,32
#@cli : $ torus3d 100,20 rotate3d 1,1,0,60 sample ? +snapshot3d[0] [1],1.2
snapshot3d : check "${2=1}>=0" skip ${1=512},${3=""}
if ${"is_image_arg $1"}
e[0--3] "Take $1x$1 snapshot$? of 3D object$?, with zoom factor $2 and background image $3."
v - pass$1 0 to_color.
elif {isval($3)}
e[0--3] "Take $1x$1 snapshot$? of 3D object$?, with zoom factor $2 and background color ${3--1}."
v - (${3--1}) y. c r. $1,$1 to_color.
else
e[0--3] "Take $1x$1 snapshot$? of 3D object$?, with zoom factor $2 and default background."
v - 1,2,1,3,32,64,32,116,64,96 r. $1,$1,1,3,3
fi
repeat {$!-1} . l[$>,-1]
if {$2!=0} c3d[0] n3d[0] *3d[0] {3*min(w,h)*$2/4} fi
if {s>3}
100%,100%,1,3,-1 j3d. [0],50%,50%,0,1
to_rgba. replace_color. 0,0,-1,-1,-1,255,0,0,0,0 blend[-2,-1] alpha
else
j3d[1] [0],50%,50%,0,1
fi
nm[1] {-2,n} rm[0]
endl done rm. v +
#@cli sl3d : eq. to 'specl3d'. : (+)
#@cli specl3d : value>=0 : (+)
#@cli : Set lightness of 3D specular light.
#@cli : (eq. to 'sl3d').
#@cli : Default value: 'value=0.15'.
#@cli : $ (0,0.3,0.6,0.9,1.2) repeat {w} torus3d 100,30 rotate3d[-1] 1,1,0,60 color3d[-1] 255,0,0 specl3d {0,@$>} snapshot3d[-1] 400 done remove[0]
#@cli ss3d : eq. to 'specs3d'. : (+)
#@cli specs3d : value>=0 : (+)
#@cli : Set shininess of 3D specular light.
#@cli : (eq. to 'ss3d').
#@cli : Default value: 'value=0.8'.
#@cli : $ (0,0.3,0.6,0.9,1.2) repeat {w} torus3d 100,30 rotate3d[-1] 1,1,0,60 color3d[-1] 255,0,0 specs3d {0,@$>} snapshot3d[-1] 400 done remove[0]
#@cli sphere3d : radius,_nb_recursions>=0 : (+)
#@cli : Input 3D sphere at (0,0,0), with specified geometry.
#@cli : Default value: 'nb_recursions=3'.
#@cli : $ sphere3d 100 +primitives3d 1 color3d[-2] ${-RGB}
#@cli spherical3d : _nb_azimuth>=3,_nb_zenith>=3,_radius_function(phi,theta)
#@cli : Input 3D spherical object at (0,0,0), with specified geometry.
#@cli : Default values: 'nb_zenith=nb_azimut=64' and 'radius_function="abs(1+0.5*cos(3*phi)*sin(4*theta))"'.
#@cli : $ spherical3d 64 +primitives3d 1
spherical3d : check "${1=64}>=3 && ${2=$1}>=3" skip "${3=abs(1+0.5*cos(3*phi)*sin(4*theta))}"
e[^-1] "Input 3D spherical object, with subdivisions ($1,$2) and height function '$3'."
v -
({'CImg3d'}) y.
n1={round($1)} n2={round($2)}
$n1,{$n2-1},1,3,"phi = 2*pi*(x+0.5)/w;\
theta = -pi/2+pi*(y+0.5)/h;\
cp = cos(phi);\
sp = sin(phi);\
ct = cos(theta);\
($3)*if(c==0,ct*cp,if(c==1,ct*sp,sin(theta)))"
r. {w*h},3,1,1,-1 permute. yxzc
i.. (0,0,{phi=0;theta=-pi/2;-$3};0,0,{phi=0;theta=pi/2;$3}) a[-2,-1] y
nbv={h} y.
$n1,{$n2-2},1,4,"nx=(x+1)%w;ny=(y+1);2+if(c==0,x+y*"$n1",if(c==1,nx+y*"$n1",if(c==2,nx+ny*"$n1",x+ny*"$n1")))"
r. {w*h},4,1,1,-1 permute. yxzc i.. 1,{h},1,1,4 a[-2,-1] x
2,$n1,1,1,3,0 1,$n1,1,1,'y' ++. 1 %. {h} 2,$n1,1,1,3,1 [-3,-2]
+[-5,-4] 2 rv[-5,-4] +[-2,-1] {$nbv-$n1} a[-3--1] x a[-4--2] x
nbp={h+{-2,h}+{-3,h}}
y[-3--1] a[-3--1] y
i... ($nbv;$nbp)
1,{3*$nbp},1,1,200 1,$nbp,1,1,1 a[-2,-1] y
a[-5--1] y nm. "[3D spherical surface '$3']"
v +
#@cli spline3d : x0[%],y0[%],z0[%],u0[%],v0[%],w0[%],x1[%],y1[%],z1[%],u1[%],v1[%],w1[%],_nb_vertices>=2
#@cli : Input 3D spline with specified geometry.
#@cli : Default values: 'nb_vertices=128'.
#@cli : $ repeat 100 spline3d {u},{u},{u},{u},{u},{u},{u},{u},{u},{u},{u},{u},128 color3d[-1] ${-RGB} done box3d 1 primitives3d[-1] 1 add3d
spline3d : check ${13=128}>=2
e[^-1] "Input new 3D spline from (${1-3}) [${4-6}] to (${7-9}) [${10-12}] with $13 vertices."
v -
({'CImg3d'}) +. 0.5
($13;{$13-1})
1,$13,1,1,1 (0;1) r. 1,$13,1,1,3 +sqr. +*[-2,-1] a[-4--1] x
+*. '$2,$5,{3*(($8)-($2))-2*($5)-($11)},{($5)+($11)+2*(($2)-($8))}' l. s x + endl
+*.. '$3,$6,{3*(($9)-($3))-2*($6)-($12)},{($6)+($12)+2*(($3)-($9))}' l. s x + endl
*... '$1,$4,{3*(($7)-($1))-2*($4)-($10)},{($4)+($10)+2*(($1)-($7))}' l... s x + endl
a[-3--1] x
1,{$13-1},1,1,2 (0,1;{$13-2},{$13-1}) r. 2,..,1,1,3 round. a[-2,-1] x
1,{3*($13-1)},1,1,200 1,{$13-1},1,1,1
y[-3,-4,-6] a[-6--1] y
v +
#@cli s3d : eq. to 'split3d'. : (+)
#@cli split3d : _keep_shared_data={ 0 | 1 } : (+)
#@cli : Split selected 3D objects into 6 feature vectors :
#@cli : { header, sizes, vertices, primitives, colors, opacities }.
#@cli : (eq. to 's3d').\n
#@cli : To recreate the 3D object, append these 6 images along the y-axis.
#@cli : Default value: 'keep_shared_data=1'.
#@cli : $ box3d 100 +split3d
#@cli sprite3d
#@cli : Convert selected images as 3D sprites.
#@cli : Selected images with alpha channels are managed.
#@cli : $ image.jpg sprite3d
sprite3d :
e[^-1] "Convert image$? as 3D sprites."
v - repeat $! l[$>] nm={0,n}
split_opacity
i[0] (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};{0,s}) y[1]
if {$!==2} (1) a y
else /. 255 i.. (-128;{w};{h};{s}) y.
fi
a y
nm $nm endl done v +
#@cli sprites3d : [sprite],_sprite_has_alpha_channel={ 0 | 1 }
#@cli : Convert selected 3D objects as a sprite cloud.
#@cli : Set 'sprite_has_alpha_channel' to 1 to make the last channel of the selected sprite be a transparency mask.
#@cli : Default value: 'mask_has_alpha_channel=0'.
#@cli : $ torus3d 100,20 image.jpg resize2dy[-1] 64 100%,100% gaussian[-1] 30%,30% *[-1] 255 append[-2,-1] c +sprites3d[0] [1],1 display_rgba[-2]
sprites3d : check ${is_image_arg\ $1} skip ${2=0}
e[^-1] "Convert image$? as 3D sprites clouds, using sprite $1 ("${"arg {1+!$2},with,without"}" alpha-channel)."
v - repeat $!
if {!{$>,i(0,7)}} continue fi
pass$1 0
if {!w} empty3d rv[$>,-1] nm[$>] {n} rm. continue fi
l[$>,-1]
s3d[0] N={1,@0} =[1] $N,0,1
rm[3-5] i[3] (1,0;1,{$N-1}) r[3] 2,$N,1,1,3 round[3]
if $2
if {s==1}
i.. 3,$N,1,1,200 /. 255
i.. (-128;{w};{h};1)
if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 fi
else
s. c,-{s-1} /. 255
i... (-128;{w};{h};{-2,s})
if {$N>1} i.. 1,{4*($N-1)},1,1,-128,0,0,0 fi
i.. (-128;{w};{h};1)
if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 fi
fi
else
i.. (-128;{w};{h};{s}) y[-3,-1]
if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 fi
1,$N,1,1,1
fi
y a y
endl done v +
#@cli star3d : _nb_branches>0,0<=_thickness<=1
#@cli : Input 3D star at (0,0,0), with specified geometry.
#@cli : Default values: 'nb_branches=5' and 'thickness=0.38'.
#@cli : $ star3d , +primitives3d 1 color3d[-2] ${-RGB}
star3d : check "${1=5}>0 && ${2=0.38}>=0 && $2<=1"
e[^-1] "Input 3D star, with $1 branches and thickness $2."
v -
N={2*$1} ({'CImg3d'}) +. 0.5 ({$N+1};$N)
({-pi/2};{3*pi/2}) r. 1,{$N+1},1,1,3 rows. 0,{h-2} +sin. cos.. a[-2,-1] x
(1,1;$2,$2) *[-2,-1] z. 0,2 r. 3,{h+1},1,1,0
(3,$N,1,0;3,$N,$N,{$N-1}) r. 4,$N,1,1,3 round. =. 0,2,100%
3,$N,1,1,200 1,$N,1,1,1 y[-6,-4--2] a[-6--1] y nm. [3D\ star]
v +
#@cli streamline3d : x[%],y[%],z[%],_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : 'formula',x,y,z,_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : (+)
#@cli : Extract 3D streamlines from selected vector fields or from specified formula.
#@cli : 'interpolation' can be { 0=nearest integer | 1=1st-order | 2=2nd-order | 3=4th-order }.
#@cli : Default values: 'dl=0.1', 'interpolation=2', 'is_backward=0' and 'is_oriented=0'.
#@cli : $ 100,100,100,3 rand -10,10 blur 3 repeat 300 +streamline3d[0] {u(100)},{u(100)},{u(100)},1000,1,1 color3d[-1] ${-RGB} done remove[0] box3d 100 primitives3d[-1] 1 add3d
#@cli -3d : eq. to 'sub3d'. : (+)
#@cli sub3d : tx,_ty,_tz : (+)
#@cli : Shift selected 3D objects with the opposite of specified displacement vector.
#@cli : (eq. to '3d').
#@cli : Default values: 'ty=tz=0'.
#@cli : $ sphere3d 10 repeat 5 +sub3d[-1] 10,{u(-10,10)},0 color3d[-1] ${-RGB} done add3d
#@cli superformula3d : resolution>1,m>=1,n1,n2,n3
#@cli : Input 2D superformula curve as a 3D object.
#@cli : Default values: 'resolution=1024', 'm=8', 'n1=1', 'n2=5' and 'n3=8'.
#@cli : $ superformula3d ,
superformula3d : check "${1=1024}>1 && ${2=8}>=1" skip ${3=1},${4=5},${5=8}
e[^-1] "Input 2D superformula curve, with resolution $1, m=$2 and (n1,n2,n3)=($3,$4,$5)."
v -
res={round($1)}
(67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
(0,{2*pi}) r. $res,1,1,1,3 .
*. {$2/4} +sin. cos.. abs[-2,-1]
^.. $4 ^. $5 +[-2,-1] ^. {-1/$3}
+sin.. cos... *. .. *[-3,-2] n[-2,-1] -1,1
a[-2,-1] y rows. 0,2 transpose. r. 1,{w*h},1,1,-1
1,{$res-1},1,1,2 (0;{$res-2}) r. 1,{$res-1},1,1,3 ++. 1 a[-3--1] x round. 1 r. 1,{w*h},1,1,-1
1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 a[-5--1] y nm. [3D\ superformula]
v +
#@cli tensors3d : _radius_factor>=0,_shape={ 0=box | >=N=ellipsoid },_radius_min>=0
#@cli : Generate 3D tensor fields from selected images.
#@cli : when 'shape'>0, it gives the ellipsoid shape precision.
#@cli : Default values: 'radius_factor=1', 'shape=2' and 'radius_min=0.05'.
#@cli : $ 6,6,6,9,"U = [x,y,z] - [w,h,d]/2; U/=norm(U); mul(U,U,3) + 0.3*eye(3)" tensors3d 0.8
tensors3d : check "${1=1}>=0 && isint(${2=2}) && $2>=0 && ${3=0.05}>=0"
e[^-1] "Generate 3D tensor field(s) from image$?, with radius factor $1, "\
${"v - if $2 u ellipsoid else u box fi v +"}" shape and radius min $3."
v - repeat $! l[$>]
if {s==1} 100%,100%,100%,6,"[i#0,0,0,i#0,0,i#0]" k.
elif {s==3} 100%,100%,100%,6,"[R#0,G#0,0,B#0,0,0]" k.
elif {s==4} 100%,100%,100%,6,"[R#0,G#0,0,A#0,0,0]" k.
elif {s==9} 100%,100%,100%,6,"I=I#0;[I[0],I[1],I[2],I[4],I[5],I[8]]" k.
fi
if {s!=6} error[0--4] "Command '$0': Image '"{n}"' has an invalid size (spectrum="{s}")." fi
100%,100%,100%,12,"
T = I(#0);
M = [ T[0], T[1], T[2], T[1], T[3], T[4], T[2], T[4], T[5] ];
eig = eig(M);
if (det(eig[3,9])<0, eig[3]*=-1; eig[4]*=-1; eig[5]*=-1);
eig[0] = max(0,eig[0]);
eig[1] = max(0,eig[1]);
eig[2] = max(0,eig[2]);
eig"
k.
if $2 sphere3d 1,{$2-1} else box3d 1 fi
N,P={[i[6],i[7]]} siz={h} n3d. c3d. .x{0,whd-1}
f[0] "
const N = "$N";
const P = "$P";
const siz = "$siz";
eig = I;
const d = size(eig);
ind = 1 + x + w*y + wh*z;
L = eig[0,3];
if (max(L)==0,
i[#ind,6] = i[#ind,7] = 0;
resize(#ind,1,8,1,1,0);
_(else),
L*=$1;
L[0] = max($3,L[0]);
L[1] = max($3,L[1]);
L[2] = max($3,L[2]);
R = eig[3,9];
anisotropy = sqrt(((L[0] - L[1])^2 + (L[1] - L[2])^2 + (L[2] - L[0])^2)/(2*(L[0]^2 + L[1]^2 + L[2]^2)));
pts = crop(#ind,0,8,0,0,1,3*N,1,1);
pts *= resize(L,size(pts),0,2);
pts = mul(pts,R,3);
pts += resize([x,y,z],size(pts),0,2);
draw(#ind,pts,0,8,0,0,1,size(pts),1,1);
col0 = cut(255*anisotropy*abs([ R[0],R[1],R[2] ]) + (1-anisotropy)*200,0,255);
col = resize(col0,3*P,0,2);
const off = siz - 4*P;
draw(#ind,col,0,off,0,0,1,size(col),1,1);
0); I"
rm[0] +3d
endl done v +
#@cli text_pointcloud3d : _"text1",_"text2",_smoothness
#@cli : Input 3D text pointcloud from the two specified strings.
#@cli : Default values: 'text1="text1"', 'text2="text2"' and 'smoothness=1'.
#@cli : $ text_pointcloud3d "G'MIC","Rocks!"
text_pointcloud3d : skip "${1=text1}","${2=text2}",${3=1}
e[^-1] "Input 3D pointcloud text object from strings '$1' and '$2', with smoothness $3."
v -
0 t. "$1",0,0,53,1,1
0 t. "$2",0,0,53,1,1 mirror. y
autocrop[-2,-1] 0
expand_xy[-2,-1] 2,0 dilate[-2,-1] 2
permute. zyxc r[-2,-1] ${-max_whd} &[-2,-1]
100%,100% rand. 0,{{-2,d}-1} round. r. .. f. 'if(z==i,1,0)'
distance. 1 +. 1 +f. 1 rv[-2,-1] /[-2,-1] *. ..
+dilate. 0,0,{d} ==[-2,-1] *. ..
1,100%,100% rand. 0,{{-2,w}-1} round. r. .. f. 'if(x==i,1,0)'
distance. 1 +. 1 +f. 1 rv[-2,-1] /[-2,-1] *. ...
+dilate. 0,0,{d} ==[-2,-1] *[-3,-1]
-|[-2,-1]
b. $3 isosurface3d. 25%
c3d. n3d. nm. "[3D text pointcloud]" v +
#@cli text3d : text,_font_height>0,_depth>0,_smoothness
#@cli : Input a 3D text object from specified text.
#@cli : Default values: 'font_height=53', 'depth=10' and 'smoothness=1.5'.
#@cli : $ text3d "G'MIC as a\n3D logo!"
text3d : skip ${2=53},${3=10},${4=1.5}
e[^-1] "Input 3D text object '$1' with size $2, depth $3 and smoothness $4."
v - 0 t. "$1",0,0,$2,1,1 autocrop. 0 r. 100%,100%,$3 expand_xyz. 10,0
b. $4 isosurface3d. 40% rv3d. nm. "[3D text '$1']" v +
#@cli t3d : eq. to 'texturize3d'.
t3d : check ${"is_image_arg $1"}" && (!narg(${2=}) || "${"is_image_arg $2"}")"
e[^-1] "Texturize 3D object$? with texture $1"${"v - if {narg($2)} u \" and texture coordinates $2\" else u \"\" fi v +"}"."
v - pass$1 0 slices. 0 if {s==1} to_rgb. else channels. 0,2 fi
if {narg($2)} pass$2 else 0 fi
_texturize3d
v +
#@cli texturize3d : [ind_texture],_[ind_coords]
#@cli : Texturize selected 3D objects with specified texture and coordinates.
#@cli : (eq. to 't3d').\n
#@cli : When '[ind_coords]' is omitted, default XY texture projection is performed.
#@cli : Default value: 'ind_coords=(undefined)'.
#@cli : $ image.jpg torus3d 100,30 texturize3d[-1] [-2] keep[-1]
texturize3d : check ${"is_image_arg $1"}" && (!narg(${2=}) || "${"is_image_arg $2"}")"
e[^-1] "Texturize 3D object$? with texture $1"${"v - if {narg($2)} u \" and texture coordinates $2\" else u \"\" fi v +"}"."
v - pass$1 0 slices. 0 if {s==1} to_rgb. else channels. 0,2 fi
if {narg($2)} pass$2 else 0 fi
_$0
v +
_texturize3d :
repeat {$!-2} l[$>,-2,-1]
s3d[0]
if {!w}
+r[2] 3,{2,round(h/3)},1,1,-1 s. x,3 rm.
n.. 0,{6,w-1} n. 0,{6,h-1} a[-2,-1] x
mv. -2
fi
np={1,i[1]} 1,{2*$np} 1,{3*$np} 1,$np,1,1,1
eval "
add_material() = (
ind_tex>=0?(
copy(i[#-2,qc],[ -128,ind_tex,0,0 ],4); qc+=4
):(
qc + whds#6 + 4>=h(#-2)?resize(#-2,1,int(1.5*qc + whds#6 + 4),1,1,0,0);
copy(i[#-2,qc],[ -128,w#6,h#6,s#6 ],4); qc+=4;
copy(i[#-2,qc],i(#6),whds#6); qc+=whds#6;
ind_tex = np;
);
);
ind_tex = -1;
for (pp = pc = qp = qc = np = 0, pp<h#3, ++np,
qp + 13>=h(#-3)?resize(#-3,1,int(1.5*qp + 13),1,1,0,0);
qc + 3>=h(#-2)?resize(#-2,1,int(1.5*qc + 3),1,1,0,0);
N = i[#3,pp++];
N==1?(
v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
R = i(#6,tx0,ty0,0,0); G = i(#6,tx0,ty0,0,1); B = i(#6,tx0,ty0,0,2);
copy(i[#-3,qp],[ 1,v0 ],2); qp+=2;
copy(i[#-2,qc],[ R,G,B ],3); qc+=3;
):(N==2 || N==6)?(
v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
N==6?(pp+=4);
copy(i[#-3,qp],[ 6,v0,v1,tx0,ty0,tx1,ty1 ],7); qp+=7;
add_material();
):(N==3 || N==9)?(
v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
v2 = i[#3,pp++]; tx2 = i(#7,0,v2); ty2 = i(#7,1,v2);
N==9?(pp+=6);
copy(i[#-3,qp],[ 9,v0,v1,v2,tx0,ty0,tx1,ty1,tx2,ty2 ],10); qp+=10;
add_material();
):(N==4 || N==12)?(
v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
v2 = i[#3,pp++]; tx2 = i(#7,0,v2); ty2 = i(#7,1,v2);
v3 = i[#3,pp++]; tx3 = i(#7,0,v3); ty3 = i(#7,1,v3);
N==12?(pp+=8);
copy(i[#-3,qp],[ 12,v0,v1,v2,v3,tx0,ty0,tx1,ty1,tx2,ty2,tx3,ty3 ],13); qp+=13;
add_material();
):N==5?(
v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
v2 = i[#3,pp++]; pp+=2;
(tx0+=tx1)/=2; (ty0+=ty1)/=2;
R = i(#6,tx0,ty0,0,0); G = i(#6,tx0,ty0,0,1); B = i(#6,tx0,ty0,0,2);
copy(i[#-3,qp],[ 5,v0,v1,v2,0,0 ],6); qp+=6;
copy(i[#-2,qc],[ R,G,B ],3); qc+=3;
);
);
resize(#-3,1,qp,1,1,0,0);
resize(#-2,1,qc,1,1,0,0)"
rm[3-5] mv[-3--1] 3
if {!w} rm.. fi
a[0-5] y
endl done rm[-2,-1]
#@cli torus3d : _radius1,_radius2,_nb_subdivisions1>2,_nb_subdivisions2>2
#@cli : Input 3D torus at (0,0,0), with specified geometry.
#@cli : Default values: 'radius1=1', 'radius2=0.3', 'nb_subdivisions1=24' and 'nb_subdivisions2=12'.
#@cli : $ torus3d 10,3 +primitives3d 1 color3d[-2] ${-RGB}
torus3d : check "${3=24}>2 && ${4=12}>2" skip ${1=1},${2=0.3}
e[^-1] "Input 3D torus, with radii ($1,$2) and subdivisions ($3,$4)."
v -
nbp={$3*$4}
1,8,1,1,67.5,73.5,109.5,103.5,51.5,100.5,$nbp,{$4*$3}
(0;{2*pi}) +y. x
r.. 1,{$3+1},1,1,3 z.. 0,0,0,{$3-1}
r. {$4+1},1,1,1,3 z. 0,{$4-1}
+sin[-2,-1] cos[-4,-3] r[-4--1] $4,$3
*... $2 +... $1 *. $2 *[-4] ... *[-3,-2]
y[-3--1] a[-3--1] x
1,$3,1,1,'y' *. $4 +shift. 0,-1 $4,1,1,1,'x' +shift. -1 r[-4--1] $4,$3
++[-4,-1] +.. [-4] +[-5] ... +[-4,-3] y[-4--1] i[-5] 1,{h},1,1,4 a[-5--1] x
3,{h},1,1,200 1,{h},1,1,1 y[-4--2] a[-5--1] y
nm. [3D\ torus]
v +
#@cli triangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2
#@cli : Input 3D triangle at specified coordinates.
#@cli : $ repeat 100 a={$>*pi/50} triangle3d 0,0,0,0,0,3,{cos(3*$a)},{sin(2*$a)},0 color3d[-1] ${-RGB} done add3d
triangle3d :
e[^-1] "Input 3D triangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)."
v - 1,25,1,1,67.5,73.5,109.5,103.5,51.5,100.5,3,1,${1-9},3,0,1,2,200,200,200,1 nm. [3D\ triangle] v +
#@cli volume3d
#@cli : Transform selected 3D volumetric images as 3D parallelepipedic objects.
#@cli : $ image.jpg animate blur,0,5,30 append z volume3d
volume3d :
e[^-1] "Transform image$? as 3D parallelepipedic objects."
v - repeat $! l[$>]
w={w} h={h} d={d}
+slices 0 +slices[0] 100% mirror. y
+columns[0] 0 +columns[0] 100% permute[-2,-1] zyxc mirror.. x
+rows[0] 0 +rows[0] 100% permute[-2,-1] xzyc mirror.. y
rm[0] image6cube3d *3d $w,$h,$d
endl done v +
#@cli weird3d : _resolution>0
#@cli : Input 3D weird object at (0,0,0), with specified resolution.
#@cli : Default value: 'resolution=32'.
#@cli : $ weird3d 48 +primitives3d 1 color3d[-2] ${-RGB}
weird3d : skip ${1=32}
e[^-1] "Input 3D weird object, with resolution $1."
v -
isosurface3d "'\
T = 1.61803399;\
2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x))\
'",0,-4.7,-4.7,-4.7,4.7,4.7,4.7,$1,$1,$1
c3d. n3d. nm. [3D\ weird]
v +
#@cli :: Control Flow
#@cli ap : eq. to 'apply_parallel'.
ap :
v - _gmic_s="$?" v +
_apply_parallel "$*"
#@cli apply_parallel : "command"
#@cli : Apply specified command on each of the selected images, by parallelizing it for all image of the list.
#@cli : (eq. to 'ap').
#@cli : $ image.jpg +mirror x +mirror y apply_parallel "blur 3"
apply_parallel :
v - _gmic_s="$?" v +
_$0 "$*"
_apply_parallel :
e[0--3] "Apply command '$*' on all image"$_gmic_s" in parallel, using "$_cpus" threads."
v -
if {$!" && "narg("$*")}
m "_ap : repeat $! l[$>] $* if $! k[0] else 0 fi endl done"
N={min($!,$_cpus)}
commands= sep= repeat $N commands=$commands${sep}_ap[$>--1:$N] sep=, done
parallel $commands
uncommand _ap
fi
v +
#@cli apc : eq. to 'apply_parallel_channels'.
apc :
v - _gmic_s="$?" v +
_apply_parallel_channels "$*"
#@cli apply_parallel_channels : "command"
#@cli : Apply specified command on each of the selected images, by parallelizing it for all channel of the images independently.
#@cli : (eq. to 'apc').
#@cli : $ image.jpg apply_parallel_channels "blur 3"
apply_parallel_channels :
v - _gmic_s="$?" v +
_$0 "$*"
_apply_parallel_channels :
e[0--3] "Apply command '$*' on all channels of image"$_gmic_s" in parallel, using "$_cpus" threads."
v - N=$! repeat $N s$>={$>,s} done s c
ap "$1"
repeat $N a[$>-{$>+${s$>}-1}] c done v +
#@cli apo : eq. to 'apply_parallel_overlap'.
apo : check "${2=0}>=0 && isint(${3=0}) && $3>=0"
v - _gmic_s="$?" v +
_apply_parallel_overlap "$1",${2--1}
#@cli apply_parallel_overlap : "command",overlap[%],nb_threads={ 0=auto | 1 | 2 | 4 | 8 | 16 }
#@cli : Apply specified command on each of the selected images, by parallelizing it on 'nb_threads' overlapped sub-images.
#@cli : (eq. to 'apo').\n
#@cli : 'nb_threads' must be a power of 2.
#@cli : Default values: 'overlap=0','nb_threads=0'.
#@cli : $ image.jpg +apply_parallel_overlap "smooth 500,0,1",1
apply_parallel_overlap : check "${2=0}>=0 && isint(${3=0}) && $3>=0"
v - _gmic_s="$?" v +
_$0 "$1",${2--1}
_apply_parallel_overlap : check "${2=0}>=0 && isint(${3=0}) && $3>=0"
v - N={if($3,max(1,round($3)),$_cpus)} N={2^int(log2(min(16,$N)))} v +
e[0--3] "Apply parallelized command '$1' on image"$_gmic_s", with overlap $2 and "$N" threads."
v -
__apo_exception=""
m "_check1 : if {$!!=1} rm 0 __apo_exception=\"Command 'apply_parallel_overlap': Specified command '$1' changes the size of the image stack.\" fi"
repeat $! l[$>]
_apply_parallel_overlap$N "$1",$2
endl done
uncommand _check1
v +
_apply_parallel_overlap1 :
$1
if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi
_apply_parallel_overlap2 :
if {w>=h}
ovx={round(if(${"is_percent $2"},w*$2,$2))} w2={int(w/2)}
+z[0] {$w2-$ovx},100% z[0] 0,{$w2+$ovx-1}
parallel "l[0] $1 _check1 endl","l[1] $1 _check1 endl"
if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi
z[0] 0,{0,w-1-$ovx} z[1] $ovx,100% a x
else
ovy={round(if(${"is_percent $2"},h*$2,$2))} h2={int(h/2)}
+rows[0] {$h2-$ovy},100% rows[0] 0,{$h2+$ovy-1}
parallel "l[0] $1 _check1 endl","l[1] $1 _check1 endl"
if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi
rows[0] 0,{0,h-1-$ovy} rows[1] $ovy,100% a y
fi
_apply_parallel_overlap4 :
if {max(w,h)/min(w,h)>=3}
_apply_parallel_overlap2 "_apply_parallel_overlap2 \"$1\",$2",$2
else
ovx={round(if(${"is_percent $2"},w*$2,$2))} w2={int(w/2)}
ovy={round(if(${"is_percent $2"},h*$2,$2))} h2={int(h/2)}
+z[0] {$w2-$ovx},0,100%,{$h2+$ovy-1} +z[0] 0,{$h2-$ovy},{$w2+$ovx-1},100%
+z[0] {$w2-$ovx},{$h2-$ovy},100%,100% z[0] 0,0,{$w2+$ovx-1},{$h2+$ovy-1}
parallel "l[0] $1 _check1 endl","l[1] $1 _check1 endl","l[2] $1 _check1 endl","l[3] $1 _check1 endl"
if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi
z[0] 0,0,{0,w-1-$ovx},{0,h-1-$ovy} z[1] $ovx,0,100%,{1,h-1-$ovy}
z[2] 0,$ovy,{2,w-1-$ovx},100% z[3] $ovx,$ovy,100%,100%
a[0,1] x a[1,2] x a y
fi
_apply_parallel_overlap8 :
_apply_parallel_overlap2 "_apply_parallel_overlap4 \"$1\",$2",$2
_apply_parallel_overlap16 :
_apply_parallel_overlap2 "_apply_parallel_overlap8 \"$1\",$2",$2
#@cli at : eq. to 'apply_tiles'.
at : check "${2=10%}>0 && ${3=10%}>0 && ${4=10%}>0 && ${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && isint(${8=1}) && $8>=0 && $8<=3"
v - _gmic_s="$?" v +
_apply_tiles "$1",${2--1}
#@cli apply_tiles : "command",_tile_width[%]>0,_tile_height[%]>0,_tile_depth[%]>0,_overlap_width[%]>=0,_overlap_height[%]>=0,_overlap_depth[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply specified command on each tile (neighborhood) of the selected images, eventually with overlapping tiles.
#@cli : (eq. to 'at').
#@cli : Default values: 'tile_width=tile_height=tile_depth=10%','overlap_width=overlap_height=overlap_depth=0' and 'boundary_conditions=1'.
#@cli : $ image.jpg +equalize[0] 256 +apply_tiles[0] "equalize 256",16,16,1,50%,50%
apply_tiles : check "${2=10%}>0 && ${3=10%}>0 && ${4=10%}>0 && ${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && isint(${8=1}) && $8>=0 && $8<=3"
v - _gmic_s="$?" v +
_$0 "$1",${2--1}
_apply_tiles :
e[0--3] "Apply command '$1' on $2x$3x$4 tiles of image$?, with overlaps ($5,$6,$7) and "${"arg 1+$8,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! l[$>]
bw={cut(round(${"is_percent $2"}?w*$2:$2),1,w)}
bh={cut(round(${"is_percent $3"}?h*$3:$3),1,h)}
bd={cut(round(${"is_percent $4"}?d*$4:$4),1,d)}
ow={round(${"is_percent $5"}?$bw*$5:$5)}
oh={round(${"is_percent $6"}?$bh*$6:$6)}
od={round(${"is_percent $7"}?$bd*$7:$7)}
sw={cut($bw-$ow,1,$bw)}
sh={cut($bh-$oh,1,$bh)}
sd={cut($bd-$od,1,$bd)}
100%,100%,100%,{s+1}
if {$ow>0" || "$oh>0" || "$od>0} l[]
$bw,1,1 1,$bh,1 1,1,$bd
= 1,50%,50%,50% distance 1
/[0] {0.3*$bw} /[1] {0.3*$bh} /[2] {0.3*$bd}
sqr * -1 exp r $bw,$bh,$bd,1 *
endl else $bw,$bh,$bd,1,1
fi
$bw,$bh,$bd,[0]
m "__at : $1 k. r "$bw,$bh,$bd,{0,s},0
eval "
mask = crop(#2);
for (z = 0, z<d#0, z+="$sd",
for (y = 0, y<h#0, y+="$sh",
for (x = 0, x<w#0, x+="$sw",
draw(crop(#0,x,y,z,w,h,d,$8),0,0,0,0,w,h,d);
ext('__at.');
breakpoint();
draw(#1,crop(#-1),x,y,z,0,w,h,d,s#0,-1,mask);
draw(#1,mask,x,y,z,s#0,w,h,d,1,-1);
)
)
)"
rm[-2,-1]
s. c,-{0,s} /[-2,-1] k.
uncommand __at
endl done v +
#@cli apply_timeout : "command",_timeout={ 0=no timeout | >0=with specified timeout (in seconds) }
#@cli : Apply a command with a timeout.
apply_timeout :
if {!$2}
e[0--3] "Apply command '$1' on image$?, with no timeout."
v - $1 v +
else
e[0--3] "Apply command '$1' on image$?, with a timeout of $2 seconds."
v -
l[] ({'$/'}) id={is} rm endl
__done$id=0 __is_timeout$id=0
l
parallel "$1 __done"$id"=1",\
"do if {$|>$2} __is_timeout"$id"=1 error \"\" elif $__done"$id" break fi wait 100 while 1"
onfail
v +
if ${__is_timeout$id} v + error[0--5] "Command '$0': Time out ($2 seconds) for command '$1'."
else v + error[0--5] "Command '$0': "${}
fi
endl
v +
fi
#@cli check : expression : (+)
#@cli : Evaluate specified expression and display an error message if evaluated to false.
#@cli : If 'expression' is not a math expression, it is regarded as a filename and checked if it exists.
#@cli check3d : _is_full_check={ 0 | 1 } : (+)
#@cli : Check validity of selected 3D vector objects, and display an error message
#@cli : if one of the selected images is not a valid 3D vector object.
#@cli : Full 3D object check is slower but more precise.
#@cli : Default value: 'is_full_check=1'.
#@cli continue : (+)
#@cli : Go to end of current 'repeat...done', 'do...while' or 'local...endlocal' block.
#@cli : $ image.jpg repeat 10 blur 1 if {1==1} continue fi deform 10 done
#@cli break : (+)
#@cli : Break current 'repeat...done', 'do...while' or 'local...endlocal' block.
#@cli : $ image.jpg repeat 10 blur 1 if {1==1} break fi deform 10 done
#@cli do : (+)
#@cli : Start a 'do...while' block.
#@cli : $ image.jpg luminance i={ia+2} do set 255,{u(100)}%,{u(100)}% while {ia<$i}
#@cli done : (+)
#@cli : End a 'repeat/for...done' block, and go to associated 'repeat/for' position, if iterations remain.
#@cli elif : boolean : filename : (+)
#@cli : Start a 'elif...[else]...fi' block if previous 'if' was not verified
#@cli : and test if specified boolean is true, or if specified filename exists.
#@cli : 'boolean' can be a float number standing for { 0=false | other=true }.
#@cli else : (+)
#@cli : Execute following commands if previous 'if' or 'elif' conditions failed.
#@cli fi : eq. to 'endif'. : (+)
#@cli endif : (+)
#@cli : End a 'if...[elif]...[else]...endif' block.
#@cli : (eq. to 'fi').\n
#@cli endl : eq. to 'endlocal'. : (+)
#@cli endlocal : (+)
#@cli : End a 'local...endlocal' block.
#@cli : (eq. to 'endl').
#@cli error : message : (+)
#@cli : Print specified error message on the standard error (stderr) and exit interpreter, except
#@cli : if error is caught by a 'onfail' command.
#@cli : Command selection (if any) stands for displayed call stack subset instead of image indices.
#@cli eval : expression : (+)
#@cli : Evaluate specified math expression.
#@cli : - If no command selection is specified, the expression is evaluated once and its result is set to status.
#@cli : - If command selection is specified, the evaluation is looped over selected images. Status is not modified.
#@cli :   (in this latter case, 'eval' is similar to 'fill' without assigning the image values).
#@cli x : eq. to 'exec'. : (+)
#@cli exec : _is_verbose={ 0 | 1 },"command" : (+)
#@cli : Execute external command using a system call.
#@cli : The status value is then set to the error code returned by the system call.
#@cli : If 'is_verbose=1', the executed command is allowed to output on stdout/stderr.
#@cli : (eq. to 'x').
#@cli : Default value: 'is_verbose=1'.
#@cli for : condition : (+)
#@cli : Start a 'for...done' block.
#@cli : $ image.jpg resize2dy 32 400,400,1,3 x=0 for {$x<400} image[1] [0],$x,$x x+=40 done
#@cli if : boolean : filename : (+)
#@cli : Start a 'if...[elif]...[else]...fi' block and test if specified boolean is true,
#@cli : or if specified filename exists.
#@cli : 'boolean' can be a float number standing for { 0=false | other=true }.
#@cli : $ image.jpg if {ia<64} add 50% elif {ia<128} add 25% elif {ia<192} sub 25% else sub 50% fi cut 0,255
#@cli l : eq. to 'local'. : (+)
#@cli local : (+)
#@cli : Start a 'local...[onfail]...endlocal' block, with selected images.
#@cli : (eq. to 'l').
#@cli : $ image.jpg local[] 300,300,1,3 rand[0] 0,255 blur 4 sharpen 1000 endlocal
#@cli : $ image.jpg +local repeat 3 deform 20 done endlocal
#@cli : $$
#@cli mutex : index,_action={ 0=unlock | 1=lock } : (+)
#@cli : Lock or unlock specified mutex for multi-threaded programming.
#@cli : A locked mutex can be unlocked only by the same thread. All mutexes are unlocked by default.
#@cli : 'index' designates the mutex index, in [0,255].
#@cli : Default value: 'action=1'.
#@cli noarg : (+)
#@cli : Used in a custom command, 'noarg' tells the command that its argument list have not been used
#@cli : finally, and so they must be evaluated next in the G'MIC pipeline, just as if the custom
#@cli : command takes no arguments at all.
#@cli : Use this command to write a custom command which can decide if it takes arguments or not.
#@cli onfail : (+)
#@cli : Execute following commands when an error is encountered in the body of the 'local...endlocal' block.
#@cli : The status value is set with the corresponding error message.
#@cli : $ image.jpg +local blur -3 onfail mirror x endlocal
#@cli parallel : _wait_threads,"command1","command2",... : (+)
#@cli : Execute specified commands in parallel, each in a different thread.
#@cli : Parallel threads share the list of images.
#@cli : 'wait_threads' can be { 0=when current environment ends | 1=immediately }.
#@cli : Default value: 'wait_threads=1'.
#@cli : $ image.jpg [0] parallel "blur[0] 3","mirror[1] c"
parallel : skip "${1=},${2=},${3=},${4=},${5=},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=}"
if {$1==0||$1==1||$1==2} e[0--3] "Execute "{$#-1}" commands '${2--1}' in parallel on image$?."
else e[0--3] "Execute "$#" commands '$*' in parallel on image$?."
fi
v - parallel $"*" v +
#@cli progress : 0<=value<=100 : -1 : (+)
#@cli : Set the progress index of the current processing pipeline.
#@cli : This command is useful only when G'MIC is used by an embedding application.
#@cli q : eq. to 'quit'. : (+)
#@cli quit : (+)
#@cli : Quit G'MIC interpreter.
#@cli : (eq. to 'q').
#@cli repeat : nb_iterations,_variable_name : (+)
#@cli : Start iterations of a 'repeat...done' block.
#@cli : $ image.jpg split y repeat $!,n shift[$n] $<,0,0,0,2 done append y
#@cli : $ image.jpg mode3d 2 repeat 4 imagecube3d rotate3d 1,1,0,40 snapshot3d 400,1.4 done
#@cli : $$
#@cli return : (+)
#@cli : Return from current custom command.
#@cli rprogress : 0<=value<=100 | -1 | "command",0<=value_min<=100,0<=value_max<=100
#@cli : Set the progress index of the current processing pipeline (relatively to
#@cli : previously defined progress bounds), or call the specified command with
#@cli : specified progress bounds.
rprogress : skip ${2=""}
v -
if {!narg($_progress_bounds)} _progress_bounds=0,100 fi
m={arg(-2,$_progress_bounds)} M={arg(-1,$_progress_bounds)}
if {$#==2&&!narg($2)}
v + e[0--3] "Set relative progress index to $1%." v -
progress {if($1<0,-1,min(100,max(0,$m+($M-$m)*$1%)))}
elif {$#==3}
nm={min($2,$-1)} nM={max($2,$-1)}
v + e[0--3] "Call command '$1' with progress bounds ["$nm,$nM"]." v -
progress $m _progress_bounds=$_progress_bounds,{$m+$nm*($M-$m)/100},{$m+$nM*($M-$m)/100}
run "$1"
progress $M ($_progress_bounds) _progress_bounds={@0--3} rm.
else v + error[0--3] "Command '$0': Invalid argument '$*'."
fi
v +
#@cli run : "G'MIC pipeline"
#@cli : Run specified G'MIC pipeline.
#@cli : This is only useful when used from a shell, e.g. to avoid shell substitutions to happen in argument.
run :
$*
#@cli skip : item : (+)
#@cli : Do nothing but skip specified item.
#@cli u : eq. to 'status'. : (+)
#@cli status : status_string : (+)
#@cli : Set the current status. Used to define a returning value from a function.
#@cli : (eq. to 'u').
#@cli : $ image.jpg command "foo : u0=Dark u1=Bright status ${u{ia>=128}}" text_outline ${-foo},2,2,23,2,1,255
#@cli while : boolean : filename : (+)
#@cli : End a 'do...while' block and go back to associated 'do'
#@cli : if specified boolean is true or if specified filename exists.
#@cli : 'boolean' can be a float number standing for { 0=false | other=true }.
#@cli :: Arrays, Tiles and Frames
#@cli array : M>0,_N>0,_expand_type={ 0=min | 1=max | 2=all }
#@cli : Create MxN array from selected images.
#@cli : Default values: 'N=M' and 'expand_type=0'.
#@cli : $ image.jpg array 3,2,2
array : check "isint($1) && $1>0 && isint(${2=$1}) && $2>0" skip ${3=0}
e[^-1] "Create $1x$2 array from image$?, with expand type $3."
v - r0={100/max($1,$2)} r1={100/min($1,$2)} r2=100
r ${r$3}%,${r$3}%,1,100%,2 r {$1*100}%,{$2*100}%,1,100%,0,2 v +
#@cli array_fade : M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0=min | 1=max | 2=all}
#@cli : Create MxN array from selected images.
#@cli : Default values: 'N=M', 'fade_start=60', 'fade_end=90' and 'expand_type=1'.
#@cli : $ image.jpg array_fade 3,2
array_fade : skip ${2=$1},${3=60},${4=90},${5=1}
e[^-1] "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
v - repeat $! l[$>] . shift.. {round(w/2)},{round(h/2)},1,1,2 fade_diamond $3,$4 endl done
array $1,$2,$5
v +
#@cli array_mirror : N>=0,_dir={ 0=x | 1=y | 2=xy | 3=tri-xy },_expand_type={ 0 | 1 }
#@cli : Create 2^Nx2^N array from selected images.
#@cli : Default values: 'dir=2' and 'expand_type=0'.
#@cli : $ image.jpg array_mirror 2
array_mirror : skip ${2=2},${3=0}
e[^-1] "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
v - repeat $1
if {$3==0}
if {$2>=3} r 33%,33%,100%,100%,2
else r 50%,50%,100%,100%,2
fi
fi
repeat $! l[$>]
if {$2==0} +mirror x a x
elif {$2==1} +mirror y a y
else +mirror x a x +mirror y a y if {$2==3} r 150%,150%,1,100%,0,2,1,1 fi
fi
endl done
done v +
#@cli array_random : Ms>0,_Ns>0,_Md>0,_Nd>0
#@cli : Create MdxNd array of tiles from selected MsxNs source arrays.
#@cli : Default values: 'Ns=Ms', 'Md=Ms' and 'Nd=Ns'.
#@cli : $ image.jpg +array_random 8,8,15,10
array_random : skip ${2=$1},${3=$1},${4=$2}
e[^-1] "Create $3x$4 array of tiles from $1x$2 array$?."
v - repeat $! l[$>] nm={0,n}
split_tiles $1,$2
repeat $3 repeat $4 [{u($1*$2-1)}] done done
rm[0-{$1*$2-1}] append_tiles $3,$4
nm $nm endl done v +
#@cli frame : eq. to 'frame_xy'.
frame : skip ${2=$1}>=0,${3=255},${4=$3},${5=$4},${6=255}
v - _gmic_s="?" v +
_frame_xy ${1--1}
#@cli frame_blur : _sharpness>0,_size>=0,_smoothness,_shading,_blur
#@cli : Draw RGBA-colored round frame in selected images.
#@cli : Default values: 'sharpness=10', 'size=30', 'smoothness=0', 'shading=1' and 'blur=3%'.
#@cli : $ image.jpg frame_blur 3,30,8,10%
frame_blur : skip ${1=10},${2=30},${3=0},${4=1},${5=3%}
e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and blur $5."
v - to_rgba repeat $! l[$>] nm={0,n}
100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" >=. $2%
if $4 distance. 1 n. 0,1 *. -1 +. 1 ^. {1/$4} fi
b. $3 +b.. $5 mv. -3 blend_fade[0,1] . rm.
nm $nm endl done v +
#@cli frame_cube : _depth>=0,_centering_x,_centering_y,_left_side={0=normal | 1=mirror-x | 2=mirror-y | 3=mirror-xy},_right_side,_lower_side,_upper_side
#@cli : Insert 3D frames in selected images.
#@cli : Default values: 'depth=1', 'centering_x=centering_y=0' and 'left_side=right_side,lower_side=upper_side=0'.
#@cli : $ image.jpg frame_cube ,
frame_cube : check "${1=1}>=0" skip ${2=0},${3=0},${4=0},${5=0},${6=0},${7=0}
e[^-1] "Insert 3D frame in image$?, with depth $1, centering point ($2,$3) and orientations (${4--1})."
v - repeat $! l[$>] nm={0,n} split_opacity
if {$!==2} frame_cube ${1--1} a c
else
m={max(w,h)} w={w} h={h} s={s}
imageplane3d c3d /3d. $w,$h,1
+_frame_cube[0] $4 r3d. 0,1,0,-90 +3d. -0.5,0,-0.5
+_frame_cube[0] $5 r3d. 0,1,0,90 +3d. 0.5,0,-0.5
+_frame_cube[0] $6 r3d. 1,0,0,-90 +3d. 0,0.5,-0.5
+_frame_cube[0] $7 r3d. 1,0,0,90 +3d. 0,-0.5,-0.5
+3d 0,0,1 +3d *3d $w,$h,$m
f=1000
cx=$2*$w/2*($f+$m*$1)/$f
cy=$3*$h/2*($f+$m*$1)/$f
s3d r[2] 3,{{2,h}/3},1,1,-1
f[2] "if(i(2,y)<0.5,i,i+if(x==0,"$cx",if(x==1,"$cy",($1-1)*"$m")))"
y[2] a y
*3d 2 {2*$w},{2*$h},1,$s f3d {2*$f}
j3d. ..,50%,50%,0,1,2,0,0 rm..
r $w,$h,1,100%,2
fi
nm $nm endl done
v +
_frame_cube :
if {$1==1} r3d. 0,1,0,180 rv3d.
elif {$1==2} r3d. 1,0,0,180 rv3d.
elif {$1==3} r3d. 0,0,1,180
fi
#@cli frame_fuzzy : size_x[%]>=0,_size_y[%]>=0,_fuzzyness>=0,_smoothness[%]>=0,_R,_G,_B,_A
#@cli : Draw RGBA-colored fuzzy frame in selected images.
#@cli : Default values: 'size_y=size_x', 'fuzzyness=5', 'smoothness=1' and 'R=G=B=A=255'.
#@cli : $ image.jpg frame_fuzzy 20
frame_fuzzy : skip ${2=$1},${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
e[^-1] "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
v - to_rgba repeat $! l[$>]
100%,100%,1,1,1
padx={if(${"is_percent $1"},$1*(w-1)/2,$1)}
pady={if(${"is_percent $2"},$2*(h-1)/2,$2)}
rectangle. $padx,$pady,{w-1-$padx},{h-1-$pady}
spread. $3 b. $4 100%,100%,1,4 fc. ${5-8}
j[0] [2],0,0,0,0,1,[1] k[0]
endl done v +
#@cli frame_painting : _size[%]>=0,0<=_contrast<=1,_profile_smoothness[%]>=0,_R,_G,_B,_vignette_size[%]>=0,_vignette_contrast>=0,_defects_contrast>=0,0<=_defects_density<=100,_defects_size>=0,_defects_smoothness[%]>=0,_serial_number
#@cli : Add a painting frame to selected images.
#@cli : Default values: 'size=10%', 'contrast=0.4', 'profile_smoothness=6%', 'R=225', 'G=200', 'B=120', 'vignette_size=2%', 'vignette_contrast=400', 'defects_contrast=50', 'defects_density=10', 'defects_size=1', 'defects_smoothness=0.5%' and 'serial_number=123456789'.
#@cli : $ image.jpg frame_painting ,
frame_painting :
check "${1=10%}>=0 && ${2=0.4}>=0 && $2<=1 && ${3=6%}>=0 && ${7=2%}>=0 && ${8=400}>=0 && ${9=50}>=0 && ${10=10}>=0 && $10<=100 && ${11=1}>=0 && ${12=0.5%}>=0"
skip ${4=225},${5=200},${6=120},${13=123456789}
e[^-1] "Add painting frame to image$?, with size $1, contrast $2, profile smoothness $3, color (${4-6}), vignette size $7, "\
"vignette strength $8, defects contrast $9, defects density $10, defects size $11, defects smoothness $12 and serial number $13."
if {!$1} return fi
v - repeat $! l[$>]
$1,$1 s={max(w,h)} rm.
({'${dec2bin\ $13}'}) -. {'0'} r. $s
transpose. b. $3 n. {1-$2},{1+$2}
+r. {{-2,w}+2*$s},100%,1,1
+mirror. y
mv... $! transpose. r. 100%,{-4,h+2*$s},1,1
+mirror. x
...,...,1,1,1 polygon. 3,0,0,{$s-1},{$s-1},0,{$s-1},1,0 polygon. 3,100%,0,{w-$s},100%,100%,100%,1,0
..,..,1,1,1 polygon. 3,1,0,100%,{$s-2},100%,0 polygon. 3,1,100%,100%,{h-$s+1},100%,100%,1,0
_frame_painting[-6--3] ${4-6},${9-12}
{-7,w+2*$s},{-7,h+2*$s},1,3
j. [-7],0,0,0,0,1,...,1 rm[-7] mirror... y
j. [-6],0,{h-$s},0,0,1,...,1 rm[-6,-3]
j. [-4],0,0,0,0,1,..,1 rm[-4] mirror.. x
j. ...,{w-$s},0,0,0,1,..,1 rm[-3,-2]
..,..,1,1,-255 r. ..,..,1,1,0,0,0.5,0.5 +. 255 +b. $7 n. 0,$8 max[-2,-1] c. 0,255
a[-2--1] c
r.. .,.,1,100%,0,0,0.5,0.5 blend alpha
endl done v +
_frame_painting :
repeat $! l[$>]
+*. $2 +*.. $3 *... $1 a[-3--1] c
100%,100%
i=0 do rand. 0,1 remove_pixels. {100-$5}% b. $6 >=. 50% i+=1 while {"m=$5/200;(ia<m-0.2 || ia>m+0.2) && "$i"<10"}
b. $7 g. +[-2,-1] n. -$4,$4
+[-2,-1] c. 0,255
endl done
#@cli frame_pattern : M>=3,_constrain_size={ 0 | 1 } : M>=3,_[frame_image],_constrain_size={ 0 | 1 }
#@cli : Insert selected pattern frame in selected images.
#@cli : Default values: 'pattern=0' and 'constrain_size=0'.
#@cli : $ image.jpg frame_pattern 8
frame_pattern : check $1>=3 skip ${2=0},${3=}
v - to_colormode 0
if ${"is_image_arg $2"}
v + e[^-1] "Insert $1x$1 pattern frame on image$?, using frame image$2." v -
pass$2 0 repeat {$!-1} l[$>,-1]
wh={0,w},{0,h}
+r[1] {0,max(1,w/($1-2))},{0,max(1,h/($1-2))},1,100%,2
r[0] {{0,w}+2*w},{{0,h}+2*h},1,100%,0,0,0.5,0.5
[-1]x{$1+2} a[{-$1-2}--1] x j[0] .,0,0 j[0] .,0,{{0,h}-1-h} rm.
[-1]x{$1+1} a[{-$1-2}--1] y j[0] .,0,0 j[0] .,{{0,w}-1-w} rm.
if $3 r[0] $wh,1,100%,2 fi
endl done rm.
else
v + e[^-1] "Insert $1x$1 self-pattern frame on image$?." v -
repeat $! l[$>]
wh={w},{h}
+r {max(1,w/($1-2))},{max(1,h/($1-2))},1,100%,2 r.. {$1*w},{$1*h},1,100%,0,0,0.5,0.5
[-1]x{$1+2} a[{-$1-2}--1] x j... .,0,0 j... .,0,{{-3,h}-1-h} rm.
[-1]x{$1+1} a[{-$1-2}--1] y j.. .,0,0 j.. .,{{-2,w}-1-w} rm.
if $3 r $wh,1,100%,2 fi
endl done
fi
v +
#@cli frame_round : _sharpness>0,_size>=0,_smoothness,_shading,_R,_G,_B,_A
#@cli : Draw RGBA-colored round frame in selected images.
#@cli : Default values: 'sharpness=10', 'size=10', 'smoothness=0', 'shading=0' and 'R=G=B=A=255'.
#@cli : $ image.jpg frame_round 10
frame_round : skip ${1=10},${2=10},${3=0},${4=0},${5=255},${6=$5},${7=$6},${8=255}
e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and RGBA color ($5,$6,$7,$8)."
v - to_rgba repeat $! l[$>] nm={0,n}
100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" >=. $2%
if $4 distance. 1 n. 0,1 *. -1 +. 1 ^. {1/$4} fi
b. $3 i... 100%,100%,1,4 fc... $5,$6,$7,$8 blend_fade[0,1] . rm.
nm $nm endl done v +
#@cli frame_seamless : frame_size>=0,_patch_size>0,_blend_size>=0,_frame_direction={ 0=inner (preserve image size) | 1=outer }
#@cli : Insert frame in selected images, so that tiling the resulting image makes less visible seams.
#@cli : Default values: 'patch_size=7', 'blend_size=5' and 'frame_direction=1'.
#@cli : $ image.jpg +frame_seamless 30 array 2,2
frame_seamless : check "$1>=0 && isint(${2=7}) && $2>0 && isint(${3=5}) && $3>=0" skip ${4=1}
v - s0="inner" s1="outer"
v + e[^-1] "Insert "${s{!!$4}}" seamless frame in image$?, with size $1, patch size $2 and blend size $3." v -
repeat $! l[$>]
w2={round(w/2)} h2={round(h/2)}
w4={round(w/4)} h4={round(h/4)}
if {!$4} r {max(1,w-$1)},{max(1,h-$1)},1,100%,0,0,0.5,0.5 fi
100%,100%,1,1,-1 r[-2,-1] {w+$1},{h+$1},1,100%,0,0,0.5,0.5 n. 0,1
shift -$w2,-$h2,0,0,2
inpaint_matchpatch.. [1],0,$2,10,$3
rectangle. $1,$1,{w-1-$1},{h-1-$1}
shift -$w4,-$h4,0,0,2
inpaint_matchpatch.. [1],0,$2,10,$3
rm.
shift {$w4+$w2},{$h4+$h2},0,0,2
endl done v +
#@cli frame_x : size_x[%],_col1,...,_colN
#@cli : Insert colored frame along the x-axis in selected images.
#@cli : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@cli : $ image.jpg frame_x 20,255,0,255
frame_x : skip ${2=255},${3=$2},${4=$3},${5=255}
e[^-1] "Insert $1 outer frame in image$? along the x-axis, with color (${2--1})."
_frame $1,0,0,${2--1}
#@cli frame_xy : size_x[%],_size_y[%],_col1,...,_colN
#@cli : Insert colored frame along the x-axis in selected images.
#@cli : Default values: 'size_y=size_x', 'col1=col2=col3=255' and 'col4=255'.
#@cli : (eq. to 'frame').
#@cli : $ image.jpg frame_xy 1,1,0 frame_xy 20,10,255,0,255
frame_xy : skip ${2=$1},${3=255},${4=$3},${5=$4},${6=255}
v - _gmic_s="$?" v +
_$0 ${1--1}
_frame_xy :
e[0--3] "Insert $1x$2 outer frame in image"$_gmic_s" along the xy-axes, with color (${3--1})."
_frame $1,$2,0,${3--1}
#@cli frame_xyz : size_x[%],_size_y[%],_size_z[%]_col1,...,_colN
#@cli : Insert colored frame along the x-axis in selected images.
#@cli : Default values: 'size_y=size_x=size_z', 'col1=col2=col3=255' and 'col4=255'.
frame_xyz : skip ${2=$1},${3=$2},${4=255},${5=$4},${6=$5},${7=255}
e[^-1] "Insert $1x$2x$3 outer frame in image$? along the xyz-axes, with color (${4--1})."
_frame $1,$2,$3,${4--1}
#@cli frame_y : size_y[%],_col1,...,_colN
#@cli : Insert colored frame along the y-axis in selected images.
#@cli : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@cli : $ image.jpg frame_y 20,255,0,255
frame_y : skip ${2=255},${3=$2},${4=$3},${5=255}
e[^-1] "Insert $1 outer frame in image$? along the y-axis, with color (${2--1})."
_frame 0,$1,0,${2--1}
_frame :
v - repeat $! l[$>]
nm={0,n}
w={round($1*if(${is_percent\ $1},w,1))}
h={round($2*if(${is_percent\ $2},h,1))}
d={round($3*if(${is_percent\ $3},d,1))}
{w+2*$w},{h+2*$h},{d+2*$d},100% fc[1] ${4--1}
j[1] [0],$w,$h,$d rm[0] nm $nm
endl done v +
#@cli img2ascii : _charset,_analysis_scale>0,_analysis_smoothness[%]>=0,_synthesis_scale>0,_output_ascii_filename
#@cli : Render selected images as binary ascii art.
#@cli : This command returns the corresponding the list of widths and heights (expressed as a number of characters) for each selected image.
#@cli : Default values: 'charset=[ascii charset]', 'analysis_scale=16', 'analysis_smoothness=20%', 'synthesis_scale=16' and '_output_ascii_filename=[undefined]'.
#@cli : $ image.jpg img2ascii ,
img2ascii : skip "${1= !\042#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~}","${5=}" check "${2=16}>0 && ${3=20%}>=0 && ${4=16}>0"
e[^-1] "Render image$? as binary ascii art, with charset '$1', analysis scale $2, analysis smoothness $3, synthesis scale $4 and output ascii filename '$5'."
v -
is_multi={$!>1}
l[]
({'"$1"'}) repeat {w}
C={`92`}${dec2oct\ {0,@$>}}
0 t. $C,0,0,$2,1,1
0 t. $C,0,0,$4,1,1
done rm[0]
= -1 = -1,0,100% autocrop = 0 = 0,0,100%
l[0--2:2] r {${-max_w}+1},100%,1,1,0,0,0.5 b $3 n 0,255 a z endl
l[1--1] r {${-max_w}+1},100%,1,1,0,0,0.5 a z endl
endl
w={-2,w} h={-2,h}
repeat {$!-2} l[$>,-2,-1]
luminance[0] n[0] 0,255
nw={0,round(w/$w,1,1)}
nh={0,round(h/$h,1,1)}
if $> list_wh=$list_wh,$nw,$nh else list_wh=$nw,$nh fi
s[0] y,-$h s[0--3] x,-$w r[0--3] $w,$h,1,1,0,0
repeat {$!-2} l[$>,-2,-1]
rprogress {$>*100/($!-2)}
r[0] [1] -[0] [1] sqr[0] r[0] 1,1,100%,1,2 y[0]
C={0,ym} rm[0]
+slices[1] $C mv. 0
if {narg("$5")} +f[0] $C a[0,-1] c fi
endl done
append_tiles[0--2] $nw,$nh
if {narg("$5")} s[0] c l[1]
r $nw,$nh,1,1,1
({'"$1"'}) map[0] . k[0]
s y i[1-$!] ({'\n'})
a x
if $is_multi filename=${filename\ "$5",$>} else filename="$5" fi
o raw:$filename,char rm
endl fi
endl done
rm[-2,-1] u $list_wh v +
#@cli imagegrid : M>0,_N>0
#@cli : Create MxN image grid from selected images.
#@cli : Default value: 'N=M'.
#@cli : $ image.jpg imagegrid 16
imagegrid : skip ${2=$1}
e[^-1] "Create $1x$2 image grid from image$?."
v - repeat $! l[$>]
({w},{h}) ($1,$2) /[-2,-1] round. 1 r.. {^},..,..,2 rm.
({w},{h}) ($1,$2) *[-2,-1] r.. {^},..,..,2 rm.
$1,$2,1,.,1 shift. 1,1 r. ..,0,2 *
endl done v +
#@cli imagegrid_hexagonal : _resolution>0,0<=_outline<=1
#@cli : Create hexagonal grids from selected images.
#@cli : Default values: 'resolution=32', 'outline=0.1' and 'is_antialiased=1'.
#@cli : $ image.jpg imagegrid_hexagonal 24
imagegrid_hexagonal : check "isint(${1=32}) && $1>0 && ${2=0.1}>=0 && $2<=1"
e[^-1] "Create hexagonal grid(s) from image$?, with resolution $1 and outline $2."
v - repeat $! l[$>]
l[]
({'CImg3d'},6,6)
(0;{2*pi}) -. {pi/2} r. 1,7,1,1,3 +sin. cos.. a[-2,-1] x rows. 0,5 z. 0,2
2,6,1,1,3,0 1,100%,1,1,y ++. 1 %. 6 rv[-2,-1] a[-3--1] x
3,100%,1,1,1 1,100%,1,1,1 y a y
*3d. {1-$2}
++3d {sqrt(3)} ++3d {sqrt(3)/2},1.5
col3d... 2 col3d.. 3 col3d. 4 +3d
/3d 1.5
endl
ny={1+round(0.5*$1,1,1)}
nx={0,1+round($1*w/h*3/(sqrt(3)*4),1,1)}
array3d. $nx,$ny,1,{4*sqrt(3)/3},2
c3d. *3d. {0,h/$1}
[0],[0] j3d. ..,50%,50%,0,1,2,0,0 rm..
blend shapeaverage0
endl done v +
#@cli imagegrid_triangular : pattern_width>=1,_pattern_height>=1,_pattern_type,0<=_outline_opacity<=1,_outline_color1,...
#@cli : Create triangular grids from selected images.
#@cli : 'pattern type' can be { 0=horizontal | 1=vertical | 2=crossed | 3=cube | 4=decreasing | 5=increasing }.
#@cli : Default values: 'pattern_width=24', 'pattern_height=pattern_width', 'pattern_type=0', 'outline_opacity=0.1' and 'outline_color1=0'.
#@cli : $ image.jpg imagegrid_triangular 6,10,3,0.5
imagegrid_triangular : check "$1>=1 && ${2=$1}>=1 && isint(${3=0}) && $3>=0 && $3<=5" skip ${4=0},${5=0}
v - s0="horizontal" s1="vertical" s2="crossed" s3="cube" v +
e[^-1] "Create triangular grid(s) from image$?, with pattern width $1, height $2, pattern type '"${s$3}"', "\
"outline opacity $4 and outline color (${5--1})."
v -
M={max($1,$2)}
if {$3==4" || "$3==5}
$M,$M,1,1,x>y ++. 2 a[-2,-1] x ++. 4 a[-2,-1] y
$M,$M,1,1,"!x || !y || x==y" r. 200%,200%,1,1,0,2
a[-2,-1] c
if {$3==5} mirror. y fi
elif {$3==3}
$M,$M,1,1,x>y 100%,100%,1,1,w-1-x>=y a[-2,-1] x ++. 2 mirror. y a[-2,-1] y
++. 4 =. 4,50%,50% =.. 2 a[-2,-1] x label. 0,0
(2,2,2,0,1,2,1,1,3,3,3,1,1,0) map.. . rm.
100%,100%,1,1
line. 0,0,{$M-1},{$M-1},1,1 line. {$M-1},$M,0,100%,1,1
line. {$M-1},{$M-1},{3*$M-1},{$M-1},1,1 line. {2*$M},0,0,0,1,1
line. {2*$M},0,100%,100%,1,1 line. {2*$M},100%,100%,0,1,1
a[-2,-1] c
elif {$3==2}
$M,$M,1,1,x>y ++. 2 mirror. x a[-2,-1] x ++. 4 mirror. y a[-2,-1] y
100%,100%,1,1,"!x || !y || x==int(w/2) || y==int(h/2) || x==y || w-1-x==y"
a[-2,-1] c
elif {$3==1}
$M,$M,1,1,x>y 100%,100%,1,1,w-1-x<=y a[-2,-1] y ++. 2 mirror. x a[-2,-1] x
100%,100%,1,1,"!x || x==int(w/2) || x==y || w-1-x==y"
a[-2,-1] c
else
$M,$M,1,1,x>y 100%,100%,1,1,w-1-x>=y a[-2,-1] x ++. 2 mirror. y a[-2,-1] y
100%,100%,1,1,"!y || y==int(h/2) || x==y || w-1-x==y"
a[-2,-1] c
fi
repeat {$!-1}
wh={$>,w},{$>,h}
if {$1>$2} r[$>] 100%,{$>,$1*h/$2} elif {$1<$2} r[$>] {$>,$2*w/$1} fi
+r. [$>],[$>],1,2,0,2,0.5,0.5
s. c
blend[$>,-2] shapeaverage
+fc[$>] ${5--1} j[$>] .,0,0,0,0,$4,.. rm[-2,-1]
r[$>] $wh,1,100%,2
done
rm.
v +
#@cli linearize_tiles : M>0,_N>0
#@cli : Linearize MxN tiles on selected images.
#@cli : Default value: 'N=M'.
#@cli : $ image.jpg +linearize_tiles 16
linearize_tiles : check "$1>0 && ${2=$1}>0"
e[^-1] "Linearize $1x$2 tiles on image$?."
v - repeat $! l[$>] nm={0,n}
s={s} split_tiles $1,$2 s c
repeat $! l[$>]
wh={w},{h}
+f x +f. y +f. 1 y a[^0] x solve.. . rm.
$wh,1,1,{@0}"*x + "{@1}"*y + "{@2} rm..
endl done
repeat {int($!/$s)} a[-$s--1] c mv. 0 done append_tiles $1,$2
nm $nm endl done v +
#@cli map_sprites : _nb_sprites>=1,_allow_rotation={ 0=none | 1=90 deg. | 2=180 deg. }
#@cli : Map set of sprites (defined as the 'nb_sprites' latest images of the selection) to other selected images,
#@cli : according to the luminosity of their pixel values.
#@cli : $ image.jpg resize2dy 48 repeat 16 ball {8+2*$>},${-RGB} mul[-1] {(1+$>)/16} done map_sprites 16
map_sprites : check "isint($1) && $1>0 && isint(${2=0}) && $2>=0 && $2<=2"
e[^-1] "Map set of $1 sprites to image selection$?."
v - norm[0--{$1+1}] quantize[0--{$1+1}] $1,0,1
slices[-$1--1] 0 r[-$1--1] ${max_wh[-$1--1]},1,100%,0,0,0.5,0.5
if {$2==1}
N={4*$1}
repeat {$!-$1} *[$>] 4 +rand[$>] 0,3 round. +[$>,-1] done
repeat $1 l[{1+$<}] +mirror xy +rotate 90 endl done
elif {$2==2}
N={2*$1}
repeat {$!-$1} *[$>] 2 +rand[$>] 0,1 round. +[$>,-1] done
repeat $1 l[{1+$<}] +mirror xy endl done
else N=$1 fi
r[-$N--1] 100%,100%,1,${max_s[-$N--1]} w={w} h={h} a[-$N--1] x
r[^-1] ${w}00%,${h}00%,1,1 *[^-1] $w
(0,{$w-1};0,{$w-1}^0,0;{$h-1},{$h-1}) r. $w,$h,1,2,3 round.
repeat {$!-2} +r. [$>],[$>],1,2,0,2 r[$>] 100%,100%,1,2,0 +[$>,-1] +warp.. [$>],0,0 rv[$>,-1] rm. done rm[-2,-1] v +
#@cli pack : is_ratio_constraint={ 0 | 1 },_sort_criterion
#@cli : Pack selected images into a single image.
#@cli : The returned status contains the list of new (x,y) offsets for each input image.
#@cli : Parameter 'is_ratio_constraint' tells if the resulting image must tend to a square image.
#@cli : Default values: 'is_ratio_constraint=0' and 'sort_criterion=max(w,h)'.
#@cli : $ image.jpg repeat 10 +resize2dx[-1] 75% balance_gamma[-1] ${-RGB} done pack 0
pack : skip ${1=0},${2=max(w,h)}
e[^-1] "Pack image$? into a single image."
if {$!<2} return fi
if {${-max_d}>1} error[0--3] "Command '$0': Selected images contain at least one volumetric image (depth>1). Should all be 2D." fi
v -
nm={0,n} to_colormode 0
repeat $! nm$>={0,n} nm[$>] $> done
sort_list -,"$2"
offsets{0,n}=0,0
N=$!
i[0] 0
do l[0,1,2]
w1={1,w} h1={1,h} w2={2,w} h2={2,h}
slot=-1 min_slot_area=inf
repeat {0,h}
x={0,i(0,$>)} y={0,i(1,$>)} w={0,i(2,$>)} h={0,i(3,$>)}
slot_area={$w*$h}
if {$w>=$w2" && "$h>=$h2" && "$slot_area<=$min_slot_area}
slot=$> min_slot_area=$slot_area
fi
done
if {$slot>=0}
x={0,i(0,$slot)} y={0,i(1,$slot)} w={0,i(2,$slot)} h={0,i(3,$slot)}
j[1] [2],$x,$y offsets{2,n}=$x,$y
l[0]
s y rm[$slot]
area1={max(($w-$w2)*$h,$w2*($h-$h2))}
area2={max(($w-$w2)*$h2,$w*($h-$h2))}
if {$area1>=$area2}
if {$w2<$w} i[$slot] ({$x+$w2},$y,{$w-$w2},$h) fi
if {$h2<$h} i[$slot] ($x,{$y+$h2},$w2,{$h-$h2}) fi
else
if {$w2<$w} i[$slot] ({$x+$w2},$y,{$w-$w2},$h2) fi
if {$h2<$h} i[$slot] ($x,{$y+$h2},$w,{$h-$h2}) fi
fi
a y if {!$!} 0 fi
endl
rm[2]
else
if $1
metric_h={abs($w1+$w2-max($h1,$h2))}
metric_v={abs($h1+$h2-max($w1,$w2))}
else
metric_h={if($h2<$h1,$w2*($h1-$h2),$w1*($h2-$h1))}
metric_v={if($w2<$w1,($w1-$w2)*$h2,($w2-$w1)*$h1)}
fi
if {$metric_h<=$metric_v}
offsets{2,n}=$w1,0
a[1,2] x,0
if {$h2<$h1} ($w1,$h2,$w2,{$h1-$h2}) a[0,-1] y
elif {$h2>$h1} (0,$h1,$w1,{$h2-$h1}) a[0,-1] y
fi
else
offsets{2,n}=0,$h1
a[1,2] y,0
if {$w2<$w1} ($w2,$h1,{$w1-$w2},$h2) a[0,-1] y
elif {$w2>$w1} ($w1,0,{$w2-$w1},$h1) a[0,-1] y
fi
fi
fi
endl while {$!>2}
rm[0]
status=
repeat $N if {narg($status)} status=$status,${offsets$>} else status=${offsets$>} fi done
nm $nm u $status
v +
#@cli puzzle : _width>0,_height>0,_M>=1,_N>=1,_curvature,_centering,_connectors_variability,_resolution>=1
#@cli : Input puzzle binary mask with specified size and geometry.
#@cli : Default values: 'width=height=512', 'M=N=5', 'curvature=0.5', 'centering=0.5', 'connectors_variability=0.5' and 'resolution=64'.
#@cli : $ puzzle ,
puzzle : check "isint(${1=512}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=5}) && $3>0 && isint(${4=$3}) && $4>0 && isint(${8=64}) && $8>0"
skip ${5=0.5},${6=0.5},${7=0.5}
e[^-1] "Draw $3x$4 puzzle pattern on image$?, with curvature $5, centering $6, connectors variability $7 and resolution $8."
v - l[]
if {$4>=2} _puzzle[] $3,{$4-1},${5-8} +3d. 0,1 fi
if {$3>=2} _puzzle[] $4,{$3-1},${5-8} r3d. 0,0,1,-90 +3d. 1,$4 fi
*3d {$1/$3},{$2/$4} quadrangle3d 0,0,0,{$1-1},0,0,{$1-1},{$2-1},0,0,{$2-1},0 p3d. 1 +3d col3d 1
$1,$2 j3d. ..,0,0,0,1,1,0,0 rm..
endl v +
_puzzle :
R={$6*$1}
repeat $2
({'CImg3d'},$R,{$R-1})
repeat $1
sign={if(u<=0.5,-1,1)}
center={$4*u(-0.25,0.25)}
knob={$5*u(-0.05,0.12)}
($>,0;\
{0.2+$center+$>},{-$sign*$3*0.1};\
{0.4+$center+$>},0;\
{0.35+$center+$>},{0.1*$sign};\
{0.45+$center+$>},{(0.15+$knob)*$sign};\
{0.55+$center+$>},{(0.15+$knob)*$sign};\
{0.65+$center+$>},{0.1*$sign};\
{0.6+$center+$>},0;\
{0.8+$center+$>},{-$sign*$3*0.1})
done
($1,0) a[-{$1+1}--1] y r. 2,$R,1,1,5 z. 0,2
(2,0,1;2,{$R-2},{$R-1}) r. 3,{$R-1},1,1,3 round.
3,{h},1,1,255 1,{h},1,1,255 y[-5--1] y a[-5--1] y +3d. 0,$>
done +3d
#@cli quadratize_tiles : M>0,_N>0
#@cli : Quadratize MxN tiles on selected images.
#@cli : Default value: 'N=M'.
#@cli : $ image.jpg +quadratize_tiles 16
quadratize_tiles : check "$1>0 && ${2=$1}>0"
e[^-1] "Quadratize $1x$2 tiles on image$?."
v - repeat $! l[$>] nm={0,n}
s={s} split_tiles $1,$2 s c
repeat $! l[$>]
wh={w},{h}
+f x^2 +f. y^2 +f. x*y +f. x +f. y +f. 1 y a[^0] x
solve.. . rm.
$wh,1,1,{@0}"*x^2 + "{@1}"*y^2 + "{@2}"*x*y +"{@3}"*x + "{@4}"*y + "{@5} rm..
endl done
repeat {int($!/$s)} a[-$s--1] c mv. 0 done append_tiles $1,$2
nm $nm endl done v +
#@cli rotate_tiles : angle,_M>0,N>0
#@cli : Apply MxN tiled-rotation effect on selected images.
#@cli : Default values: 'M=8' and 'N=M'.
#@cli : $ image.jpg to_rgba rotate_tiles 10,8 drop_shadow 10,10 display_rgba
rotate_tiles : skip ${2=8},${3=$2}
e[^-1] "Apply $2x$3 tiled-rotation effect on image$?, with angle $1 deg."
v - split_tiles $2,$3,1 rotate $1 append_tiles $2,$3 v +
#@cli shift_tiles : M>0,_N>0,_amplitude
#@cli : Apply MxN tiled-shift effect on selected images.
#@cli : Default values: 'N=M' and 'amplitude=20'.
#@cli : $ image.jpg +shift_tiles 8,8,10
shift_tiles : check "${2=$1}>=0" skip ${3=20}
e[^-1] "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
v - repeat $! l[$>]
$1,$2,1,2 noise. $3 r. ..,..,1,2 warp.. .,1,1,0 rm.
endl done v +
#@cli taquin : M>0,_N>0,_remove_tile={ 0=none | 1=first | 2=last | 3=random },_relief,_border_thickness[%],_border_outline[%],_outline_color
#@cli : Create MxN taquin puzzle from selected images.
#@cli : Default value: 'N=M', 'relief=50', 'border_thickness=5', 'border_outline=0' and 'remove_tile=0'.
#@cli : $ image.jpg +taquin 8
taquin : check "isint($1) && $1>0 & isint(${2=$1}) && $2>0" skip ${3=0},${4=50},${5=5%},${6=0},${7=0},${8=$7},${9=$8},${10=255}
e[^-1] "Create $1x$2 taquin puzzle from image$?, with relief $4, border thickness $5, border outline $6 and outline color (${7--1})."
v - repeat $! l[$>] nm={0,n}
split_tiles $1,$2 r ${-min_wh},100%,100%,0
100%,100%,1,1,1
if ${"is_percent $5"} rectangle. {100*$5/2}%,{100*$5/2}%,{100-50*$5}%,{100-50*$5}%,1,0
else rectangle. $5,$5,{w-1-$5},{h-1-$5},1,0 fi
*. '1-2*(x/w<y/h)' *. $4
repeat {$!-1} l[$>,-1] split_opacity[0] +[0] . a[^-1] c endl done rm. c 0,255
frame $6,$6,${7-10}
if {$3==3} f. 0 fi
repeat $! mv[$>] {u($!)} done
if {$3==1} f[0] 0 elif {$3==2} f. 0 fi
append_tiles $1,$2
nm $nm endl done v +
#@cli tunnel : _level>=0,_factor>0,_centering_x,_centering_y,_opacity,_angle
#@cli : Apply tunnel effect on selected images.
#@cli : Default values: 'level=9', 'factor=80%', 'centering_x=centering_y=0.5', 'opacity=1' and 'angle=0'
#@cli : $ image.jpg tunnel 20
tunnel : check "${1=9}>=0 && ${2=80%}>0" skip ${3=0.5},${4=0.5},${5=0.1},${6=0}
e[^-1] "Apply tunnel effect on image$?, with depth $1, factor $2, centering ($3,$4), opacity $5 and angle $6."
v - repeat $! l[$>]
repeat $1 +r. $2,$2,1,100%,5
if $6 100%,100%,1,1,1 rotate[-2,-1] $6,1,0 erode. 3 j... ..,{({-3,w}-w)*$3},{({-3,h}-h)*$4},0,0,$5,. rm[-2,-1]
else j.. .,{({-2,w}-w)*$3},{({-2,h}-h)*$4},0,0,$5 rm. fi
done
endl done c 0,255 v +
#@cli :: Artistic
#@cli boxfitting : _min_box_size>=1,_max_box_size>=0,_initial_density>=0,_nb_attempts>=1
#@cli : Apply box fitting effect on selected images, as displayed the web page:
#@cli : [http://www.complexification.net/gallery/machines/boxFittingImg/]
#@cli : Default values: 'min_box_size=1', 'max_box_size=0', 'initial_density=0.1' and 'nb_attempts=3'.
#@cli : $ image.jpg boxfitting ,
boxfitting : check "isint(${1=3}) && $1>=1 && isint(${2=0}) && $2>=0 && ${3=0.1}>=0 && isint(${4=3}) && $4>=1"
e[^-1] "Apply box fitting effect on image$?, with box sizes ($1,$2), density $3 and $4 attempts."
v -
min_size=$1
max_size={if($2,$2,max(w,h))}
repeat $! l[$>]
nb_attempts=0 prec=5
100%,100%
repeat 1e8
if {$><1}
100%,100% noise. {max(1e-3,$3)},2 ==. 1
else
+distance. 1 +rand. 0,1 *[-2,-1] max_patch. {round($prec*$min_size)}
prec={max(1,$prec*0.9)}
fi
dilate. $min_size area_fg. 0,1 ==. {($min_size)^2}
+dilate.. 3 ==. 0 *[-2,-1] area_fg. 0,1 ==. {($min_size)^2}
if {!iM} nb_attempts+=1 if {$nb_attempts>$4} rm. break fi
else nb_attempts=0 fi
+[-2,-1]
repeat {int(($max_size-$min_size)/2)}
+dilate. 3 area_fg. 0,1 ==. {($min_size+2*$>+2)^2}
if {!iM} rm. break fi
-|[-2,-1]
done
done
blend shapeaverage0
endl done v +
#@cli brushify : [brush],_brush_nb_sizes>=1,0<=_brush_min_size_factor<=1,_brush_nb_orientations>=1,_brush_light_type,0<=_brush_light_strength<=1,_brush_opacity,_painting_density[%]>=0,0<=_painting_contours_coherence<=1,0<=_painting_orientation_coherence<=1,_painting_coherence_alpha[%]>=0,_painting_coherence_sigma[%]>=0,_painting_primary_angle,0<=_painting_angle_dispersion<=1
#@cli : Apply specified brush to create painterly versions of specified images.
#@cli : 'brush_light_type' can be { 0=none | 1=flat | 2=darken | 3=lighten | 4=full }.
#@cli : Default values: 'brush_nb_sizes=3', 'brush_min_size_factor=0.66', 'brush_nb_orientations=12', 'brush_light_type=0', 'brush_light_strength=0.25', 'brush_opacity=0.8', 'painting_density=20%', 'painting_contours_coherence=0.9', 'painting_orientation_coherence=0.9', 'painting_coherence_alpha=1', 'painting_coherence_sigma=1', 'painting_primary_angle=0', 'painting_angle_dispersion=0.2'
#@cli : $ image.jpg 40,40 gaussian[-1] 8,2 spread[-1] 4,0 +brushify[0] [1]
brushify : check ${"is_image_arg $1"}" &&"\
"isint(${2=4}) && $2>=1 &&"\
"${3=0.25}>=0 && $3<=1 &&"\
"isint(${4=12}) && $4>=1 &&"\
"isint(${5=4}) && $5>=0 &&"\
"${6=0.07}>=0 && $6<=1 &&"\
"isval(${7=0.75}) &&"\
"${8=40%}>=0 && $8>=0 &&"\
"${9=0.7}>=0 && $9<=1 &&"\
"${10=1}>=0 && $10<=1 &&"\
"${11=1}>=0 && ${12=0.5%}>=0 &&"\
"isval(${13=45}) &&"\
"${14=0.2}>=0 && $14<=1"
e[^-1] "Brushify image$?, with brush $1."
v -
pass$1 0 l.
slices 0 norm n 0,1 threshold 0.1,1 autocrop.
repeat $4 +rotate[0] {360*$>/$4} done
rm[0] n 0,1 threshold 0.1,1 autocrop r ${-max_wh},1,1,0,0,0.5,0.5
a z nm brush
wb={w} hb={h} whb={wh} ls={255*$6}
if {$5==0} +f. 0
elif {$5==1} +n. -$ls,0
elif {$5==2} +g xy +[-2,-1] min. 0 n. -$ls,0
elif {$5==3} +g xy +[-2,-1] max. 0 n. 0,$ls
else +g xy +[-2,-1] n. -$ls,$ls
fi
nm. brushlight
repeat {$2-1}
ratio={v=(1+$>)/max(1,$2-1);100*((1-v)+$3*v)}%
+r[brush,brushlight] $ratio,$ratio,100%,1,2
r[-2,-1] [brush],0,0,0.5,0.5
done
a[^:2] z a[^0] z
endl
repeat {$!-2} l[$>,brush,brushlight]
s={0,s} nm={0,n} to_rgb[0] nm[0] img
+diffusiontensors[img] $9,$10,$11,$12 nm. geometry
+channels[geometry] 0 sh[geometry] 2 +[-2,-1] ^. 0.3 quantize. $2,0 *. -1 +. $2 -. 1 nm. contours
1,{img,max(1,${"is_percent $8"}?wh*$8:$8)} rand. 0,{img,w-1} +rand. 0,{img,h-1} a[-2,-1] c nm. pts
+to_rgba[img] nm. res
f[pts] "*
begin(
S2 = round(0.5*["$wb","$hb"]);
brush_r = brush_g = brush_b = brush_a = vector"$whb"(255);
ang = $13*pi/180;
cu = [ cos(ang),sin(ang) ];
cv = [ -cu[1],cu[0] ];
T = mul(cu,cu,2) + $14*mul(cv,cv,2);
);
P = I;
G = I(#"$geometry",P);
ang = u(pi);
V = [ G[0],G[1],G[1],G[2] ]*(T*[ cos(ang),sin(ang) ]);
amp = i(#"$contours",P);
ang = round(((atan2(V[1],V[0])%(2*pi))*$4/(2*pi)))%$4;
col = I(#"$img",P);
ind = amp*$4 + ang;
brush = crop(#"$brush",0,0,ind,0,"$wb","$hb",1,1);
brushlight = crop(#"$brushlight",0,0,ind,0,"$wb","$hb",1,1);
brush_r = cut(col[0] + brushlight,0,255);
brush_g = cut(col[1] + brushlight,0,255);
brush_b = cut(col[2] + brushlight,0,255);
draw(#"$res",[brush_r,brush_g,brush_b,brush_a],P - S2,"$wb","$hb",1,4,$7,brush,1);
P"
k[res,brush,brushlight] mv[res] 0 nm[0] $nm to_colormode[0] {$s+($s%2)}
endl done rm[brush,brushlight] v +
#@cli cartoon : _smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0
#@cli : Apply cartoon effect on selected images.
#@cli : Default values: 'smoothness=3', 'sharpening=150', 'threshold=20', 'thickness=0.25', 'color=1.5' and 'quantization=8'.
#@cli : $ image.jpg cartoon 3,80,15
cartoon : skip ${1=3},${2=150},${3=20},${4=0.25},${5=1.5},${6=8}
e[^-1] "Apply cartoon effect on image$?, with smoothness $1, sharpening $2, threshold $3, thickness $4, color $5 and quantization $6."
v - repeat $! l[$>] split_opacity l[0] to_rgb
b $1 sharpen $2,1 c 0,255 n 0,255
if $4 +edges $3 b. $4 >=. 0.9 else 100%,100%,1,1,1 fi
rgb2lab.. s.. c *[-3,-2] $5 a[-4--2] c lab2rgb.. quantize.. $6,1,0 n.. 0,255 *
endl a c endl done v +
#@cli color_ellipses : _count>0,_radius>=0,_opacity>=0
#@cli : Add random color ellipses to selected images.
#@cli : Default values: 'count=400', 'radius=5' and 'opacity=0.1'.
#@cli : $ image.jpg +color_ellipses ,,0.15
color_ellipses : skip ${1=1400},${2=5},${3=0.1}
e[^-1] "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
v - repeat $1 ellipse {u(0,100)}%,{u(0,100)}%,{u(0,$2)}%,{u(0,$2)}%,{u(0,360)},$3,{u(60,255)},{u(60,255)},{u(60,255)},255 done v +
#@cli cubism : _density>=0,0<=_thickness<=50,_max_angle,_opacity,_smoothness>=0
#@cli : Apply cubism effect on selected images.
#@cli : Default values: 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'.
#@cli : $ image.jpg cubism ,
cubism : check "${1=50}>=0 && ${2=10}>=0 && $2<=50 && ${5=0}>=0" skip ${3=75},${4=0.7}
e[^-1] "Apply cubism effect on image$?, with density $1, thickness $2, maximum angle $3 deg., opacity $4 and smoothness $5."
if {"!$1 || !$2 || !$3 || !$4"} return fi
v - repeat $! l[$>]
w={w} h={h} s={s}
P={round($2*max(w,h)/200)}
N={round(1.5*$1*w*h/(4*$P)/100)}
({'CImg3d'}) +. 0.5 ({4*$N};$N)
1,$N rand. $P,{$w-1-$P} +rand. $P,{$h-1-$P} a[-2,-1] x round.
++. '-$P,-$P' ++.. '$P,-$P' ++... '$P,$P' ++[-4] '-$P,$P'
a[-4--1] x i.. (12,0,1,2,3;12,{4*($N-1)},{4*($N-1)+1},{4*($N-1)+2},{4*($N-1)+3})
r.. 5,$N,1,1,3 round.. 1 a[-2,-1] x
1,$N rand. {225-$3},{225+$3} *. {pi/180}
+sin. cos.. +*. -1 ... a[-4--3] x a[-2,-1] x z[-4,-2,-1] 0,2 +*[-2,-1] -1 a[-4--1] x *. {sqrt(2)*$P}
r... 400%,100%,1,1,0,2 +[-3,-1]
(-128;$w;$h;$s) +b[0] $5
if {$N>1} 4,{$N-1},1,1,-128,0,0,0 fi
1,$N,1,1,1
y[1--1] a[1--1] y rv3d.
if {$4>=1} j3d[0] [1],0,0,0,1,2,0,0 rm[1]
else +j3d[0] [1],0,0,0,1,2,0,0 rm[1] blend alpha,$4
fi
endl done v +
#@cli draw_whirl : _amplitude>=0
#@cli : Apply whirl drawing effect on selected images.
#@cli : Default value: 'amplitude=100'.
#@cli : $ image.jpg draw_whirl ,
draw_whirl : skip ${1=100}
e[^-1] "Apply whirl drawing effect on image$? with amplitude $1."
v - repeat $! l[$>]
100%,100% noise. 70,2 ==. 1 *. 255 r. .. &[-1,-2] smooth. $1,0,1,2,2
sqrt. n. 0,255 equalize.
endl done v +
#@cli drawing : _amplitude>=0
#@cli : Apply drawing effect on selected images.
#@cli : Default value: 'amplitude=200'.
#@cli : $ image.jpg +drawing ,
drawing : skip ${1=200}
e[^-1] "Apply drawing effect on image$? with amplitude $1."
v - repeat $! l[$>] split_opacity l[0] to_rgb
smooth $1,0.2,1,3,3 b 2 sharpen 1000 [0]
r[0] 20,20,1,3,2 equalize[0] index[1] [0],1,1
nm[1] {0,n},1 rm[0]
endl a c endl done v +
#@cli drop_shadow : _offset_x[%],_offset_y[%],_smoothness[%]>=0,0<=_curvature<=1,_expand_size={ 0 | 1 }
#@cli : Drop shadow behind selected images.
#@cli : Default values: 'offset_x=20', 'offset_y=offset_x', 'smoothness=5', 'curvature=0' and 'expand_size=1'.
#@cli : $ image.jpg drop_shadow 10,20,5,0.5 expand_xy 20,0 display_rgba
drop_shadow : check "${3=5}>=0 && ${4=0}>=0 && $4<=1" skip ${1=20},${2=$1},${5=1}
e[^-1] "Drop shadow behind image$?, with offsets ($1,$2), smoothness $3 and curvature $4."
v - to_a repeat $! l[$>]
nm={0,n}
dx={if(${is_percent\ $1},w*$1,$1)}
dy={if(${is_percent\ $2},h*$2,$2)}
sigma={if(${is_percent\ $3},max(w,h)*$3,$3)}
w={w} h={h} s={s} +channels 100% coords=${autocrop_coords.\ 0} rm. z $coords
r {w+abs($dx)},{h+abs($dy)},1,100%,0,0,{if($dx>0,0,1)},{if($dy>0,0,1)} r. {w+4*$sigma},{h+4*$sigma},1,100%,0,0,0.5,0.5
+channels. 100%
if {!$4} shift. $dx,$dy
else
(0;{pi}) r. ..,3 sin. *. -$4 +. 1 *. $dx
(0,{pi}) r. ..,3 sin. *. -$4 +. 1 *. $dy
a[-2,-1] c warp.. .,1,0,0 rm.
fi
b. $sigma,0
r. 100%,100%,1,2,0,0,0,0,0,1 mv. 0 blend alpha
+channels. 100% >=. 1 * autocrop 0
if {!$5} $w,$h,1,$s j. ..,{arg(1,$coords)},{arg(2,$coords)} rm.. fi
nm $nm
endl done v +
#@cli ellipsionism : _R>0[%],_r>0[%],_smoothness>=0[%],_opacity,_outline>0,_density>0
#@cli : Apply ellipsionism filter to selected images.
#@cli : Default values: 'R=10', 'r=3', 'smoothness=1%', 'opacity=0.7', 'outlise=8' and 'density=0.6'.
#@cli : $ image.jpg +ellipsionism ,
ellipsionism : check "${1=10}>0 && ${2=3}>0 && ${5=8}>0 && ${6=0.6}>0" skip ${3=1%},${4=0.7}
e[^-1] "Apply ellipsionism filter to image$?, with radii ($1,$2), smoothness $3, opacity $4 and outline $5."
v - to_rgba repeat $! l[$>]
+luminance g. xy a[-2,-1] c b. $3 orientation.
sh. 0 sh.. 1 atan2. .. *. {180/pi} +. 90 rm[-2,-1] channels. 1,1
..,..,1,..
repeat {$6*w*h/max($1,$2)}
xy={u(w)},{u(h)}
ellipse. $xy,$1,$2,{-2,i($xy)},$4,\
{-3,i($xy,0,0)},{-3,i($xy,0,1)},{-3,i($xy,0,2)},{-3,i($xy,0,3)}
ellipse. $xy,$1,$2,{-2,i($xy)},$4,0x1,\
{-3,i($xy,0,0)/$5},{-3,i($xy,0,1)/$5},{-3,i($xy,0,2)/$5},{-3,i($xy,0,3)/$5}
done rm..
n. .. blend alpha
endl done v +
#@cli fire_edges : _edges>=0,0<=_attenuation<=1,_smoothness>=0,_threshold>=0,_nb_frames>0,_starting_frame>=0,frame_skip>=0
#@cli : Generate fire effect from edges of selected images.
#@cli : Default values: 'edges=0.7', 'attenuation=0.25', 'smoothness=0.5', 'threshold=25', 'nb_frames=1', 'starting_frame=20' and 'frame_skip=0'.
#@cli : $ image.jpg fire_edges ,
fire_edges : check "${1=0.7}>=0 && ${2=0.25}>=0 && $2<=1 && ${3=0.5}>=0 && ${4=25}>=0 && ${5=1}>0 && ${6=20}>=0 && ${7=0}>=0"
e[^-1] "Generate fire effect from edges of image$?, with edges $1, attenuation $2, smoothness $3, threshold $4, "\
"$5 frames, starting frame $6 and frame skip $7."
v - repeat $! l[$>] nm={0,n}
norm +gradient_norm n. 0,1 roundify. $1 f[0] 0
(0,0,0;0,0,0;1,1,1;0,1,0) *. {(1-$2^4)/4}
repeat {$5*(1+$7)+$6}
{0,w},{0,h} rand. 0,255 *. [1]
b. $3
if $4 >=. $4% else equalize. fi
n. 0,255
j[0] .,0,0,0,0,1,[1],1 rm.
correlate[0] [2]
if {$>>=$6" && "($>-$6)%($7+1)==0} [0] fi
done rm[0-2]
nm $nm endl done
(0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) r. 256,1,1,3,3
map[^-1] . rm. v +
#@cli fractalize : 0<=detail_level<=1
#@cli : Randomly fractalize selected images.
#@cli : Default value: 'detail_level=0.8'
#@cli : $ image.jpg fractalize ,
fractalize : check "${1=0.8}>=0 && $1<=1"
e[^-1] "Randomly fractalize image$?, with detail level $1."
v -
xc=0.4433
yc=0.2645
delta=0.1
c0r=0.317
c0i=0.03
repeat $! l[$>] nm={0,n}
luminance equalize 256 b 0.25% n 0,255
100%,100%
dx={$delta*w/max(w,h)}
dy={$delta*h/max(w,h)}
x0={$xc-$dx/2}
y0={$yc-$dy/2}
x1={$xc+$dx/2}
y1={$yc+$dy/2}
mandelbrot. $x0,$y0,$x1,$y1,256,1,$c0r,$c0i
+==. 0 inpaint.. . rm.
n. 0,256
16,1,1,3 rand. 0,255 r. 256,1,1,3,3 map.. . rm.
s. c
i[2,3] [0]
s={0.1*(1-$1)}
parallel "register_nonrigid[1] [0],"$s",5","register_nonrigid[3] [2],"$s",5","register_nonrigid[5] [4],"$s",5"
rm[0,2,4] a c nm $nm
endl done v +
#@cli glow : _amplitude>=0
#@cli : Add soft glow on selected images.
#@cli : Default value: 'amplitude=1%'.
#@cli : $ image.jpg glow ,
glow : skip ${1=1%}
e[^-1] "Add soft glow on image$?, with amplitude $1."
v - repeat $! l[$>] split_opacity +b[0] $1 n. [0] blend_edges[0,-1] 1 a c endl done v +
#@cli halftone : nb_levels>=2,_size_dark>=2,_size_bright>=2,_shape={ 0=square | 1=diamond | 2=circle | 3=inv-square | 4=inv-diamond | 5=inv-circle },_smoothness[%]>=0
#@cli : Apply halftone dithering to selected images.
#@cli : Default values: 'nb_levels=5', 'size_dark=8', 'size_bright=8', 'shape=5' and 'smoothnesss=0'.
#@cli : $ image.jpg halftone ,
halftone : check "${1=5}>=2 && ${2=8}>=2 && ${3=8}>=2 && ${5=0}>=0" skip ${4=5}
v - s0="square" s1="diamond" s2="circle" s3="inv-square" s4="inv-diamond" s5="inv-circle" v +
e[^-1] "Apply halftone dithering to image$?, with $1 levels, dark size $3, bright size $4, "${s$4}" shape and smoothness $5."
v - repeat $! l[$>] s c repeat $! l[$>]
(0,255) a y quantize $1,0 rows 0,{h-2}
repeat $1
s={round(($2*$<+$3*$>)/($1-1))}
$s,$s =. 1,50%,50% distance. 1,{$4%3} +shift. {round(w/2)},{round(h/2)},0,0,2 min[-2,-1]
if {$4>=3} <. {100*$</($1-1.1)}% *. {-255} +. {255-$>}
else <. {100*$>/($1-1.1)}% *. 255 -. $>
fi
r. ..,0,2 b. $5 +==.. $> *[-2,-1] +[-2,-1]
done endl done a c
endl done v +
#@cli hardsketchbw : _amplitude>=0,_density>=0,_opacity,0<=_edge_threshold<=100,_is_fast={ 0 | 1 }
#@cli : Apply hard B&W sketch effect on selected images.
#@cli : Default values: 'amplitude=1000', 'sampling=3', 'opacity=0.1', 'edge_threshold=20' and 'is_fast=0'.
#@cli : $ image.jpg +hardsketchbw 200,70,0.1,10 median[-1] 2 +local reverse blur[-1] 3 blend[-2,-1] overlay endlocal
hardsketchbw : skip ${1=300},${2=50},${3=0.1},${4=20},${5=0}
e[^-1] "Apply hard B&W sketch effect on image$?, with amplitude $1, density $2, opacity $3 and edge threshold $4."
if {!$2} channels 0 f 255 return fi
v - luminance n 0,1
if $5
repeat $! l[$>] nm={0,n}
g xy rv *.. -1 a c
if $4 +norm >=. $4% * fi
100%,100%,1,1,255 quiver. ..,{max(1,10-$2/6)},$1,0,$3 rm..
nm $nm endl done
else
repeat $! l[$>] nm={0,n}
w={w} h={h} g xy rv *.. -1 a c * $1
+norm >=. $4% 100%,100% noise. $2,2 ==. 1 *[-2,-1]
pointcloud3d. s3d. rm[-6--5,-3--1] r. 3,{h/3},1,1,-1 s. x rm. a[-2,-1] c
warp.. .,0,0 +-. .. +[-3,-2] s[-2,-1] c
i... 1,{h} 1,{h} a[-6--1] x
i.. ({'CImg3d'}) i.. ({2*h},{h})
1,{h},1,1,2 1,{h},1,1,2*y ++. 1 a[-3--1] x
3,{h} 1,{h},1,1,$3 y[-6--1] a[-6--1] y
$w,$h,1,1,255 j3d. ..,0,0,0,1,1,0,0 rm..
nm $nm endl done
fi v +
#@cli hearts : _density>=0
#@cli : Apply heart effect on selected images.
#@cli : Default value: 'density=10'.
#@cli : $ image.jpg +hearts ,
hearts : skip ${1=10}
e[^-1] "Apply heart filter on image$?, with density $1."
v - repeat $! l[$>]
100%,100%,1 noise. $1,2 ==. 1 r. .. n. 0,1 *[-1,-2] _heart9x7
dilate.. . rm.
endl done v +
_heart9x7 :
(9,7,1,1,0,1,-1,2,-3,2,-1,4,-1,13,-1,7,-3,5,-5,3,-7,1,-4)
decompress_rle.
#@cli houghsketchbw : _density>=0,_radius>0,0<=_threshold<=100,0<=_opacity<=1,_votesize[%]>0
#@cli : Apply hough B&W sketch effect on selected images.
#@cli : Default values: 'density=8', 'radius=5', 'threshold=80', 'opacity=0.1' and 'votesize=100%'.
#@cli : $ image.jpg +houghsketchbw ,
houghsketchbw : check "${1=8}>=0 && ${2=5}>=0 && ${3=80}>=0 && $3<=100 && ${4=0.1}>=0 && $4<=1 && ${5=100%}>0"
e[^-1] "Apply hough B&W sketch effect on image$?, with density $1, radius $2, threshold $3, opacity $4 and votesize $5."
v - luminance repeat $! l[$>] nm={0,n}
res={round(if(${is_percent\ $5},$5*max(w,h),$5))} w={w} h={h} rhomax={sqrt(w^2+h^2)/2}
hough $res,$res n 0,255
normalize_local. $1,$2 >=. $3% pointcloud3d.
s3d. rm[-6--5,-3--1] r. 3,{h/3},1,1,-1 columns. 0,1
s. x,2
*.. {2*pi/$res}
*. {$rhomax/$res}
+cos.. *. .. +. {$w/2}
+sin... *. ... +. {$h/2}
rm...
i... ...
cos[-4] sin... *[-4,-3] 10000
++.. ...
+-.. [-5]
-[-4] [-5]
+... [-6]
rm[-6,-5]
i... 1,{h} 1,{h} a[-6--1] x
i.. ({'CImg3d'}) i.. ({2*h},{h})
1,{h},1,1,2 1,{h},1,1,2*y ++. 1 a[-3--1] x
3,{h},1,1,0 1,{h},1,1,$4
y[-6--1] a[-6--1] y
$w,$h,1,1,255 j3d. ..,0,0,0,1,1,0,0 rm..
nm $nm endl done v +
#@cli lightrays : 100<=_density<=0,_center_x[%],_center_y[%],_ray_length>=0,_ray_attenuation>=0
#@cli : Generate ray lights from the edges of selected images.
#@cli : Defaults values : 'density=50%', 'center_x=50%', 'center_y=50%', 'ray_length=0.9' and 'ray_attenuation=0.5'.
#@cli : $ image.jpg +lightrays , + cut 0,255
lightrays : check "${1=50}>=0 && $1<=100 && ${4=1}>=0 && ${5=1}>=0" skip ${2=50%},${3=50%}
e[^-1] "Generate ray lights from image$?, with density $1, center point ($2,$3), ray length $4 and attenuation $5."
v - repeat $! l[$>]
gradient_norm >= $1% euclidean2polar $2,$3
repeat {log2(w)} +shift. {2^$>} +[-2,-1] done
function1d 0.5,0,1,{$4*w},1,{1+($4+1-$5)*w},0 r. {-2,w},1,1,1,0
(1,{w}) r. {-2,w},1,1,1,3 /[-2,-1]
r. .. *[-2,-1] polar2euclidean $2,$3 n 0,255
endl done v +
#@cli light_relief : _ambient_light,_specular_lightness,_specular_size,_light_smoothness,_darkness,_xl,_yl,_zl,_zscale,_opacity_is_heightmap={ 0 | 1 }
#@cli : Apply relief light to selected images.
#@cli : Default values(s) : 'ambient_light=0.3', 'specular_lightness=0.5', 'specular_size=0.2', 'darkness=0', 'xl=0.2', 'yl=zl=0.5',
#@cli : 'zscale=1', 'opacity=1' and 'opacity_is_heightmap=0'.
#@cli : $ image.jpg blur 2 light_relief 0.3,4,0.1,0
light_relief : skip ${1=0.3},${2=0.5},${3=0.2},${4=0},${5=0.2},${6=0.5},${7=0.5},${8=1},${9=1},${10=0}
e[^-1] "Apply relief light to image$?."
v - repeat $! l[$>]
({-$6},{1-$6};{-$6},{1-$6}^{-$7},{-$7};{1-$7},{1-$7}^$8,$8;$8,$8) r. ..,..,1,3,3
if $10 +channels.. 3 to_rgb... else +to_rgb.. norm. fi
b. $5% g. xy 100%,100%,1,1,$9 a[-3--1] c
orientation[-2,-1] *[-2,-1] s. c +[-3--1]
100%,100% =. 1,{$6*100}%,{$7*100}% distance. 1 sqr. *. -1
/. {($3*max(w,h))^2} exp. *. $2 +. $1
*[-2,-1] -. $4 *. {-2,iM}
split_opacity[0] +[0,-1] a c c 0,255
endl done v +
#@cli linify : 0<=_density<=100,_spreading>=0,_resolution[%]>0,_line_opacity>=0,_line_precision>0,_mode={ 0=subtractive | 1=additive }
#@cli : Apply linify effect on selected images.
#@cli : The algorithm is inspired from the one described on the webpage 'http://linify.me/about'.
#@cli : Default values: 'density=50', 'spreading=2', 'resolution=40%', 'line_opacity=10', 'line_precision=24' and 'mode=0'.
#@cli : $ image.jpg linify 40
linify : check "${1=40}>=0 && $1<=100 && ${2=2}>=0 && ${3=40%}>0 && ${4=10}>=0 && isint(${5=24}) && $5>0 && isbool(${6=0})"
e[^-1] "Apply linify effect on image$?, with density $1, spreading $2, resolution $3, line opacity $4, line precision $5 and "${"-arg 1+$6,subtractive,additive"}" mode."
v - repeat $! l[$>] remove_opacity nm={n}
100%,100%,1,{s},$6?0:255
if {0,w>h} r2dx[0] {${"-is_percent $3"}?max(1,$3*w):min(w,$3)}
else r2dy[0] {${"-is_percent $3"}?max(1,$3*h):min(h,$3)}
fi
n[0] 0,100
if {narg($_debug)" && "!{*,w}} w[] ${-fitscreen[]\ {1,[w,h]}} fi
eval "
is_in(ind,P) = (P[0]>=0 && P[0]<w#ind && P[1]>=0 && P[1]<h#ind);
const add = $6;
const density = add?100 - $1:$1;
const spreading = max(0.1,$2);
const opacity = $4;
const precision = $5;
const om2add = 1 - 2*add;
fact = [ w/w#0, h/h#0,1,1 ];
nb_lines = 0;
ref0 = add?iM#0:im#0;
do (
S = stats(#0);
P0 = add?[ S[8],S[9],0,S[11] ]:[ S[4],S[5],0,S[7] ];
ref = S[add];
best_ang = best_avg = add?0:inf;
for (k = 0, k<precision, ++k,
ang = u(360)*pi/180;
dP = [ cos(ang), sin(ang),0,0 ];
dP/=max(abs(dP));
N = avg = 0;
P = P0; while (is_in(#0,P), avg+=i(#0,P); ++N; P+=dP);
P = P0; while (is_in(#0,P), avg+=i(#0,P); ++N; P-=dP);
avg/=N;
if (add?(avg>best_avg):(avg<best_avg), best_avg = avg; best_ang = ang);
);
dP = [ cos(best_ang), sin(best_ang),0,0 ];
dP/=max(abs(dP));
P = P0; while (is_in(#0,P), i(#0,P)+=om2add*spreading; P+=dP);
P = P0; while (is_in(#0,P), i(#0,P)+=om2add*spreading; P-=dP);
P = P0*fact; while (is_in(#1,P), i(#1,P)-=om2add*opacity*spreading; P+=dP);
P = P0*fact; while (is_in(#1,P), i(#1,P)-=om2add*opacity*spreading; P-=dP);
if (!(nb_lines%250),
progress = density==ref0?100:round(100*(ref - ref0)/(density - ref0));
ext('progress ',vtos(progress));
if (narg("$_debug"),ext('+c[1] 0,255 r. {*,w},{*,h},1,3,2 to. ',vtos(progress),'%,1%,1%,5%,1 w. -1,-1,0 rm.'));
);
++nb_lines;
breakpoint();
_(while), add?(ref>density):(ref<density))"
k. c 0,255 nm $nm
endl done v +
#@cli mosaic : 0<=_density<=100
#@cli : Create random mosaic from selected images.
#@cli : Default values: 'density=30'.
#@cli : $ image.jpg mosaic ,
mosaic : check "${1=30}>=0"
e[^-1] "Apply mosaic effect on image$?, with density $1."
v - repeat $! l[$>]
100%,100%,1,2,'u<0.25*($1%)^4?[u,1]' s. c
distance. 1 *. -1 watershed.. . rm.
blend shapeaverage
endl done v +
#@cli old_photo
#@cli : Apply old photo effect on selected images.
#@cli : $ image.jpg old_photo
old_photo :
e[^-1] "Apply old photo effect on image$?."
v - noise 20 bilateral 30,60 b 2 sharpen 100 frame_fuzzy 8%,8%,6,3 to_rgb shadow_patch 0.75 n 0,255 sepia v +
#@cli pencilbw : _size>=0,_amplitude>=0
#@cli : Apply B&W pencil effect on selected images.
#@cli : Default values: 'size=0.3' and 'amplitude=60'.
#@cli : $ image.jpg pencilbw ,
pencilbw : skip ${1=0.3},${2=60}
e[^-1] "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
v - repeat $! l[$>] split_opacity l[0] norm b $1 sharpen 4000 smooth $2,0,1 equalize sqrt n 0,255 endl a c endl done v +
#@cli pixelsort : _ordering={ + | - },_axis={ x | y | z | xy | yx },_[sorting_criterion],_[mask]
#@cli : Apply a 'pixel sorting' algorithm on selected images, as described in the page :
#@cli : http://satyarth.me/articles/pixel-sorting/
#@cli : Default values: 'ordering=+', 'axis=x' and 'sorting_criterion=mask=(undefined)'.
#@cli : $ image.jpg +norm +ge[-1] 30% +pixelsort[0] +,y,[1],[2]
pixelsort : check "(str1='${1=+}'; str1=='+' || str1=='-') && "\
"(str2='${2=x}'; str2=='x' || str2=='y' || str2=='z' || str2=='xy' || str2=='yx') && "\
"('${3=}'==0 || "${"is_image_arg $3"}") && "\
"('${4=}'==0 || "${"is_image_arg $4"}")"
v - s0="descending" s1="ascending" v +
if {'$3'!=0" && "'$4'!=0}
e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with sorting criterion $3 and mask $4."
elif {'$3'!=0" && "'$4'==0}
e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with sorting criterion $3."
elif {'$3'==0" && "'$4'!=0}
e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with mask $4."
else
e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2."
fi
v - repeat $!
if {'$3'!=0} pass$3 0 else +compose_channels[$>] + fi
if {'$4'!=0} pass$4 0 else [$>],[$>],[$>],1,1 fi
l[$>,-2,-1]
nm={0,n} >=. 50% mv.. 0 a c
order={`";'$1'=='+'?'<':'>'"`}
if {'$2'=='x';}
_pixelsort $order channels 1,{s-2}
elif {'$2'=='y';}
permute yxzc _pixelsort $order channels 1,{s-2} permute yxzc
elif {'$2'=='z';}
permute zxyc _pixelsort $order channels 1,{s-2} permute yzxc
elif {'$2'=='xy';}
_pixelsort $order permute yxzc _pixelsort $order channels 1,{s-2} permute yxzc
elif {'$2'=='yx';}
permute yxzc _pixelsort $order permute yxzc _pixelsort $order channels 1,{s-2}
fi
nm $nm
endl
done v +
_pixelsort :
1,{h},{d}
f. ":
quicksort(x0,x1,y,z) = (
stack = vector"{0,2*w}"();
stacksize = 0;
push(elt0,elt1) = (stack[stacksize++] = elt0; stack[stacksize++] = elt1);
pop() = (_s1 = stack[--stacksize]; _s0 = stack[--stacksize]; [_s0,_s1]);
push(x0,x1);
while (stacksize>0,
range = pop();
lo = range[0];
hi = range[1];
pivot = i(#0,int((lo + hi)/2),y,z,0);
while (lo<=hi,
while (i(#0,lo,y,z,0)$1pivot, ++lo);
while (pivot$1i(#0,hi,y,z,0), --hi);
if (lo<=hi, _tmp = I(#0,lo,y,z); I(#0,lo++,y,z) = I(#0,hi,y,z); I(#0,hi--,y,z) = _tmp);
);
if (range[0]<hi,push(range[0],hi));
if (lo<range[1],push(lo,range[1]));
)
);
s1 = s#0 - 1;
for (x0 = 0, x0<w#0, ++x0,
if (i(#0,x0,y,z,s1),
for (x1 = x0, x1<w#0 && i(#0,x1,y,z,s1)==1, ++x1);
quicksort(x0,min(x1,w#0-1),y,z);
x0 = ++x1;
)
)"
rm.
#@cli polaroid : _size1>=0,_size2>=0
#@cli : Create polaroid effect in selected images.
#@cli : Default values: 'size1=10' and 'size2=20'.
#@cli : $ image.jpg to_rgba polaroid 5,30 rotate 20 drop_shadow ,
polaroid : check "${1=10}>=0 && ${2=20}>=0"
e[^-1] "Create polaroid effect in image$?, with borders sizes $1 and $2."
v - - 255 r {100+$1}%,{100+$1}%,1,100%,0,0,0.5,0.5 r 100%,{100+$2}%,1,100%,0,0,0 + 255 v +
#@cli polygonize : _warp_amplitude>=0,_smoothness[%]>=0,_min_area[%]>=0,_resolution_x[%]>0,_resolution_y[%]>0
#@cli : Apply polygon effect on selected images.
#@cli : Default values: 'warp_amplitude=300', 'smoothness=2%', 'min_area=0.1%', 'resolution_x=resolution_y=10%'.
#@cli : $ image.jpg polygonize 300,1%,0.1%,3%,3%
polygonize : check "${1=300}>=0 && ${2=2%}>=0 && ${3=0.1%}>=0 && ${4=10%}>0 && ${5=$4}>0"
e[^-1] "Polygonize image$? with warp amplitude $1, smoothness $2, minimal area $3 and resolutions ($4,$5)."
v -  repeat $! l[$>]
+b $2 gradient_norm. g. a[-2,-1] c channels. 0,2 *. {1/0.1+max(abs(im),abs(iM))}
resx={max(1,round(if(${is_percent\ $4},w*$4,w/$4)-1))}
resy={max(1,round(if(${is_percent\ $5},h*$5,h/$5)-1))}
plane3d 1,1,$resx,$resy *3d. {0,w-1},{0,h-1},1
s3d. rm.. i.. (0;{h-1}) r.. 3,{h},1,1,3 round.. y..
[-4] a[-7--2] y r. 3,{h/3},1,1,-1 z. 0,1 permute. yzcx
repeat $1 +warp[1] .,0,0 +[-2,-1] done
permute. cxyz z. 0,2 y. j[2] .,0,8 rm[-3,-1]
[0],[0] j3d. [1],0,0,0,1,2 rm[1]
if {$3>0}
min_area={0,if(${is_percent\ $3},$3*w*h,$3)}
+area. 0,1 >=. $min_area +.. 1 *.. . distance. 1 *. -1 watershed.. . rm.
fi
blend shapeaverage
endl done v +
#@cli poster_edges : 0<=_edge_threshold<=100,0<=_edge_shade<=100,_edge_thickness>=0,_edge_antialiasing>=0,0<=_posterization_level<=15,_posterization_antialiasing>=0
#@cli : Apply poster edges effect on selected images.
#@cli : Default values: 'edge_threshold=40', 'edge_shade=5', 'edge_thickness=0.5', 'edge_antialiasing=10', 'posterization_level=12' and 'posterization_antialiasing=0'.
#@cli : $ image.jpg +poster_edges ,
poster_edges : check "${1=40}>=0 && $1<=100 && ${2=5}>=0 && $2<=100 && ${3=0.5}>=0 && ${4=10}>=0 && ${5=12}>=0 && $5<=15 && ${6=0}>=0"
e[^-1] "Apply poster edge on image$?, with edge threshold $1, edge shade $2, edge thickness $3, edge antialiasing $4, $5 level of posterization and posterization antialiasing $6."
v - repeat $! l[$>] split_opacity l[0]
+g xy,1 a[-2,-1] c norm. b. $3 n. 0,255
apply_curve. 1,0,1,{max(0,(100-($1%)^0.1*100)*255%)},0.99,{min(255,(101-($1%)^0.1*100+$2)*255%)},0.01,255,0 c. 0,1
if $4 smooth. {min(50,$4)},0,1,{$4/40},{$4/40},0.8,90 fi
if $5 autoindex[0] {round((4-sqrt($5+1))*32+2)} fi
if $6 smooth[0] {min(50,$6)},0,1,{$6/40},{$6/40},0.8,90 fi
*
endl a c endl done v +
#@cli poster_hope : _smoothness>=0
#@cli : Apply Hope stencil poster effect on selected images.
#@cli : Default value: 'smoothness=3'.
#@cli : $ image.jpg poster_hope ,
poster_hope : check "${1=3}>=0"
e[^-1] "Apply Hope stencil poster effect on image$?, with smoothness $1."
v - repeat $! l[$>] to_rgb
apc "smooth 200,0,1,$1,1"
quantize 7,0 f 'if(i!=5,i,i+1-2*(y%2))'
(0,32,47;0,32,47;209,1,23;209,1,23;90,141,145;-1,-1,-1;253,221,138) permute. yzcx
map[0] [1] rm[1]
endl done v +
#@cli rodilius : 0<=_amplitude<=100,_0<=thickness<=100,_sharpness>=0,_nb_orientations>0,_offset,_color_mode={ 0=darker | 1=brighter }
#@cli : Apply rodilius (fractalius-like) filter on selected images.
#@cli : Default values: 'amplitude=10', 'thickness=10', 'sharpness=400', 'nb_orientations=7', 'offset=0' and 'color_mode=1'.
#@cli : $ image.jpg rodilius 12,10,300,10 normalize_local 10,6
#@cli : $ image.jpg normalize_local 10,16 rodilius 10,4,400,16 smooth 60,0,1,1,4 normalize_local 10,16
rodilius : check "${1=10}>=0 && $1<=200 && ${2=10}>=0 && $2<=100 && ${3=400}>=0 && ${4=7}>0" skip ${5=0},${6=1}
e[^-1] "Apply rodilius filter on image$? with amplitude $1, thickness $2, sharpness $3, $4 orientations, offset $5 and "\
${arg\ 1+!$6,brighter,darker}" color mode."
v - repeat $! l[$>] split_opacity rv
if {!$6} negate. fi
+f. 0 nm. {-2,n}
repeat {round($4)}
angle={$5+$>*180/round($4)}
+blur_linear.. $1%,{$1*$2/100}%,$angle,1 b. 0.7 sharpen. $3 max[-2,-1]
done rm..
if {!$6} negate. fi
rv a c endl done v +
#@cli stained_glass : _edges[%]>=0, shading>=0, is_thin_separators={ 0 | 1 }
#@cli : Generate stained glass from selected images.
#@cli : Default values: 'edges=40%', 'shading=0.2' and 'is_precise=0'.
#@cli : $ image.jpg stained_glass 20%,0.1
stained_glass : check "${1=40%}>=0 && ${2=0.2}>=0" skip ${3=0}
e[^-1] "Apply stained glass effect on image$?, with edges $1, shading $2 and thin-separators "${arg\ 1+!$3,enabled,disabled}"."
v - repeat $! l[$>]
im={im-1} - $im
+gradient_norm >=. $1 *.. .
distance. 1 sharpen. 1e10 !=. 0
if $3 skeleton. 0 fi
distance. 1 watershed.. . +.. $im
n. 0,1  ^. $2 *
endl done v +
#@cli stars : _density[%]>=0,_depth>=0,_size>0,_nb_branches>=1,0<=_thickness<=1,_smoothness[%]>=0,_R,_G,_B,_opacity
#@cli : Add random stars to selected images.
#@cli : Default values: 'density=10%', 'depth=1', 'size=32', 'nb_branches=5', 'thickness=0.38', 'smoothness=0.5', 'R=G=B=200' and 'opacity=1'.
#@cli : $ image.jpg stars ,
stars : check "${1=10%}>=0 && ${2=1}>=0 && ${3=32}>0 && ${4=5}>=1 && ${5=0.38}>=0 && $5<=1 && ${6=0.5}>=0" skip ${7=200},${8=$7},${9=$8},${10=1}
e[^-1] "Add $1 random stars to image$?, with depth $2, size $3, $4 branches, thickness $5, smoothness $6, color ($7,$8,$9) and opacity $10."
if {!$1} return fi
v -
star3d $4,$5 col3d. 255 *3d. $3
l. repeat 4 {round(2*$3)},{round(2*$3)} j3d. [0],50%,50%,0,1,2,0,0 r3d[0] 0,0,1,-90 done rm[0] endl
autocrop[-4--1] 0 r2dy[-4--1] $3 b[-4--1] $6,0 r[-4--1] 100%,100%,1,4
repeat 4 sh[{-1-$>}] 0,2 fc. $7,$8,$9 rm. done
repeat {$!-1} [-4--1] l[$>,-4--1]
N={round(if(${is_percent\ $1},w*h*$1,$1)/4,1,1)}
repeat 4
2,$N rand. -1,1 1,$N rand. 0,1 a[-2,-1] x
i.. ({'CImg3d'}) +.. 0.5 i.. ($N;$N)
(1,0;1,{$N-1}) r. 2,$N,1,1,3 round. 4,$N,1,1,1 y[-5,-3--1] a[-5--1] y
rv[-2,-1] sprites3d.. .,1 rm. *3d. {0.75*{0,w}},{0.75*{0,h}},{1000*$2}
j3d[0] .,50%,50%,0,$10,0,0,0 rm.
done
endl done
rm[-4--1] v +
#@cli sketchbw : _nb_angles>0,_start_angle,_angle_range>=0,_length>=0,_threshold>=0,_opacity,_bgfactor>=0,_density>0,_sharpness>=0,_anisotropy>=0,_smoothness>=0,_coherence>=0,_is_boost={ 0 | 1 },_is_curved={ 0 | 1 }
#@cli : Apply sketch effect to selected images.
#@cli : Default values: 'nb_angles=2', 'start_angle=45', 'angle_range=180', 'length=30', 'threshold=3', 'opacity=0.03',
#@cli : 'bgfactor=0', 'density=0.6', 'sharpness=0.1', 'anisotropy=0.6', 'smoothness=0.25', 'coherence=1', 'is_boost=0' and 'is_curved=1'.
#@cli : $ image.jpg +sketchbw 1 reverse blur[-1] 3 blend[-2,-1] overlay
sketchbw :
check "${1=2}>0 && ${3=180}>=0 && ${4=30}>=0 && ${5=3}>=0 && ${7=0}>=0 && ${8=0.6}>0 && ${9=0.1}>=0 && ${10=0.6}>=0 && ${11=0.25}>=0 && ${12=1}>=0"
skip ${2=45},${6=0.03},${13=0},${14=0}
e[^-1] "Apply B&W sketch effect on image$?."
nb_angles,start_angle,angle_range,length,threshold,opacity,bgfactor,density,sharpness,anisotropy,smoothness,coherence,is_boost,is_curved=${1-14}
length={max($length,1)}
v - repeat $! l[$>]
{0,[w,h,1,1,0]}
+gradient_norm[0] sqrt.
diffusiontensors[0] $sharpness,$anisotropy,$smoothness,$coherence
a[0,-1] c
1,{$density*wh/sqrt($length)},1,2,round(u([w#0,h#0]-1))
repeat $nb_angles
[0],[0],1,2,"
const angle = ("$start_angle" + "$>"*"$angle_range"/"$nb_angles")*pi/180;
const ca = cos(angle);
const sa = sin(angle);
T = I(#0);
U = [ T[0]*ca + T[1]*sa, T[1]*ca + T[2]*sa ];
if ("$is_boost",U/=(1e-8 + norm(U)));
U"
if $is_curved
f[2] "*
oub = ovb = ouf = ovf = 0;
oixb = xb = xf = i0;
oiyb = yb = yf = i1;
oixf = oiyf = -1;
op = "$opacity" * (i(#0,xf,yf,0,3)<"$threshold"?"$bgfactor":1);
omop = 1 - op;
if (op>0, for (dl = 0, dl<"$length", ++dl,
ixf = round(xf);
iyf = round(yf);
if (ixf!=oixf || iyf!=oiyf, (i(#1,ixf,iyf)*=omop)+=op; oixf = ixf; oiyf = iyf);
uf = i(#-1,xf,yf,0,0,1,1);
vf = i(#-1,xf,yf,0,1,1,1);
if (ouf*uf + ovf*vf<0, uf*=-1; vf*=-1);
xf+=uf;
yf+=vf;
ouf = uf;
ovf = vf;
ub = i(#-1,xb,yb,0,0,1,1);
vb = i(#-1,xb,yb,0,1,1,1);
if (oub*ub + ovb*vb<0, ub*=-1; vb*=-1);
xb-=ub;
yb-=vb;
oub = ub;
ovb = vb;
ixb = round(xb);
iyb = round(yb);
if (ixb!=oixb || iyb!=oiyb, (i(#1,ixb,iyb)*=omop)+=op; oixb = ixb; oiyb = iyb);
));
I"
else
f[2] "*
const l = "$length";
x = i0;
y = i1;
u = i(#-1,x,y,0,0);
v = i(#-1,x,y,0,1);
op = "$opacity" * (i(#0,x,y,0,3)<"$threshold"?"$bgfactor":1);
omop = 1 - op;
polygon(#1,2,x - l*u,y - l*v,x + l*u,y + l*v,op,1);
I"
fi
rm.
done
k.. * -1 n 0,255
endl done v +
#@cli sponge : _size>0
#@cli : Apply sponge effect on selected images.
#@cli : Default value: 'size=13'.
#@cli : $ image.jpg +sponge ,
sponge : skip ${1=13}
e[^-1] "Apply sponge filter on image$?, with brush size $1."
v - repeat $! l[$>]
100%,100%,1,1 noise. 20,2 ==. 1 r. .. n. 0,1 *[-1,-2]
_circle $1 dilate.. . rm.
endl done v +
_circle :
if {$1%2==0} 2,2 else 1 fi
+. 1 r. $1,$1,1,1,0,0,0.5,0.5 distance. 1 n. 0,1 sqrt. c. 0.85,0.86 *. -1 n. 0,1
#@cli stencil : _radius[%]>=0,_smoothness>=0,_iterations>=0
#@cli : Apply stencil filter on selected images.
#@cli : Default values: 'radius=3', 'smoothness=1' and 'iterations=8'.
#@cli : $ image.jpg stencil 1,10,3
stencil : check "${1=3}>=0 && ${2=1}>=0 && ${3=8}>=0"
e[^-1] "Apply stencil filter on image$?, with radius $1, smoothness $2 and $3 iterations."
v - n 0,1 repeat $3 b $1 unsharp {$1+$2},1000 c 0,255 done v +
#@cli stencilbw : _edges>=0,_smoothness>=0
#@cli : Apply B&W stencil effect on selected images.
#@cli : Default values: 'edges=15' and 'smoothness=10'.
#@cli : $ image.jpg +stencilbw 40,4
stencilbw : skip ${1=15},${2=10}
e[^-1] "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
v - repeat $! l[$>] split_opacity luminance[0] n[0] 0,255
+edges[0] $1 quantize[0] 3,0,1 b[0] $2
sharpen[0] 1000000 n[0] 0,1 *[0,-1] n[0] 0,255
a c endl done v +
#@cli tetris : _scale>0
#@cli : Apply tetris effect on selected images.
#@cli : Default value: 'scale=10'.
#@cli : $ image.jpg +tetris 10
tetris : skip ${1=10}
e[^-1] "Apply tetris effect on image$?, with scale $1."
v - repeat $! l[$>]
wh={w},{h},1,{s} r $1%,$1%,$1%,100%,2 n 0,255 quantize 10,1,0 r $wh b 2 sharpen 300,1
endl done v +
#@cli warhol : _M>0,_N>0,_smoothness>=0,_color>=0
#@cli : Create MxN Andy Warhol-like artwork from selected images.
#@cli : Default values: 'M=3', 'N=M', 'smoothness=2' and 'color=20'.
#@cli : $ image.jpg warhol 3,3,3,40
warhol : skip ${1=3},${2=$1},${3=2},${4=20}
e[^-1] "Create $1x$2 Andy Warhol-like artwork from image$?."
v - r0={100/max($1,$2)}
repeat $! l[$>]
norm b $3 r $r0%,$r0%,1,100%,2 quantize 6 n 0,5 round 1
repeat $1 repeat $2
(0,1,2,3,4,5) n. 32,224 6,1,1,2,128 noise. $4,0 c. 0,255 a[-2,-1] c ycbcr2rgb. +map[0] . rm..
done done append_tiles[^0] $1,$2 nm[1] {0,n} rm[0]
endl done v +
#@cli weave : _density>=0,0<=_thickness<=100,0<=_shadow<=100,_shading>=0,_fibers_amplitude>=0,_fibers_smoothness>=0,_angle,-1<=_x_curvature<=1,-1<=_y_curvature<=1
#@cli : Apply weave effect to the selected images.
#@cli : 'angle' can be { 0=0 deg. | 1=22.5 deg. | 2=45 deg. | 3=67.5 deg. }.
#@cli : Default values: 'density=6', 'thickness=65', 'shadow=40', 'shading=0.5', 'fibers_amplitude=0', 'fibers_smoothness=0', 'angle=0' and 'curvature_x=curvature_y=0'
#@cli : $ image.jpg weave ,
weave : check "${1=6}>=0 && ${2=65}>=0 && $2<=100 && ${3=40}>=0 && $3<=100 && ${4=0.5}>=0"
check "${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && $7<=3 && ${8=0}>=-1 && $8<=1 && ${9=0}>=-1 && $9<=1"
e[^-1] "Apply weave effect to image$?, with $1 strips, thickness $2, shadow $3, shading $4, "\
"fibers amplitude $5 and fibers smoothness $6, angle "{$7*22.5}" deg. and curvatures ($8,$9)."
v - repeat $! l[$>] split_opacity l[0]
w={round(max(w,h)/$1,1,1)} h=$w s={(100-$3)*255%} p={max(0.01,$4)}
1,$h =. 1,0,50% distance. 1 ^. $p c. 50%,100% r. {max(1,round($2*$w%))},100%
$w,1 =. 1,50% distance. 1 ^. $p c. 50%,100% *. -1 r. 100%,{max(1,round($2*$h%))}
+*. -1 +*... -1 n[-4,-2] 0,$s n[-3,-1] $s,255
{w},1 1,... rand[-2,-1] 0,1 b[-2,-1] $6% n[-2,-1] -$5,$5 r. [-4] +[-5] . +[-4,-1] +[-5] . +[-2,-1]
+f... 255 a[-4,-1] c +f. 255 a[-2,-1] c
amp_x={$8*($w-w)/2} amp_y={$9*($w-w)/2}
r[-4--1] $w,$h,1,100%,0,0,0.5,0.5
f[-4] 'i(x+$amp_x*sin(y/h*pi),y,0,c,1,2)' f. 'i(x-$amp_x*sin(y/h*pi),y,0,c,1,2)'
f... 'i(x,y+$amp_y*sin(x/w*pi),0,c,1,2)' f.. 'i(x,y-$amp_y*sin(x/w*pi),0,c,1,2)'
blend[-4,-3] alpha blend[-2,-1] alpha c[-2,-1] 0,255
/[-2,-1] 255 . ... a[-4,-2] x a[-2,-1] x a[-2,-1] y rotate_tileable. {$7*22.5}
r. ..,..,1,1,0,2 *[-2,-1]
endl a c endl done v +
#@cli whirls : _texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0
#@cli : Add random whirl texture to selected images.
#@cli : Default values: 'texture=3', 'smoothness=6', 'darkness=0.5' and 'lightness=1.8'.
#@cli : $ image.jpg +whirls ,
whirls : skip ${1=3},${2=6},${3=0.5},${4=1.8}
e[^-1] "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
v - repeat $! l[$>]
100%,100% noise. 0.3,2 ==. 1 repeat $1 b. $2 +. 0.1 gradient_norm. ^. 0.2 done
n. $3,$4 r. .. * c 0,255
endl done v +
#@cli :: Warpings
#@cli deform : _amplitude>=0,_interpolation
#@cli : Apply random smooth deformation on selected images.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
deform : skip ${1=10},${2=1}
e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
v - repeat $! l[$>]
2%,2%,1,2 noise. $1 r. ..,..,1,2,5 warp.. .,1,$2,1 rm.
endl done v +
#@cli euclidean2polar : _center_x[%],_center_y[%],_stretch_factor>0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply euclidean to polar transform on selected images.
#@cli : Default values: 'center_x=center_y=50%', 'stretch_factor=1' and 'boundary_conditions=1'.
#@cli : $ image.jpg +euclidean2polar ,
euclidean2polar : skip ${1=50%},${2=50%} check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=3"
e[^-1] "Apply euclidean to polar transform on image$?, with center point ($1,$2), stretch factor $3 and "${"arg 1+$4,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! l[$>]
cx={if(${is_percent\ $1},$1*(w-1),$1)}
cy={if(${is_percent\ $2},$2*(h-1),$2)}
R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
f 'r=$R*(x/(w-1))^$3;a=y*2*pi/(h-1);i($cx+r*cos(a),$cy+r*sin(a),z,c,1,$4)'
endl done v +
#@cli equirectangular2nadirzenith
#@cli : Transform selected equirectangular images to nadir/zenith rectilinear projections.
equirectangular2nadirzenith :
e[^-1] "Transform equirectangular image$? to nadir/zenith rectilinear projections."
v - repeat $! l[$>]
100%,100%,1,2
sh. 100%
f. "
X = 2*x/(w-1) - 1;
Y = y/(h-1) - 0.5;
if (X<0,
sinphi1 = 1; X+=0.5,
sinphi1 = -1; X-=0.5
);
rr = sqrt(X*X + Y*Y);
cc = atan(2*rr);
phi = rr==0?0:asin(cos(cc)*sinphi1);
X = atan2(X,-Y*sinphi1)/pi;
Y = phi/pi;
(++X)*=0.5*w;
(Y+=0.5)*=h;
i(#-2) = X; Y;"
warp[0] [1],0,0,1 k...
endl done v +
#@cli fisheye : _center_x,_center_y,0<=_radius<=100,_amplitude>=0
#@cli : Apply fish-eye deformation on selected images.
#@cli : Default values: 'x=y=50', 'radius=50' and 'amplitude=1.2'.
#@cli : $ image.jpg +fisheye ,
fisheye : skip ${1=50},${2=50},${3=50},${4=1.2}
e[^-1] "Apply Fish-eye effect on image$?, centered at ($1%,$2%) with radius $3% and amplitude $4."
if {$4==0} return fi
v - repeat $! l[$>]
100%,100%,1,1 =. 1,$1%,$2% distance. 1 c. 0,$3% *. -1 n. 0,1 ^. {1/$4}
i.. ({-$1/100},{1-$1/100};{-$1/100},{1-$1/100}^{-$2/100},{-$2/100};{1-$2/100},{1-$2/100}) r.. .,.,1,2,3
n. 0,{max(w,h)} *[-2,-1]
warp.. .,1,1,1 rm.
endl done v +
#@cli flower : _amplitude,_frequency,_offset_r[%],_angle,_center_x[%],_center_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror}
#@cli : Apply flower deformation on selected images.
#@cli : Default values: 'amplitude=30', 'frequency=6', 'offset_r=0', 'angle=0', 'center_x=center_y=50%' and 'boundary_conditions=3'.
#@cli : $ image.jpg flower ,
flower : skip ${1=30},${2=6},${3=0},${4=0},${5=50%},${6=50%},${7=3}
e[^-1] "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 deg. and center point ($1,$2)."
v - if ${"is_percent $3"}
transform_polar "r + (R*$3) + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
else
transform_polar "r + $3 + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
fi v +
#@cli kaleidoscope : _center_x[%],_center_y[%],_radius,_angle,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Create kaleidoscope effect from selected images.
#@cli : Default values: 'center_x=center_y=50%', 'radius=100', 'angle=30' and 'boundary_conditions=3'.
#@cli : $ image.jpg +kaleidoscope ,
kaleidoscope : skip ${1=50%},${2=50%},${3=100},${4=30},${5=3}
e[^-1] "Create kaleidoscope effect from image$?, with center point ($1,$2), radius $3, angle $4 deg."
v - euclidean2polar $1,$2,1,$5 repeat $! l[$>]
+columns 0,$3% rows. 0,$4% r. ..,0,2 nm[1] {0,n} rm[0]
endl done polar2euclidean $1,$2,1,$5 v +
#@cli map_sphere : _width>0,_height>0,_radius,_dilation>0,_fading>=0,_fading_power>=0
#@cli : Map selected images on a sphere.
#@cli : Default values: 'width=height=512', 'radius=100', 'dilation=0.5', 'fading=0' and 'fading_power=0.5'.
#@cli : $ image.jpg map_sphere ,
map_sphere : check "${1=512}>0 && ${2=512}>0 && ${5=0}>=0 && ${6=0.5}>=0" skip ${3=100},${4=0.5}
e[^-1] "Map image$? on spheres in $1x$2 images, with radius $3, dilation $4 and fading $5."
v - r2={($3*min($1,$2)/200)^2}
repeat $! l[$>]
i.. 100%,1,1,100%,0 nm[0] {1,n} a y
({-$1/2},{$1/2}) ({-$2/2};{$2/2}) r[-2,-1] $1,$2,1,1,3 atan2. .. rm..
$1,$2 =. 1,50%,50% distance. 1,3 /. $r2 sqrt. c. 0,1
asin.
+.. {pi} *.. {({-3,w}-1)/(2*pi)}
*. {2/pi} ^. $4 *. {{-3,h}-1} *. -1 +. {{-3,h}-1}
if $5 +>=. 1 distance. 1 c. 0,$5% n. 0,1 ^. $6 c.. 1,100% -[-2,-1] fi
r[-1,-2] 100%,100%,{-3,d}
+f. z a[-3--1] c
warp.. .,0,1,1 rm.
endl done v +
#@cli nadirzenith2equirectangular
#@cli : Transform selected nadir/zenith rectilinear projections to equirectangular images.
nadirzenith2equirectangular :
e[^-1] "Transform nadir/zenith rectilinear projection$? to equirectangular images."
v - repeat $! l[$>]
100%,100%,1,2
sh. 100%
f. "
X = 2*x/(w-1) - 1;
Y = y/(h-1) - 0.5;
output = 1;
if (Y>0.125,
sinphi1 = 1; xc = -0.5,
if (Y<-0.125,
sinphi1 = -1; xc = 0.5,
output = 0
));
cosc = sinphi1*sin(Y*pi);
xx = cos(Y*pi)*sin(X*pi)/cosc;
yy = -sinphi1*cos(Y*pi)*cos(X*pi)/cosc;
if (abs(xx)>1, output=0);
(xx*=0.5)+=xc;
yy*=0.5;
if (!output, xx = yy = -1);
(++xx)*=0.5*w;
(yy+=0.5)*=h;
i(#-2) = xx; yy;"
to_a[0] warp[0] [1],0,0,0 k...
endl done v +
#@cli polar2euclidean : _center_x[%],_center_y[%],_stretch_factor>0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply euclidean to polar transform on selected images.
#@cli : Default values: 'center_x=center_y=50%', 'stretch_factor=1' and 'boundary_conditions=1'.
#@cli : $ image.jpg +euclidean2polar ,
polar2euclidean : skip ${1=50%},${2=50%} check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=3"
e[^-1] "Apply polar to euclidean transform on image$?, with center point ($1,$2), stretch factor $3 and "${"arg 1+$4,dirichlet,neumann,periodic,mirror"}" boundary conditions."
v - repeat $! l[$>]
cx={if(${is_percent\ $1},$1*(w-1),$1)}
cy={if(${is_percent\ $2},$2*(h-1),$2)}
R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
f 'X=sqrt((x-$cx)^2+(y-$cy)^2);tmp=atan2((y-$cy),(x-$cx));Y=if(tmp<0,tmp+2*pi,tmp);i((X/$R)^(1/$3)*(w-1),Y*(h-1)/(2*pi),z,c,1,$4)'
endl done v +
#@cli raindrops : _amplitude,_density>=0,_wavelength>=0,_merging_steps>=0
#@cli : Apply raindrops deformation on selected images.
#@cli : Default values: 'amplitude=80','density=0.1', 'wavelength=1' and 'merging_steps=0'.
#@cli : $ image.jpg +raindrops ,
raindrops : check "${2=0.1}>=0 && ${3=1}>=0 && isint(${4=0}) && $4>=0" skip ${1=80}
e[^-1] "Apply raindrops deformation on image$?, with amplitude $1, density $2, wavelength $3 and $4 merging steps."
v - repeat $! l[$>]
100%,100% noise. $2,2 ==. 1 distance. 1 f. 'cos(i)/(1+i/(1e-8+$3))'
if $4
i.. (0,1,0;1,0,1;0,1,0) /.. 2 .
repeat $4 +convolve. ...,1 -. ... rm... done rm[-3,-2]
fi
g. a[-2,-1] c *. {$1/(1e-5+max(abs(im),abs(iM)))}
warp.. .,1 rm.
endl done v +
#@cli ripple : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@cli : Apply ripple deformation on selected images.
#@cli : Default values: 'amplitude=10', 'bandwidth=10', 'shape=2', 'angle=0' and 'offset=0'.
#@cli : $ image.jpg +ripple ,
ripple : skip ${1=10},${2=20},${3=2},${4=0},${5=0}
e[^-1] "Apply ripple deformation on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
v -
theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
repeat $! l[$>]
100%,100%,1,1,"x" -. {w/2} 100%,100%,1,1,'y'
-. {h/2-$5} *.. $S *. $C +[-2,-1]
_ripple$3. $1,$2
+*. {-$S} *.. $C a[-2,-1] c
warp.. .,1 rm.
endl done v +
_ripple0 : f {$1/2}*"(1-2*(i%"{2*$2}"<$2))"
_ripple1 : f "I=(i%$2)/$2;$1*(2*if(I<0.5,I,1-I)-0.5)"
_ripple2 : f {-$1/2}*"cos(i*"{2*pi/$2}")"
_ripple3 : f {-$1/2}*"abs(cos(i*"{2*pi/$2}"))"
_ripple4 : skip $* n 0,{h-1} 1,{h} rand. {-$1/2},{$1/2} m={im} M={iM} b. {$2/10} n. $m,$M map.. . rm.
#@cli rotoidoscope : _center_x[%],_center_y[%],_tiles>0,_smoothness[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Create rotational kaleidoscope effect from selected images.
#@cli : Default values: 'center_x=center_y=50%', 'tiles=10', 'smoothness=1' and 'boundary_conditions=3'.
#@cli : $ image.jpg +rotoidoscope ,
rotoidoscope : skip ${1=50%},${2=50%},${5=1} check "${3=10}>0 && ${4=3}>=0"
e[^-1] "Create rotational kaleidoscope effect from image$?, with center point ($1,$2), $3 tiles and smoothness $4."
v - repeat $! l[$>]
repeat $3 +rotate[0] {360/$3},1,$5,$1,$2 blend_edges $4 done
endl done v +
#@cli spherize : _radius[%]>=0,_strength,_smoothness[%]>=0,_center_x[%],_center_y[%],_ratio_x/y>0,_angle,_interpolation
#@cli : Apply spherize effect on selected images.
#@cli : Default values: 'radius=50%', 'strength=1', 'smoothness=0', 'center_x=center_y=50%', 'ratio_x/y=1', 'angle=0' and 'interpolation=1'.
#@cli : $ image.jpg grid 5%,5%,0,0,0.6,255 spherize ,
spherize : check "${1=50%}>=0 && ${3=0}>=0 && ${6=1}>0 && isint(${8=1}) && $8>=0 && $8<=2" skip "${2=1},${4=50%},${5=50%},${7=0}"
e[^-1] "Apply spherize effect on image$?, with radius $1, strength $2, smoothness $3, center ($4,$5), x/y-ratio $6, angle $7 and "${"arg 1+$8,nearest-neighbor,linear,cubic"}" interpolation."
if {!$1||!$2} return fi
v - repeat $! l[$>]
rmax={${"is_percent $1"}?0.5*sqrt((w-1)^2+(h-1)^2)*$1:$1}
centerx={${"is_percent $4"}?(w-1)*$4:$4}
centery={${"is_percent $5"}?(h-1)*$5:$5}
strength={$2>0?$2:1-exp($2/5)}
100%,100%,1,2,"
begin(
center = [ "$centerx","$centery" ];
wh1 = [ w,h ] - 1;
m2wh1 = 0.5*max(wh1);
rmax = "$rmax"/m2wh1;
const f = 1/"$strength";
const ratio = $6;
rotf = rot($7);
rotb = rot(-$7);
);
xy = ([x,y] - center)/m2wh1;
xy = rotf*xy;
ratio>=1?(xy[1]*=ratio):(xy[0]/=ratio);
r = norm2(xy);
z = r<rmax?sign($2)*sqrt(rmax^2 - r^2):0;
ratio>=1?(xy[1]/=ratio):(xy[0]*=ratio);
xy = rotb*xy;
xy = center + f*xy/(f + z)*m2wh1"
b. $3
warp.. .,0,$8,1 rm.
endl done v +
#@cli symmetrize : _x[%],_y[%],_angle,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror },_is_antisymmetry={ 0 | 1 },_swap_sides={ 0 | 1 }
#@cli : Symmetrize selected images regarding specified axis.
#@cli : Default values: 'x=y=50%', 'angle=90', 'boundary_conditions=3', 'is_antisymmetry=0' and 'swap_sides=0'.
#@cli : $ image.jpg +symmetrize 50%,50%,45 +symmetrize[-1] 50%,50%,-45
symmetrize : skip ${1=50%},${2=50%},${3=90},${4=3},${5=0},${6=0}
e[^-1] "Symmetrize image$?, regarding axis ($1,$2,$3 deg.)."
v -
theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
if $6 symmetry_cond=A<0 else symmetry_cond=A>0 fi
repeat $! l[$>]
x0={if(${is_percent\ $1},w*$1,$1)}
y0={if(${is_percent\ $2},h*$2,$2)}
if $5 f 'A=($y0-y)*$u-($x0-x)*$v;X=x+2*($x0-x);Y=y+2*($y0-y);if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
else f 'A=($y0-y)*$u-($x0-x)*$v;X=x-2*$v*A;Y=y+2*$u*A;if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
fi
endl done
v +
#@cli transform_polar : "expr_radius",_"expr_angle",_center_x[%],_center_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Apply user-defined transform on polar representation of selected images.
#@cli : Default values: 'expr_radius=R-r', 'expr_rangle=a', 'center_x=center_y=50%' and 'boundary_conditions=1'.
#@cli : $ image.jpg +transform_polar[0] R*(r/R)^2,a +transform_polar[0] r,2*a
transform_polar : skip "${1=R-r}","${2=a}",${3=50%},${4=50%},${5=1}
e[^-1] "Apply custom polar transform with 'new_r = $1', 'new_a = $2', center point ($3%,$4%)."
v - repeat $! l[$>]
cx={if(${is_percent\ $3},$3*(w-1),$3)}
cy={if(${is_percent\ $4},$4*(h-1),$4)}
R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
f "R ="$R";
r = sqrt((x-"$cx")^2 + (y-"$cy")^2);
a = atan2(y-"$cy",x-"$cx");
nr = ($1);
na = ($2);
i("$cx" + nr*cos(na), "$cy" + nr*sin(na), z, c,1,$5)"
endl done v +
#@cli twirl : _amplitude,_center_x[%],_center_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply twirl deformation on selected images.
#@cli : Default values: 'amplitude=1', 'center_x=center_y=50%' and 'boundary_conditions=3'.
#@cli : $ image.jpg twirl 0.6
twirl : skip ${1=1},${2=50%},${3=50%},${4=3}
e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center point at ($2%,$3%)."
v - euclidean2polar $2,$3,1,$4 repeat $!
[$>],[$>],1,1,$1*x channels. -1,0 warp[$>] .,1,1,2 rm.
done polar2euclidean $2,$3,1,1 v +
#@cli warp_perspective : _x-angle,_y-angle,_zoom>0,_x-center,_y-center,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Warp selected images with perspective deformation.
#@cli : Default values: 'x-angle=1.5', 'y-angle=0', 'zoom=1', 'x-center=y-center=50' and 'boundary_conditions=2'.
#@cli : $ image.jpg warp_perspective ,
warp_perspective : skip ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
e[^-1] "Apply perspective warp on image$?, with angles ($1 deg.,$2 deg.), zoom $3 and offsets ($4,$5)."
v - repeat $! l[$>]
(0,100) -. $4 /. 100 (0;100) -. $5 /. 100 r[-2,-1] ...,...,...,1,3
+*.. $2 +*.. $1 +[-2,-1] +. $3 /... . /[-2,-1]
*.. 100 +.. $4 /.. 100 *.. {-3,w}
*. 100 +. $5 /. 100 *. {-3,h}
a[-2,-1] c warp.. .,0,1,$6 rm.
endl done v +
#@cli water : _amplitude,_smoothness>=0,_angle
#@cli : Apply water deformation on selected images.
#@cli : Default values: 'amplitude=30', 'smoothness=1.5' and 'angle=45'.
#@cli : $ image.jpg water ,
water : check ${2=1.5}>=0 skip ${1=30},${3=1},${4=45}
e[^-1] "Apply water deformation on image$?, with amplitude $1, smoothness $2 and angle $3."
v - repeat $! l[$>]
25%,25%,25%,1 noise. $1 g. xy *.. {-sin($3*pi/180)} *. {cos($3*pi/180)} +[-2,-1] b. $2 *. 2 r. ..,..,1,2,3 warp.. .,1 rm.
endl done v +
#@cli wave : _amplitude>=0,_frequency>=0,_center_x,_center_y
#@cli : Apply wave deformation on selected images.
#@cli : Default values: 'amplitude=4', 'frequency=0.4' and 'center_x=center_y=50'.
#@cli : $ image.jpg wave ,
wave : skip ${1=4},${2=0.4},${3=50},${4=50}
e[^-1] "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center point at ($3%,$4%)."
v - repeat $! l[$>]
100%,100% =. 1,$3%,$4% distance. 1
*. $2 +sin. cos.. a[-2,-1] c *. $1
warp.. .,1 rm.
endl done v +
#@cli wind : _amplitude>=0,_angle,0<=_attenuation<=1,_threshold
#@cli : Apply wind effect on selected images.
#@cli : Default values: 'amplitude=20', 'angle=0', 'attenuation=0.7' and 'threshold=20'.
#@cli : $ image.jpg +wind ,
wind : check "isint(${1=20}) && $1>=0 && ${3=0.7}>=0 && $3<=1" skip "${2=0},${4=20}"
e[^-1] "Apply wind effect on image$?, with amplitude $1, angle "{round($2/45)*45}" deg., attenuation $3 and threshold $4."
if {!$1} return fi
v -
dxdy=${-_wind{round($2/45)%8}}
fact={(1-$3)^(1/$1)}
repeat $! l[$>]
+gradient_norm >=. $4%
r. 100%,100%,1,.. *. ..
repeat $1
shift. $dxdy,0,0,0 max.. . *. $fact
remove_pixels. {100/$1}%
done rm.
endl done v +
_wind0 : u 1,0
_wind1 : u 1,1
_wind2 : u 0,1
_wind3 : u -1,1
_wind4 : u -1,0
_wind5 : u -1,-1
_wind6 : u 0,-1
_wind7 : u 1,-1
#@cli zoom : _factor,_cx,_cy,_cz,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply zoom factor to selected images.
#@cli : Default values: 'factor=1', 'cx=cy=cz=0.5' and 'boundary_conditions=0'.
#@cli : $ image.jpg +zoom[0] 0.6 +zoom[0] 1.5
zoom : skip ${1=2},${2=0.5},${3=0.5},${4=0.5},${5=0}
e[^-1] "Apply zoom effect on image$?, with factor $1 and center ($2,$3)."
v - repeat $! l[$>]
if {d==1}
({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
({({-2,h}-1)*$3*(1-1/$1)};{({-2,h}-1)*($3+(1-$3)/$1)})
r[-2--1] ...,...,1,1,3 a[-2--1] c warp.. .,0,1,$5
else
({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
({({-2,h}-1)*$3*(1-1/$1)};{({-2,h}-1)*($3+(1-$3)/$1)})
({({-3,d}-1)*$4*(1-1/$1)}/{({-3,d}-1)*($4+(1-$4)/$1)})
r[-3--1] [-4],[-4],[-4],1,3 a[-3--1] c warp.. .,0,1,$5
fi
rm.
endl done v +
#@cli :: Degradations
#@cli cracks : 0<=_density<=100,_is_relief={ 0 | 1 },_opacity,_color1,...
#@cli : Draw random cracks on selected images with specified color.
#@cli : Default values: 'density=25', 'is_relief=0', 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg +cracks ,
cracks : check "${1=25}>=0" skip ${2=0},${3=1},${4=0}
e[^-1] "Add random cracks to image$?, with density $1, opacity $3 and color (${4--1})."
v - repeat $! l[$>] cut={[im,iM]}
100%,100%,1,2,'u<0.25*($1%)^4?[u,1]:[0,0]'
s. c distance. 1 *. -1 watershed.. . rm.
+dilate. 3 -[-2,-1] !=. 0 thinning. 1
if $2
f. "i?i:j(1)?2:j(-1)?0.5:i" n. 0,1
+fc.. ${4--1} *. .. !=.. 0 j... .,0,0,0,0,$3,..
else
+fc.. ${4--1} j... .,0,0,0,0,$3,..
fi
k[0]
endl done v +
#@cli light_patch : _density>0,_darkness>=0,_lightness>=0
#@cli : Add light patches to selected images.
#@cli : Default values: 'density=10', 'darkness=0.9' and 'lightness=1.7'.
#@cli : $ image.jpg +light_patch 20,0.9,4
light_patch : skip ${1=10},${2=0.9},${3=1.7}
e[^-1] "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
v - repeat $! l[$>]
n 0,255 $1,$1 noise. 40 r. ..,5 c. 0,255
n. $2,$3 * c 0,255
endl done v +
#@cli noise_hurl : _amplitude>=0
#@cli : Add hurl noise to selected images.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +noise_hurl ,
noise_hurl : skip ${1=10}
e[^-1] "Add hurl noise to image$?, with amplitude $1%."
v - repeat $! l[$>]
+f 0 noise. 10 n. {-2,[im,iM]} 100%,100%,1,1,-2
noise. $1,2 >=. 0 r. ..
*.. . *. -1 +. 1 *[-3,-1] +
endl done v +
#@cli pixelize : _scale_x>0,_scale_y>0,_scale_z>0
#@cli : Pixelize selected images with specified scales.
#@cli : Default values: 'scale_x=20' and 'scale_y=scale_z=scale_x'.
#@cli : $ image.jpg +pixelize ,
pixelize : skip ${1=20},${2=$1},${3=$1}
e[^-1] "Pixelize image$? with scales ($1%,$2%,$3%)."
v - repeat $! l[$>] whd={w},{h},{d} r $1%,$2%,$3%,100%,2 r $whd endl done v +
#@cli scanlines : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@cli : Apply ripple deformation on selected images.
#@cli : Default values: 'amplitude=60', 'bandwidth=2', 'shape=0', 'angle=0' and 'offset=0'.
#@cli : $ image.jpg +scanlines ,
scanlines : skip ${1=60},${2=2},${3=0},${4=0},${5=0}
e[^-1] "Apply scanlines effect on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
v -
theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
repeat $! l[$>]
100%,100%,1,1,"x" -. {w/2} 100%,100%,1,1,'y'
-. {h/2-$5} *.. $S *. $C +[-2,-1]
_ripple$3. $1,$2
n. {-$1},$1
+ cut 0,255
endl done v +
#@cli shade_stripes : _frequency>=0,_direction={ 0=horizontal | 1=vertical },_darkness>=0,_lightness>=0
#@cli : Add shade stripes to selected images.
#@cli : Default values: 'frequency=5', 'direction=1', 'darkness=0.8' and 'lightness=2'.
#@cli : $ image.jpg +shade_stripes 30
shade_stripes : skip ${1=5},${2=1},${3=0.8},${4=2}
e[^-1] "Add "${arg\ 1+!$2,vertical,horizontal}" shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4."
v - n 0,255 repeat $! l[$>]
{max(1,w*($2!=0))},{max(1,h*($2==0))} noise. $1,2 ==. 1 distance. 1 r. .. n. $3,$4 * c 0,255
endl done v +
#@cli shadow_patch : _opacity>=0
#@cli : Add shadow patches to selected images.
#@cli : Default value: 'opacity=0.7'.
#@cli : $ image.jpg +shadow_patch 0.4
shadow_patch : skip ${1=0.7}
e[^-1] "Apply shadow patches to image$?, with opacity $1."
v - repeat $! l[$>]
100%,100%,1,1 shift. -2,-2 shift. 1,1
plasma. 3,0.3,8 abs. b. 1 c. 3%,15% r. ..
n. $1,1 *
endl done v +
#@cli spread : _dx>=0,_dy>=0,_dz>=0
#@cli : Spread pixel values of selected images randomly along x,y and z.
#@cli : Default values: 'dx=3', 'dy=dx' and 'dz=0'.
#@cli : $ image.jpg +spread 3
spread : skip ${1=3},${2=$1},${3=0}
e[^-1] "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
v - repeat $! l[$>]
100%,100%,100%,3
sh. 0 rand. {-$1},$1 rm.
sh. 1 rand. {-$2},$2 rm.
sh. 2 rand. {-$3},$3 rm.
warp.. .,1 rm.
endl done v +
#@cli stripes_y : _frequency>=0
#@cli : Add vertical stripes to selected images.
#@cli : Default value: 'frequency=10'.
#@cli : $ image.jpg +stripes_y ,
stripes_y : skip ${1=10}
e[^-1] "Add vertical stripes to image$?, with frequency $1."
v - repeat $! l[$>]
100% noise. $1,2 ==. 1 *. 255 r. ..
*. 0.15 + c 0,255
endl done v +
#@cli texturize_canvas : _amplitude>=0,_fibrousness>=0,_emboss_level>=0
#@cli : Add paint canvas texture to selected images.
#@cli : Default values: 'amplitude=20', 'fibrousness=3' and 'emboss_level=0.6'.
#@cli : $ image.jpg +texturize_canvas ,
texturize_canvas : check "${1=20}>=0 && ${2=3}>=0 && ${3=0.6}>=0 && ${4=80}"
e[^-1] "Add canvas texture to image$?, with amplitude $1, fibrousness $2 and emboss level $3."
v -
repeat $! l[$>]
{w},{h} rand. 0,255 +blur_x. $2 blur_y.. $2 +[-2,-1] g. a[-2,-1] c
+compose_channels. + orientation.. compose_channels.. + n.. $3,1 n. 0,255
sharpen. 80 *[-2,-1] n. -$1,$1 + c 0,255
endl done v +
#@cli texturize_paper
#@cli : Add paper texture to selected images.
#@cli : $ image.jpg +texturize_paper
texturize_paper :
e[^-1] "Add paper texture to image$?."
v - repeat $! l[$>]
. 30%,30% noise. 1,2 ==. 1 r. ..,..,..,1,0 ifft.
rm. shift. {round(w/2)},{round(h/2)},{round(d/2)},0,2 sharpen. 1 n. 1,1.2 r. ..
*[-2,-1] c. ..,.. rm..
endl done v +
#@cli vignette : _strength>=0,0<=_radius_min<=100,0<=_radius_max<=100
#@cli : Add vignette effect to selected images.
#@cli : Default values: 'strength=100', 'radius_min=70' and 'radius_max=90'.
#@cli : $ image.jpg vignette ,
vignette : check "${1=100}>=0 && ${2=70}>=0 && $2<=100 && ${3=90}>=0 && $3<=100"
e[^-1] "Add vignette effect to image$?, with strength $1 and size $2."
v - repeat $! l[$>]
mM={[im,iM]} d={max(w,h)}
$d,$d =. 1,50%,50% distance. 1 r. ..,2
c. $2%,$3% n. 0,$1 - c $mM
endl done v +
#@cli watermark_visible : _text,0<_opacity<1,_size>0,_angle,_mode={ 0=remove | 1=add },_smoothness>=0
#@cli : Add or remove a visible watermark on selected images (value range must be [0,255]).
#@cli : Default values: 'text=(c) G'MIC', 'opacity=0.3', 'size=53', 'angle=25', 'mode=1' and 'smoothness=0'.
#@cli : $ image.jpg watermark_visible ,0.7
watermark_visible : skip "${1=\251\ G\47MIC}" check "${2=0.3}>0 && $2<1 && ${3=53}>0 && ${6=0.5}>=0" skip ${4=25},${5=1}
e[^-1] ${arg\ 1+!$5,Add,Remove}" visible watermark '$1' on image$?, with opacity $2, size $3, angle $4 deg."
v - repeat $! l[$>]
0 t. "$1",0,0,$3,1,255 rotate. $4,0,0 b. $6 n. 0,255
r. ..,0,2 +. .. c. 0,255
if $5 *. $2 *.. {1-$2} +
else *. $2 - / {1-$2}
fi
c 0,255
endl done v +
#@cli :: Blending and Fading
#@cli blend : [layer],blending_mode,_opacity[%],_selection_is={ 0=base-layers | 1=top-layers } : blending_mode,_opacity[%]
#@cli : Blend selected G,GA,RGB or RGBA images by specified layer or blend all selected images together, using specified blending mode.
#@cli : 'blending_mode' can be { add | alpha | and | average | blue | burn | darken | difference |
#@cli : divide | dodge | edges | exclusion | freeze | grainextract | grainmerge | green | hardlight |
#@cli : hardmix | hue | interpolation | lighten | lightness | linearburn | linearlight | luminance |
#@cli : multiply | negation | or | overlay | pinlight | red | reflect | saturation | seamless | seamless_mixed | screen |
#@cli : shapeareamax | shapeareamax0 | shapeareamin | shapeareamin0 | shapeaverage | shapeaverage0 | shapemedian | shapemedian0 |
#@cli : shapemin | shapemin0 | shapemax | shapemax0 | softburn | softdodge | softlight | stamp | subtract | value | vividlight | xor }.
#@cli : 'opacity' should be in '[0,1]', or '[0,100]' if expressed with a '%'.
#@cli : Default values: 'blending_mode=alpha', 'opacity=1' and 'selection_is=0'.
#@cli : $ image.jpg +drop_shadow , resize2dy[-1] 200 rotate[-1] 20 +blend alpha display_rgba[-2]
#@cli : $ image.jpg testimage2d {w},{h} blend overlay
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex add,alpha,and,average,blue,burn,darken
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex difference,divide,dodge,exclusion,freeze,grainextract,grainmerge
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex green,hardlight,hardmix,hue,interpolation,lighten,lightness
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex linearburn,linearlight,luminance,multiply,negation,or,overlay
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex pinlight,red,reflect,saturation,screen,shapeaverage,softburn
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex softdodge,softlight,stamp,subtract,value,vividlight,xor
blend : skip ${1=alpha},${2=1},${3=1},${4=0}
v -
if ${"is_image_arg $1"}
n={narg($*)} mode=${arg\ 1+($n>=2),alpha,$2}
v + e[^-1] "Blend image$? with "${arg\ 1+$4,base,top}" layer $1, using '"$mode"' mode and opacity $3." v -
repeat $! pass$1 l[$>,-1] if $4 rv fi blend $mode,$3 endl done v + return
fi
v + e[^-1] "Blend all image$? together, using '$1' mode and opacity $2." v -
repeat {$!-1} l[0,1]
r[1] [0],[0],[0],100%,0,0,0.5,0.5
s={"s0 = s#0<3?1:3; s1 = s<3?1:3; max(s0,s1)"}
to_colormode[0] {$s+1-(s#0%2)}
to_colormode[1] {$s+1-(s%2)}
if {0,"s==2 || s==4"}
if {"s==2 || s==4"}
sh[0,1] 0,{s-2} _blend_$1[2,3] rm[2,3]
if {['"$1"']=='alpha'}
sh[0,1] 0,{{0,s}-2} sh[0,1] 100% *[2,4] *[3,4] rm[2,3]
+channels[1] 100% sh[1] 100% f[3] 255 rm[3]
j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 rm[1,2]
sh[0] 0,{s-2} sh[0] 100% +[2] 1e-10 /[1,2] rm[1] c 0,255
else
sh[1] 0,{s-2} sh[1] 100% j[0] [2],0,0,0,0,{max(0,min(1,$2))},[3],255 rm[^0]
fi
else
sh[0] 0,{{0,s}-2} rv[1,2] _blend_$1[1,2] j[1] [2],0,0,0,0,{max(0,min(1,$2))} rm[^0]
fi
else
if {"s==2 || s==4"}
sh[1] 0,{s-2} _blend_$1[0,2] rm[2]
sh[1] 100% j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 rm[^0]
else
_blend_$1 j[0] [1],0,0,0,0,{max(0,min(1,$2))} rm[1]
fi
fi
endl done v +
_blend_alpha :
_blend_normal :
_blend_and :
&[1] [0]
_blend_add :
+[1] [0] c[1] 0,255
_blend_average :
+[1] [0] /[1] 2
_blend_blue :
sh[0] 0,1 j[1] [2] rm[2]
_blend_burn :
+-[0] 255 +[1] 0.1 /[2] [1] rm[1] +[1] 1 *[1] 255 c[1] 0,255
_blend_darken :
min[1] [0]
_blend_difference :
-[1] [0] abs[1]
_blend_divide :
+[1] 0.1 ^[1] -1 *[1] [0] *[1] 255 c[1] 0,255
_blend_dodge :
-[1] 255.1 ^[1] -1 *[1] [0] *[1] -255 c[1] 0,255
_blend_edges :
+blend_edges 0.5 rm[1]
_blend_exclusion :
+*[0,1] /[2] -127.5 +[1,2] +[1] [0]
_blend_freeze :
*[1] -255 -[1] 0.1 +-[0] 255 sqr[2] /[2] [1] rm[1] +[1] 1 *[1] 255 c[1] 0,255
_blend_grainextract :
-[1] [0] *[1] -1 +[1] 128 c[1] 0,255
_blend_grainmerge :
+[1] [0] -[1] 128 c[1] 0,255
_blend_green :
sh[0] 0 sh[0] 2 j[1] [2] j[1] [3],0,0,0,2 rm[2,3]
_blend_hardlight :
+*[0,1] /[2] 127.5 ++[0,1] *[3] 2 -[3] 255 -[3] [2] >[1] 128
j[2] [3],0,0,0,0,1,[1] rm[1,3] c[1] 0,255
_blend_hardmix :
+[1] [0] >=[1] 255 *[1] 255
_blend_hue :
to_color sh 0,2 rgb2hsv[2,3] sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] hsv2rgb[2,3] rm[2,3]
_blend_interpolation :
+*[0] {pi/255} *[1] {pi/255} cos[1,2] +[1,2] -[1] 2 *[1] -63.75 c[1] 0,255
_blend_lighten :
max[1] [0]
_blend_lightness :
to_color sh 0,2 rgb2lab[2,3] sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] lab2rgb[2,3] rm[2,3]
_blend_luminance :
to_color sh 0,2 rgb2ycbcr[2,3] sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] ycbcr2rgb[2,3] rm[2,3]
_blend_linearburn :
+[1] [0] -[1] 255 c. 0,255
_blend_linearlight :
*[1] 2 +[1] [0] -[1] 255 c[1] 0,255
_blend_multiply :
*[1] [0] /[1] 255
_blend_negation :
+[1] [0] -[1] 255 abs[1] *[1] -1 +[1] 255
_blend_or :
-|[1] [0]
_blend_overlay :
+*[0,1] /[2] 127.5 +[1] [0] *[1] 2 -[1] 255 -[1] [2] +<[0] 128 j[1] [2],0,0,0,0,1,[3] rm[2,3] c[1] 0,255
_blend_pinlight :
*[1] 2 +blend darken -[1] 256 +blend[0,1] lighten >=[1] 0
j[2] [3],0,0,0,0,1,[1] rm[1,3]
_blend_reflect :
-[1] 255.1 *[1] -1 +sqr[0] /[2] [1] rm[1] c[1] 0,255
_blend_red :
sh[0] 1,100% j[1] [2],0,0,0,1 rm[2]
_blend_seamless :
+blend_seamless 0 rm[1]
_blend_seamless_mixed :
+blend_seamless 1 rm[1]
_blend_saturation :
to_color sh 0,2 rgb2hsv[2,3] shift[2,3] 0,0,0,-1,2 sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] shift[2,3] 0,0,0,1,2 hsv2rgb[2,3] rm[2,3]
_blend_screen :
+-[0] 255 -[1] 255 *[1,2] /[1] 255 *[1] -1 +[1] 255
_blend_shapeareamax :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0
+f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
{1,iM+1},1,1,{0,s+1}
f[1] ">area = i(#2); best = I[#3,i]; if (area>best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
rm[2] channels[2] 0,{s-2} map[1] [2] rm[2]
_blend_shapeareamax0 :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0
+f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
{1,iM+1},1,1,{0,s+1}
f[1] ">area = i(#2); best = I[#3,i]; if (area>best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
rm[2] channels[2] 0,{s-2} point[2] 0,0,0,1,0 map[1] [2] rm[2]
_blend_shapeareamin :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0
+f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
{1,iM+1},1,1,{0,s+1},inf
f[1] ">area = i(#2); best = I[#3,i]; if (area<best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
rm[2] channels[2] 0,{s-2} map[1] [2] rm[2]
_blend_shapeareamin0 :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0
+f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
{1,iM+1},1,1,{0,s+1},inf
f[1] ">area = i(#2); best = I[#3,i]; if (area<best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
rm[2] channels[2] 0,{s-2} point[2] 0,0,0,1,0 map[1] [2] rm[2]
_blend_shapeaverage :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0 {iM+1},1,1,{0,s}
f[0] ">i(#2,i(#1,x,y,z,0),0,0,c)+=i;i"
+histogram[1] {w},0,{w-1} /[-2,-1] map[1] . rm.
_blend_shapeaverage0 :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0 {iM+1},1,1,{0,s}
f[0] ">i(#2,i(#1,x,y,z,0),0,0,c)+=i;i"
+histogram[1] {w},0,{w-1} /[-2,-1] point. 0,0,0,1,0 map[1] . rm.
_blend_shapemedian :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0
N={iM+1} $N,1,1,{s#0} $N,8,1,{s#0} s. x
f[1] ">
begin(siz = vector"$N"());
k = i;
k3 = k + 3;
hk3 = h(#k3);
copy(i[#k3,siz[k]++],I(#0),s#0,hk3,whd#0);
if (siz[k]>=hk3,resize(#k3,1,round(1.5*hk3+1),1,s#0,0,0));
end(for (k = 0, k<size(siz), ++k, resize(#k+3,1,siz[k],1,s#0,0,0)));
i"
repeat {s#0} sh[3--1] $> $N,1,1,1,"ic(#"$N"+3+x)" j[2] .,0,0,0,$> rm[-{$N+1}--1] done
map[1] [2] k[0,1]
_blend_shapemedian0 :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0
N={iM} {$N+1},1,1,{s#0} $N,8,1,{s#0} s. x
f[1] ">
begin(siz = vector"$N"());
k = i;
if (k,
k1 = k - 1;
k2 = k + 2;
hk2 = h(#k2);
copy(i[#k2,siz[k1]++],I(#0),s#0,hk2,whd#0);
if (siz[k1]>=hk2,resize(#k2,1,round(1.5*hk2+1),1,s#0,0,0));
);
end(for (k = 0, k<size(siz), ++k, resize(#k+3,1,siz[k],1,s#0,0,0)));
i"
repeat {s#0} sh[3--1] $> $N,1,1,1,"ic(#"$N"+3+x)" j[2] .,1,0,0,$> rm[-{$N+1}--1] done
map[1] [2] k[0,1]
_blend_shapemin :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0 {iM+1},1,1,{0,s},inf
f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = min(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
map[1] [2] rm.
_blend_shapemin0 :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0 {iM+1},1,1,{0,s},inf
f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = min(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
point. 0,0,0,1,0 map[1] [2] rm.
_blend_shapemax :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0 {iM+1},1,1,{0,s},-inf
f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = max(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
map[1] [2] rm.
_blend_shapemax0 :
f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0 {iM+1},1,1,{0,s},-inf
f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = max(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
point. 0,0,0,1,0 map[1] [2] rm.
_blend_softburn :
+-[0] 255.1 ^[2] -1 *[2] [1] *[2] -127.5 +-[0] 255 ++[1] 0.1 /[3,4] *[3] 127.5 +[3] 255 +[1] [0] >[1] 255
j[2] [3],0,0,0,0,1,[1] rm[1,3] c[1] 0,255
_blend_softdodge :
+-[1] 255.1 ^[2] -1 *[2] [0] *[2] -127.5 +-[1] 255 ++[0] 0.1 /[3,4] *[3] 127.5 +[3] 255 +[1] [0] >[1] 255
j[2] [3],0,0,0,0,1,[1] rm[1,3] c[1] 0,255
_blend_softlight :
+/[0] 255 /[1] 255 +sqr. *[2] [1] *[1] [3] *[1] -2 *[2] 2 +[1-3] *[1] 255 c[1] 0,255
_blend_stamp :
*[1] 2 +[1] [0] -[1] 255 c[1] 0,255
_blend_subtract :
-[1] [0] *[1] -1 c[1] 0,255
_blend_value :
to_color sh 0,2 rgb2hsv[2,3] sh[2] 0,1 j[1] [4] rm[4] hsv2rgb[2,3] rm[2,3]
_blend_vividlight :
*[1] 2 +blend burn -[1] 256 +blend[0,1] dodge >=[1] 0
j[2] [3],0,0,0,0,1,[1] rm[1,3]
_blend_xor :
xor[1] [0]
#@cli blend_edges : smoothness[%]>=0
#@cli : Blend selected images togethers using 'edges' mode.
#@cli : $ image.jpg testimage2d {w},{h} +blend_edges 0.8
blend_edges : check {$1>=0}
e[^-1] "Blend image$? using 'edges' mode, with smoothness $1."
if {$!>1} v - to_rgb r[^0] [0],0,0,0.5,0.5 repeat $! l[$>]
+gradient_norm +. 1 b. $1 n. 1,10 sqr. s.. c *[-4--2] . a[-4--1] c
endl done r[^0] [0],0,0,0.5,0.5 + s. c /[-4--2] . rm. a[-3--1] c v + fi
#@cli blend_fade : [fading_shape]
#@cli : Blend selected images together using specified fading shape.
#@cli : $ image.jpg testimage2d {w},{h} 100%,100%,1,1,'cos(y/10)' normalize[-1] 0,1 +blend_fade[0,1] [2]
blend_fade :
e[^-1] "Blend image$? together using fading pattern $1."
v - r ${-max_whds},0
pass$1 0 r. [0],[0],[0],100%,1 max. 0 min. {$!-2}
repeat {$!-1} +-. $> abs. -. 1 *. -1 max. 0 *[$>,-1] done rm.
+ v +
_fade :
r.. ...,5 r. ..,3 c. $1%,$2% n. 0,1 j... ..,0,0,0,0,1,. rm[-2,-1]
#@cli blend_median
#@cli : Blend selected images together using 'median' mode.
#@cli : $ image.jpg testimage2d {w},{h} +mirror[0] y +blend_median
blend_median :
e[^-1] "Blend image$? using 'median' mode."
if {$!<2} return fi
v - to_colormode 0 r ${-max_whd},100%,0,0,0.5,0.5,0.5
if {$!==2} + / 2
else
whds={w},{h},{d},{s} r 100%,100%,{d*s},1,-1 a c
100%,100%,100%,1,"med(I(#0))" k. r $whds,-1
fi
v +
#@cli blend_seamless : _is_mixed_mode={ 0 | 1 },_inner_fading[%]>=0,_outer_fading[%]>=0
#@cli : Blend selected images using a seamless blending mode (Poisson-based).
#@cli : Default values: 'is_mixed=0', 'inner_fading=0' and 'outer_fading=100%'.
blend_seamless : check "${2=0}>=0 && ${3=100%}>=0" skip ${1=0}
v - s0="non-mixed" s1="mixed"
v + e[^-1] "Blend image$? using seamless mode (Poisson-based), in "${s{$1!=0}}" mode with inner fading $2 and outer fading $3." v -
to_a[^0] r {0,w+32},{0,h+32},1,100%,0,0,0.5,0.5
if {['$3']!='100%'}
repeat {$!-1} l[0,1]
+blend_seamless $1,$2,100% channels.. 100% !=.. 0 distance.. 1
iM={-2,iM} ic={if(${is_percent\ $3},2*$3*$iM,1+$3)}
if {$ic<=$iM} c.. 0,{max(1,$ic)} n.. 0,1
else n.. 0,{max(0,2-$ic/$iM)}
fi
*.. -1 +.. 1
j[0] [2],0,0,0,0,1,[1] rm[1,2]
endl done
else
repeat {$!-1} l[0,1]
+r[0] 1,1,1,100%,2 avg={^} rm.
split_opacity. !=. 0 *.. . erode. 3
g[0,1] xy,1
*[-3,-2] .
if $1
+a[0,1] c +a[2,3] c norm[-2,-1]
<[-2,-1] *[-2,-1]
fi
if {$2}
distance. 0
iM={iM} ic={if(${is_percent\ $2},2*$2*$iM,1+$2)}
if {$ic<=$iM} c. 0,{max(1,$ic)} n. 0,1
else n. 0,{max(0,2-$ic/$iM)}
fi
fi
j[-5] ...,0,0,0,0,1,.
j[-4] ..,0,0,0,0,1,.
rm[-3--1]
g[0] x,-1 g[1] y,-1 +
ilaplacian 0
+fc. $avg
+[-2,-1]
c 0,255
endl done
fi
z 16,16,{w-17},{h-17} v +
#@cli fade_diamond : 0<=_start<=100,0<=_end<=100
#@cli : Create diamond fading from selected images.
#@cli : Default values: 'start=80' and 'end=90'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_diamond 80,85
fade_diamond : skip ${1=70},${2=90}
e[^-1] "Create ($1%,$2%) diamond-shaped fading from image$?."
v - repeat {int($!/2)} l[$>,{$>+1}]
(0,1,0;1,1,1;0,1,0) _fade $1,$2
endl done v +
#@cli fade_linear : _angle,0<=_start<=100,0<=_end<=100
#@cli : Create linear fading from selected images.
#@cli : Default values: 'angle=45', 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_linear 45,48,52
fade_linear : skip ${1=45},${2=30},${3=70}
e[^-1] "Create ($2%,$3%) linear fading from image$?, with angle $1 deg."
v - repeat {int($!/2)} l[$>,{$>+1}]
64,64,1,1,"x*cos($1*pi/180) + y*sin($1*pi/180)" _fade $2,$3
endl done v +
#@cli fade_radial : 0<=_start<=100,0<=_end<=100
#@cli : Create radial fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_radial 30,70
fade_radial : skip ${1=30},${2=70}
e[^-1] "Create ($1%,$2%) radial fading from image$?."
v - repeat {int($!/2)} l[$>,{$>+1}]
100%,100% =. 1,50%,50% distance. 1 _fade $1,$2
endl done v +
#@cli fade_x : 0<=_start<=100,0<=_end<=100
#@cli : Create horizontal fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_x 30,70
fade_x : skip ${1=30},${2=70}
e[^-1] "Create ($1%,$2%) horizontal fading from image$?."
v - repeat {int($!/2)} l[$>,{$>+1}] (0,1) _fade $1,$2 endl done v +
#@cli fade_y : 0<=_start<=100,0<=_end<=100
#@cli : Create vertical fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_y 30,70
fade_y : skip ${1=30},${2=70}
e[^-1] "Create ($1%,$2%) vertical fading from image$?."
v - repeat {int($!/2)} l[$>,{$>+1}] (0;1) _fade $1,$2 endl done v +
#@cli fade_z : 0<=_start<=100,0<=_end<=100
#@cli : Create transversal fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
fade_z : skip ${1=30},${2=70}
e[^-1] "Create ($1%,$2%) transversal fading from image$?."
v - repeat {int($!/2)} l[$>,{$>+1}] (0/1) _fade $1,$2 endl done v +
#@cli sub_alpha : [base_image],_opacity_gain>=1
#@cli : Compute the minimal alpha-channel difference (opposite of alpha blending) between the selected images and the specified base image.
#@cli : The alpha difference A-B is defined as the image having minimal opacity, such that alpha_blend(B,A-B) = A.
#@cli : Default value: 'opacity_gain=1'.
#@cli : $ image.jpg testimage2d {w},{h} +sub_alpha[0] [1] display_rgba
sub_alpha : check "${2=1}>=1 && "${"is_image_arg $1"}
e[^-1] "Compute minimal alpha-channel difference between image$? and base image $1, with opacity gain $2."
v - remove_opacity repeat $! pass$1 0 l[$>,-1]
to_colormode 0 r ${-max_whd},100%,0,0,0.5,0.5
+>[0,1] *[2] 255
-[0,2] [1] replace[2] 0,1
i[2] [0] /[2,3]
compose_channels[2] max
*[2] $2 c[2] 0,1
+replace[2] 0,1 /[0,3] +[0,1] *[1] 255 a c
endl done v +
#@cli :: Image Sequences and Videos
#@cli animate : filter_name,"param1_start,...,paramN_start","param1_end,...,paramN_end",nb_frames>=0,_output_frames={ 0 | 1 },_output_filename : delay>0,_back and forth={ 0 | 1 }
#@cli : Animate filter from starting parameters to ending parameters or animate selected images
#@cli : in a display window.
#@cli : Default value: 'delay=30'.
#@cli : $ image.jpg animate flower,"0,3","20,8",9
animate : skip ${1=30},${2=0},${3=""},${4=10},${5=1},"${6=}"
if {"isval($1)"}
e[0--3] "Animate image$?, with a delay of $1 ms"${"v - if $2 u \", in back-and-forth mode\" else u \"\" fi v +"}.
if {!$!} return fi
v -
speed,pause,direction,scale,frame=$1,-1,1,1,0
is_same_size={"res = 1; s = [ w#0,h#0 ]; for (k = 1, k<l && res, ++k, res = (s==[ w#k,h#k ]))"}
w[0] ${fitscreen[]\ {0,[w,h]}},1,0,-1,-1,{0,b}.{0,x}
do
if $is_same_size
w[$frame] -1,-1,1,0,-1,-1,{$frame,b}.{$frame,x}
else
w[$frame] {$scale*[${fitscreen[]\ {$frame,[w,h]}}]},1,0,-1,-1,{$frame,b}.{$frame,x}
fi
frame+=$direction
if $2
if {$frame==-1} frame=0 direction=1
elif {$frame==$!} frame={$!-1} direction=-1
fi
else frame%=$!
fi
wait $speed
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} scale*=1.5 wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} scale/=1.5 wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} scale=1 wait -1 fi
if {*,o} speed={min(500,max(10,$speed-10*{*,o}))} wait -1 fi
if {*,SPACE}
if {$pause>=0} direction=$pause pause=-1
else pause=$direction direction=0 fi
wait -1
fi
while {{*}" && "!{*,Q}" && "!{*,ESC}} w 0 v +
else
e[0--3] "Compute animated version of filter '$1', from parameters $2 to $3 with $4 frames."
if {!($5||narg("$6"))} return fi
v - ($2) ($3) y[-2,-1] x a[-2,-1] y r. 100%,$4,1,1,3 mv. 0 rprogress 0
repeat {$!-1},u
v + e[] " > Animate image ["$>"]" v -
repeat $4 +l[0,1]
-$1. {0,@{$>*{0,w}}-{($>+1)*{0,w}-1}} rm[0]
if {narg("$6")} o ${filename\ "$6",$u,$>} fi
if {!$5} rm fi
rprogress {100*($>+1)/$4}
v + e[] "\r > Animate image ["$u"] : Frame "{$>+1}"/$4    " v -
endl done
rm[1] done rm[0] v +
fi
#@cli apply_camera : _"command",_camera_index>=0,_skip_frames>=0,_output_filename
#@cli : Apply specified command on live camera stream, and display it on display window [0].
#@cli : Default values: 'command=""', 'camera_index=0' (default camera), 'skip_frames=0' and 'output_filename=""'.
apply_camera : skip "${1=},${4=}" check "${2=0}>=0 && ${3=0}>=0"
e[^-1] "Apply command '$1' on camera stream ""#$2, with $3 frames skip and output filename '$4'."
v - is_ext "$4",avi is_outavi=${}
l[] i=0 do
camera $2,1,$3 $1 w. -1,-1,"[G'MIC] Camera ""#$2 ("{w}x{h}")"
if {narg("$4")} if $is_outavi z. 0,{w-(w%8)-1} o. "$4",25,mp4v,1 else o. ${filename\ "$4",$i} i+=1 fi fi
if {*,S} o. gmic_camera.png fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi
rm.
while {{*}" && "!{*,ESC}" && "!{*,Q}} camera $2,0 endl v +
#@cli apply_files : "filename_pattern",_"command",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Apply a G'MIC command on specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'command=(undefined)', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
apply_files : check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${2=},${6=}"
e[^-1] "Apply command '$2' on input image files '$1', with first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _apply_stream[] "${_file{$frame+1}}","$2",${3-5},"$6" v +
#@cli apply_video : video_filename,_"command",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Apply a G'MIC command on all frames of the specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
apply_video : check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${2=},${6=}"
e[^-1] "Apply command '$2' on input video file '$1', with first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
v - _N= _apply_stream[] "\"$1\",$frame","$2",${3-5},"$6" v +
_apply_stream : skip "${2=},${6=}"
is_ext "$6",avi is_outavi=${}
frame=$3 i=0 go_on=1
do
l[] $1 onfail go_on=0 endl
if $go_on
v + e[] "\r  > Frame ""#"$frame$_N"        " v -
frame+=$5
l $2 onfail error[0--5] "Command 'apply_stream': Specified command errored: "${} endl
if {!$!} continue fi
if {narg("$6")}
if $is_outavi z. 0,{w-(w%8)-1} o. "$6",25,mp4v,1 else o. ${filename\ "$6",$i} i+=1 fi
fi
if {*}
title="[G'MIC] Frame ""#"$frame
if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,0,$title
else w. -1,-1,0,$title
fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi
fi
rm.
fi
while {$go_on" && "($4==-1" || "$frame<=$4)}
if $is_outavi o[] "$6",25,mp4v,0 fi
#@cli average_files : "filename_pattern",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Average specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
average_files : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1" skip "${5=}"
e[^-1] "Average input image files '$1', with first frame $2, last frame $3, frame step $4 and output filename '$5'.\n"
v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _average_stream[] "${_file{$frame+1}}",${2-4},"$5" v +
#@cli average_video : video_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Average frames of specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
average_video : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1" skip "${5=}"
e[^-1] "Average frames of input video file '$1', with first frame $2, last frame $3, frame step $4 and output filename '$5'.\n"
v - _N= _average_stream[] "\"$1\",$frame",${2-4},"$5" v +
_average_stream : skip "${5=}"
is_ext "$5",avi is_outavi=${}
frame=$2 i=0 go_on=1 N=0
imM=inf,-inf
do
l[] $1 onfail go_on=0 endl
if $go_on
v + e[] "\r  > Frame ""#"$frame$_N"        " v -
imM={v=[$imM];[min(im,v[0]),max(iM,v[1])]}
N+=1
if {$!>1} + fi
if {narg("$5")}
+/. $N c. $imM
if $is_outavi z. 0,{w-(w%8)-1} o. "$5",25,mp4v,1 else o. ${filename\ "$5",$i} i+=1 fi
rm.
fi
if {*}
title="[G'MIC] Frame ""#"$frame
+n 0,255
if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,0,$title
else w. -1,-1,0,$title
fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi
rm.
fi
frame+=$4
fi
while {$go_on" && "($3==-1" || "$frame<=$3)}
/ $N c $imM
if $is_outavi o[] "$5",25,mp4v,0 fi
#@cli fade_files : "filename_pattern",_nb_inner_frames>0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Generate a temporal fading from specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension 'avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'nb_inner_frames=10', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
fade_files : check "isint(${2=10}) && $2>0 && isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${6=}"
e[^-1] "Fade input image files '$1', with $2 inner frames, first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _fade_stream[] "${_file{$frame+1}}",${2-5},"$6" v +
#@cli fade_video : video_filename,_nb_inner_frames>0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Create a temporal fading sequence from specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : Default values: 'nb_inner_frames=10', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
fade_video : check "isint(${2=10}) && $2>0 && isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${6=}"
e[^-1] "Fade frames of input video file '$1', with $2 inner frames, first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
v - _N= _fade_stream[] "\"$1\",$frame",${2-5},"$6" v +
_fade_stream : skip "${6=}"
is_ext "$6",avi is_outavi=${}
frame=$3 i=0 go_on=1
l $1 onfail go_on=0 endl
if {!$go_on} return fi
w={w} h={h} s={s}
if {*} w. ${fitscreen\ $w,$h},0,"[G'MIC]" fi
pframe=$frame frame+=$5
do
l[] $1 onfail go_on=0 endl
if {!$go_on} break fi
to_colormode. $s r. $w,$h
repeat {$2+2} if {$<}
title="[G'MIC] Frame ""#"$pframe" -> ""#"$frame$_N" ("{1+$>}/$2")"
v + e[] "\r  - "$title v -
+j[0] [1],0,0,0,0,{$>/($2+1)}
if {narg("$6")}
if $is_outavi z. 0,{w-(w%8)-1} o. "$6",25,mp4v,1 else filename "$6",$i i+=1 o. ${} fi
fi
if {*}
w. -1,-1,0,$title
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi
fi
rm.
fi done
rm[0] pframe=$frame frame+=$5
while {$go_on" && "($4==-1" || "$frame<=$4)}
if {narg("$6")}
if $is_outavi z. 0,{w-(w%8)-1} o[] "$6",25,mp4v,0 else filename "$6",$i o. ${} fi
fi
rm
#@cli files2video : "filename_pattern",_output_filename,_fps>0,_codec
#@cli : Convert several files into a single video file.
#@cli : Default values: 'output_filename=output.avi', 'fps=25' and 'codec=mp4v'.
files2video : check "isint(${3=25}) && $3>0" skip "${2=output.avi}",${4=mp4v}
v -
files=${"files \"$1\""} arg2var _file,$files nb_files=${}
({'$files'}) if {w>128} z. 0,127 s_files={t}... else s_files=$files fi rm.
v + e[^-1] "Convert image files '"$s_files"' into frames of output video '$2', with $3 fps and $4 codec.\n" v -
repeat $nb_files l[]
file=${_file{$>+1}}
_file=${basename\ $file}
v + e[] "\r - Image "{1+$>}/$nb_files" ["$_file"] -> [$2]                    " v -
i $file o "$2",$3,$4,1
rm
onfail v + e[] "\n - Error occurred on input file '"$file"'.\n" v -
endl done
o $"$2",0,0,0 v +
#@cli median_files : "filename_pattern",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_frame_rows[%]>=1,_is_fast_approximation={ 0 | 1 }
#@cli : Compute the median frame of specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frame is displayed in it during processing.
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1', 'frame_rows=20%' and 'is_fast_approximation=0'.
median_files : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1 && ${5=20%}>0 && isval(${6=0})"
v - s0="fast" s1="precise"
v + e[^-1] "Compute median of input image files '$1', with first frame $2, last frame $3, frame step $4, frame rows $5, using "${s{!$6}}" algorithm." v -
files 3,"$1" _N=/{narg(${})-1} arg2var _file,${}
l[]
i[res] ${_file{$frame+1}} f. 0
_median_stream "${_file{$frame+1}}",${2-6}
endl v +
#@cli median_video : video_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_frame_rows[%]>=1,_is_fast_approximation={ 0 | 1 }
#@cli : Compute the median of all frames of an input video file, in a streamed way.
#@cli : If a display window is opened, rendered frame is displayed in it during processing.
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1', 'frame_rows=100%' and 'is_fast_approximation=1'.
median_video : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1 && ${5=100%}>0 && isval(${6=1})"
v - s0="fast" s1="precise"
v + e[^-1] "Compute median frame of input video file '$1', with first frame $2, last frame $3, frame step $4, frame rows $5, using "${s{!$6}}" algorithm." v -
_N=
l[]
i[res] "$1",0 f. 0
_median_stream "\"$1\",$frame",${2-6}
endl v +
_median_stream :
if $6
v + e[] "- Retrieve min/max values of all frames.\n" v -
frame=$2 go_on=1
imM=inf,-inf
do
l[] $1 onfail go_on=0 endl
if $go_on
v + e[] "\r    > Frame ""#"$frame$_N"        " v -
imM={v=[$imM];[min(im,v[0]),max(iM,v[1])]}
if {*}
title="[G'MIC] Frame ""#"$frame
if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,1,$title
else w. -1,-1,1,$title
fi
fi
rm.
frame+=$4
fi
while {$go_on" && "($3==-1" || "$frame<=$3)}
_N=/{$frame-$4}
fact={v=[$imM];dv=v[1]-v[0];dv<=0?0:255/dv}
fi
h1={h-1} drows={round(${is_percent\ $5}?$5*h:$5)}
nb_iter={round(h/$drows,1,1)}
repeat $nb_iter
row0={$drows*$>} row1={0,min(h,$row0+$drows-1)}
v + e[] "- Iteration \#"{$>+1}/$nb_iter": Load rows "$row0-$row1/$h1".\n" v -
frame=$2 go_on=1
if $6
N=0
i[hist] {w},$drows,256,{s}
do
l[] $1 nm. img onfail go_on=0 endl
if $img
v + e[] "\r    > Frame ""#"$frame$_N"        " v -
if {{*}" && "!$>}
title="[G'MIC] Frame ""#"$frame
if {!narg($wh)} wh=${fitscreen[]\ {img,w},{img,h}} w[img] $wh,1,$title
else w[img] -1,-1,1,$title
fi
fi
rows[img] $row0,$row1 f[img] ":++i(#-2,x,y,round(i*"$fact"),c)"
rm[img]
frame+=$4 N+=1
fi
while {$go_on" && "($3==-1" || "$frame<=$3)}
cumulate[hist] z
N2={int($N/2)}
[hist],[hist],1,[hist]
if {$N%2}
f. ":go_on = 1; for (z = 0, i(#"$hist",x,y,z,c)<"$N2" && z<256, ++z); z"
else
f. ":begin(N2p = "$N2"; N2n = N2p + 1);
go_on = 1;
for (zp = 0, i(#"$hist",x,y,zp,c)<N2p && zp<256, ++zp);
for (zn = zp, i(#"$hist",x,y,zn,c)<N2n && zn<256, ++zn);
0.5*(zn + zp);"
fi
rm..
/. $fact c. $imM
else
l[]
do
l[] $1 nm. img onfail go_on=0 endl
if $go_on
v + e[] "\r    > Frame ""#"$frame$_N"        " v -
if {{*}" && "!$>}
title="[G'MIC] Frame ""#"$frame
if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,1,$title
else w. -1,-1,1,$title
fi
fi
rows. $row0,$row1
frame+=$4
fi
while {$go_on" && "($3==-1" || "$frame<=$3)}
v + e[] "\r    > Compute median blending of "$!" frames." v -
__median_stream
endl
fi
_N=/{$frame-$4}
j[res] .,0,$row0
if {*} w[res] -1,-1,1,"[G'MIC] Iteration ""#"$> fi
rm.
done
v + e[] "- Done!" v -
__median_stream :
if {$!<2} return
elif {$!==2} + / 2
else
f. ":
stack = vector"{0,2*$!}"();
stacksize = 0;
push(elt0,elt1) = (stack[stacksize++] = elt0; stack[stacksize++] = elt1);
pop() = (_s1 = stack[--stacksize]; _s0 = stack[--stacksize]; [_s0,_s1]);
push(0,"$!" - 1);
while (stacksize>0,
range = pop();
lo = range[0];
hi = range[1];
pivot = i(#int((lo + hi)/2));
while (lo<=hi,
while (i(#lo)<pivot, ++lo);
while (pivot<i(#hi), --hi);
if (lo<=hi, _tmp = i(#lo); i(#lo++) = i(#hi); i(#hi--) = _tmp);
);
if (range[0]<hi,push(range[0],hi));
if (lo<range[1],push(lo,range[1]));
)"
if {$!%2} k[{int($!/2)}]
else k[{int($!/2-1)},{$!/2}] + / 2
fi
fi
#@cli morph : nb_inner_frames>=1,_smoothness>=0,_precision>=0
#@cli : Create morphing sequence between selected images.
#@cli : Default values: 'smoothness=0.1' and 'precision=4'.
#@cli : $ image.jpg +rotate 20,1,1,50%,50% morph 9
morph : check "$1>=0 && ${2=0.1}>=0 && ${3=4}>=0"
e[^-1] "Create morphing sequence between image$?, with $1 inner frames, smoothness $2 and precision $3.\n"
if {!$1} return fi
v - r[^0] [0],3 repeat {$!-1} nm={$>,n} l[$<,{$<+1}]
v + e[] "\r > Morph image "$>" to image "{$>+1}".    " v -
+equalize[0,1] n[-2,-1] 0,255
+displacement[3] [2],$2,$3 +displacement[2] [3],$2,$3 rm[-4,-3]
repeat {$1+2} if {$>&&$<}
t={$>/($1+1)} omt={1-$t}
+*[2] $t +warp[0] .,1,1,1 rm.. *. $omt
+*[3] {1-$t} +warp[1] .,1,1,1 rm.. *. $t
+[-2,-1]
fi done
rm[2,3] mv[2--1] 1 nm $nm
endl done v +
#@cli morph_files : "filename_pattern",_nb_inner_frames>0,_smoothness>=0,_precision>=0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Generate a temporal morphing from specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'nb_inner_frames=10', 'smoothness=0.1', 'precision=4', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
morph_files : check "isint(${2=10}) && $2>0 && ${3=0.1}>=0 && ${4=4}>=0 && isint(${5=0}) && $5>=0 && isint(${6=-1}) && ($6>=0 || $6==-1) && ${7=1}>=1" skip "${8=}"
e[^-1] "Morph input image files '$1', with $2 inner frames, smoothness $3, precision $4, first frame $5, last frame $6, frame step $7 and output filename '$8'.\n"
v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _morph_stream[] "${_file{$frame+1}}",${2-7},"$8" v +
#@cli morph_video : video_filename,_nb_inner_frames>0,_smoothness>=0,_precision>=0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Generate a temporal morphing from specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'nb_inner_frames=10', 'smoothness=0.1', 'precision=4', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
morph_video : check "isint(${2=10}) && $2>0 && ${3=0.1}>=0 && ${4=4}>=0 && isint(${5=0}) && $5>=0 && isint(${6=-1}) && ($6>=0 || $6==-1) && ${7=1}>=1" skip "${8=}"
e[^-1] "Morph frames of input video file '$1', with $2 fading frames, smoothness $3, precision $4, first frame $5, last frame $6, frame step $7 and output filename '$8'.\n"
v - _N= _morph_stream[] "\"$1\",$frame",${2-7},"$8" v +
_morph_stream : skip "${8=}"
is_ext "$8",avi is_outavi=${}
frame=$5 i=0 go_on=1
l $1 onfail go_on=0 endl
if {!$go_on} return fi
w={w} h={h} s={s}
if {*} w. ${fitscreen\ $w,$h},0,"[G'MIC]" fi
pframe=$frame frame+=$7
do
l[] $1 onfail go_on=0 endl
if {!$go_on} break fi
to_colormode. $s r. $w,$h
cutvals={[min(im#0,im#1),max(iM#0,iM#1)]}
v + e[] "\r  - Frame ""#"$pframe" -> ""#"$frame"            " v -
+equalize[0,1] n[-2,-1] 0,255
+displacement[3] [2],$3,$4 +displacement[2] [3],$3,$4 rm[-4,-3]
repeat {$2+2} if {$<}
title="Frame ""#"$pframe" -> ""#"$frame" ("$>/$2")        "
v + e[] "\r  - "$title v -
t={$>/($2+1)} omt={1-$t}
+*[2] $t +warp[0] .,1,1,1 rm.. *. $omt
+*[3] {1-$t} +warp[1] .,1,1,1 rm.. *. $t
+[-2,-1] c. $cutvals
if {narg("$8")}
if $is_outavi z. 0,{w-(w%8)-1} o. "$8",25,mp4v,1 else filename "$8",$i i+=1 o. ${} fi
fi
if {*}
w. -1,-1,0,$title
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi
fi
rm.
fi done
rm[0,-2,-1] pframe=$frame frame+=$7
while {$go_on" && "($6==-1" || "$frame<=$6)}
if {narg("$8")}
if $is_outavi z. 0,{w-(w%8)-1} o[] "$8",25,mp4v,0 else filename "$8",$i o. ${} fi
fi
rm
#@cli register_nonrigid : [destination],_smoothness>=0,_precision>0,_nb_scale>=0
#@cli : Register selected source images with specified destination image, using non-rigid warp.
#@cli : Default values: 'smoothness=0.2', 'precision=6' and 'nb_scale=0(auto)'.
#@cli : $ image.jpg +rotate 20,1,1,50%,50% +register_nonrigid[0] [1]
register_nonrigid : check ${is_image_arg\ $1}" && ${2=0.2}>=0 && ${3=5}>0 && ${4=0}>=0"
e[^-1] "Register source image$? with destination image $1, using non-rigid warp with smoothness $1, precision $2 and $3 scale(s)."
v - pass$1 0 equalize. n. 0,255
repeat {$!-1}
+equalize[$>] n. 0,255 +displacement.. .,$2,$3,$4 rm..
warp[$>] .,1,1,1 rm.
done rm. v +
#@cli register_rigid : [destination],_smoothness>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Register selected source images with specified destination image, using rigid warp (shift).
#@cli : Default values: 'smoothness=1' and 'boundary_conditions=0'.
#@cli : $ image.jpg +shift 30,20 +register_rigid[0] [1]
register_rigid : check ${is_image_arg\ $1}" && ${2=1}>=0 && isint(${3=0}) && $3>=0 && $3<=3"
e[^-1] "Register source image$? with destination image $1, using rigid warp with smoothness $2."
v - pass$1 0 equalize. b. $2 n. 0,255
repeat {$!-1}
+equalize[$>] b. $2 n. 0,255
+phase_correlation. .. rm..
shift[$>] {^},0,$3 rm.
done rm. v +
#@cli transition : [transition_shape],nb_added_frames>=0,100>=shading>=0,_single_frame_only={ -1=disabled | >=0 }
#@cli : Generate a transition sequence between selected images.
#@cli : Default values: 'shading=0' and 'single_frame_only=-1'.
#@cli : $ image.jpg +mirror c 100%,100% plasma[-1] 1,1,6 transition[0,1] [2],5
transition : check ${is_image_arg\ $1}" && $2>=0 && ${3=0}>=0 && $3<=100" skip ${4=-1}
v - frame={round($4)} s0=" and shading $3" s1=", shading $3 and single-frame-only "$frame v +
e[^-1] "Create transition sequence between image$? with $2 added frames, transition shape $1"${s{$4>0}}"."
if {$!<2" || "!$2} return fi
v - to_colormode 0 r ${-max_whd},100%,0,0,0.5,0.5
pass$1 0 norm. r. [0],[0],[0],1,3 n. 0,1 mv. 0
repeat {$!-2} l[0,{$<+1},{$<+2}]
nm0={1,n}
if $3 repeat $2 if {$4<0" || "$>==$frame}
val0={($>+0.5)/$2-$3%}
val1={($>+0.5)/$2+$3%}
+f[0] '(i-$val0)/($val1-$val0)' c. 0,1
+j[2] [1],0,0,0,0,1,. rm..
nm. $nm0\ ""#{1+$>}
fi done else repeat $2 if {$4<0" || "$>==$frame}
+>=[0] {($>+0.5)/$2}
+j[2] [1],0,0,0,0,1,. rm..
nm. $nm0\ ""#{1+$>}
fi done fi
mv[2] $!
endl done rm[0] v +
#@cli transition3d : _nb_frames>=2,_nb_xtiles>0,_nb_ytiles>0,_axis_x,_axis_y,_axis_z,_is_antialias={ 0 | 1 }
#@cli : Create 3D transition sequence between selected consecutive images.
#@cli : 'axis_x', 'axis_y' and 'axis_z' can be set as mathematical expressions, depending on 'x' and 'y'.
#@cli : Default values: 'nb_frames=10', 'nb_xtiles=nb_ytiles=3', 'axis_x=1', 'axis_y=1', 'axis_z=0' and 'is_antialias=1'.
#@cli : $ image.jpg +blur 5 transition3d 9 display_rgba
transition3d : check "isint(${1=10}) && $1>=2 && isint(${2=3}) && $2>0 && isint(${3=$2}) && $3>0" skip ${4=1},${5=1},${6=0},${7=1}
e[^-1] "Create 3D transition sequence between image$?, with $1 frames, $2x$3 tiles and rotation axis ($4,$5,$6).\n"
if {$!<2} return fi
v -
slices 0 to_rgb r ${-max_whds},3
off=0 repeat {$!-1} l[{$>+$off},{$>+$off+1}]
v + e[] "\r > Generate transition from image "$>" to image "{$>+1}".    " v -
$2,$3,1,1,'$4'
$2,$3,1,1,'$5'
$2,$3,1,1,'$6'
a[-3--1] z
permute. zxyc r. 3,{$2*$3},1,1,-1
repeat {h} rot$>={@0-2} shift. 0,-1,0,0 done
rm.
+split_tiles[-2,-1] $2,$3 mv[0,1] $!
N={$2*$3} i=0 y=0
repeat $3
x=0
repeat $2
lw={$i,w} lh={$i,h}
imageplane3d[$i] imageplane3d[$N] r3d[$N] ${rot$i},180 c3d[$i,$N] +3d[$i,$N]
x$i=$x y$i=$y x+=$lw i+=1
done
y+=$lh
done
repeat {$1-2}
repeat $N r3d[$>] ${rot$>},{180/(1-$1)} ++3d[$>] ${x$>},${y$>},0 done
+3d[-$N--1] c3d.
if $7
i... {-2,2*[w,h]},1,3,-1
*3d. 2 j3d... .,50%,50%,0,1,2,0,0 rm.
to_rgba.. replace_color.. 0,0,-1,-1,-1,255,0,0,0,0
downsize_aliased.. 50
else
i... {-2,w},{-2,h},1,3,-1 j3d... .,50%,50%,0,1,2,0,0 rm.
to_rgba.. replace_color.. 0,0,-1,-1,-1,255,0,0,0,0
fi
done
rm[0-{$N-1}]
nm[1--2] {0,n}
off+={$1-2}
endl done
v +
#@cli video2files : input_filename,_output_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1
#@cli : Split specified input video file into image files, one for each frame.
#@cli : First and last frames as well as step between frames can be specified.
#@cli : Default values: 'output_filename=frame.png', 'first_frame=0', 'last_frame=-1' and 'frame_step=1'.
video2files : check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && isint(${5=1}) && $5>=1" skip ${2="frame.png"}
e[^-1] "Split input video file '$1' into image frames '$2', with first frame $3, last frame $4, and frame step $5.\n"
v -
frame=$3 stopflag=0
do l[]
i "$1",$frame
if $!
o ${"filename \"$2\","$frame} rm
v + e[] "\r  > Frame ""#"$frame v -
frame+=$5
else stopflag=1
fi
onfail stopflag=1
endl while {!$stopflag" && "($frame<=$4" || "$4==-1)}
v +
#@cli :: Convenience Functions
#@cli alert : _title,_message,_label_button1,_label_button2,...
#@cli : Display an alert box and wait for user's choice.
#@cli : If a single image is in the selection, it is used as an icon for the alert box.
#@cli : Default values: 'title=[G'MIC Alert]' and 'message=This is an alert box.'.
alert : skip "${1=[G"{`39`}"MIC Alert]},${2=This is an alert box.},${3=OK}"
if {$!==1}
e[0--3] "Display alert box, with image$?, title '$1', message '$2' and buttons '${3--1}'."
else
e[0--3] "Display alert box, with title '$1', message '$2' and buttons '${3--1}'."
fi
v -
if {$!==1} logo= else logo=[] fi
+l$logo
if {$!==1} to_rgb
else
64,64 polygon 3,50%,10%,10%,90%,90%,90%,1,1 b 3 >= 50%
+erode. 5 -. .. ==. 0
polygon. 4,47%,43%,53%,43%,53%,66%,47%,66%,1,0 circle. 50%,76%,2,1,0
+*[0] 255 . 100%,100% a[-3--1] c -. '3*(y-h/2)'
*. .. rm.. *[0] 255 rv a c
drop_shadow 3,3,1 i[0] 100%,100%,1,3,200 blend alpha
fi
channels -1,2
$=arg
repeat {$#-2} label=${arg{$>+3}} 0 t. $label,0,0,16,1,-200 done
r[^0] {min(128,max(64,${max_w[^0]}+12))},{min(48,max(24,${max_h[^0]}+12))},1,1,0,0,0.5,0.5
+[^0] 200 to_rgb[^0]
mv[0] $!
[0],[0],1,1,'(y-h/2)' *. -2 c. -30,30 +[0--3] . rm. c[^-1] 0,255
repeat {$!-1} l[$<]
+rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
rectangle. 1,1,{w-2},{h-2},1,0xFFFFFFFF,0
line. 2,{h-3},{w-3},{h-3},1,150 line. {w-3},{h-3},{w-3},2,1,150
line. 1,1,{w-3},1,1,255 line. 1,1,1,{h-3},1,255
rectangle. 4,4,{w-5},{h-5},1,0xAAAAAAAA,0
+shift.. 1,1,0,0,2
rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
rectangle. 1,1,{w-2},{h-2},1,0xFFFFFFFF,150
rectangle. 4,4,{w-5},{h-5},1,0xAAAAAAAA,0
rectangle... 0,0,100%,100%,1,0xFFFFFFFF,0
line... 1,{h-2},{w-2},{h-2},1,150 line... {w-2},{h-2},{w-2},1,1,150
line... 0,0,{w-2},0,1,255 line... 0,0,0,{h-2},1,255
i[0] 100%,100% =[0] 1,0,0
a c endl done
+l
channels 0,3 sh 1,100% -[50%--1] 200 rm[50%--1] frame 8,8,0
if {$!<6} a[^-1] x else append_tiles[^-1] , fi
0 t. "$2",0,0,16,1,0,-200,-200,-200 r. {w+16},{h+8},1,4,0
a[-2,-1] x,0.5 rv a y,0.5
sh 1,100% +. 200 rm.
rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
line 0,0,{w-2},0,1,0,255,255,255 line 0,0,0,{h-2},1,0,255,255,255
endl
rm..
+channels. 0
(0,{w-1}) (0;{-2,h-1}) r[-2,-1] ...,3 a[-2,-1] c round. rv[-2,-1] *[-2,-1]
discard. 0 r. {h/2},2,1,1,-1
channels.. 1,3 rv[-2,-1]
100%,100% repeat {-3,w} x0={-3,i($>,0)} y0={-3,i($>,1)} rectangle. $x0,$y0,{$x0+{0,w}-1},{$y0+{0,h}-1},1,{1+$>} done
a[-2,-1] c
repeat 9 if {!{*$>}} disp=$> break fi done
if {!narg($disp)} v + error[0--4] "Command '$0': Cannot open display window for alert box." fi
selected={if($#==3,0,-1)} clicked=-1
do
+channels. 0,2
if {$clicked>=0}
x0={-3,i($clicked,0)} y0={-3,i($clicked,1)}
sh[$clicked] 7,9
j.. .,$x0,$y0 rm.
elif {$selected>=0}
x0={-3,i($selected,0)} y0={-3,i($selected,1)}
sh[$selected] 4,6
j.. .,$x0,$y0 rm.
fi
w$disp. 100%,100%,0,"$1" rm. wait
xm={*$disp,x} ym={*$disp,y} bm={{*$disp,b}&1} val={i($xm,$ym,0,3)}
if {$bm" && "$val} clicked={$val-1}
elif {$bm" && "!$val" && "$clicked>=0} selected=$clicked clicked=-1
elif {!$bm" && "$clicked>=0" && "$clicked==$val-1} break
fi
if {*$disp,ARROWRIGHT} selected={($selected+1)%{-2,w}} wait -1
elif {*$disp,ARROWLEFT} selected={($selected-1)%{-2,w}+($selected==-1)} wait -1
elif {$selected>=0" && "{*$disp,ENTER}} clicked=$selected break
fi
while {{*$disp}" && "!{*$disp,ESC}}
w$disp 0 rm u $clicked
endl
v +
#@cli arg : n>=1,_arg1,...,_argN
#@cli : Return the n-th argument of the specified argument list.
arg : check "isint($1) && ($1)>0"
v - $=arg u ${arg{1+($1)}} v +
#@cli arg2var : variable_name,argument_1,...,argument_N
#@cli : For each i in [1...N], set 'variable_name$i=argument_i'.
#@cli : The variable name should be global to make this command useful (i.e. starts by an underscore).
arg2var :
v - $=arg u {$#-1} repeat ${} $1{1+$>}=${arg{2+$>}} done v +
#@cli autocrop_coords : value1,value2,... | auto
#@cli : Return coordinates (x0,y0,z0,x1,y1,z1) of the autocrop that could be performed on the latest of the selected images.
#@cli : Default value: 'auto'
autocrop_coords : skip ${1=auto}
v -
is_auto={['"$1"']=='auto'}
w={w} h={h} d={d}
value={i(w-1,h-1,d-1)} +=. {1+$value},100%,100%,100% _autocrop$is_auto. ${1--1} =. $value,100%,100%,100%
x0={$w-w} y0={$h-h} z0={$d-d} rm.
+_autocrop$is_auto. ${1--1}
x1={$x0+w-1} y1={$y0+h-1} z1={$z0+d-1} rm.
u $x0,$y0,$z0,$x1,$y1,$z1
v +
_autocrop0 : autocrop $*
_autocrop1 : skip $* autocrop
#@cli base642img : "base64_string"
#@cli : Decode given base64-encoded string as a newly inserted image at the end of the list.
#@cli : The argument string must have been generated using command 'img2base64'.
base642img :
v - base642uchar "$1" unserialize. v +
#@cli base642uchar : "base64_string"
#@cli : Decode given base64-encoded string as a newly inserted 1-column image at the end of the list.
#@cli : The argument string must have been generated using command 'uchar2base64'.
base642uchar :
v - 0
eval "
hash = vector256();
for (k = _'A', k<=_'Z', ++k, hash[k] = k - _'A');
for (k = _'a', k<=_'z', ++k, hash[k] = k - _'a' + 26);
for (k = _'0', k<=_'9', ++k, hash[k] = k - _'0' + 52);
hash[_'+'] = hash[_'-'] = 62;
hash[_'/'] = hash[_'_'] = 63;
s = ['$1'];
const ss = size(s);
ss>=2?(
resize(#-1,1,ss*3/4 - (s[ss-1]==_'=') - (s[ss-2]==_'='),1,1);
od = 0;
for (os = 0, os<size(s),
c1 = hash[s[os++]];
c2 = hash[s[os++]];
c3 = hash[s[os++]];
c4 = hash[s[os++]];
i[#-1,od++] = (c1<<2) | (c2>>4);
i[#-1,od++] = ((c2&15)<<4) | (c3>>2);
i[#-1,od++] = ((c3&3)<<6) | c4;
)
)"
nm. "[unnamed]"
v +
#@cli basename : file_path,_variable_name_for_folder
#@cli : Return the basename of a file path, and opt. its folder location.
#@cli : When specified 'variable_name_for_folder' must starts by an underscore
#@cli : (global variable accessible from calling function).
basename : skip ${2=unused}
v -
l[] ({"'$1'"}) replace 92,47 s +,47
if {i==47} a y $2={t} u ""
elif {$!==1} u {t} $2=""
else a[^-1] y u {t} $2={-2,t}
fi
rm endl
v +
#@cli bin : binary_int1,...
#@cli : Print specified binary integers into their octal, decimal, hexadecimal and string representations.
bin :
v - dec=${bin2dec\ ${^0}} v +
e[^-1] "Convert binary integer"${arg\ 1+($#>1),"",s}" '${^0}' to octal '"${dec2oct\ $dec}"',
decimal '"$dec"', hexadecimal '"${dec2hex\ $dec}"' and string '"${dec2str\ $dec}"'."
#@cli bin2dec : binary_int1,...
#@cli : Convert specified binary integers into their decimal representations.
bin2dec :
v - res=${_$0\ $1} repeat {$#-1} res=$res,${_$0\ ${arg\ $>+2,${^0}}} done u $res v +
_bin2dec :
({'${strlowercase\ $1}'})
is_negative=0
if {i[0]==45} z. 1,100% is_negative=1 fi
f. "if(i>=48 && i<=49,(i-48)*2^(w-1-x),nan)"
u {if($is_negative,-1,1)*{is}}
rm.
compress_gmic :
v -
s -,10 N=$!
ap _compress_gmic
s -,10 i[1--2] (10) a y
v +
_compress_gmic :
if {i==_'#'}
if {h<5" || "(!same([{^}],'#@gui',5)" && "!same([{^}],'#@cli',5)" && "!same([{^}],'#@web',5))} rm. (10) fi
else
l. s +,32,35 if {$!>2} k[0] fi a y endl
autocrop. 32 if {!w} rm. (10) fi
fi
compress_gmic_cli :
v -
s -,10 N=$!
ap _compress_gmic_cli
s -,10 i[1--2] (10) a y
v +
_compress_gmic_cli :
if {i==_'#'}
if {!same([{^}],'#@cli',5)" || (i[5]!=_' ' && i[5]!=_':')"} rm. (10) fi
else
l. s +,32,35 if {$!>2} k[0] fi a y endl
autocrop. 32 if {!w} rm. (10) fi
fi
compress_gmic_gui :
v -
s -,10 N=$!
ap _compress_gmic_gui
s -,10 i[1--2] (10) a y
v +
_compress_gmic_gui :
if {i==_'#'}
if {!same([{^}],'#@gui',5)} rm. (10) fi
else
l. s +,32,35 if {$!>2} k[0] fi a y endl
autocrop. 32 if {!w} rm. (10) fi
fi
#@cli dec : decimal_int1,...
#@cli : Print specified decimal integers into their binary, octal, hexadecimal and string representations.
dec :
e[^-1] "Convert decimal integer"${arg\ 1+($#>1),"",s}" '${^0}' to binary '"${dec2bin\ ${^0}}"',"\
" octal '"${dec2oct\ ${^0}}"', hexadecimal '"${dec2hex\ ${^0}}"' and string '"${dec2str\ ${^0}}"'."
#@cli dec2str : decimal_int1,...
#@cli : Convert specifial decimal integers into its string representation.
dec2str :
v - u {`[${^0}]`} v +
#@cli dec2bin : decimal_int1,...
#@cli : Convert specified decimal integers into their binary representations.
dec2bin :
v - res=${_$0\ $1} repeat {$#-1} res=$res,${_$0\ ${arg\ $>+2,${^0}}} done u $res v +
_dec2bin : check isint($1)
res="" r={abs($1)}
do res={$r%2}$res r={int($r/2)} while $r
u ${arg\ 1+($1>=0),-,""}$res
#@cli dec2hex : decimal_int1,...
#@cli : Convert specified decimal integers into their hexadecimal representations.
dec2hex :
v - res=${_$0\ $1} repeat {$#-1} res=$res,${_$0\ ${arg\ $>+2,${^0}}} done u $res v +
_dec2hex : check isint($1)
res="" r={abs($1)}
do res=${-_dec2hex_{$r%16}}$res r={int($r/16)} while $r
u ${arg\ 1+($1>=0),-,""}$res
_dec2hex_0 : u 0
_dec2hex_1 : u 1
_dec2hex_2 : u 2
_dec2hex_3 : u 3
_dec2hex_4 : u 4
_dec2hex_5 : u 5
_dec2hex_6 : u 6
_dec2hex_7 : u 7
_dec2hex_8 : u 8
_dec2hex_9 : u 9
_dec2hex_10 : u a
_dec2hex_11 : u b
_dec2hex_12 : u c
_dec2hex_13 : u d
_dec2hex_14 : u e
_dec2hex_15 : u f
#@cli dec2oct : decimal_int1,...
#@cli : Convert specified decimal integers into their octal representations.
dec2oct :
v - res=${_$0\ $1} repeat {$#-1} res=$res,${_$0\ ${arg\ $>+2,${^0}}} done u $res v +
_dec2oct : check isint($1)
res="" r={abs($1)}
do res={$r%8}$res r={int($r/8)} while $r
u ${arg\ 1+($1>=0),-,""}$res
#@cli fact : value
#@cli : Return the factorial of the specified value.
fact : check isint($1)
v - res=1 repeat $1 res*={($>+1)} done u $res v +
#@cli fibonacci : N>=0
#@cli : Return the Nth number of the Fibonacci sequence.
fibonacci : check "$1>=0"
u {N=$1;if(N<2,N,for(n=N;F0=0;F1=1,n=n-1,F2=F0+F1;F0=F1;F1=F2))}
#@cli file_mv : filename_src,filename_dest
#@cli : Rename or move a file from a location $1 to another location $2.
file_mv :
e[^-1] "Move file '$1' to location '$2'."
v - if ${-is_windows} x "move "$1" "$2 else x "mv "$1" "$2 fi v +
#@cli file_rand
#@cli : Return a random filename for storing temporary data.
file_rand :
v -
do filename=${-path_tmp}gmic$_pid{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}
while $filename
u $filename
v +
#@cli file_rm : filename
#@cli : Delete a file.
file_rm :
e[^-1] "Remove file '$1'."
v -
if ${-is_windows}
1 nm. "$1" dir={/{f}} base={/{b}} ext={/{x}} rm. com=""
if {narg($dir)} com="cd \""$dir"\\\" && " fi
if {narg($ext)} com=${com}"del \""$base.$ext"\"" else com=${com}"del \""$base"\"" fi
x $com
else
x "rm -f \"$1\""
fi
v +
#@cli filename : filename,_number1,_number2,...,_numberN
#@cli : Return a filename numbered with specified indices.
filename : skip "${1=default}"
v -
if {$#==1} u "$1"
else
(${2--1}) nm. "$1" u {f}{b}
repeat {w}
u ${}_{int(i/100000)%10}{int(i/10000)%10}{int(i/1000)%10}{int(i/100)%10}{int(i/10)%10}{i%10}
shift. -1
done
if {narg({'{x}'})} u ${}.{x} fi
rm.
fi
v +
#@cli files : _mode,path : (+)
#@cli : Return the list of files and/or subfolders from specified path.
#@cli : 'path' can be eventually a matching pattern.
#@cli : 'mode' can be { 0=files only | 1=folders only | 2=files + folders }.
#@cli : Add '3' to 'mode' to return full paths instead of filenames only.
#@cli : Default value: 'mode=5'.
#@cli fitratio_wh : min_width,min_height,ratio_wh
#@cli : Return a 2D size 'width,height' which is bigger than 'min_width,min_height' and has the specified w/h ratio.
fitratio_wh :
v - if {$3*$2>$1} u {int($3*$2)},$2 else u $1,{int($1/$3)} fi v +
#@cli fitscreen : width,height,_depth,_minimal_size[%],_maximal_size[%]
#@cli : Return the 'ideal' size WxH for a window intended to display an image of specified size on screen.
#@cli : Default values: 'depth=1', 'minimal_size=128' and 'maximal_size=85%'.
fitscreen : check "$1>=1 && $2>=1 && ${3=1}>=1 && ${4=128}>0 && ${5=85%}>0"
v -
eval "
is_percent(str) = (unref(_is_pct); _is_pct=['#str']; _is_pct[size(_is_pct) - 1]==_'%');
const u = "{*,u}";
const v = "{*,v}";
ms = round(is_percent($4)?[ u,v ]*$4:[ $4,$4 ]);
Ms = round(is_percent($5)?[ u,v ]*$5:[ $5,$5 ]);
s = [ $1,$2 ];
$3>1?(s+=$3);
s[0]<ms[0]?(s = [ ms[0],s[1]*ms[0]/s[0] ]);
s[1]<ms[1]?(s = [ s[0]*ms[1]/s[1],ms[1] ]);
s[0]>Ms[0]?(s = [ Ms[0],s[1]*Ms[0]/s[0] ]);
s[1]>Ms[1]?(s = [ s[0]*Ms[1]/s[1],Ms[1] ]);
s[0] = max(1,s[0],ms[0]);
s[1] = max(1,s[1],ms[1]);
round(s)"
v +
#@cli fontchart
#@cli : Insert G'MIC font chart at the end of the image list.
#@cli : $ fontchart
fontchart :
e[^-1] "Generate G'MIC font chart."
v - l[]
repeat 256
if {$>==92} char=\\ else char={`max(1,(c=$>;c>=23&&c<=28?32:c))`} fi
0 t. {``$char},0,0,50,1,255
done
a z,0.5
s z
repeat $!
t[$>] $>,1,-1,13,1,200
0 t. \\${dec2oct\ $>},1,-1,13,1,1
100%,100%,1,1,200 j[$>] .,{$>,[w,h]-[w#-1,h#-1]},0,0,1,.. rm[-2,-1]
done
frame 1,1,128 append_tiles ,
endl v +
font2cimgh :
e[^-1] "Encode font image$? as a C-style string for CImg.h."
v - repeat $! l[$>] bnm={0,b}
v + e[] "  > Encode font '"$bnm"'." v -
W,H={[w/256,h]}
if {!isint($W)} error[0--4] "Font image '"$bnm"' has wrong dimensions ("{[w,h,d,s]}")." fi
+f "i==im || i==iM" is_binary={im==1} rm.
Mm=0 MM=100
do
M={floor(($Mm+$MM)/2)}
+compress_rle $is_binary,$M rows. 6,100% +. {32-im} iM={iM}
if {iM<126} Mm=$M rm. elif {iM>126} MM=$M rm. fi
while {$iM!=126}
k. nb_chunks={1+int(h/65536)}
v + e[] "\r  > Encode font '"$bnm"' -> W = "$W", H = "$H", M = "$M", is_binary = "$is_binary", nb_chunks = "$nb_chunks"." v -
replace_str "\\","\\\\"
replace_str "\"","\\\""
s y,-111
repeat $!
if {$>,i[h-1]==_'\\'&&i[h-2]!=_'\\'} rows[$>] 0,{$>,h-2} rows[{$>+1}] -1,100% =[{$>+1}] {'\\'} fi
l[$>]
i[0] ({'"      \""'}) ({'\"'})
if {!$<} ({'" };"'}) fi
({'\n'})
y a y
endl
done
repeat {$nb_chunks-1} ind={int($!*($>+1)/$nb_chunks)} l[$ind] = {','},0,100% ({'\n'}) y a y endl done
i[0] ({'"    static const char *const data_font"${W}x${H}"[] = {"\n'})
y a y o raw:$bnm.h,uchar
endl done v +
#@cli fps
#@cli : Return the number of time this function is called per second, or -1 if this info is not yet available.
#@cli : Useful to display the framerate when displaying animations.
fps :
v -
if {narg($_fps_fps)}
dt={$|-$_fps_time}
if {$dt>1} _fps_fps={round($_fps_nbframes/$dt)} _fps_time=$| _fps_nbframes=0 fi
u $_fps_fps
_fps_nbframes+=1
else _fps_nbframes=0 _fps_time=$| _fps_fps=-1 u -1
fi
v +
#@cli gcd : a,b
#@cli : Return the GCD (greatest common divisor) between a and b.
gcd : check "isint($1) && isint($2) && $1*$2!=0"
v - _gcd {max(abs($1),abs($2))},{min(abs($1),abs($2))} v +
_gcd :
r={$1%$2} if $r u ${_gcd\ $2,$r} else u $2 fi
#@cli hex : hexadecimal_int1,...
#@cli : Print specified hexadecimal integers into their binary, octal, decimal and string representations.
hex :
v - dec=${hex2dec\ ${^0}} v +
e[^-1] "Convert hexadecimal integer"${arg\ 1+($#>1),s,""}" '${^0}' to binary '"${dec2bin\ $dec}"',
octal '"${dec2oct\ $dec}"', decimal '"$dec"' and string '"${dec2str\ $dec}"'."
#@cli hex2dec : hexadecimal_int1,...
#@cli : Convert specified hexadecimal integers into their decimal representations.
hex2dec :
v - res=${_$0\ $1} repeat {$#-1} res=$res,${_$0\ ${arg\ $>+2,${^0}}} done u $res v +
_hex2dec :
({'${strlowercase\ $1}'})
is_negative=0
if {i[0]==45} z. 1,100% is_negative=1 fi
f. "if(i>=48 && i<=57,i-48,if(i>=97 && i<=102,i-87,nan))*16^(w-1-x)"
u {if($is_negative,-1,1)*{is}}
rm.
#@cli hex2img : "hexadecimal_string"
#@cli : Insert new image 1xN at the end of the list with values specified by the given hexadecimal-encoded string.
hex2img :
v - ({'"$1"'}) 1,{w/2}
f. "*
from_char(x) = x>=48 && x<=57?x - 48:x-87;
off = 2*y;
from_char(i[#-2,off])*16 + from_char(i[#-2,off+1])"
rm.. v +
#@cli hex2str : hexadecimal_string
#@cli : Convert specified hexadecimal string into a string.
hex2str : skip ${1=""}
v -
if {!narg("$1")} u "" v + return fi
({'$*'}) if {w<2} rm. u "" v + return fi
f. 'v=i-if(i>=97,87,48);if(x%2,v,v*16)' r. 2,{int(w/2)},1,1,-1 cumulate. x z. 1,1
u {t} rm. v +
#@cli img2hex
#@cli : Return representation of last image as an hexadecimal-encoded string.
#@cli : Input image must have values that are integers in [0,255].
img2hex :
v - whds={w},{h},{d},{s} y. 2,{h}
f.. "*
to_char(x) = x>=0 && x<=9?48 + x:87 + x;
i(#-1,0,y) = to_char(int(i/16));
i(#-1,1,y) = to_char(i%16);
i"
u {t} rm. r. $whds,-1 v +
#@cli img2str
#@cli : Return the content of the latest of the selected images as a special G'MIC input string.
img2str :
v - i[-2] 256
eval. ">begin(off = 0);
sep = x==w - 1?(y==h - 1?(z==d - 1?(c==s - 1?0:_'^'):_'/'):_';'):_',';
it = vtos(i);
off + size(it) + 1>=w(#-2)?resize(#-2,round(1.5*w(#-2)),1,1,1,0);
for (k = 0, k<size(it) && it[k], ++k, i[#-2,off++] = it[k]);
i[#-2,off++] = sep"
u {-2,t} rm.. v +
#@cli img2text : _line_separator
#@cli : Return text contained in a multi-line image.
#@cli : Default value: 'line_separator= '.
img2text : skip "${1= }"
v - +l s y s -,0 y x if {$!>1} i[1--2] ({'"$1"'}) fi a x u {0,t} rm endl v +
#@cli img82hex
#@cli : Convert selected 8bits-valued vectors into their hexadecimal representations (ascii-encoded).
img82hex :
e[^-1] "Convert 8bits-valued vector$? into hexadecimal representations (ascii-encoded)."
v - % 256 y
repeat $!
+f[$>] 'v=int(i)&15;v+if(v<10,48,87)'
f[$>] 'v=int(i)>>4;v+if(v<10,48,87)'
a[$>,-1] x
done v +
#@cli hex2img8
#@cli : Convert selected hexadecimal representations (ascii-encoded) into 8bits-valued vectors.
hex2img8 :
e[^-1] "Convert hexadecimal representation$? (ascii-encoded) into 8bits-valued vectors."
v - repeat $!
s. x,2 f[-2,-1] 'if(i>=97,i-87,i-48)' *.. 16 +[-2,-1]
mv. 0 done v +
#@cli is_3d
#@cli : Return 1 if all of the selected images are 3D objects, 0 otherwise.
is_3d :
v - u 1 l check3d 1 onfail u 0 endl v +
_is_3d :
v - u {"h>6 && int(i[0])==67 && int(i[1])==73 && int(i[2])==109 && int(i[3])==103 && int(i[4])==51 && int(i[5])==100"} v +
#@cli is_ext : filename,_extension
#@cli : Return 1 if specified filename has a given extensioin.
is_ext : skip "${1=}"
v - 0 nm. "_$1" u {"lowercase(['"{x}"'])==lowercase(['$2'])"} rm. v +
#@cli is_image_arg : string
#@cli : Return 1 if specified string looks like '[ind]'.
is_image_arg : skip "${1=;}"
v -
u {"str = ['$1'];
s1 = size(str) - 1;
(str[0]==_'[' && str[s1]==_']') || (str[0]=='.' && str[s1]=='.') && min(str)>=45 && max(str)<=122"}
v +
#@cli is_pattern : string
#@cli : Return 1 if specified string looks like a drawing pattern '0x......'.
is_pattern : skip "${1=;}"
v - u {"str = ['$1']; size(str)>2 && same(str,'0x',2)"} v +
#@cli is_percent : string
#@cli : Return 1 if specified string ends with a '%', 0 otherwise.
is_percent :
v - u {"s=['$1'];s[size(s)-1]==_'%'"} v +
#@cli is_videofilename
#@cli : Return 1 if extension of specified filename is typical from video files.
is_videofilename : skip "${1=}"
v - 0 nm. "_$1" u {"
ext = lowercase(['"{x}"']);
ext=='avi' || ext=='mov' || ext=='asf' || ext=='divx' || ext=='flv' || ext=='mpg' ||
ext=='m1v' || ext=='m2v' || ext=='m4v' || ext=='mjp' || ext=='mp4' || ext=='mkv' ||
ext=='mpe' || ext=='movie' || ext=='ogm' || ext=='ogg' || ext=='ogv' || ext=='qt' || ext=='rm' ||
ext=='vob' || ext=='wmv' || ext=='xvid' || ext=='mpeg'"}
rm. v +
#@cli is_windows
#@cli : Return 1 if current computer OS is Windows, 0 otherwise.
is_windows :
v - u {narg($OS)==1" && "narg($WINDIR)==1} v +
#@cli math_lib
#@cli : Return string that defines a set of several useful macros for the embedded math evaluator.
math_lib :
v -
u "
dar_size(ind) = i[#ind,whd(#ind)-1];
dar_insert(ind,elt,pos) = (
_dar_pos = pos;
_dar_siz = dar_size(#ind);
if (_dar_pos<=_dar_siz,
_dar_siz>=h(#ind) - 1?resize(#ind,1,_dar_siz*2 + 2,1,s#ind,0);
for (_dar_c = 0, _dar_c<s#ind, ++_dar_c, copy(i(#ind,_dar_pos + 1,0,0,_dar_c),i(#ind,_dar_pos,0,0,_dar_c),_dar_siz - _dar_pos));
unref(_dar_elt); _dar_elt = elt;
copy(i[#ind,_dar_pos],_dar_elt,max(1,size(_dar_elt)),h(#ind),1);
(dar_size(ind#)) = ++_dar_siz;
);
);
dar_insert(ind,elt) = (
_dar_siz = dar_size(#ind);
_dar_siz>=h(#ind) - 1?resize(#ind,1,_dar_siz*2 + 2,1,s#ind,0);
unref(_dar_elt); _dar_elt = elt;
copy(i[#ind,_dar_siz],_dar_elt,max(1,size(_dar_elt)),h(#ind),1);
(dar_size(ind#)) = ++_dar_siz;
);
dar_remove(ind,pos) = (
_dar_pos = pos;
_dar_siz = dar_size(#ind);
if (_dar_pos<_dar_siz,
_dar_siz = --dar_size(#ind);
for (_dar_c = 0, _dar_c<s#ind, ++_dar_c, copy(i(#ind,_dar_pos,0,0,_dar_c),i(#ind,_dar_pos + 1,0,0,_dar_c),_dar_siz - _dar_pos));
)
);
dar_remove(ind) = (
_dar_siz = dar_size(#ind);
_dar_size>0?dar_size(#ind) = --_dar_size;
);
dist(A,B) = (
norm(B - A);
);
dist(X,A,B) = (
AB = B - A;
P = A + dot(X - A,B - A)/max(1e-8,dot(AB,AB))*AB;
dot(P - A,P - B)<=0?norm(P - X):min(norm(A - X),norm(B - X));
);
dist(A,B,C,D) = (
min(dist(A,C,D),dist(B,C,D),dist(C,A,B),dist(D,A,B));
);
search_dichotomic(fn_x,target,epsilon,xmin,xmax) = (
_dicho_fn(x) = _dicho_sgn*(fn_x);
_dicho_epsilon = epsilon;
_dicho_m = xmin;
_dicho_M = xmax;
_dicho_sgn = 1;
_dicho_autom = isnan(_dicho_m);
_dicho_autoM = isnan(_dicho_M);
if (_dicho_autom, _dicho_m = -1);
if (_dicho_autoM, _dicho_M = 1);
_dicho_sgn = _dicho_fn(_dicho_m)>_dicho_fn(_dicho_M)?-1:1;
_dicho_res = nan;
_dicho_target = _dicho_sgn*target;
_dicho_nb_attempts = 30;
_dicho_autom?do (_dicho_fm = _dicho_fn(_dicho_m); _dicho_fm<_dicho_target?break(); _dicho_m*=2; _(while), --_dicho_nb_attempts);
_dicho_nb_attempts?(
_dicho_autoM?do (_dicho_fM = _dicho_fn(_dicho_M); _dicho_fM>_dicho_target?break(); _dicho_M*=2; _(while), --_dicho_nb_attempts);
_dicho_nb_attempts?(
_dicho_nb_attempts = 100;
do (
_dicho_c = (_dicho_m + _dicho_M)/2;
_dicho_fc = _dicho_fn(_dicho_c);
abs(_dicho_fc - _dicho_target)<_dicho_epsilon?(_dicho_res = _dicho_c; break()):
_dicho_fc<_dicho_target?(_dicho_m = _dicho_c):
(_dicho_M = _dicho_c);
_(while), --_dicho_nb_attempts
);
);
);
_dicho_res;
);
search_dichotomic(fn_x,target,epsilon) = search_dichotomic(fn_x,target,1e-3,nan,nan);
search_dichotomic(fn_x,target) = search_dichotomic(fn_x,target,1e-3);
search_dichotomic(fn_x) = search_dichotomic(fn_x,0);
arrow(ind,P0,P1,angle,length,opacity,color) = (
unref(_da_color);
_opacity = opacity;
_da_color = color;
_P0 = P0;
_P1 = P1;
_P0P1 = _P1;
_P0P1-=_P0;
if (length<0, _P0P1*=-length/100, _P0P1*=length/norm2(_P0P1));
coords = [ _P0,_P1,_P1,_P1 - rot(angle)*_P0P1,_P1,_P1 - rot(-angle)*_P0P1 ];
for (_k = 0, _k<3, ++_k,
polygon(#ind,2,coords[4*_k,2],coords[4*_k+2,2],_opacity,_da_color);
);
);
spline(ind,P0,T0,P1,T1,opacity,color) = (
unref(_ds_color);
_P0 = P0;
_P1 = P1;
_opacity = opacity;
_ds_color = resize(color,s#ind)*=abs(_opacity);
_omopacity = 1 - max(_opacity,0);
_C = mul([ 2,-2,1,1,-3,3,-2,-1,0,0,1,0,1,0,0,0 ],[ _P0,P1,T0,T1 ],2);
_dt = _dtmin = 1/max(abs(_P1 - _P0));
_P0 = inf;
for (_t = 0, _t<=1, _t+=_dt,
_P = round(mul([_t^3,_t^2,_t,1],_C,2));
_dP = abs(mul([3*_t^2,2*_t,1,0],_C,2));
_dt = min(_dtmin,0.75/max(_dP));
if (_P0!=_P, I(#ind,_P) = _ds_color + _omopacity*I(#ind,_P));
_P0 = _P;
);
nan;
);
triangle(ind,P0,P1,P2,opacity,color0,color1,color2) = (
unref(_dt_color);
unref(_dt_color0);
unref(_dt_color1);
unref(_dt_color2);
_opacity = opacity;
_dt_color0 = resize(color0,s#ind);
_dt_color1 = resize(color1,s#ind);
_dt_color2 = resize(color2,s#ind);
_A = round(P0);
_B = round(P1);
_C = round(P2);
_xmin = max(0,min(_A[0],_B[0],_C[0]));
_xmax = min(w#ind-1,max(_A[0],_B[0],_C[0]));
_ymin = max(0,min(_A[1],_B[1],_C[1]));
_ymax = min(h#ind-1,max(_A[1],_B[1],_C[1]));
_M = transp([_A,1,_B,1,_C,1],3);
for (_y = _ymin, _y<_ymax, ++_y,
for (_x = _xmin, _x<_xmax, ++_x,
_L = round(solve(_M,[_x,_y,1]),1e-5);
if (min(_L)>=0,
_dt_color = _L[0]*_dt_color0 + _L[1]*_dt_color1 + _L[2]*_dt_color2;
copy(i(#ind,_x,_y,0,0),_dt_color,size(_dt_color),whd#ind,1,_opacity);
);
);
);
nan;
);
hsv2rgb(I) = (
_I = I;
_I[0]%=360;
_I[1] = cut(_I[1],0,1);
_I[2] = cut(_I[2],0,1);
_c = _I[2]*_I[1];
_x = _c*(1-abs((_I[0]/60)%2-1));
(arg(1 + int(_I[0]/60),[_c,_x,0],[_x,_c,0],[0,_c,_x],[0,_x,_c],[_x,0,_c],[_c,0,_x])+=_I[2] - _c)*=255;
);
is_intriangle(P,A,B,C) = (
_v0 = C - A;
_v1 = B - A;
_v2 = P - A;
_dot00 = dot(_v0,_v0);
_dot01 = dot(_v0,_v1);
_dot02 = dot(_v0,_v2);
_dot11 = dot(_v1,_v1);
_dot12 = dot(_v1,_v2);
_invDenom = 1/(_dot00*_dot11 - _dot01*_dot01);
_u = (_dot11*_dot02 - _dot01*_dot12)*_invDenom;
_v = (_dot00*_dot12 - _dot01*_dot02)*_invDenom;
_u>=0 && _v>=0 && _u + _v<1);
is_inquadrilateral(P,A,B,C,D) = (
is_intriangle(P,A,B,D) || is_intriangle(P,B,C,D);
);
is_percent(str) = (unref(_is_pct); _is_pct=['#str']; _is_pct[size(_is_pct) - 1]==_'%');
length_spline(P0,T0,P1,T1) = (
_P0 = P0;
_P1 = P1;
_C = mul([ 2,-2,1,1,-3,3,-2,-1,0,0,1,0,1,0,0,0 ],[ _P0,_P1,T0,T1 ],2);
_l = norm(_P1 - _P0);
if (_l,
_nl = _l + 1;
_dt = 1/_l;
while (_nl - _l>=0.01,
_l = _nl;
_nl = 0;
__P0 = _P0;
for (_t = 0, _t<=1, _t+=_dt,
__P = mul([_t^3,_t^2,_t,1],_C,2);
_nl+=norm(__P - __P0);
__P0 = __P;
);
_dt = 1/max(1,_nl);
);
);
_l
);
map(V,x,fnx) = (
unref(x#,_#x);
for (_#x = 0, _#x<size(V#), ++_#x, x# = V#[_#x]; V#[_#x] = fnx#);
V#;
);
pexp(x) = (
_pexp_x = abs(x);
_pexp_x<2?-0.110353*_pexp_x^4 + 0.683221*_pexp_x^3 -1.17282*_pexp_x^2 + 1:0
);
proj(X,A,B) = (
_AB = B - A;
P = A + dot(X - A,_AB)/max(1e-8,dot(_AB,_AB))*_AB;
);
"
v +
#@cli mad
#@cli : Return the MAD (Maximum Absolute Deviation) of the last selected image.
#@cli : The MAD is defined as MAD = med_i|x_i-med_j(x_j)|
mad :
v - if $! +-. {ic} abs. u {1.4826*ic} rm. else u 0 fi v +
#@cli max_w
#@cli : Return the maximal width between selected images.
max_w :
v - u {arg(1,${_max_whds\ 4})} v +
#@cli max_h
#@cli : Return the maximal height between selected images.
max_h :
v - u {arg(2,${_max_whds\ 4})} v +
#@cli max_d
#@cli : Return the maximal depth between selected images.
max_d :
v - u {arg(3,${_max_whds\ 4})} v +
#@cli max_s
#@cli : Return the maximal spectrum between selected images.
max_s :
v - u {arg(4,${_max_whds\ 4})} v +
#@cli max_wh
#@cli : Return the maximal wxh size of selected images.
max_wh :
v - _max_whds 2 v +
#@cli max_whd
#@cli : Return the maximal wxhxd size of selected images.
max_whd :
v - _max_whds 3 v +
#@cli max_whds
#@cli : Return the maximal wxhxdxs size of selected images.
max_whds :
v - _max_whds 4 v +
_max_whds :
w=0 h=0 d=0 s=0
repeat $!
w={max($w,w)}
h={max($h,h)}
d={max($d,d)}
s={max($s,s)}
mv. 0 done
if {$1>=4} u $w,$h,$d,$s
elif {$1==3} u $w,$h,$d
elif {$1==2} u $w,$h
else u $w
fi
#@cli med
#@cli : Return the median value of the last selected image.
med :
v - u {ic} v +
#@cli median_color
#@cli : Return the median color value of the last selected image.
median_color :
v - u "" s="" repeat {s} +channels. $> u ${}$s${med.} s=, rm. done v +
#@cli min_w
#@cli : Return the minimal width between selected images.
min_w :
v - u {arg(1,${_min_whds\ 4})} v +
#@cli min_h
#@cli : Return the minimal height between selected images.
min_h :
v - u {arg(2,${_min_whds\ 4})} v +
#@cli min_d
#@cli : Return the minimal depth between selected images.
min_d :
v - u {arg(3,${_min_whds\ 4})} v +
#@cli min_s
#@cli : Return the minimal s size of selected images.
min_s :
v - _min_s ${_min_whds\ 4} v +
_min_s :
u $4
#@cli min_wh
#@cli : Return the minimal wxh size of selected images.
min_wh :
v - _min_whds 2 v +
#@cli min_whd
#@cli : Return the minimal wxhxd size of selected images.
min_whd :
v - _min_whds 3 v +
#@cli min_whds
#@cli : Return the minimal wxhxdxs size of selected images.
min_whds :
v - _min_whds 4 v +
_min_whds :
w={w} h={h} d={d} s={s}
repeat $!
w={min($w,w)}
h={min($h,h)}
d={min($d,d)}
s={min($s,s)}
mv. 0 done
if {$1>=4} u $w,$h,$d,$s
elif {$1==3} u $w,$h,$d
elif {$1==2} u $w,$h
else u $w
fi
#@cli normalize_filename : filename
#@cli : Return a "normalized" version of the specified filename, without spaces and capital letters.
normalize_filename :
v - ({'"$1"'}) f. 'if(i>=65&&i<=90,i+32,if(i==32,95,i))' u {t} rm. v +
#@cli oct : octal_int1,...
#@cli : Print specified octal integers into their binary, decimal, hexadecimal and string representations.
oct :
v - dec=${oct2dec\ ${^0}} v +
e[^-1] "Convert octal integer"${arg\ 1+($#>1),"",s}" '${^0}' to binary '"${dec2bin\ $dec}"', decimal '"$dec"',
hexadecimal '"${dec2hex\ $dec}"' and string '"${dec2str\ $dec}"'."
#@cli oct2dec : octal_int1,...
#@cli : Convert specified octal integers into their decimal representations.
oct2dec :
v - res=${_$0\ $1} repeat {$#-1} res=$res,${_$0\ ${arg\ $>+2,${^0}}} done u $res v +
_oct2dec :
({'${strlowercase\ $1}'})
is_negative=0
if {i[0]==45} z. 1,100% is_negative=1 fi
f. "if(i>=48 && i<=55,(i-48)*8^(w-1-x),nan)"
u {if($is_negative,-1,1)*{is}}
rm.
#@cli padint : number,_size>0
#@cli : Return a integer with 'size' digits (eventually left-padded with '0').
padint : check "isint($1)" skip ${2=4}
v - u "" repeat $2 u ${}{int($1/10^$<)%10} done v +
#@cli path_gimp
#@cli : Return a path to store GIMP configuration files for one user (whose value is OS-dependent).
path_gimp :
v -
if {!narg({'$_path_gimp'})}
if {narg({'${GIMP2_DIRECTORY}'})} _path_gimp=${GIMP2_DIRECTORY}
elif {narg({'${USERPROFILE}'})} _path_gimp=${USERPROFILE}
elif {narg({'${HOME}'})} _path_gimp=${HOME}
fi
if ${-is_windows} sep=\\ else sep=/ fi
if $_path_gimp${sep}AppData${sep}Roaming${sep}GIMP${sep}2.10${sep}pluginrc
_path_gimp=$_path_gimp${sep}AppData${sep}Roaming${sep}GIMP${sep}2.10${sep}
elif $_path_gimp${sep}.gimp-2.8${sep}pluginrc
_path_gimp=$_path_gimp${sep}.gimp-2.8${sep}
elif $_path_gimp${sep}.gimp-2.6${sep}pluginrc
_path_gimp=$_path_gimp${sep}.gimp-2.6${sep}
else
_path_gimp=${-path_tmp}
fi
fi
u $_path_gimp
v +
#@cli path_tmp
#@cli : Return a path to store temporary files (whose value is OS-dependent).
path_tmp :
v -
if {!narg({'$_path_tmp'})}
if {narg({'${TMP}'})} _path_tmp=${TMP}
elif {narg({'${TEMP}'})} _path_tmp=${TEMP}
elif {narg({'${TMPDIR}'})} _path_tmp=${TMPDIR}
elif {narg({'${HOME}'})} _path_tmp="/tmp"
fi
if ${-is_windows} _path_tmp=$_path_tmp{`92`} else _path_tmp=$_path_tmp/ fi
fi
u $_path_tmp
v +
#@cli reset
#@cli : Reset global parameters of the interpreter environment.
reset :
e[^-1] "Reset global parameters of the interpreter environment."
v -1 db3d m3d md3d f3d l3d sl3d ss3d v +
#@cli RGB
#@cli : Return a random int-valued RGB color.
RGB :
v - u {round(u(255))},{round(u(255))},{round(u(255))} v +
#@cli RGBA
#@cli : Return a random int-valued RGBA color.
RGBA :
v - u {round(u(255))},{round(u(255))},{round(u(255))},{round(u(255))} v +
#@cli std_noise
#@cli : Return the estimated noise standard deviation of the last selected image.
std_noise :
v - if $! +laplacian. -. {ic} abs. u {1.4826*ic/sqrt(d==1?20:42)} rm. else u 0 fi v +
#@cli str : string
#@cli : Print specified string into its binary, octal, decimal and hexadecimal representations.
str : skip $1
v - dec={'$*'} v +
e[^-1] "Convert string '$*' to binary '"${dec2bin\ $dec}"', octal '"${dec2oct\ $dec}"', decimal '"$dec"' and
hexadecimal '"${dec2hex\ $dec}"'."
#@cli str2hex : string
#@cli : Convert specified string into a sequence of hexadecimal values.
str2hex :
v - ({'"$*"'}) y. r. 2,100% f. 'v=if(x,i%16,int(i/16));if(v<=9,48+v,87+v)' u {t} rm. v +
#@cli strcontains : string1,string2
#@cli : Return 1 if the first string contains the second one.
strcontains :
v - l[] ({'"$1"'}) s +,{'"$2"'} u {$!>1} rm endl v +
#@cli strlen : string1
#@cli : Return the length of specified string argument.
strlen : skip "${1=}"
v - u {narg({'"$1"'})} v +
#@cli strreplace : string,search,replace
#@cli : Search and replace substrings in an input string.
strreplace : skip "${3=}"
v -
if {narg("$3")}
ls=${strlen\ "$2"}
lr={${strlen\ "$3"}-1}
l[] ({'"$1"'}) s +,{'"$2"'} s y,-$ls
repeat $! if {[{$>,^}]==['"$2"']} rows[$>] 0,$lr f[$>] {'"$3"'} fi done
a y u {t} rm endl
else
l[] ({'"$1"'}) s -,{'"$2"'} a y u {t} rm endl
fi
v +
#@cli strlowercase : string
#@cli : Return a lower-case version of the specified string.
strlowercase :
v - ({'"$*"'}) +. 'if(i>=65&&i<=90,32,0)' u {t} rm. v +
#@cli strvar : string
#@cli : Return a simplified version of the specified string, that can be used as a variable name.
strvar :
v - ({'"$*"'}) f. "
(i>=_'0' && i<=_'9') || (i>=_'a' && i<=_'z') || i==_'_'?i:
(i>=_'A' && i<=_'Z')?i - _'A' + _'a':
_'_'"
if {"i>=_'0' && i<=_'9'"} r. {w+1},1,1,1,0,0,1 =. {_'_'} fi
y. do h={h} replace_str. "__","_" while {h!=$h}
u {t} rm. v +
#@cli strver : _version
#@cli : Return the specified version number of the G'MIC interpreter, as a string.
#@cli : Default value: 'version=$_version'.
strver : check ${1=$_version}>0
v - ({'$1'}) r. {2*w-1} f. 'if(x%2,_'.',i)' u {t} rm. v +
#@cli tic
#@cli : Initialize tic-toc timer.
#@cli : Use it in conjunction with 'toc'.
tic :
e[^-1] "Initialize timer."
v - if {!narg($_ticpos)} _ticpos=0 fi _tic$_ticpos=$| _ticpos={$_ticpos+1} v +
#@cli toc
#@cli : Display elapsed time of the tic-toc timer since the last call to 'tic'.
#@cli : This command returns the elapsed time in the status value.
#@cli : Use it in conjunction with 'tic'.
toc :
v - _ticpos={$_ticpos-1} u {_$|-${_tic$_ticpos}} v +
e[^-1] "Elapsed time: "${}" s".
#@cli uchar2base64 : _encoding={ 0=base64 | 1=base64url }
#@cli : Encode the values of the latest of the selected images as a base64-encoded string.
#@cli : The string can be decoded using command 'base642uchar'.
#@cli : Selected images must have values that are integers in [0,255].
#@cli : Default values: 'encoding=0'.
uchar2base64 : skip "${1=0}"
v -
if {isval("$1")} encoding=$1 else encoding=0 noarg fi
{ceil(whds*4/3)+([0,2,1])[whds%3]}
eval "
hash = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
"$encoding"?(hash[62] = _'-'; hash[63] = _'_');
od = ov = n = 0;
for (os = 0, os<whds#-2,
v = i[#-2,os++]&255;
n==0?(i[#-1,od++] = hash[v>>2]; ov = v; n = 1):
n==1?(i[#-1,od++] = hash[((ov&3)<<4) | (v>>4)]; ov = v; n = 2):
(i[#-1,od++] = hash[((ov&15)<<2) | (v>>6)]; i[#-1,od++] = hash[v&63]; n = 0);
);
n==1?(i[#-1,od++] = hash[((ov&3)<<4)]; copy(i[#-1,od],_'=',2,1,0); od+=2):
n==2?(i[#-1,od++] = hash[((ov&15)<<2)]; i[#-1,od++] = _'=');
"
u {t} rm. v +
#@cli img2base64 : _encoding={ 0=base64 | 1=base64url }
#@cli : Encode selected images as a base64-encoded string.
#@cli : The images can be then decoded using command 'base642img'.
#@cli : Default values: 'encoding=0'.
img2base64 : skip "${1=0}"
v -
if {isval("$1")} encoding=$1 else encoding=0 noarg fi
+serialize u ${uchar2base64\ $encoding} rm.
v +
#@cli average_colors
#@cli : Return the average vector-value of the latest of the selected images.
average_colors :
v -
res=""
repeat {s-1} sh. {1+$>} res=$res,{ia} rm. done
sh. 0 u {ia}$res rm.
v +
#@cli covariance_colors : _avg_outvarname
#@cli : Return the covariance matrix of the vector-valued colors in the latest of the selected images (for arbitrary number of channels).
#@cli : Parameter 'avg_outvarname' is used as a variable name that takes the value of the average vector-value.
covariance_colors : skip "${1=avg}"
v -
$1=${-average_colors}
f ">begin(avg = [ "$""$1" ]; const S2 = s^2; C = vectorS2(0); ); mI = I - avg; C+=mul(mI,mI,s); end(C/=whd - 1; ext('u ',vtos(C))); I"
v +
#@cli :: Other Interactive Commands
#@cli demo : _run_in_parallel={ 0=no | 1=yes | 2=auto }
#@cli : Show a menu to select and view all G'MIC interactive demos.
demo : check "isint(${1=2}) && $1>=0 && $1<=2"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v -
use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r
strver=${-strver}
if {narg($_prerelease)} strver=${strver}_pre#$_prerelease fi
v +
e[] "\n
------ "${g}"G\47MIC demos"$n" ------------------\n
----\n
---- "${c}"Mouse button"$n" to select a demo.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------"
v - l[]
entries="2048 game","Blobs Editor","Bouncing Balls","Connect Four","Fire Effect","Fireworks","Fish-Eye Effect",\
"Fourier Filtering","Tower of Hano\357","Histogram Demo","Hough Transform","Jawbreaker","Virtual Landscape","The Game of Life",\
"Light Effect","Mandelbrot Explorer","3D Metaballs","Minesweeper","Minimal Path","Pacman","Paint",\
"Plasma Effect","RGB Quantization","3D Reflection","3D Rubber Object","Shade Bobs","Spline Editor","3D Starfield",\
"Tetris","Tic-Tac-Toe","Image Waves","Fractal Whirls","Color Curves"
commands=x_2048,x_blobs,x_bouncing,x_connect4,x_fire,x_fireworks,x_fisheye,\
x_fourier,x_hanoi,x_histogram,x_hough,x_jawbreaker,x_landscape,x_life,\
x_light,x_mandelbrot,x_metaballs3d,x_minesweeper,x_minimal_path,x_pacman,x_paint,\
x_plasma,x_quantize_rgb,x_reflection3d,x_rubber3d,x_shadebobs,x_spline,x_starfield3d,\
x_tetris,x_tictactoe,x_waves,x_whirl,_demo_color_curves
nb_entries={narg($entries)}
parallel_mode={1-if($1!=2,$1,$_cpus>=2)}
strver=${-strver}
if {narg($_prerelease)} strver.=_pre#$_prerelease fi
l[]
repeat $nb_entries
arg 1+$>,$entries entry=${}
0 t. $entry,0,0,24,1,1
done
r ${-max_wh},1,1,0,0,0.5,0.5
frame 12,6,0 a z
+n[0] 0,255
+shift[0] 1,3,0,0 max[0,-1]
+f[0] z+1
1,1,100%,3,u(128,255) r. 1,[0],[0],3 *. 'y/(h-1)' r. [0],[0],[0],3,3
100%,100%,1,1,"x = min(x,w-1-x); y = min(y,h-1-y); (x*y/wh)^0.7>0.01"
+dilate. 3 xor.. .
+[0] ..
*.. 100 +[1,-2]
*[2,3] .
rm.
frame 4,4,0
a c s z
append_tiles 3 s c
to_rgb[1] a[3-5] c
0 t. "G\'MIC demos",2,2,32,1,1,1,1
if $_prerelease 0 t. "Version:\n"$strver,40,1,18,1,1,1,1 rows. 2,100%
else 0 t. "Version: "$strver,40,1,18,1,1,1,1 rows. -2,100%
fi
a[-2,-1] x,0.5
b. 0.5 n. 0,1
(32;255^255;255^0;0) r. ..,..,1,3,3 *[-2,-1] round. 1,-1 +!=. 0 channels. 1
s=8
r[^-2,-1] 100%,{h+h#0+2*$s+6},1,100%,0,0,0,1
rectangle[0] 0,$s,100%,{$s+6+h-1},1,0.6
rectangle[1] 0,$s,100%,{$s+6+h-1},1,120,120,32
j[0] .,{(w#0-w)/2},{$s+3},0,0,-1
j[1] ..,{(w#0-w)/2},{$s+3},0,0,1,. rm[-2,-1]
c[0] 0,1
nm menu_opac,menu_fgcol,menu_ind,menu_bgcol
endl
arrow3d 20,20,0,0,0,0,20%,40%,40% col3d. 255,128,0 nm. cursor3d
l[]
n=16
chromeball64x64[] 200,100,64 n. 0,230 s. c,-3
rgb2hsv.. r.. 100%,100%,$n,3 f.. "[z*360/d,G,B]" hsv2rgb..
N={6*$n} P={2*$N-1}
i[0] ({'CImg3d'}) i[1] ($N,$P) i[2] 3,$N
i[3] 2,$N,1,1,"x?y:1" i[4] 3,{$N-1},1,1,"x==0?2:x==1?y:y+1" y[3,4] a[3,4] y
l[4]
s z i[0--2] (-128,{w},{h},3) 4,{$N-$n},1,1,'x==0?-128:x==1?y%$n:0'
3,{$P-$N},1,1,200 y a y
endl
l[5]
n 0,0.5 i[0] (-128,{w},{h},1) 4,{$N-1},1,1,-128,0,0,0
1,{$P-$N},1,1,0.25 y a y
endl
y a y
nm background3d
endl
{menu_fgcol,[w,h]},1,3 +plasma. 1,1,5 n. 0,230 water. 100
(0.1;0.03^0;0.1^0.2;0.1) r. ..,3 *[-2,-1]
(0;1) r. ..,..,1,1,3 pow. 1.5 n. 0.2,1.15 *[-2,-1] n. 0,128
nm. background
w. -1,-1,0,"[G'MIC - "$strver"]" cursor 0
omb,ind_clicked,cfx,cfy,cfz,alpha=0
nfx,nfy,nfz={[g,g,g]} time0={$|-4}
do
mx,my,mb={menu_fgcol,x={*,x};y={*,y};[x<0?-1:x*(w-1)/({*,w}-1),y<0?-1:y*(h-1)/({*,h}-1),{*,b}]}
ind={menu_ind,i($mx,$my)}
if {$mb" && "!$ind_clicked} ind_clicked=$ind fi
[background]
3,$N,1,1,"const t = 0.8*"$|"; const a = "$alpha"; const oma = 1 - a;
x==0?oma*cos("$cfx"*y + t) + a*cos("$nfx"*y + t):
x==1?oma*sin("$cfy"*y + t) + a*sin("$nfy"*y + t):
oma*sin("$cfz"*y + t) + a*sin("$nfz"*y + t)"
y.
j[background3d] .,0,8 rm.
+r3d[background3d] 1,2,3,{20*$|} *3d. {menu_fgcol,[w,h]/2-30},300 +3d. 0,0,300
j3d.. .,50%,50%,0,1,1,0,0,200 rm.
if {$|-$time0>5} alpha+=0.02 fi
if {$alpha>1} alpha-=1 cfx,cfy,cfz=$nfx,$nfy,$nfz nfx,nfy,nfz={[g,g,g]} time0={$|-u*3} fi
if {$ind>0} +==[menu_ind] $ind j.. [menu_bgcol],0,0,0,0,{$mb" && "$ind_clicked==$ind?0.6:1},. rm. fi
j. [menu_fgcol],0,0,0,0,1,[menu_opac]
if {$mx>0}
+r3d[cursor3d] 1,1.3,0.6,{50*cos($|)}
j3d.. .,$mx,$my,0,1,4,0,0,800,{-2,[w,h]/2},-1000,0.7 rm.
fi
w. -1,-1,0
if {{*,CTRLLEFT}&&{*,D}} w. 150%,150% elif {{*,CTRLLEFT}&&{*,C}} w. 100%,100% fi
rm.
if {!$mb" && "$omb" && "$ind_clicked" && "$ind_clicked==$ind}
m "com : v 0 "${arg\ $ind,$commands} parallel $parallel_mode,"l[] com v -1 rm endl" uncommand com
elif {!$mb} ind_clicked=0
fi
omb=$mb
wait 20
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 endl v 0 e[] ""
_demo_color_curves :
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
if {!narg($__demo_color_curve)}
e[] "\n
------ "${g}"Color curves"$n" ----------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" on a curve creates a new control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" on a control point deletes it.\n
---- "${c}"Left mouse button"$n" on the main image window shows the initial image until button is released.\n
---- "${c}"Right mouse button"$n" on the main image window adds a keypoint to all curves from picked color.\n
---- Key '"${c}"R"$n"' on a curve resets it.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' close the current window.\n
----\n
------------------------------------------------------------------------------------------------"
v - __demo_color_curve=1 l[] do rm sp ? while {s!=3} endl x_color_curves rgb __demo_color_curve= v +
else
e[] "\n
------ "${g}"Color curves"$n" ----------------------------------------------------------------------------\n
----\n
---- Only "${c}"one session"$n" allowed at the same time !\n
----\n
------------------------------------------------------------------------------------------------"
fi
#@cli x_2048
#@cli : Launch the 2048 game.
x_2048 :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"2048"$n" -----------------------------------------------\n
----\n
---- Join the numbers and get to the "${g}"2048"$n" tile!\n
----\n
---- Use your "${c}"arrow keys"$n" to move the tiles. When two tiles\n
---- with the same number touch, they merge into one!\n
---- This command is a port of the '"${c}"2048"$n"' game originally\n
---- designed by "${c}"Gabriele Cirulli"$n", and available at:\n
---- "${g}"http://gabrielecirulli.github.io/2048/"$n"\n
----\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
v - l[]
score=0 f3d 50 m3d 0
m "_x_2048_setrandom : +==[0] 0 f. 'if(i,4*y+x,-1)' discard. -1
off={i[round(u(h-1))]} rm. x={$off&3} y={$off>>2} n={if(u<0.75,1,2)}
=[0] $n,$x,$y [{2+$n}] c3d.
repeat 6 j3d[1] .,{78+$x*121},{190+$y*121},{10*$<},{(1+$>)/6} w[1] wait 20 done
rm."
m "_x_2048_object3d : +f[0] 'if(i,i*16+4*y+x,-1)' discard. -1
N={h} repeat {h} v={-{1+$>},@$>} ++3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} done
+3d[-$N--1] rm.."
i[0] 4,4
b0=204,192,179 b1=238,228,218 b2=237,224,200 b3=242,177,121
b4=245,149,99 b5=246,124,95 b6=246,94,59 b7=237,207,114
c0=119,110,101 c1=249,246,242 s0=" "
520,630,1,3 fc. 250,248,239
t. "2048",20,10,86,1,$c0
t. "Join the numbers and get to the 2048 tile!",20,90,20,1,$c0
rectangle. 422,20,501,75,1,187,173,160 t. "SCORE",439,25,15,1,238,228,218
repeat 12
107,107,1,3 fc. ${b{min($>,7)}} +fc. ${c{$>>2}}
s1={2^$>} 0 t. ${s{$>>0}},0,0,52,1,1
r. ..,..,1,1,0,0,0.5,0.5 dilate_circ. 3 b. 0.5
j... ..,0,0,0,0,1,.,1 rm[-2,-1]
done
frame_round[2--1] 10,5,1,0.5,187,173,160 frame[2--1] 7,7,187,173,160 to_rgb[2--1]
r[2] 400%,400%,1,3,0,2 j[1] [2],18,130
sprite3d[3--1]
w[1] 100%,100%,0,"[G"{`39`}"MIC] 2048" insert_new=1
repeat 2 _x_2048_setrandom done
do
if $insert_new
_x_2048_object3d *3d. 121 j[1] [2],18,130 j3d[1] .,78,190 rm.
80,25,1,3 fc. $c1 0 t. $score,0,0,25,1,1,1,1 r. ..,0,0,0.5,0.8
rectangle[1] 422,45,501,69,1,187,173,160 j[1] ..,422,45,0,0,1,. rm[-2,-1]
w[1] insert_new=0
fi
++[0] 1 f. 'j(-1)==i||j(1)==i||j(0,-1)==i||j(1,0)==i||i==1'
if {0,iM==11}
alert "Game Over","\nCongratulations! You got the 2048 title!\n\n   Your score: "$score,"OK"
break
elif {!iM}
alert "Game Over","\nBad luck! You lost the game!\n\n   Your score: "$score,"OK"
break
fi
rm.
wait
is_shift=0 uncommand shift2048,ishift2048,vshift2048
if {*,ARROWLEFT}
m "shift2048:" m "ishift2048:" m "vshift2048:"
is_shift=1
elif {*,ARROWRIGHT}
m "shift2048: rotate 180" m "ishift2048: rotate 180"
m "vshift2048: s3d l[2] r 3,{h/3},1,1,-1 s x -[0,1] 3 *[0,1] -1 a x y endl a y"
is_shift=1
elif {*,ARROWUP}
m "shift2048: rotate -90" m "ishift2048: rotate 90"
m "vshift2048: s3d l[2] r 3,{h/3},1,1,-1 s x rv[0,1] -[0] 3 *[0] -1  a x y endl a y"
is_shift=1
elif {*,ARROWDOWN}
m "shift2048: rotate 90" m "ishift2048: rotate -90"
m "vshift2048: s3d l[2] r 3,{h/3},1,1,-1 s x rv[0,1] -[1] 3 *[1] -1  a x y endl a y"
is_shift=1
fi
if {*,r} w[1] 100%,100% fi
if $is_shift
wait -1
shift2048[0]
repeat 2
_x_2048_object3d
+s[0] y discard[-4--1] 0 y[-4--1] x r[-4--1] 4,1,1,1,0,0 a[-4--1] y
+==[0,-1] insert_new={$insert_new||!im} rm.
+f[0,-1] 'if(i,x,-1)' discard[-2,-1] -1 rv[-2,-1] -[-2,-1] rv[0,-2] rm..
if {(im||iM)&&!{*,k}}
/. 5 z. 0,2 y.
repeat 5
j.. .,0,8,0,0,-1
j[1] [2],18,130 +vshift2048.. *3d. 121 j3d[1] .,78,190 rm.
w[1] wait 20
done
fi
rm[-2,-1]
if {!$>} dscore=0
[0] +f[0] 'if(i,i*16+4*y+x,-1)' discard. -1
repeat {h}
x={i[$>]&3} y={(i[$>]>>2)&3} n={i[$>]>>4}
if {$x>0" && "{0,i($x-1,$y)}==$n}
=[0] 0,$x,$y =[0] {$n+1},{$x-1},$y =.. 0,$x,$y insert_new=1 dscore+={2^($n+1)}
else =. -1,0,$>
fi
done
score+=$dscore
if {iM<0} rm[-2,-1]
else
discard. -1
rv[0,-2] _x_2048_object3d rv[0,-3] vshift2048. *3d. 121
j[1] [2],18,130 j3d[1] .,78,190 rm[-3,-1]
N={h} repeat {h} v={-{1+$>},@$>} ++3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} done
+3d[-$N--1] rm..
0 t. +$dscore,0,0,33,1,1 100%,100%,1,3 fc. $c0
repeat 6
+vshift2048... *3d. 121 +j3d[1] .,78,190
j. ...,430,{80-$>},0,0,{min(1,$</6)},[-4]
w. rm[-2,-1] -3d... {1/6},0,0 wait 20
done
rm[-3--1]
fi
fi
done
ishift2048[0]
if $insert_new _x_2048_setrandom fi
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 endl uncommand _x_2048_setrandom,_x_2048_object3d v +
#@cli x_blobs
#@cli : Launch the blobs editor.
x_blobs :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Blobs editor"$n" --------------------------\n
----\n
---- "${c}"Mouse"$n" to insert/move/delete blobs.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
v -
l[] (0;0^0;128^0;255) r. 450,450,1,3,3 flower. 30,8,0,0,50%,50%,1 water. 20
w {f=h<0.5*{*,v}?1.5:1;[w,h]*=f},0,0,"[G"{`39`}"MIC] Blobs Editor"
moving=-1
do
x={{*,x}*{0,w}/{*,w}}
y={{*,y}*{0,h}/{*,h}}
b={*,b} nearest=-1
fps=${-fps}
if {$!>1}
{0,[w,h]},1,2
repeat {1,h}
r={1,i[2]*(1+i[3]*cos(i[4]+i[5]*$|*1000))}
ellipse. {1,@0,1},$r,$r,0,1,{1,@6-7}
d={sqrt(($x-{1,@0})^2+($y-{1,@1})^2)}
if {$d<$r} nearest=$> fi
shift[1] 0,-1,0,0,2 done
b. 15
+norm. +>=. 50 <=.. 40 *[-3,-1]
+*[0,-1] rm.. rv[-2,-1] *. 1.6 c. 0,255 +[-2,-1]
if {$fps>0} to. $fps" fps",5,{h-29},24,2,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {2*[w,h]} elif {{*,CTRLLEFT}&&{*,C}} w[] {[w,h]} fi
rm.
else
+to[0] "G\47MIC Blobs Editor",75,100,35,3,1,200,128,255
to. "* Left mouse button : Create and move blobs.\n\n\
* Right mouse button : Remove blob.\n\n\
* Middle mouse button : Remove all blobs.\n\n\
* Key 'ESC' or 'Q' : Quit.\n\n\
* Colors and sizes of appearing blobs are\n   chosen randomly",\
50,180,18,1,1,255
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {1.5*[w,h]} elif {{*,CTRLLEFT}&&{*,C}} w[] {[w,h]} fi
rm.
fi
wait 20
if {$x<0||$y<0} continue fi
if {$b&1}
if {$nearest>=0" || "$moving>=0}
if {$moving<0} moving=$nearest fi
=[1] $x,0,$moving =[1] $y,1,$moving
else
($x,$y,{u(20,50)},{u(-0.3,0.3)},{u(0,pi/2)},{u(0,0.009)},{u(64,255)},{u(64,255)}) a[^0] y
moving={h-1}
fi
elif {$b&2}
if {$nearest>=0} l[1] s y rm[$nearest] a y endl nearest=-1 fi
elif {$b&4}
k[0]
else
moving=-1
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 endl v +
#@cli x_bouncing
#@cli : Launch the bouncing balls demo.
x_bouncing :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Bouncing balls"$n" ------------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
v - l[]
520,320,1,3 plasma 1,1,9 n 0,220
N=12
repeat $N
ball[] {round(u(32,80))},${-RGB}
t$>={u(200)} x$>={0,u(10,w-10)} h$>={u(150,300)} vx$>={if(u<0.5,1,-1)*u(1,8)}
done
mv[0] $!
w. {f=w<0.5*{*,u}?1.5:1;[w,h]*=f},0,"[G"{`39`}"MIC] Bouncing Balls"
(0;0.7;1) r. {-2,w},70,1,1,3
do
[$N]
repeat $N
bw={$>,w} bh={$>,h}
y={${h$>}*abs(cos(${t$>}*pi/60))-$bh/2}
dt=1
if {$y<0} d={-$y} y=0 bh-=$d bw+=$d dt={max(0.2,1-($d/$bh)^2)} else dt=1 fi
if {${x$>}+$bw/2>w}
d={${x$>}+$bw/2-w} bw-=$d bh+={0.5*$d}
if {${x$>}+$bw/4>w} vx$>={-${vx$>}} fi
fi
if {${x$>}-$bw/2<0}
d={$bw/2-${x$>}} bw-=$d bh+={0.5*$d}
if {${x$>}-$bw/4<0} vx$>={-${vx$>}} fi
fi
+r[$>] $bw,$bh,1,4,3 s. c,-3
j... ..,{max(0,min({$N,w-$bw},${x$>}-$bw/2))},{{$N,h}-{h}-$y-70},0,0,1,.,255 rm[-2,-1]
t$>+=$dt
x$>+={$dt*${vx$>}}
done
+rows. {h-2*70},{h-1-70} mirror. y *. [{$N+1}]
j.. .,0,{-2,h-71},0,0,0.5 rm.
fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-29},24,2,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {1.5*w},{1.5*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
rm. wait 20
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w 0 rm endl v +
#@cli x_color_curves : _colorspace={ rgb | cmy | cmyk | hsi | hsl | hsv | lab | lch | ycbcr | last }
#@cli : Apply color curves on selected RGB[A] images, using an interactive window.
#@cli : Set 'colorspace' to 'last' to apply last defined color curves without opening interactive windows.
#@cli : Default value: 'colorspace=rgb'.
x_color_curves : skip ${1=rgb}
if {['"$1"']!='last'&&!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[^-1] "Apply color curves of image$?, in the '$1' colorspace."
if {['"$1"']=='last'} v -
if {!narg($_xcc_colorbase)} v + return fi
__x_color_curves[] $_xcc_colorbase
else
e[] "\n
------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" on a curve creates a new control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" on a control point deletes it.\n
---- "${c}"Left mouse button"$n" on the main image window shows the initial image until button is released.\n
---- "${c}"Right mouse button"$n" on the main image window adds a keypoint to all curves from picked color.\n
---- Key '"${c}"R"$n"' on a curve resets it.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' close the current window.\n
----\n
------------------------------------------------------------------------------------------------"
v -
__x_color_curves[] $1 _xcc_colorbase=$1
fi
to_color repeat $! l[$>]
if {['"$1"']!='last'}
+r[0] ${fitscreen[]\ {0,w},{0,h},1,128,70%},1,100%,3
+l. xcc_goto s c histogram 256,0,255 xcc_info endl
__C0= __C1= __C2= __C3= __C4=
if {narg($__xcc_C0)} __C0=$__xcc_C0 fi
if {narg($__xcc_C1)} __C1=$__xcc_C1 fi
if {narg($__xcc_C2)} __C2=$__xcc_C2 fi
if {narg($__xcc_C3)} __C3=$__xcc_C3 fi
if {narg($__xcc_C4)} __C4=$__xcc_C4 fi
x={1,({*,u}-560-w)/2} y={1,({*,v}-h)/2}
if {$!==5}
parallel "w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" x_select_function1d... __C0,"$_color0"",\
"w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" x_select_function1d.. __C1,"$_color1"",\
"w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" x_select_function1d. __C2,"$_color2"",\
"w. 100%,100%,0,0,"{$x+560}","$y" _x_color_curves[-4]"
elif {$!==6}
parallel "w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" x_select_function1d[-4] __C0,"$_color0"",\
"w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" x_select_function1d... __C1,"$_color1"",\
"w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" x_select_function1d.. __C2,"$_color2"",\
"w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" x_select_function1d. __C3,"$_color3"",\
"w. 100%,100%,0,0,"{$x+560}","$y" _x_color_curves[-5]"
elif {$!==7}
parallel "w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" x_select_function1d[-5] __C0,"$_color0"",\
"w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" x_select_function1d[-4] __C1,"$_color1"",\
"w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" x_select_function1d... __C2,"$_color2"",\
"w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" x_select_function1d.. __C3,"$_color3"",\
"w[] 256,256,0,0,"{$x+280}","{$y+600}",\"Curve: "$_title4"\" x_select_function1d. __C4,"$_color4"",\
"w. 100%,100%,0,0,"{$x+560}","$y" _x_color_curves[-6]"
fi
k[0]
fi
xcc_goto
repeat {s} function1d[] 1,${__xcc_C$>} *. {255%} r. 256,1,1,1,5 c. 0,255 sh[0] $> map. .. rm[-2,-1] done
xcc_backto
endl done
uncommand xcc_goto,xcc_backto,xcc_info v +
_x_color_curves :
title={0,b} if {narg({'{0,x}'})} title=$title.{0,x} fi ({'$title'}) discard. {'~'} title={t} rm.
+drgba. w. 100%,100%,0,"[G"{`39`}"MIC] Image: "$title rm.
xcc_goto. .
oC0= oC1= oC2= oC3= oC4= viewmode=0
do
wait 100 need_refresh=0
oviewmode=$viewmode is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}} x={*,x} y={*,y}
if {*,r} need_refresh=1
elif {$is_ctrl" && "{*,-D}} w[] {{*,w}*125%},{{*,h}*125%} need_refresh=1
elif {$is_ctrl" && "{*,-C}} w[] {{*,w}*80%},{{*,h}*80%} need_refresh=1
elif {$is_ctrl" && "{*,-R}} w[] {w},{h} need_refresh=1
elif {{*,b}&1} viewmode={x={*,x};if(x<w/3,1,if(x<2*w/3,2,3))}
elif {{*,b}&2" && "$x>=0" && "$y>=0}
xc={$x*w/{*,w}} yc={$y*h/{*,h}} +z[0] $xc,$yc,$xc,$yc
repeat {s} (${__C$>},{i[$>]/255%},{i[$>]/255%}) r. 2,{w/2},1,1,-1 sort. +,y __C$>={^} rm. done
rm. wait -1
else viewmode=0
fi
need_refresh={$need_refresh||$oviewmode!=$viewmode}
repeat {s} if {['_${oC$>}']!=['_${__C$>}']}
function1d[] 1,${__C$>} *. {255%} r. 256,1,1,1,5 c. 0,255
+channels[0] $> map. .. j[1] .,0,0,0,$> rm[-2,-1]
need_refresh=1 oC$>=${__C$>}
fi done
if $need_refresh
if {$viewmode==0}
+xcc_backto[1]
elif {$viewmode%2}
w2={0,int(w/2)} b={$viewmode==1} +z[{!$b}] 0,{$w2-1} +z[$b] $w2,100%
xcc_backto.. xcc_backto. a[-2,-1] x line. 50%,0,50%,100%,1,0
else
+xcc_backto[0]
fi
if {s>3} drgba. fi w. rm. refresh=0
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,SPACE}" && "!{*,ENTER}}
w 0
repeat 5 if {narg(${__C$>})} __xcc_C$>=${__C$>} __C$>=-1 fi done
__x_color_curves :
if {['"$1"']=='rgb'}
_color0="255,180,180" _color1="180,255,180" _color2="180,180,255" _color3="220,220,220" _title0=Red _title1=Green _title2=Blue _title3=Alpha
m "xcc_goto:" m "xcc_backto:"
m "xcc_info: (0,255;0,0;0,0) (0,0;0,255;0,0) (0,0;0,0;0,255) r[-3--1] 256,3,1,1,3 "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
elif {['"$1"']=='cmy'}
_color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Alpha
m "xcc_goto: s c,-3 rgb2cmy[0] a c" m "xcc_backto: s c,-3 cmy2rgb[0] a c"
m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) r[-3--1] 256,3,1,1,3 "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
elif {['"$1"']=='cmyk'}
_color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="180,180,180" _color4="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Key _title4=Alpha
m "xcc_goto: s c,-3 rgb2cmyk[0] a c" m "xcc_backto: s c,-4 cmyk2rgb[0] a c"
m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) (255,0) r[-4--1] 256,3,1,1,3 "\
"a[0,-4] y a[1,-3] y a[2,-2] y a[3,-1] y"
elif {['"$1"']=='hsi'}
_color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Intensity _title3=Alpha
m "xcc_goto: s c,-3 rgb2hsi8[0] a c" m "xcc_backto: s c,-3 hsi82rgb[0] a c"
m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) hsi82rgb[-3--1] permute[-3--1] xcyz "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
elif {['"$1"']=='hsl'}
_color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Lightness _title3=Alpha
m "xcc_goto: s c,-3 rgb2hsl8[0] a c" m "xcc_backto: s c,-3 hsl82rgb[0] a c"
m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) hsl82rgb[-3--1] permute[-3--1] xcyz "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
elif {['"$1"']=='hsv'}
_color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Value _title3=Alpha
m "xcc_goto: s c,-3 rgb2hsv8[0] a c" m "xcc_backto: s c,-3 hsv82rgb[0] a c"
m "xcc_info: 256,1,1,3,if(!c,x,255) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) hsv82rgb[-3--1] permute[-3--1] xcyz "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
elif {['"$1"']=='lab'}
_color0="180,180,180" _color1="220,180,220" _color2="220,220,180" _color3="220,220,220" _title0=Lightness _title1=Chroma-A _title2=Chroma-B _title3=Alpha
m "xcc_goto: s c,-3 srgb2rgb[0] apo[0] rgb2lab8,0,4 a c" m "xcc_backto: s c,-3 apo[0] lab82rgb,0,4 rgb2srgb[0] a c"
m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,240,if(c==1,x,128)) 256,1,1,3,if(!c,240,if(c==1,128,x)) lab82rgb[-3--1] permute[-3--1] xcyz "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
elif {['"$1"']=='lch'}
_color0="180,180,180" _color1="220,180,220" _color2="255,220,220" _color3="220,220,220" _title0=Lightness _title1=Chroma _title2=Hue _title3=Alpha
m "xcc_goto: s c,-3 srgb2rgb[0] apo[0] rgb2lch8[0],0,4 a c" m "xcc_backto: s c,-3 apo[0] lch82rgb[0],0,4 rgb2srgb[0] a c"
m "xcc_info: 256,1,1,3,if(!c,x,0) 256,1,1,3,if(!c,255,if(c==1,x,128)) 256,1,1,3,if(!c,220,if(c==1,128,x)) lch82rgb[-3--1] permute[-3--1] xcyz "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
elif {['"$1"']=='ycbcr'}
_color0="180,180,180" _color1="220,220,255" _color2="255,220,220" _color3="220,220,220" _title0=Luma _title1=Blue\ chroma _title2=Red\ chroma _title3=Alpha
m "xcc_goto: s c,-3 rgb2ycbcr[0] a c" m "xcc_backto: s c,-3 ycbcr2rgb[0] a c"
m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,128,if(c==1,x,128)) 256,1,1,3,if(!c,128,if(c==1,128,x)) ycbcr2rgb[-3--1] permute[-3--1] xcyz "\
"a[0,-3] y a[1,-2] y a[2,-1] y"
else v + error[0--3] "Command 'x_color_curves': Unknown specified color space '$1'."
fi
#@cli x_colorize : _is_lineart={ 0 | 1 },_max_resolution={ 0 | >=128 },_multichannels_output={ 0 | 1 },_[palette1],_[palette2],_[grabber1]
#@cli : Colorized selected B&W images, using an interactive window.
#@cli : When >0, argument 'max_resolution' defines the maximal image resolution used in the interactive window.
#@cli : Default values: 'is_lineart=1', 'max_resolution=1024' and 'multichannels_output=0'.
x_colorize : skip ${1=0},${3=0},${4=0},${5=0},${6=0} check "${2=1024}==0 || $2>=128"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - s0="image" s1="lineart" s2="multichannel" s3="merged" use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[^-1] "Colorize selected B&W "${s{!$1}}"$? interactively, with maximum resolution $2 and "${s{2+!$3}}" output."
e[] "\n
--------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" creates a new colored control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" or key '"${c}"X"$n"' over a control point deletes it.\n
---- "${c}"Right mouse button"$n" or key '"${c}"P"$n"' anywhere else picks a color from the image.\n
---- "${c}"Mouse wheel"$n", or keys '"${c}"CTRL+arrows UP/DOWN"$n"' zoom view in/out.\n
---- '"${c}"CTRL+mouse wheel"$n"', '"${c}"SHIFT+mouse wheel"$n"' or "${c}"arrow keys"$n" move image in zoomed view.\n
---- Key '"${c}"SPACE"$n"' updates the extrapolated color field.\n
---- Key '"${c}"TAB"$n"' toggles between markers view modes.\n
---- Key '"${c}"BACKSPACE"$n"' deletes the last control point added.\n
---- Key '"${c}"PAGE UP"$n"' increases image contrast.\n
---- Key '"${c}"PAGE DOWN"$n"' decreases image contrast.\n
---- Key '"${c}"R"$n"' toggles color replace mode.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
--------------------------------------------------------------------------------------"
v -
N=$!
thread_main="_x_colorize[0] ${1--1}"
thread_color="w[] 400,320,0,\"Palette: main\" x_select_color[] __color,255,255,255"
is_palette1=${"is_image_arg[] $4"}
if $is_palette1
pass$4 1 ({'{b}'}) discard. {'~'} palette_title1={t} rm.
thread_palette1="w[] 400,400,0,\"Palette: "$palette_title1"\" x_select_palette["{$!-1}"] __color"
fi
is_palette2=${"is_image_arg[] $5"}
if $is_palette2
pass$5 1 ({'{b}'}) discard. {'~'} palette_title2={t} rm.
thread_palette2="w[] 400,400,0,\"Palette: "$palette_title2"\" x_select_palette["{$!-1}"] __color"
fi
is_grabber=${"is_image_arg[] $6"}
if $is_grabber
pass$6 1 ({'{b}'}) discard. {'~'} palette_grabber={t} rm.
thread_grabber="w[] ${\"fitscreen[] {w},{h},1,128,50%\"},0,\"Grabber: "$palette_grabber"\" x_grab_color["{$!-1}"] __color"
fi
__color=255,255,255
if {!$is_palette1" && "!$is_palette2" && "!$is_grabber}
repeat $N l[$>]
parallel $thread_main,$thread_color
endl done
else
repeat $N l[$>,$N--1]
parallel $thread_main,$thread_color,$thread_palette1,$thread_palette2,$thread_grabber
endl done
fi
k[0-{$N-1}]
v +
_x_colorize :
name={n} title={b} if {narg({x})} title=$title.{x} fi
w={w} h={h}
if $1
if {s==4} sh. 3 if {abs(im-iM)>64} +*. -1 rm.. +. 255 else rm. sh. 0 fi
else sh. 0
fi
n 0,255
else
if {s==1} sh. 0
else +luminance.
fi
fi
nm. img
fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
selection=-1 view_markers=2 contrast=9 xpan=-1 ypan=-1 replace_color= current_replace_color=
if {narg($_gui_control_points)>=6}  ($_gui_control_points) r. {w/6},6,1,1,-1
else 0
fi
nm. points
if {$2>0} if {$w>$h} +r2dx[img] {min($2,$w)},2 else +r2dy[img] {min($2,$h)},2 fi else [img] fi
__x_colorize. $1
pw={potential,w} ph={potential,h}
do
if {narg($replace_color)" && "{*,x}<0" && "{*,y}<0} wait 200 else wait fi
x={*,x} y={*,y} b={*,b} o={*,-o}
is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
is_shift={{*,SHIFTLEFT}" || "{*,SHIFTRIGHT}}
is_mouseout={$x<0" || "$y<0}
x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1
if {*,r}
nww={*,d} nwh={*,e} m={min($nww,$nwh)}
cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
x0={$cx-$dx/2} x1={$cx+$dx/2}
y0={$cy-$dy/2} y1={$cy+$dy/2}
ww=$nww wh=$nwh
elif {$is_ctrl" && "{*,-D}}
nww={min({*,u},$ww*1.25)} nwh={min({*,v},$wh*1.25)} m={min($nww,$nwh)}
if {$m==$nww} ww=$m wh={$h*$m/$w} else ww={$w*$m/$h} wh=$m fi
elif {$is_ctrl" && "{*,-C}}
nww={$ww/1.25} nwh={$wh/1.25}
if {min($nww,$nwh)>=64} ww=$nww wh=$nwh fi
elif {$is_ctrl" && "{*,R}}
fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
x0=0 y0=0 x1={$w-1} y1={$h-1}
elif {($is_shift" && "$o<0)" || "{*,ARROWLEFT}}
dx={($x1-$x0)/6} x0-=$dx x1-=$dx
elif {($is_shift" && "$o>0)" || "{*,ARROWRIGHT}}
dx={($x1-$x0)/6} x0+=$dx x1+=$dx
elif {($is_ctrl" && "$o>0)" || "({*,ARROWUP}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0-=$dy y1-=$dy
elif {($is_ctrl" && "$o<0)" || "({*,ARROWDOWN}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0+=$dy y1+=$dy
elif {$o>0" || "($is_ctrl" && "{*,ARROWUP})}
if {$x1-$x0>16" && "$y1-$y0>16}
cx={if($x>=0" && "!{*,ARROWUP},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWUP},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
fi
elif {$o<0" || "($is_ctrl" && "{*,ARROWDOWN})}
zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
if {$zfactor<1.3}
cx={if($x>=0" && "!{*,ARROWDOWN},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWDOWN},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
else
dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
fi
elif {$b&4" && "!$is_mouseout}
if {$panx<0" && "$pany<0} panx=$x pany=$y
else dx={round($panx-$x)} dy={round($pany-$y)} x0+=$dx y0+=$dy x1+=$dx y1+=$dy
fi
else panx=-1 pany=-1
fi
if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} rm[baseview] fi
N={points,w}
if {narg($baseview)" && "($b&3" || "{*,X}" || "{*,P})" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
if {$selection==-1" && "$N}
($x;$y) r. $N,2 -. [points] *. {max($ww,$wh)/max($x1-$x0,$y1-$y0)} sqr. s. y +[-2,-1]
dmin={im} selection={if($dmin>25,-1,xm)} rm.
fi
if {narg($replace_color)}
replace_color= wait -1
elif {$selection>=0}
if {$b&1" && "$view_markers}
+columns[points] $selection ox={i[0]} oy={i[1]} =. $x =. $y,0,1 j[points] .,$selection rm.
rm[view]
elif {($b&2" || "{*,X})" && "$view_markers}
if {$N>1} +z[points] {$selection+1},100% j[points] .,$selection rm. r[points] {$N-1},100%,1,1,0
else rm[points] i[points] 0 fi
wait -1 rm[view]
fi
elif {$b&1}
($x;$y;0) ($__color) y. y +. 1 a[-2,-1] y a[points,-1] x selection=$N if {!$view_markers} view_markers=2 fi rm[view]
elif {$b&2" || "{*,P}}
__color={colors,I($x*$pw/$w,$y*$ph/$h)}
fi
else selection=-1
if {{*,-SPACE}" && "narg($colors)} replace_color= rm[colors]
elif {*,-TAB} view_markers={($view_markers-1)%3} rm[view] wait -1
elif {!$is_ctrl" && "{*,-R}}
if {narg($replace_color)} replace_color= else replace_color=$__color fi
rm[baseview] wait -1
elif {*,PAGEDOWN} contrast={max(0,$contrast-1)} rm[view] wait -1
elif {*,PAGEUP} contrast={min(9,$contrast+1)} rm[view] wait -1
elif {{*,BACKSPACE}" && "$N} if {$N>1} z[points] 0,{$N-2} else i=$points rm[points] i[$i] 0 nm[$i] points fi rm[view] wait -1
fi
fi
w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
if {$x0<-$w2} x1-={$x0+$w2} x0=-$w2 fi
if {$y0<-$h2} y1-={$y0+$h2} y0=-$h2 fi
if {$x1>=$w+$w2} x0+={$w-1+$w2-$x1} x1={$w-1+$w2} fi
if {$y1>=$h+$h2} y0+={$h-1+$h2-$y1} y1={$h-1+$h2} fi
if {!narg($colors)}
N={points,w}
if {narg($view)} to[view] "Processing...",5,5,20,2 w[view] fi
if $N
[points]
sh. 0,0,0,0 *. {$pw/$w} rm.
sh. 1,1,0,0 *. {$ph/$h} rm.
pointcloud. -1,$pw,$ph
+compose_channels. max !=. 0 distance. 1 *. 0.02 +. 1 ^. -1 +. [potential]
if {!$1} dilate.. 3 fi
watershed.. . rm. -. 1
else [potential],[potential],1,3,255
fi
nm. colors
if {narg($baseview)} rm[baseview] fi
fi
if {!narg($replace_color)" && "narg($points_replaced)}
rm[points,colors,view] nm[colors_replaced] colors nm[points_replaced] points current_replace_color=
elif {narg($replace_color)" && "['$__color']!=['$current_replace_color']}
if {narg($colors_replaced)} rm[colors_replaced,points_replaced] fi
current_replace_color=$__color
if {points,w}
+replace_color[colors] 0,0,$replace_color,$current_replace_color
+rows[points] 3,5 permute. xzcy -. 1
replace_color. 0,0,$replace_color,$current_replace_color
+. 1 permute. xcyz +j[points] .,0,3 rm..
else 0 0
fi
nm.. colors_replaced
nm. points_replaced
if {narg($baseview)} rm[baseview] fi
fi
if {!narg($baseview)}
nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
+z[img] $x0,$y0,$x1,$y1
r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
if {narg($replace_color)" && "{points,w}} icolors=$colors_replaced else icolors=$colors fi
+z[$icolors] $nx0,$ny0,$nx1,$ny1
r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
if $1 *.. -1 +.. 255 channels.. -3,0 blend. ..,alpha rm..
else rgb2ycbcr. j. ..,0,0,0,0 rm.. ycbcr2rgb.
fi
nm. baseview
if {narg($view)} rm[view] fi
fi
if {!narg($view)}
[baseview] r. 100%,100%,1,3
if {$contrast<9} /. {10-$contrast} +. {128*(1-1/(10-$contrast))} fi
if $view_markers
if {$view_markers==2} rad1=5 rad2=3 else rad1=3 rad2=2 fi
if {narg($replace_color)" && "{points,w}} ipoints=$points_replaced else ipoints=$points fi
repeat {$ipoints,w}
+columns[$ipoints] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} col={i[3]-1},{i[4]-1},{i[5]-1} rm.
circle. $x,$y,$rad1,1,0 circle. $x,$y,$rad2,1,$col
done
fi
if {narg($replace_color)}
to. "Replace      by",5,5,20,2
rectangle. 80,8,111,25,1,0 rectangle. 82,10,109,23,1,$replace_color
rectangle. 150,8,181,25,1,0 rectangle. 152,10,179,23,1,$current_replace_color
fi
nm. view
w[view] $ww,$wh,0,$title
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}
if {narg($view)} to[view] "Processing fullres...",5,5,20,2 w[view] fi
k[0,img,points]
N={points,w} status=
if $N
status={points,^}
[img] __x_colorize. $1
pointcloud[points] -1,$w,$h
+compose_channels[points] max !=. 0 distance. 1 *. 0.02 +. 1 ^. -1 +[potential,-1]
if {!$1} zfact={{img,max(w,h)}/{potential,max(w,h)}} dilate[points] {int(3*$zfact)} fi
watershed[points] [potential] -[points] 1 nm[points] colors
else [img],[img],1,3,255 nm. colors
fi
if $3
k[0,colors] a c
else
k[0,img,colors]
if $1 +*[img] -1 +. 255 channels. -3,0 blend[colors,-1] alpha rm[0,img]
else rgb2ycbcr[colors] j[colors] [img],0,0,0,0 rm[0,img] ycbcr2rgb[colors]
fi
fi
a c nm $name
__color=-1
u $status
w 0
__x_colorize :
if $1
n. 0,1 ^. 5 repeat 4 +b. 0.5% min done
else
gradient_norm. n. 0,255 normalize_local. 3,3 *. -1 n. 0,255
b. 0.05% n. 0,1 sqr. +b. 0.5% n[-2,-1] 0,1 min[-2,-1]
fi
nm. potential
#@cli x_connect4
#@cli : Launch the Connect Four game.
x_connect4 :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Connect Four"$n" --------------------------------------------\n
----\n
---- Connect four tokens in a row, column or diagonally\n
---- to win the game.\n
----\n
---- "${c}"Left mouse button"$n" on a column inserts a new token.\n
---- Keys '"${c}"SPACE"$n"' or '"${c}"ENTER"$n"' lets the computer play the turn\n
---- (or restart game when it's over).\n
---- Key '"${c}"ENTER"$n"' also enables autoplay for the current player.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' close the window.\n
----\n
----------------------------------------------------------------"
v - l[]
7,6 nm. board
R={board,u={*,u};v={*,v};int(0.5*min(u/w,v/h))}
{2*$R},{2*$R} circle. 50%,50%,32%,1,1 b. 2% g. xy +[-2,-1] n. 0,1
+n. -1,0.5 abs. negate. +f. 200 rv[-3--1] a[-3--1] c hsv2rgb.
to_rgba. circle. 50%,50%,27%,1,0
{4*$R},{4*$R} circle. 50%,50%,20%,1,1 b. 1% g. xy +[-2,-1] n. 0,1 negate.
pow. 0.5 +n. -1,0.8 abs. negate. +f. 10 rv[-3--1] a[-3--1] c
. sh. 0 f. 60 rm. hsv2rgb[-2,-1]
100%,100% circle. 50%,50%,30%,1,255 a[-3,-2] .,c rm.
r2dx[-3--1] $R s[-3--1] c,-3 rm...
n[^0] 0,255 round[^0] nm[^0] cache,cachem,token0,token1,tokenm
+b[cachem] 2% shift. 1%,1%,0,0,2 max[cachem,-1]
r[cache,cachem] 100%,{board,h*100}%,1,100%,0,2
evalf="const op = 3 - p;
case(dx,dy) = (
pgood = pbad = 0;
for (k = -2, k<2, ++k,
X = x + k*dx;
Y = y + k*dy;
if (X>=0 && X<w && Y>=0 && Y<h,
val = i(X,Y);
if (pgood>=0 && val==op, pgood = -1, pgood+=!!val);
if (pbad>=0 && val==p,  pbad = -1, pbad+=!!val);
);
);
pgood = arg(2+pgood,0,1,2,4,100,1e8);
pbad = arg(2+pbad,0,1,2,4,10000,1e8);
pgood - pbad;
);
case(1,0) + case(0,1) + case(1,1) + case(1,-1)"
do
if {!narg($visu)}
{board,[w,h]*$R},1,3,64
repeat {board,h},y repeat {board,w},x
val={board,i($x,$y)} if $val j. [token{$val-1}],{$x*$R},{$y*$R},0,0,1,[tokenm],255 fi
done done
+r[cache,cachem] {board,[w,h]*$R},1,100%,0,2 a[-2,-1] c blend[-2,-1] alpha
nm. visu w[visu] 100%,100%,0,"[G'MIC] Connect Four"
turn=0 is_falling=0 x=-1 yv=0 dyv=0 winner=
autoplayer0=0 autoplayer1=0
fi
if {!narg($ymax)}
i[ymax] {board,w},1,1,1,"y=-1; for (k = 0, k<h#"$board", ++k, if(!i(#"$board",x,k),y = k)); y"
if {iM<0} winner=-1,-1,-1 fi
fi
if {narg($winner)}
i[tmpvisu] [visu]
x={arg(1,$winner)} y={arg(2,$winner)} c={arg(3,$winner)}
if {$x<0}
if {!narg($text)}
0 t. "Draw game",0,0,57,1,1 r2dx. {tmpvisu,w/2} expand_xy. 3,0 +dilate. 5 n.. 0,255 to_rgb..
nm[-2,-1] text,textm
fi
j[tmpvisu] [text],{tmpvisu,([w,h]-[w#$text,h#$text])/2},0,0,{0.7+0.3*sin(5*$|)},[textm]
else
repeat 4
[token$turn]
rgb2hsv. sh. 1,2 +. {0.4*sin(5*$|)} c. 0,1 rm. hsv2rgb.
j. [cache],0,0,0,0,1,[cachem],255
j[tmpvisu] .,{$R*[$x,$y]},0,0,1 rm.
x+={$c!=2?1:0} y+={$c==1?0:$c==4?-1:1}
done
fi
w[tmpvisu] 100%,100% rm[tmpvisu] wait 20
if {{*,-SPACE}" || "{*,-ENTER}}
rm[visu,ymax] f[board] 0 winner=
fi
elif {!$is_falling}
if {!${autoplayer$turn}}
x={visu,X={*,x};X<0?X:int(X*w#$board/w)}
yM={i("#"$ymax,$x)}
if {board,$x<0" || "$x>=w} w[visu] 100%,100%
else
[visu] $R,100%,1,3,($yM>=0?1:0)*($turn?[255,255,0]:[255,0,0])
j.. .,{$x*$R},0,0,0,{$yM>=0?0.15:0.3} rm.
w. 100%,100% rm.
fi
wait
fi
if {{*,-b}&1" && "$yM>=0" && "$x>=0} is_falling=1 yv=0 dyv=1
elif {${autoplayer$turn}" || "{*,-SPACE}" || "{*,ENTER}}
if {*,-ENTER} autoplayer$turn=1 fi
max_score=-inf max_col=
repeat {board,w},move1
yM1={i("#"$ymax,$move1)}
if {$yM1>=0}
+=[board] {1+$turn},$move1,$yM1 nm. board1
i[ymax1] {board,w},1,1,1,"y=-1; for (k = 0, k<h#"$board1", ++k, if(!i(#"$board1",x,k),y = k)); y"
opp_max_score=-inf opp_max_board={board,^}
opp_turn={($turn+1)%2}
repeat {board,w},move2
yM2={i("#"$ymax1,$move2)}
if {$yM2>=0}
+=[board1] {1+$opp_turn},$move2,$yM2
+f. "const p = 1 + "$opp_turn"; "$evalf score={is+u} rm.
if {$score>$opp_max_score} opp_max_score=$score opp_max_board={^} fi
rm.
fi
done
rm[board1,ymax1]
{board,[w,h,1,1]},$opp_max_board
f. "const p = 1 + "$turn"; "$evalf score={is+u} rm.
if {$score>$max_score} max_score=$score max_col=$move1 fi
fi
done
x=$max_col is_falling=1 yv=0 dyv=1
fi
else
if {!narg($column)}
$R,{board,h*$R},1,3,64
repeat {board,h} v={board,i($x,$>)} if $v j. [token{$v-1}],0,{$>*$R},0,0,1,[tokenm],255 fi done
nm. column
fi
yM={i("#"$ymax,$x)}
[column]
j. [token$turn],0,$yv,0,0,1,[tokenm],255
j. [cache],0,0,0,0,1,[cachem],255
i[tmpvisu] [visu]
j[tmpvisu] ..,{$R*$x},0,0,0 rm.. w[tmpvisu] 100%,100%
if {$yv>=$yM*$R}
j[visu] [tmpvisu] is_falling=0
=[board] {$turn+1},$x,$yM
rm[ymax,column]
+f[board] "if (!i,0,
case_h = i==j(1) && i==j(2) && i==j(3);
case_v = i==j(0,1) && i==j(0,2) && i==j(0,3);
case_d1 = i==j(1,1) && i==j(2,2) && i==j(3,3);
case_d2 = i==j(1,-1) && i==j(2,-2) && i==j(3,-3);
case_h?1:case_v?2:case_d1?3:case_d2?4)"
if {iM} winner={[xM,yM,i(xM,yM)]}
else turn={($turn+1)%2}
fi
rm.
fi
rm[tmpvisu]
yv={min($yM*$R,$yv+$dyv)} dyv+={visu,h/100}
wait 20
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 endl v +
#@cli x_fire
#@cli : Launch the fire effect demo.
x_fire : skip "${1=G\47MIC}"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Fire effect"$n" ------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
v -
i[0] 100,32 w[0] {[4.5*w,6.75*h]},0,"[G"{`39`}"MIC] Fire Effect"
if {{*,w}<0.5*{*,u}} w[] {[{*,w},{*,h}]*1.5} fi
i[1] (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) r[1] 256,1,1,3,3
i[2] (0,0,0;0,0,0;1,1,1;0,1,0) *[2] 0.21
text3d "$1",33,3,1
mv. 3 c3d[3] n3d[3] *3d[3] 320 col3d[3] 255,205,130 db3d 0 f3d 300
100,100 rand. 0,255 ellipse. 50%,50%,5,5,0,1,300 b. 10
sharpen. 1000 shrink_xy. 1 n. 0,255 to_rgb. light3d . rm.
angle=0
do
correlate[0] [2]
{0,w},1 rand. 128,256 j[0] .,0,{{0,h}-1} rm.
+r[0] 400,200,1,1,3 map. [1]
+r3d[3] 0,1,0,$angle j3d.. .,50%,50%,0,1,5,0,0
*3d. 0.25,0.16,1 j3d[0] .,50%,50%,0,1,3,0,0
rm.
angle+=3
fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-22},16,1,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {1.5*[w,h]} elif {{*,CTRLLEFT}&&{*,C}} w[] {[w,h]} fi
rm. wait 40
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm[0-3] w 0
v +
#@cli x_fireworks
#@cli : Launch the fireworks demo.
x_fireworks :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Fireworks"$n" --------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------"
v - l[]
(16;64^64;32^128;32) r 320,160,1,3,3
.
w. {1.5*w},{1.5*h},0,"[G"{`39`}"MIC] Fireworks"
time=0
do
time-=1
if {$!==2\ ||\ $time<0}
i[0] ({u(w)},\
{h},\
{u(-3,3)},\
{u(2)-5},\
{30+u(20)},\
1.5,\
255,255,255)
time={u(20)}
fi
*. 0.99
j. ..,0,0,0,0,0.2
i=0
repeat {$!-2}
to_be_removed=0
radius={if({$i,@4}>0,{$i,@5}/3,{$i,@5}*(1+2*({$i,@4}+2)/120))}
ellipse. {$i,@0},{$i,@1},{$i,@5},{max(0.5,$radius)},{atan2({$i,@3},{$i,@2})*180/pi},0.6,{$i,@6-8}
({$i,@2},{$i,@3},0,0.09,-1,0,0,0,0) +[$i,-1]
if {{$i,@0}<0\ ||\ {$i,@0}>=w\ ||\ {$i,@1}>=h\ ||\ $radius<0} to_be_removed=1 fi
if {{$i,@4}<0\ &&\ {$i,@4}>=-1}
color={min(255,80+u(200))},{min(255,80+u(200))},{min(255,80+u(200))}
radius={u(10)}
N={5+u(10)}
repeat $N
angle={$>*2*pi/$N}
i... ({$i,@0,1},{2*cos($angle)+{$i,@2}/1.5},{2*sin($angle)+{$i,@3}/1.5},-2,$radius,$color)
done
to_be_removed=1
fi
if $to_be_removed rm[$i] else i+=1 fi
done
fps=${-fps} if {$fps>0} to. $fps" fps",3,{h-20},14,1,0.2 fi
w. wait 20
if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 endl v +
#@cli x_fisheye
#@cli : Launch the fish-eye effect demo.
x_fisheye :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Fish-eye effect"$n" --------------------\n
----\n
---- "${c}"Mouse pointer"$n" moves fish-eye center.\n
---- "${c}"Mouse buttons"$n" set fish-eye size.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
v -
if {$!>0} a x n 0,255 r2dy 220 else
120,90,1,3 rand. 0,255 plasma. 0.3,3 n 0,255
t "  G\47MIC\nFISH-EYE\n EFFECT",20,13,23,1,255 scale3x b 5 sharpen 1000
f i+150-3*abs(y-h/2) c. 0,255 frame_fuzzy. 15,10,15,1.5,0 to_rgb.
fi
torus3d 20,6 col3d. {u(30,255)},{u(30,255)},{u(30,255)} +r3d. 1,0,0,90
col3d. {u(30,255)},{u(30,255)},{u(30,255)} +3d. 15 +3d[-2,-1] *3d. 4 db3d 0 c3d.
R=30
w.. {1.25*{-2,w}},{1.25*{-2,h}},0,"[G"{`39`}"MIC] Fish-Eye Effect"
do
wait 40
if {{*,b}==1} R={min(80,$R+8)} fi
if {{*,b}==2} R={max(3,$R-8)} fi
+j3d.. .,{50+30*cos($|*2.5)}%,{50+30*sin($|*1.6)}%,{80+230*sin($|*2.6)},0.7,3,0,0 r3d.. 1,0.2,0.6,3
if {{*,x}>=0}
fisheye. {{*,x}*100/{*,w}},{{*,y}*100/{*,h}},$R
fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
rm.
if {{*}==0" || "{*,ESC}" || "{*,Q}} rm[-2,-1] w 0 v + return fi
while 1
#@cli x_fourier
#@cli : Launch the fourier filtering demo.
x_fourier :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Fourier-filtering"$n" ----------------------------------------\n
----\n
---- "${c}"Mouse buttons"$n" on the right image to set min/max frequencies.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------------"
v -
if {!$!} sp ? r2dx 400 fi
repeat $! l[$>]
need_update=1
freqmin=0
freqmax=100
if {w>3*{*,u}/5} r2dx. {3*{*,u}/10} fi
if {h>3*{*,v}/5} r2dy. {3*{*,v}/5} fi
+fft. nm.. real nm. imag
+sqr[real,imag] +[-2,-1] sqrt. +. 1 log.
n. 0,255 shift. {round(w/2)},{round(h/2)},0,0,2 to_colormode. {-2,s}
nm. logmag
+r2dy. 128 frame. 1,1,0 nm. thumb
w[0,-2] -1,-1,0,"[G"{`39`}"MIC] Fourier Filtering"
l
if {!narg($first_time)}
parallel 0,"alert[thumb] \"[G"{`39`}"MIC Fourier Filtering]\",\
\"The G\47MIC Fourier filtering demo illustrates the effect\n\
of bandpass frequency filtering on an image. Use your mouse\n\
buttons to select low and high bounds for the frequencies\n\
displayed on the Fourier representation of the image\n\
(right image).\",\
\"OK\""
first_time=0
fi
do
if $need_update
i[mask] [logmag],[logmag]
r={sqrt(w^2+h^2)*$freqmax/200} ellipse[mask] 50%,50%,$r,$r,0,1,1
r={max(0,sqrt(w^2+h^2)*$freqmin/200-1)} if $r ellipse[mask] 50%,50%,$r,$r,0,1,0 fi
+*[logmag] [mask] +. [mask] /. 2 n. 0,255
shift[mask] -{mask,round(w/2)},-{mask,round(h/2)},0,0,2
+*[real,imag] [mask]
rm[mask]
ifft[-2,-1] rm. n. 0,255
rv[-2,-1]
if {*} r[-2,-1] {{*,w}/2},{*,h} fi
t. "Freq. Min/Max = "{int($freqmin)}"% / "{int($freqmax)}"%",5,5,13,1,255
w[-2,-1] rm[-2,-1]
need_update=0
fi
wait
if {{*,b}" && "{*,x}>={*,w}/2}
r={200*sqrt(({*,x}-3*{*,w}/4)^2+({*,y}-{*,h}/2)^2)/\
sqrt(({*,w}/2)^2+{*,h}^2)}
if {{*,b}&1} freqmax=$r
else freqmin={max(0,$r-3)}
fi
if {$freqmin>=$freqmax} freqmin=$freqmax fi
need_update=1
fi
if {*,r} need_update=1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} need_update=1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} need_update=1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {2*{0,w}},{0,h} need_update=1 fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w 0
endl
rm[^0]
endl done rm v +
#@cli x_grab_color : _variable_name
#@cli : Open a color grabber widget from the first selected image.
#@cli : Argument 'variable_name' specifies the variable that contains the selected color values at any time.
#@cli : Assigning '-1' to it forces the interactive window to close.
#@cli : Default values: 'variable_name=xgc_variable'.
x_grab_color : skip ${1=xgc_variable}
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
if {!$!} error[0--3] "Command '$0': Missing specified input image." fi
v - l[0] nm={n} nm. img v +
e[^-1] "Open "${arg\ {0,s},GRAY,GRAYA,RGB,RGBA}" color grabber widget for image$?, with variable name '$1'."
v -
if {!{*}} w[] ${fitscreen[]\ {w},{h},1,128,50%},0,0,-1,-1,"Grab a color" fi
_x_grab_color +dilate. 3 nm. icon_mask *.. 255 to_rgb.. nm.. icon_sprite
xc=5 yc=5 o$1=$$1
cursor[0] 0
do
if {!narg($visu0)}
+r[img] {*,w},{*,h},1,100%,2 drgba. w. nm. visu0
fi
x={*,x} y={*,y} b={*,b} mouse_over={$x>=0" && "$y>=0}
hc={narg($$1)?40:24}
yc={visu0,nhc=h-$hc-8;!$mouse_over?$yc:$y<$hc||$yc+$hc>=h?nhc:$y>=nhc?5:$yc}
if {[0$ox,0$oy,0$ob,0$ohc,0$oyc,0$ocolor,0${o$1}]!=[$x,$y,$b,$hc,$yc,0$color,0$$1]}
i[visu] [visu0]
if {narg($color)}
24,$hc,1,[img] fc. $color
if {narg($$1)} rectangle. 0,24,100%,100%,1,$$1 line. 0,24,100%,24,1,0 fi
drgba. frame. 1,1,0 frame. 1,1,255 j[visu] .,$xc,$yc rm.
0
if {narg($$1)}
t. "Position ("$X","$Y")\nColor    ("{``$color}")\nSelected ("{``$$1}")",1,0,15,1,255
else
t. "Position ("$X","$Y")\nColor ("{``$color}")",1,0,15,1,255
fi
+dilate. 5 r.. 100%,100%,1,3
j[visu] ..,{30+$xc},$yc,0,0,0.85,.,255 rm[-2,-1]
fi
if $mouse_over
X={img,round($x*(w-1)/({*,w}-1))}
Y={img,round($y*(h-1)/({*,h}-1))}
color={img,round(I($X,$Y))}
j[visu] [icon_sprite],$x,{icon_sprite,$y-h+1},0,0,1,[icon_mask]
if {$b&1} $1=$color fi
fi
w[visu] rm[visu]
ox=$x oy=$y ob=$b ohc=$hc oyc=$yc ocolor=$color o$1=$$1
fi
if {arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} wait 50 else wait fi
if {*,r} w[] -1 rm[visu0] yc=5 v - fi
if {['$$1']=='-1'} break fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w 0 k[img] nm $nm endl
u $color
v +
_x_grab_color :
base642img \
"MSB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KMSAzMzcgMSAxICMyNzcKeJyNiNlOwlAYBi9IDDcaY+LGpiJbj7tBKEbglTQE7dcbkZS1gfNXFCxlK6"\
"WE83w+gDaaeG0mmWTm67NSea5s1Pz6Ot80tnrb/d3BnhkYBq3QKDyOTA5nmfqDnW2W5nK77Mj60yLXgZvrqm6Oq47MYWc4ZhnCJE2wrgjmBWFwRmr/hNQ3"\
"ZqivKQIlCN0YQZdeQGgxzXOD1T3XWEMhVWMtz1Wmw4h1QHEOShogqQc67YPOBwpdmgpdWzDSY9DNFJS1wWUH/NZF926FTl4oel48tgui3C6KUrMo7rWCYC"\
"vJg4k/fvp/5/dJq9QyuUy48UXMOZ5H7ah9ND2YRMbhUXgUsoLDgOnxsf++0/TX1zRf1fcNa0iPgw=="
-. 127 decompress_rle.
frame. 10,10,0
r2dx. 24
#@cli x_hanoi
#@cli : Launch the Tower of Hanoi game.
x_hanoi :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Tower of Hano"$n" ---------------------\n
----\n
---- "${c}"Left button"$n" and "${c}"mouse"$n" to move a disk.\n
---- "${c}"Right button"$n" to rotate 3D view.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
v - l[]
l[]
cylinder3d 1,10 r3d 1,0,0,90
++3d 10,0,0  +-3d.. 10,0,0
box3d 30,1,10 -3d. 15,0,5
+3d nm rods3d
400,400 noise. 1 fftpolar. f.. 'r=sqrt((x-w/2)^2+.01*(y-h/2)^2);i/(1+r)' ifftpolar[-2,-1] n. 0,31
(86,50,50;132,36,12;218,109,66;231,207,180;255,193,140) permute. yzcx r. 32,1,1,3,3
map.. . rm. b. 2% b. x,1% sharpen. 100 c. 0,255
r3d.. 1,0,0,-90 texturize3d.. . r3d.. 1,0,0,90 rm.
endl
l[]
6,1,1,3,'[360*x/w,0.9*(1-(x/w)^0.5),0.9]' hsi2rgb.
ytop0=0
repeat {0,w}
R,r={3-0.3*$>},{1.6-0.22*$>}
torus3d $R,$r,36,10
300,300 plasma. 1,1,3 b. 20 sharpen. 300 n. 150,255 1,1,1,3,{0,I[$>]} r. ..,..,1,3 rv[-2,-1] blend[-2,-1] luminance,0.75
texturize3d.. . rm.
/3d. 1,1,{0.3+$r} r3d. 1,0,0,90 -3d. 0,0.8,0
a$>,x$>,y$>,h$>=0,0,$ytop0,{1.8*$r/(0.3+$r)}
ytop0+=${h$>}
nm. disk3d$>
done
rm[0]
endl
w[] 640,400,0,"[G"{`39`}"MIC] Tower of Hano\357"
1,3,1,3,'y==0?[32,128,100]:y==1?[64,16,0]:[0,0,0]' r. {*,w},{*,h},1,3,3 nm. background
nb_moves,buttons,motion3d_x,motion3d_y=0
x,rod,rod_source,rod_target,selected=-1
fading=$| error=0
do
repeat 6 +r3d[disk3d$>] 1,1,1,${a$>} +3d. {10*(${x$>}-1)},-${y$>},0 done +3d[-6--1] +3d. [rods3d]
r3d. 1,0,0,20
if {!($buttons&2)} r3d. 0,1,0.3,{5*cos(1.5*$|)} r3d. 0.3,0,1,{3*sin(0.8*$|)} fi
r3d. 1,0,0,$motion3d_y r3d. 0,-1,0,$motion3d_x *3d. 20
[background] j3d. ..,50%,70%,10,1,5,0,1,800,200,0,-3000,0.15,0.2
t. "#Moves: "$nb_moves,2%,92%,20,1,255
if $error (255^0^0) r. .. j.. .,0,0,0,0,$error error={max(0,$error-0.2)} rm. fi
if {$|-$fading<1}  *. {$|-$fading} fi
w. wait 40
if {{*,CTRLLEFT}&&{*,D}} w[] {w*1.5},{h*1.5} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
rm[-2,-1]
top0,top1,top2,ytop0,ytop1,ytop2=-1
repeat 6
rod={round(${x$>})}
if {$selected!=$>" && "${y$>}+${h$>}>${ytop$rod}} ytop$rod={${y$>}+${h$>}} top$rod=$> fi
done
prev_buttons=$buttons
mouse_x,mouse_y,buttons={*,x},{*,y},{*,b}
if {$mouse_x>=0} x={2.6*($mouse_x/{*,w}-0.5)+1} rod={round($x)} fi
if {$mouse_x>=0" && "$buttons&2}
motion3d_x,motion3d_y={([$mouse_x,$mouse_y]/[{*,w},{*,h}]-0.5)*90}
elif {$mouse_x>=0" && "$buttons&1}
if {$selected<0}
selected=${top$rod}
rod_source={$selected<0?-1:$rod}
fi
if {$selected>=0" && "$rod>=0}
if {${y$selected}<11} y$selected={min(11,${y$selected}+3)}
else
x$selected+={d=$rod-${x$selected};sign(d)*min(0.3,abs(d))}
y$selected={x=${x$selected};11+1.5*sin(pi*abs(x-round(x)))}
a$selected={x=${x$selected};45*sin(pi*abs(x-round(x)))}
fi
fi
elif {!$buttons}
if {$rod>=0" && "$selected>=0}
if {$rod_target<0}
if {${top$rod}<$selected} rod_target=$rod nb_moves+={$rod_target!=$rod_source}
else rod_target=$rod_source error=0.8
fi
fi
x$selected=$rod_target
a$selected=0
ytop={max(0,${ytop$rod_target})}
if {${y$selected}>$ytop} y$selected={max($ytop,${y$selected}-3)}
else x,rod,rod_source,rod_target,selected=-1
fi
fi
fi
if {!($buttons&2)}
motion3d_x-={sign($motion3d_x)*min(1,abs($motion3d_x))}
motion3d_y-={sign($motion3d_y)*min(1,abs($motion3d_y))}
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w[] 0 rm endl v +
#@cli x_histogram
#@cli : Launch the histogram demo.
x_histogram :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Histogram demo"$n" -------------------------------\n
----\n
---- "${c}"Mouse"$n" to set parameters.\n
---- "${c}"Right button"$n" or key '"${c}"SPACE"$n"' to reset.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
v -
if {!$!} sp ? to_rgb
else k[0] to_rgb r2dy 300,2 if {w>800} r 800,100%,1,3,2 fi n 0,255
fi
+frame. 1,1,0
300,{h},1,3,220
t. "Gamma :",5,0,16,1,0
t. "Contrast :",5,50,16,1,0
t. "Brightness :",5,100,16,1,0
t. "Smoothness :",5,150,16,1,0
t. "Sharpness :",5,200,16,1,0
t. "Clusters :",5,250,16,1,0
a[-2,-1] x
{w},200,1,3,255
grid. 10%,10%,0,0,0.3,0xCCCCCCCC,0
rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
axes. 0,255,1,0,13,1,0
frame[-2,-1] 5,5,220
a[-2,-1] y
clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1
do
[0]
ia={ia}
if $gamma /. 255 ^. {1/$gamma} *. 255 fi
-. $ia *. $contrast +. $brightness +. $ia
b. $smoothness
sharpen. $sharpness
c. 0,255
+j.. .,6,6
sx={{0,w}+12}
_x_histogram. {$gamma*100/4} j.. .,$sx,25 rm.
_x_histogram. {$contrast*100/4} j.. .,$sx,75 rm.
_x_histogram. {($brightness+128)*100/256} j.. .,$sx,125 rm.
_x_histogram. {$smoothness*100/10} j.. .,$sx,175 rm.
_x_histogram. {$sharpness*100/2000} j.. .,$sx,225 rm.
_x_histogram. {$clusters*100/256} j.. .,$sx,275 rm.
+s.. c histogram[-3--1] $clusters,0,255 /[-3--1] {6*{0,wh}/$clusters} rm[-5]
+z[-4] 5,{0,h+16},{{-4,w}-5},{{-4,h}-6}
graph. [-4],3,0,1,0,0.2,255,0,0
graph. ...,3,0,1,0,0.2,0,255,0
graph. ..,3,0,1,0,0.2,0,0,255
rm[-4--2]
j.. .,5,{0,h+16} rm.
if {{*,b}&1\ &&\ {*,x}<{0,w}\ &&\ {*,y}<{0,h}}
j. [0],6,6 to. Original,10,10,16
fi
w. {w},{h},0,"[G"{`39`}"MIC] Histogram Demo" rm.
wait
if {{*,b}&1\ &&\ {*,x}>={0,w}-10}
if {{*,y}>=25\ &&\ {*,y}<=42}
gamma={max(0,min(4,({*,x}-$sx)*4/280))}
elif {{*,y}>=75\ &&\ {*,y}<=92}
contrast={max(0,min(4,({*,x}-$sx)*4/280))}
elif {{*,y}>=125\ &&\ {*,y}<=142}
brightness={max(-128,min(128,({*,x}-$sx)*256/280-128))}
elif {{*,y}>=175\ &&\ {*,y}<=192}
smoothness={max(0,min(10,({*,x}-$sx)*10/280))}
elif {{*,y}>=225\ &&\ {*,y}<=242}
sharpness={max(0,min(2000,({*,x}-$sx)*2000/280))}
elif {{*,y}>=275\ &&\ {*,y}<=292}
clusters={max(2,min(256,({*,x}-$sx)*256/280))}
fi
fi
if {{*,b}&2\ ||\ {*,SPACE}} clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1 fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w 0 rm v +
_x_histogram :
val={max(0,min(100,$1))}
280,2,1,3,255 line. 0,0,$val%,0,1,0,255,0 line. 0,1,$val%,1,1,240,255,62 r. 100%,16,1,3,3
0 t. {round($val)}%,0,0,14,1,1 +*. -255 +. 255 r. 100%,100%,1,3
j... .,{(280-w)/2},{(16-h)/2},0,0,1,.. rm[-2,-1]
r. {w+2},{h+2},1,3,0,0,0.5,0.5
#@cli x_hough
#@cli : Launch the hough transform demo.
x_hough :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Hough-transform"$n" -----------------------------------------\n
----\n
---- "${c}"Mouse buttons"$n" on the vote image to draw corresponding line.\n
---- "${c}"Mouse buttons"$n" on the image to vote for all lines crossing.\n
---- the clicked point.\n
---- Key '"${c}"SPACE"$n"' to reset the hough window.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------------"
v -
if {!$!} l[] sp greece onfail testimage2d 400 endl fi
n 0,255
repeat $! l[$>]
r. ${fitscreen\ {w},{h}},1,100%,3
if {!narg($first_time)}
parallel 0,"+l[0] r2dy 128 frame 1,1,0 \
alert \"[G"{`39`}"MIC Hough Transform]\",\
\"The G\47MIC Hough transform demo illustrates the application\n\
of the Hough transform to detect lines in an image. Use your\n\
mouse buttons to explore the transform image and see how\n\
lines in images are represented by points in the transform.\",\
\"OK\" \
rm endl"
first_time=0
fi
rhomax={sqrt(w^2+h^2)/2}
+b. 1.5 hough. 512,400 b. 0.5 +. 1 log. n. 0,255
w.. -1,-1,0,"[G"{`39`}"MIC] Image" w1. -1,-1,0,"[G"{`39`}"MIC] Hough Transform"
do
wait
if {*,b}
x0={{*,x}-{*,w}/2}
y0={{*,y}-{*,h}/2}
rho0={sqrt(($x0)^2+($y0)^2)}
theta0={atan2($y0,$x0)}
(0,{2*pi}) ($theta0,{$theta0-2*pi})
r[-2,-1] {-3,w},1,1,1,3
cos. *. $rho0 +<. 0 abs..
*. {pi} +[-3,-1] %.. {2*pi}
*.. {0.5*{-3,w}/pi} *. {{-3,h}/$rhomax}
a[-2,-1] y
repeat {w} point.. {i($>,0)},{i($>,1)},0,0.3,255 done
rm. w1.
elif {{*1,x}>=0" && "{*1,b}}
theta={{*1,x}*2*pi/{*1,w}}
rho={{*1,y}*$rhomax/{*1,h}}
x={{-2,w}/2+$rho*cos($theta)}
y={{-2,h}/2+$rho*sin($theta)}
x0={$x+1000*sin($theta)}
y0={$y-1000*cos($theta)}
x1={$x-1000*sin($theta)}
y1={$y+1000*cos($theta)}
..
line. $x0,$y0,$x1,$y1,1,0x0F0F0F0F,255
line. {$x0+1},$y0,$x1,$y1,1,0x0F0F0F0F,255
line. $x0,{$y0+1},$x1,$y1,1,0x0F0F0F0F,255
line. $x0,$y0,$x1,$y1,1,0xF0F0F0F0,0
line. {$x0+1},$y0,$x1,$y1,1,0xF0F0F0F0,0
line. $x0,{$y0+1},$x1,$y1,1,0xF0F0F0F0,0
w. rm.
elif {{*,SPACE}" || "{*1,SPACE}}
rm. +b. 1.5 hough. 512,400 b. 0.5 +. 1 log. n. 0,255
w1. -1,-1,0,"Hough Transform"
elif {*,r} w..
elif {*1,r} w1.
fi
while {{*}" && "{*1}" && "!{*,ESC}" && "!{*,Q}" && "!{*1,ESC}" && "!{*1,Q}}
w 0 w1 0
rm. endl
if {!{*}" || "!{*1}} break fi
done rm v +
#@cli x_jawbreaker : 0<_width<20,0<_height<20,0<_balls<=8
#@cli : Launch the Jawbreaker game.
x_jawbreaker : check "${1=12}>0 && $1<20 && ${2=13}>0 && $2<20 && ${3=5}>0 && $3<=8"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Jawbreaker"$n" --------------------------------------------\n
----\n
---- The goal of the game is to "${c}"remove the maximum number of\n
---- balls on the board"$n", simply by clicking on them. But a\n
---- colored ball can disappear only if it is grouped with at\n
---- least one ball of the same color. The score is higher if\n
---- you destroy larger sets of connected colored balls.\n
----\n
---- "${c}"Left mouse button"$n" to select/destroy balls on board.\n
---- Key '"${c}"BACKSPACE"$n"' or '"${c}"SPACE"$n"' to undo the last move.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
v -
i[board] $1,$2 rand[board] 1,$3 round[board] 1
i[undo] .
i[balls] 40,40,1,4 _x_jawbreaker_ball.
autocrop. 0 expand_xy. 1,0 *. 1.5 c. 0,255 r. {{board,w}*w},{{board,h}*h},1,1,0,2 /. 255
i[back] {w},{h},1,3 l.
rand 0,255 blur_xy 6,20 equalize 100,0,255 blur_xy 2,4
sh 0 sh.. 1 sh... 2 /... 4 /.. 8 /. 2 rm[-3--1]
endl
i[visu] [back]
score=0
undoscore=0
render_board=1
shapescorey=0
shapescore=0
do
if $render_board
+abs[board] -. 1 *. {360/$3} +>=[board] 0 *. 0.9 +!=[board] 0
r[-3--1] [balls] [balls] *[-2,-1] a[-3--1] c hsv2rgb.
+compose_channels. + >. 0 dilate. 3
j[visu] [back] j[visu] ..,0,0,0,0,1,. rm[-2,-1]
if {!$shapescorey} w[visu] {back,w},{back,h},0,"[G"{`39`}"MIC] Jawbreaker (Score : "$score")" fi
render_board=0
fi
if $shapescorey
+t[visu] "+"$shapescore,{*,x},{{*,y}-64+$shapescorey},32,{($shapescorey-1)/31},255
shapescorey={max(0,$shapescorey-1)}
w. {back,w},{back,h},0,"[G"{`39`}"MIC] Jawbreaker (Score : "$score")" rm. wait 25
else wait fi
+f[board] "if(i,j(-1)==i || j(1)==i || j(0,1)==i || j(0,-1)==i,0)"
if {!is} rm. break fi rm.
if {*,r} render_board=1
elif {*,S} o[visu] gmic_jawbreaker.png
elif {{*,BACKSPACE}" || "{*,SPACE}}
abs[undo] j[board] [undo]
score=$undoscore
render_board=1
elif {{*,x}">=0 && "{*,b}}
wait -1
x={"int("{*,x}"*"{board,w}"/"{*,w}")"}
y={"int("{*,y}"*"{board,h}"/"{*,h}")"}
if {{board,i($x,$y)}>0}
abs[board] flood[board] $x,$y,0,0,0,1,-{board,i($x,$y)}
+>=[board] 0 -. 1
shapescore={(is+1)^2} shapescorey={if($shapescore,32,0)} rm.
elif {board,i($x,$y)}
+flood[board] $x,$y,0,0,0,1,-1 ==. -1
if {is>1}
j[undo] [board]
undoscore=$score
flood[board] $x,$y,0,0,0,1,0
repeat {board,w}
+columns[board] $> mirror. y
h={board,h} l. s -,0 a y if $! r 1,$h,1,1,0 mirror y else i 1,$h fi endl
j[board] .,$> rm.
done
rows[board] -1,100% f[board] "if(y==0,if(i(x,h-1),x,w),i)" sort[board] +,x rows[board] 1,100%
score+={int((is-1)^2)}
fi
rm.
else abs[board]
fi
render_board=1
fi
while {{*}" && "!{*,Q}" && "!{*,ESC}}
if {{*}" && "!{*,ESC}}
w[] {visu,w},{visu,h},0,"[G"{`39`}"MIC] Jawbreaker (Final Score : "$score")"
i[gameover] 260,85 t. "Game Over!",3,0,53,1,1 t. "Score : "$score,23,53,32,1,1
+dilate. 5 nm. "mgameover" *.. 255 r.. 100%,100%,1,3
repeat 25
+r[gameover,mgameover] {400-12*($>+1)}%,{400-12*($>+1)}%
+j[visu] ..,{({visu,w}-w)/2},{({visu,h}-h)/2},0,0,{$>/25},.
w. rm[-3--1] wait 25
done
do
wait if {*,r} w[] {*,w},{*,h} wait -1 fi
while {{*}" && "!{*,Q}" && "!{*,ESC}" && "!{*,b}}
rm[gameover,mgameover]
fi
rm[board,undo,balls,back,visu]
w 0 v +
_x_jawbreaker_ball :
mwh={min(w,h)}
sh 3 f. 0 rm.
ellipse {0.5*$mwh},{0.5*$mwh},{0.5*$mwh-4},{0.5*$mwh-4},0,1,240,240,240,1
sh 0,2 *. '($mwh+y-x)/(2*w)' rm.
sh 3 *.. . dilate. 5 rm.
sh 0,2 +. 'if(i&&(!j(-1)||!j(1)||!j(0,-1)||!j(0,1)),240/6,0)' rm.
ellipse {$mwh*0.7},{$mwh*0.3},{min(30,$mwh*$mwh/512)},{min(30,$mwh*$mwh/512)},0,{min($mwh/64,1)},255,255,255,1
#@cli x_landscape
#@cli : Launch the virtual landscape demo.
x_landscape :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Virtual landscape"$n" -------------------------------------\n
----\n
---- Enjoy the view!\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
v - l[]
W=150 H=350
900,900 plasma. 1,1,6 b. 0.07% n. 0,255 nm. map
+g. *. 0.5 +[-2,-1] n. 0,1 ^. 2 n. -150,330
equalize[map] 256 n[map] -400,160 c[map] 0,100%
(0,102,51;149,175,124;102,42,0;255,255,255) permute. yzcx srgb2rgb. r. 256,1,1,3,3 rgb2srgb. +n[map] 0,255 map. .. rm..
+. .. rm.. c. 0,255 nm. colors
$W,$H,1,1,'x' y. x nm. x
$W,$H,1,1,'1+x+y*w' y. x nm. offsets
$W,$H,1,1,'0.5*y' nm. gmap Mgmap={iM}
$W,$H,1,3 fc. 60,80,135 nm. ccolors
$W,$H,1,1,'(y/$H)^2' nm. mcolors
$W,400,1,1,'b=h-1-$Mgmap;if(y>=b,256+(y-b)*255/(h-1-b),y*255/b)' round.
(96^16^128) (0^200^255) a[-2,-1] x r. 256,1,1,3,3
(0^32^0) (0^64^128) a[-2,-1] x r. 256,1,1,3,3
a[-2,-1] x map.. . rm.
nm. background
quadrangle3d[] -0.45,0,0,0.45,0,0,0.55,1,0,-0.55,1,0 *3d. {$W/2},{$H/2} nm. viewrange3d
(64^16^0) r. $W nm. groundcolor
w[] 600,400,0,"[G"{`39`}"MIC] Virtual Landscape"
do
t={$|*0.03}
xm={map,w/2+(w-$H/2)/2*cos(3.1*$t)}
ym={map,h/2+(h-$H/2)/2*sin(2.8*$t)}
u={map,(w-$H/2)*cos(2.5*$t)}
v={map,(h-$H/2)*sin(9.7*$t)}
a={atan2($v,$u)*180/pi}
+r3d[viewrange3d] 0,0,1,$a y. x
({$xm+i[8]},{$xm+i[11]};{$xm+i[17]},{$xm+i[14]}^{$ym+i[9]},{$ym+i[12]};{$ym+i[18]},{$ym+i[15]}) rm..
r. $W,$H,1,2,3 +warp[map,colors] .,0,1,0 rm...
nm.. lmap nm. lcolors
+!=[lmap] 0 nm. ground
+[lmap] [gmap]
j[lcolors] [ccolors],0,0,0,0,1,[mcolors]
j[lcolors] [groundcolor]
+round[lmap] f. '>m=abs(j(0,-1));i>m?i:-m' nm. y0
+shift. 0,1 abs. +. 1 nm. y1
*[y0,y1] [ground] rm[ground]
r[lcolors,y0,y1] {$W*$H},1,1,100%,-1
+>[y0] 0 *. [offsets] discard. 0
if {h}
-. 1 +warp[x] .,0,0,0 nm. lx
warp[lcolors,y0,y1] ..,0,0,0 rm..
N={h} ({'CImg3d'},{2*$N},$N)
+a[lx] [y0],x rm[y0] +a[lx] [y1],x rm[lx,y1] a[-2,-1] y z. 0,2
1,$N,1,1,2 +f. y ++. $N a[-3--1] x
mv[lcolors] $! permute. cyzx
1,$N,1,1,1
y[-5--1] y a[-5--1] y *3d. -1,-1
+j3d[background] .,{background,w-1},{background,h},0,1,1,0,0,0 rm[-3,-2]
else
rm[-5--1] [background]
fi
r. {*,w},{*,h},1,3
fps=${-fps} if {$fps>0} to. $fps" fps",5,5,24,2,0.2 fi
w. -1,-1,0 rm.
if {{*,CTRLLEFT}&&{*,D}} w[] 900,600 elif {{*,CTRLLEFT}&&{*,C}} w[] 600,400 fi
wait 20
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 endl v +
#@cli x_life
#@cli : Launch the game of life.
x_life :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"The game of life"$n" --------------------------------------\n
----\n
---- The goal is to create the "${c}"biggest possible biological\n
---- system"$n". You start with a stock of cells which you can\n
---- spread over the board. For each new cells created\n
---- simultaneously and spontaneously by your system, you\n
---- gain more new cells to scatter.\n
----\n
---- "${c}"Left mouse button"$n" to scatter cells in stock.\n
---- "${c}"Right mouse button"$n" to reset game.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
v -
i[0] 90,90,1,1,0
i[1] [0] f[1] 0
i[2] 400,400,1,3
i[3] 1
iteration=0
score=0
bestscore=0
stock=500
w[0] 400,400,0,"[G"{`39`}"MIC] The Game of Life"
cursor[0] 0
do
(1,1,1;1,0,1;1,1,1) +correlate[0] .,0 rm..
+ir. 2,2 &. [0] ir.. 3,3 -|[-2,-1]
rv[0,-1]
if {{*,x}>0" && "{*,b}==1" && "$stock>0}
nb={u*7}
repeat $nb
x={{*,x}/{*,w}*{0,w}+u(-4,4)}
y={{*,y}/{*,h}*{0,h}+u(-3,3)}
=[0] 1,$x,$y
=[1] $iteration,$x,$y
point[2] {$x*{2,w}/{0,w}},{$y*{2,h}/{0,h}},0,0.8,255
done
stock={round(max(0,$stock-$nb))}
fi
-. [0] *. -1
stock-={2*(min(0,int(is/16*$score/150)))}
+[1] [0]
min. 0 +. 1 *[1,-1]
if {{*,b}==2}
f[0-2] 0 iteration=0 score=0 bestscore=0 stock=500 rm[3] i[3] 1
fi
if {{3,w}==1}
rm[3] i[3] {u(3,12)},1,1,3,u(100,255)
r[3] {u(100,300)}%,1,1,3,4
point[3] 0,0,0,1,0
r[3] {u(100,600)}%,1,1,3,5 c[3] 0,255
fi
+r[1] {2,w},{2,h} &. 7 b. {1+$score*0.05}
n. 0,{3,w} map. [3] *. 0.1 +[2,-1] /[2] 1.1
[2] if {{*,x}>0}
opac={0.7*min(1,$stock/500)} r={min(500,$stock)*cos($iteration)/100}
ellipse. {*,x},{*,y},{15+$r},{15+$r},0,$opac,0,196,0
ellipse. {*,x},{*,y},{10+$r},{10+$r},0,$opac,32,64,16
ellipse. {*,x},{*,y},{5+$r},{5+$r},0,$opac,255,230,0
fi
t. "Living cells : "$score"\n"\
"Stock : "$stock"\n"\
"Score : "$bestscore,5,3,22,0.7,255
w. {*,w},{*,h}
if {*,S} o. gmic_life.png fi
rm.
if {!($iteration%10)} score={0,is} bestscore={max($score,$bestscore)} fi
wait 60
iteration+=1
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm[0-3] w 0 v +
#@cli x_light
#@cli : Launch the light effect demo.
x_light :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Light effect"$n" ------------------------\n
----\n
---- Move light position with "${c}"mouse"$n".\n
---- "${c}"Mouse buttons"$n" fade light in/out.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
v -
0 t. "    G\47MIC\nLight effect",0,0,80,1,255 expand_xy. 15,0 b. 3
. n.. 0,1 r.. 100%,100%,1,3
sh.. 0 *. 120 rm.
sh.. 1 *. 70 rm.
sh.. 0,50%,0,2 *. 120 rm.
25%,25%,1,1 rand. -20,20 smooth. 10,0,1,1,4 r. ..,3 b. 3 n. -100,100
+[-2,-1] g. xy a[-2,-1] c n. -150,150
w[] {1.5*{-2,w}},{1.5*{-2,h}},0,"[G"{`39`}"MIC] Light Effect"
cursor[0] 0
light=70
640,640 gaussian. $light n. 0,255
t=0
do
if {{*,x}>=0}
X={round((w-{*,x})/2)}
Y={round((h-{*,y})/2)}
else
X={round((w-{-2,w}*(1+cos(2*$t)))/2)}
Y={round((h-{-2,h}*(1+sin(2.5*$t)))/2)}
t+=0.02
fi
if {{*,b}&1} light={min(200,$light+10)} gaussian. $light n. 0,255 fi
if {{*,b}&2} light={max(10,$light-10)} gaussian. $light n. 0,255 fi
+z. $X,$Y,{$X+{-2,w}-1},{$Y+{-2,h}-1}
warp. ...,1,0,1
r. 100%,100%,1,3 +. [-4] c. 0,255
fps=${-fps} if {$fps>0} to. $fps" fps",5,5,16,1,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h}
elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
rm. if {{*,x}>=0" && "!{*,b}} wait else wait 20 fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w[] 0 rm[-3--1] v +
#@cli x_mandelbrot : _julia={ 0 | 1 },_c0r,_c0i
#@cli : Launch Mandelbrot/Julia explorer.
x_mandelbrot : skip ${1=0},${2=0.317},${3=0.03}
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Mandelbrot/Julia explorer"$n" -----------------\n
----\n
---- Select zooming region with "${c}"mouse"$n".\n
---- "${c}"Click once"$n" to reset zoom factor.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
---- Key '"${c}"C"$n"' to print current fractal coordinates.\n
----\n
--------------------------------------------------"
v -
rm w 512,512,0 _x_mandelbrot_coords $1 _x_mandelbrot_palette
do
siz={min({*,w},{*,h})}
$siz,$siz mandelbrot. {0,^},256,$1,{if($1,$2,0)},{if($1,$3,0)} map. [1]
if $1 w. $siz,$siz,0,"[G"{`39`}"MIC] Julia Set c=("{0,@0-1}")-("{0,@2-3}"), c0=($2,$3)"
else w. $siz,$siz,0,"[G"{`39`}"MIC] Mandelbrot Set c=("{0,@0-1}")-("{0,@2-3}")" fi
w={w} h={h} round. select. 2
if {i[0]>0}
M={max(i[3]-i[0],i[4]-i[1])}
if {$M<5} _x_mandelbrot_coords $1 rm[1] _x_mandelbrot_palette mv. 1
else ({{0,@0}+{@0}*({0,@2}-{0,@0})/$w};\
{{0,@1}+{@1}*({0,@3}-{0,@1})/$h};\
{{0,@0}+({@0}+$M)*({0,@2}-{0,@0})/$w};\
{{0,@1}+({@1}+$M)*({0,@3}-{0,@1})/$h})
fi
rm[0] mv. 0
fi
rm.
if {{*,C}}
if $1 v + e[0--4] "Julia set, at c = ("{0,@0-1}")-("{0,@2-3}"), with c0 = ($2,$3)." v -
else v + e[0--4] "Mandelbrot set, at c = ("{0,@0-1}")-("{0,@2-3}")." v -
fi
fi
if {!{*}" || "{*,ESC}" || "{*,Q}} rm w 0 v + return fi
wait -1
while 1
_x_mandelbrot_coords :
if $1 (-2;-2;2;2) else (-2.1;-1.5;1.2;1.5) fi
_x_mandelbrot_palette :
6,1,1,3 rand. 20,255 r. 32,1,1,3,3 r. 1024,1,1,3,0,2 =. 0,0,0,0,0 =. 0,0,0,0,1 =. 0,0,0,0,2
#@cli x_mask_color : _colorspace={ all | rgb | lrgb | ycbcr | lab | lch | hsv | hsi | hsl | cmy | cmyk | yiq },_spatial_tolerance>=0,_color_tolerance>=0
#@cli : Interactively select a color, and add an alpha channel containing the corresponding color mask.
#@cli : Argument 'colorspace' refers to the color metric used to compute color similarities, and can be basically one of { rgb | lrgb | ycbcr | lab | lch | hsv | hsi | hsl | cmy | cmyk | yiq }.
#@cli : You can also select one one particular channel of this colorspace, by setting 'colorspace' as 'colorspace_channel' (e.g. 'hsv_h' for the hue).
#@cli : Default values: 'colorspace=all', 'spatial_tolerance=5' and 'color_tolerance=5'.
x_mask_color : check "${2=5}>=0 && ${3=5}>=0" skip ${1=all}
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[^-1] "Interactively create color mask for image$?, with color space $1, spatial tolerance $2 and color tolerance $3."
e[] "\n
----------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" adds a wanted color to the selection.\n
---- "${c}"Right mouse button"$n" adds an unwanted colors to the selection.\n
---- "${c}"Middle mouse button"$n" or key '"${c}"R"$n"' resets color mask.\n
---- Key '"${c}"SPACE"$n"' or '"${c}"TAB"$n"' toggles view modes (masked RGB or mask).\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
----------------------------------------------------------------------------------------------------"
v - l[] _ac_$1 onfail error[0--3] "Command '$0' : Invalid colorspace '$*'." endl
m _ac_forward:$_f
repeat $! l[$>] slices 0 basename {0,n} nm=${}
wh=${fitscreen\ {[w,h]},1,128,1024}
+r $wh,1,100%,2
+_ac_forward. channels. $_s
if {1,s>3} channels[1] 0,2 fi to_rgb[1]
w[1] 100%,100%,0,$nm
colors_add=-1 colors_sub=-1 visumode=0
is_clicked=0 time=0 delay=0.1
do
time={$is_clicked?$time:$|}
wait
x={2,round({*,x}*(w-1)/({*,w}-1))}
y={2,round({*,y}*(h-1)/({*,h}-1))}
b={*,b}
c=$x,$y,{2,I($x,$y)}
is_add={arg(1,$colors_add)>=0}
is_sub={arg(1,$colors_sub)>=0}
is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
is_resized=0
refresh=0
if {$x>=0" && "$b&1}
if $is_add colors_add=$colors_add,$c else colors_add=$c fi
is_clicked=1
refresh={$|-$time>$delay}
elif {$x>=0" && "$b&2}
if $is_sub colors_sub=$colors_sub,$c else colors_sub=$c fi
is_clicked=1
refresh={$|-$time>$delay}
elif {$b&4" || "{*,R}}
colors_add=-1 colors_sub=-1 refresh=1 is_clicked=1
elif {!$b}
refresh={$is_clicked==1}
is_clicked=0
fi
if {{*,-TAB}||{*,-SPACE}} visumode={($visumode+1)%3} refresh=1 fi
if {*,r} is_resized=1
elif {$is_ctrl" && "{*,-D}} w[] {1,1.25*[w,h]} is_resized=1
elif {$is_ctrl" && "{*,-C}} w[] {1,0.8*[w,h]} is_resized=1
elif {$is_ctrl" && "{*,R}} w[] ${fitscreen\ {0,[w,h]},1,128,1024} is_resized=1
fi
if $is_resized rm[1,2] +r {*,d},{*,e},1,3,2 +_ac_forward. channels. $_s refresh=1 fi
if $refresh
_x_mask_color[2] {$2*w#2/w#0},$3,{``$colors_add},{``$colors_sub} delay=${}
if {$visumode==0} +. 64 c. 0,255 +a[1,-1] c drgba. w. -1,-1,$nm" [half-masked]" rm.
elif {$visumode==1} +a[1,-1] c drgba. w. -1,-1,$nm" [masked]" rm.
else w. -1,-1,$nm" [mask]"
fi
rm.
time=$|
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}
if {arg(1,$colors_add)>=0} ($colors_add) r. {2+s#2},{w/(2+s#2)},1,1,-1 +z. 0,1 *. '{(w#0-1)/(w#2-1)},{(h#0-1)/(h#2-1)}' j.. . colors_add={-2,^} rm[-2,-1] fi
if {arg(1,$colors_sub)>=0} ($colors_sub) r. {2+s#2},{w/(2+s#2)},1,1,-1 +z. 0,1 *. '{(w#0-1)/(w#2-1)},{(h#0-1)/(h#2-1)}' j.. . colors_sub={-2,^} rm[-2,-1] fi
rm[-2,-1] +_ac_forward channels. $_s
_x_mask_color. $2,$3,{``$colors_add},{``$colors_sub}
rm.. a c
endl done
uncommand _ac_forward
v +
_x_mask_color :
100%,100%
is_add={arg(1,$3)>=0}
is_sub={arg(1,$4)>=0}
t0=$|
if {$is_add" || "$is_sub}
if $is_add ($3) r. {2+s#0},{w/(2+s#0)},1,1,-1 N_add={h} M_add={"M = vectorw(); for (k = 0, k<w, ++k, M[k] = med(crop(k,1)));M"} rm. fi
if $is_sub ($4) r. {2+s#0},{w/(2+s#0)},1,1,-1 N_sub={h} M_sub={"M = vectorw(); for (k = 0, k<w, ++k, M[k] = med(crop(k,1)));M"} rm. fi
f. "begin(
const is_add = "$is_add";
const is_sub = "$is_sub";
const ss = sqrt(2)*$1;
const sc = sqrt(2)*$2;
colors_add = [ $3 ];
colors_sub = [ $4 ];
M_add = [ 0"$M_add"];
M_sub = [ 0"$M_sub"];
const N_add = 0"$N_add";
const N_sub = 0"$N_sub";
const siz = 2 + s#0;
const siz2 = sqr(siz);
sigma = vectorsiz(sc);
sigma[0] = sigma[1] = ss;
tensor(op) = (
T = vectorsiz2();
if (is_#op,
for (k = 0, k<size(colors_#op), k+=siz, C = colors_#op[k,siz]-=M_#op; C*=sigma; T+=mul(C,C,siz));
T/=1e-8 + N_#op;
T+=eye(siz);
T = inv(T);
); T
);
T_add = tensor(add);
T_sub = tensor(sub);
);
P = [ x,y,I#0 ];
pot_add = is_add?(C = P - M_add; exp(-dot(C,T_add*C))):1;
pot_sub = is_sub?(C = P - M_sub; exp(-dot(C,T_sub*C))):0;
pot_add - pot_sub"
c. 0,1 n. 0,512 c. 0,255
else f. 255
fi
u {$|-$t0}
#@cli x_metaballs3d
#@cli : Launch the 3D metaballs demo.
x_metaballs3d :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"3D metaballs"$n" ---------------------------------------\n
----\n
---- "${c}"Mouse button"$n" or '"${c}"SPACE"$n"' key to toggle rendering mode.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------"
v - l[]
100,100 noise. 100,1 plasma. 1,0,10 r. 512,320,1,3 n. 0,1 b. 4,0 n. 0,255
mix_channels. (0.7,0,0;0,0.9,0;0,0,1.2) c. 0,255 l3d
0
24,24,24,1,'X=x-w/2;Y=y-h/2;Z=z-d/2;exp(-(X*X+Y*Y+Z*Z)/100)'
72,72,72 M=8 mode=3
s0=Dots s1=Wireframe s2=Flat s3=Flat-shaded s4=Gouraud-shaded s5=Phong-shaded
repeat $M fx$>={2*g} fy$>={2*g} fz$>={2*g} done
w[0] -1,-1,0,"[G"{`39`}"MIC] 3D Metaballs"
do
repeat $M
x$>={w/2+0.5*(w-{2,w}-4)*cos(${fx$>}*$|)}
y$>={h/2+0.5*(h-{2,h}-4)*sin(${fy$>}*$|)}
z$>={d/2+0.5*(d-{2,d}-4)*sin(${fz$>}*$|)}
done
f[3] 0 repeat $M j[3] [2],{${x$>}-{2,w/2}},{${y$>}-{2,h/2}},{${z$>}-{2,d/2}},0,-1 done
+r[3] 28,28,28,1,2 isosurface3d. 0.4 -3d. 12,12,12 *3d. 13 rv3d.
r3d. 1,2,1,{100*$|}
N={i[7]} (255,255,150;200,96,164;50,150,230) r. 3,$N,1,1,3 y. j.. .,0,{{-2,h}-4*$N}
if {!$mode} circles3d.. 4 fi
if {!{1,w}}
0 t. ${s$mode},5,5,23,0.5,255,255,255 b. 0.7 n. 0,255
+dilate. 3 +j[0] ..,5,3,0,0,1,.,255 mv. 1 rm[2,-2,-1]
fi
+j3d[1] ..,50%,50%,0,1,{if(!$mode,3,$mode)},0,0,300,0,0,-500,0.1,1.5
fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-22},16,2,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
rm[-3--1] wait 20
if {{*,b}||{*,SPACE}} mode={($mode+if({*,b}&2,-1,1))%6} wait -1 rm[1] i[1] 0 fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 endl v +
#@cli x_minesweeper : 8<=_width=<20,8<=_height<=20
#@cli : Launch the Minesweeper game.
x_minesweeper : check "${1=20}>=8 && $1<=30 && ${2=$1}>=8 && $2<=30"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Minesweeper"$n" -------------------------------------------\n
----\n
---- The goal is to "${c}"clear the minefield"$n" without detonating a\n
---- mine.\n
----\n
---- "${c}"Left mouse button"$n" to try clearing one square.\n
---- "${c}"Right mouse button"$n" to flag or unflag a square.\n
---- "${c}"Middle mouse button"$n" to reset mine field.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------\n"
v -
$1,$2 noise. 30,2 ==. 1 nb_mines={is} (1,1,1;1,0,1;1,1,1) +convolve.. .,0 rm.. +. 1 ==.. 0 *[-2,-1] nm. field
do x={round(u(w-1))} y={round(u(h-1))} while {i($x,$y)!=1}
+f[field] 11 =. 12,$x,$y nm. board
24,24,1,3,200 fc. 255,180,130
ellipse. 12,12,4,4 line. 6,12,18,12 line. 12,6,12,18 line. 13,10,14,10,1,255 line. 13,11,14,11,1,255
z. 1,1,{w-2},{h-2} frame. 1,1,0
+fc. 230,250,255
+t. "1",10,5,13,1,0,196,0 +t.. "2",9,5,13,1,0,128,0 +t... "3",9,5,13,1,0,0,255
+t[-4] "4",9,5,13,1,255,0,0 +t[-5] "5",9,5,13,1,200,0,0 +t[-6] "6",9,5,13,1,150,0,0
+t[-7] "7",9,5,13,1,128,0,0 +t[-8] "8",9,5,13,1,64,0,0
+f. 'if(x<=1||y<=1||x>=w-2||y>=h-2,if(x<y,128,255),160+2*(y+x))'
+polygon. 4,13,15,11,15,6,18,17,18,1,0 line. 12,15,12,6,1,255,0,0 polygon. 3,12,6,6,9,12,12,1,220,0,0
rv[-2,-1]
. 100%,100%,1,3 line. 6,14,10,18,1,0,200,0 line. 10,18,16,6,1,0,200,0 dilate. 2
+channels. 1 n. 0,0.7 dilate. 3 j... ..,0,0,0,0,1,. rm[-2,-1]
a[-13--1] x nm. sprites
(0,23;0,23^0,0;23,23) r. 24,24,1,2,3 r. {board,w*24},{board,h*24},1,2,0,2 nm. offsets
.,.,1,3,255 frame. 1,1,0 frame. 23,23,255
0 t. "Number of mines : "$nb_mines,0,0,18,1,100,200,255 negate. j.. .,{({-2,w}-w)/2},{{-2,h}-h-2} rm.
nm. canvas
failed=0 succeeded=0 nb_flags=0 started=0
do
+*[board] 24 r. [offsets],[offsets] channels. 0,1 +. [offsets] +warp[sprites] .,0,0 rm..
j[canvas] .,24,24 rm.
wait -1
if $failed
0 t. "Game\nOver!",3,3,38,1,255 r. 100%,100%,1,4 sh. 3 dilate. 5 /. 2 rm.
drop_shadow. 5,5,1 blend[canvas,-1] alpha
0 t. "Boom! You failed!",0,0,18,1,100,255,255 r. {canvas,w},100%,1,3,0,0,0.5,0.5 negate. j[canvas] .,0,3 rm.
do w[canvas] {w},{h} wait while {{*}" && "!{*,ESC}" && "!{*,Q}}
elif $succeeded
0 t. "Success!",3,3,38,1,255 r. 100%,100%,1,4 sh. 3 dilate. 5 /. 2 rm.
drop_shadow. 5,5,1 blend[canvas,-1] alpha
0 t. "Congratulations! ("{round($|-$tic)}" s)",0,0,18,1,255,100,255 r. {canvas,w},100%,1,3,0,0,0.5,0.5
negate. j[canvas] .,0,3 rm.
do w[canvas] {w},{h} wait while {{*}" && "!{*,ESC}" && "!{*,Q}}
else
+==[board] 10 nb_flags={is} rm.
do
if {!$started} tic=$| fi
0 t. "Elapsed time : "{round($|-$tic)}" s / Flags : "$nb_flags,0,0,18,1,255,200,0 r. {canvas,w},100%,1,3,0,0,0.5,0.5
negate. j[canvas] .,0,3 rm.
wait 50
x={int(({*,x}-24)/24)} y={int(({*,y}-24)/24)} b={*,b}
w[canvas] {w},{h},0,"[G"{`39`}"MIC] Minesweeper"
while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!$b}
fi
if {$x>=0\ &&\ $y>=0\ &&\ $x<{board,w}\ &&\ $y<{board,h}}
if {$b&1}
started=1 val={field,i($x,$y)}
if {$val==0} +==[field] 0 j[board] [field],0,0,0,0,1,. rm. failed=1
elif {$val==1} +flood[field] $x,$y,0,0,1,1,-1 ==. -1 dilate. 3 j[board] [field],0,0,0,0,1,. rm.
else =[board] $val,$x,$y
fi
elif {n={board,i($x,$y)};$b&2" && "n>=10" && "n<=11}
=[board] {if({board,i($x,$y)}==11,10,11)},$x,$y
elif {$b&4} f[board] 10
fi
fi
if {$nb_mines==$nb_flags\ &&\ {board,iM}!=11} succeeded=1 fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w 0 v +
#@cli x_minimal_path
#@cli : Launch the minimal path demo.
x_minimal_path :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Minimal path"$n" ------------------------------------------\n
----\n
---- "${c}"Click on two points"$n" to compute and display the minimal\n
---- path between those points. The ending point is then\n
---- chosen as the next starting point for another path.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
v -
if {!$!} sp ? fi
n 0,200 round 1
repeat $! l[$>]
w[0] -1,-1,0,"[G"{`39`}"MIC] Select Starting Point P0"
if {!narg($first_time)}
parallel 0,"+l[0] r2dy 128 frame 1,1,0 \
alert \"[G"{`39`}"MIC Minimal Path]\",\
\"The G\47MIC minimal path demo illustrates how minimal paths\n\
can be computed in images to detect and track edge points.\n\
Use your mouse to select desired starting and ending points,\n\
and see what is the minimal path computed between these points.\",\
\"OK\" \
rm endl"
first_time=0
fi
+gradient_norm b. 1 f. exp(-i/10)
to_rgb[0] +select[0] 0 P0={^}
ellipse[0] {@0,1},3,3,0,1,255,0,255
ellipse[0] {@0,1},3,3,0,1,0xFFFFFFFF,255,255,255
rm.
if {min($P0)>=0}
p=1
do
w[0] -1,-1,0,"[G"{`39`}"MIC] Select Ending Point P"$p
+select[0] 0
if {{*,S}}
rm.
+to[0] "Saving snapshot...",5,5,13,1,1,255,255,255 w. rm.
o[0] gmic_minimal_path.png
wait -1
else
P1={^}
ellipse[0] {@0,1},3,3,0,1,255,0,255
ellipse[0] {@0,1},3,3,0,1,0xFFFFFFFF,255,255,255
rm.
if {min($P1)>=0}
+to[0] "Processing...",5,5,13,1,1,255,255,255 w. rm.
+minimal_path[1] $P0,$P1,1
pointcloud. 0 *. 255 r. 100%,100%,1,[0],0,0,0,0,0,0.5 r. [0],0 -|[0,-1]
P0=$P1 p+=1
fi
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
fi
rm[1] w 0
endl done v +
#@cli x_pacman
#@cli : Launch pacman game.
x_pacman :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Pacman"$n" -----------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the "${g}"pacman"$n" game.\n
----\n
---- Move the pacman to eat all pacdots on the different levels.\n
---- Eating a pacgum makes pacman invincible for "${c}"10 seconds"$n",\n
---- which mean pacman can eat ghosts during this time.\n
---- Eating a ghost earns "${c}"100 pts"$n".\n
---- Eating a cherry earns "${c}"10 pts"$n".\n
---- Eating a strawberry earns "${c}"100 pts"$n".\n
---- Eating an orange earns "${c}"1000 pts"$n".\n
---- Eating a banana earns "${c}"5000 pts"$n".\n
----\n
---- "${c}"Arrow keys"$n" to control pacman.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
v - l[]
m "_pacman_ghost_base_gfx : 31,19 circle. 15,15,15,1,1 31,12,1,1,'y<4+8*abs(cos(x*0.3+0.25*pi*$""1))' a[-2,-1] y"
repeat 4
_pacman_ghost_standard_gfx 255,0,0,$> nm. ghost0_$>
_pacman_ghost_standard_gfx 0,255,222,$> nm. ghost1_$>
_pacman_ghost_standard_gfx 255,184,222,$> nm. ghost2_$>
_pacman_ghost_standard_gfx 255,184,71,$> nm. ghost3_$>
_pacman_ghost_afraid_gfx $> nm. ghosta_$>
_pacman_ghost_base_gfx $> r. 16,16,1,1,2 nm. ghostm_$>
_pacman_ghost_standard_gfx 0,0,0,$> nm. ghostd_$>
_pacman_pacman_gfx $> nm.. pacman_$> nm. pacmanm_$>
done
+channels[ghostd_0] 0 !=. 0 nm. ghostdm
_pacman_cherry_gfx nm. fruit0 _pacman_strawberry_gfx nm. fruit1
_pacman_orange_gfx nm. fruit2 _pacman_banana_gfx nm. fruit3
20,2,1,3,200 nm. gate
score0,score1,score2,score3,score4=10,100,1000,5000,"Argh!"
repeat 5
0 t. ${score$>},0,0,13,1,255,255,255 autocrop. 0 expand_xy. 1,0 +dilate. 3
nm. scorem$> nm.. score$>
done
time4=255,255,255 time3=255,255,32 time2=255,128,32 time1=255,32,32
repeat 11 0 t. $<" s",0,0,23,1,${time{min(4,round(($<+1)/2))}} nm. time$< done
0 t. "Get Ready!",0,0,32,1,255 autocrop. 0 expand_xy. 4,0 +dilate. 8 r.. 100%,100%,1,3
nm.. get_ready nm. get_readym
0 t. "Game\nOver!",0,0,53,1,255 autocrop. 0 expand_xy. 4,0 +dilate. 8 r.. 100%,100%,1,3
nm.. game_over nm. game_overm
score=0 level=-1 lives=3 is_quit=0
do
if {$level<0}
_rlevel=33 _glevel=33 _blevel=255
_pacman_map_level{((-$level-1)%6)+1} mw={w} mh={h} mw2={int(w/2)} mh2={int(h/2)}
if {$level<-6} replace. 3,2 fi
nm. map0 i[map] .
+shift[map] -1,0 +shift[map] 0,-1 +shift[map] 1,0 +shift[map] 0,1 a[-4--1] z !=. 1 nm. can_go
+==[map] 1 100%,100% =. 1,$mw2,$mh2 distance. 1,..,3 rm..
f. 'if(i==2,0,if(i==8,1,if(i==1,2,if(i==4,3,i))))' nm. path
+==[map] 2 pacdots={is} rm.
level={-$level}
fi
f[map] 'if(i>=4,0,i)' +==[map] 1 expand_xy. 1,0 r. 1600%,1600% erode. 9 b. 2
g. xy abs[-2,-1] +[-2,-1] >=. 80% b. 2 n. 0,1 shrink_xy. 16
+*. $_glevel +*.. $_blevel *... $_rlevel a[-3--1] c
16,16,1,1,'x' +-[map] 1 max. 0 *. 16 r. 1600%,1600%
16,16,1,1,'y' r[-3,-1] ..,0,2 +[-2,-1] a[-2,-1] c
16,16,1,3 _pacman_pacdots_gfx _pacman_pacgum_gfx a[-3--1] y
warp. ..,0,0 rm.. -|[-2,-1] r. 100%,{h+24},1,3,0,0,0,1
t. "Lives :",10,0,24,1,255 t. "Score :",{w-140},0,24,1,255
if $lives +r[pacman_2] 12,12,1,4,2 r. {100*$lives}%,100%,1,4,0,2 j.. .,90,7 rm. fi
nm. visu
w[visu] {visu,f=h<0.5*{*,v}?1.5:1;[w,h]*=f},0,"[G"{`39`}"MIC] Pacman" cursor[0] 0
0 t. "Level "$level,0,0,64,1,1 autocrop. 0 expand_xy. 4,0 (0,255^0,255^0,0) +map.. . rm.. dilate.. 8
nm. level_N nm.. levelm_N
repeat 4 xg$>={16*$mw2} yg$>={16*$mh2+4*$>} dg$>=3 mg$>=0 done
xp={16*10} yp={16*21} dp=-1 pacgum_timer=-1 fruit_timer=$| dying_pacman=0 is_get_ready=1
xscore=0 yscore=0 nscore=0 oscore=0
do
t={int(6*$|)%4} left={if($pacgum_timer>=0,10-$|+$pacgum_timer,-1)}
[visu]
repeat 4
mg=${mg$>} xg=${xg$>} yg={${yg$>}+24}
if {$mg==0} j. [ghost$>_$t],$xg,$yg,0,0,1,[ghostm_$t]
elif {$mg==1} t2={if($left>7,$t,if($left>3,int(12*$|)%4,int(24*$|)%4))} j. [ghosta_$t2],$xg,$yg,0,0,1,[ghostm_$t]
elif {$mg==2} j. [ghostd_$t],$xg,$yg,0,0,0.8,[ghostdm]
else j. [ghost$>_$t],$xg,$yg,0,0,{$mg-2},[ghostm_$t] j. [ghostd_$t],$xg,$yg,0,0,1,[ghostdm]
fi
done
if $dying_pacman
_pacman_pacman_gfx {$dying_pacman/2} rotate[-2,-1] {90*(abs($dp)-1)} j... ..,$xp,{24+$yp},0,0,1,.,255 rm[-2,-1]
dying_pacman+=1
if {$dying_pacman>64}
if {$lives!=1} rm. break fi
j. [game_over],{(w-{game_over,w})/2},{12+(h-{game_over,h})/2},0,0,{min(1,($dying_pacman-64)/50)},[game_overm],255
rectangle. 90,7,101,18,1,0
fi
else
+rotate[pacman_$t,pacmanm_$t] {90*(abs($dp)-1)} j... ..,$xp,{24+$yp},0,0,1,.,255 rm[-2,-1]
if {$left>=0" && "($left>=5" || "$t<=2)} j. [time{round($left)}],{(w-{time0,w})/2-10},1 fi
fi
t. $score,{w-60},3,20,1,255
if {$is_get_ready}
j. [level_N],{(w-{level_N,w})/2},{12+(h-1.5*{level_N,h})/2},0,0,1,[levelm_N]
if {int($|*4)%2} j. [get_ready],{(w-{get_ready,w})/2},{24+(h+{get_ready,h})/2},0,0,1,[get_readym],255 fi
fi
if {$oscore>0} j. [score$nscore],$xscore,$yscore,0,0,$oscore,[scorem$nscore],255 oscore-=0.04 yscore-=1 fi
j. [gate],158,223,0,0,0.6
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h}
elif {{*,CTRLLEFT}&&{*,C}} w[] {f=h<0.5*{*,v}?1.5:1;[w,h]*=f}
fi
rm.
repeat 4
xg=${xg$>} yg=${yg$>} dg=${dg$>} mg=${mg$>}
if {max(abs($xg-$xp),abs($yg-$yp))<=8}
if {$mg==0" && "!$dying_pacman} dying_pacman=1
xscore=$xp yscore={$yp+12} oscore=1 nscore=4
elif {$mg==1} mg=2 mg$>=$mg score+=100
xscore=$xp yscore={$yp+12} oscore=1 nscore=1
fi
fi
if {$mg>=2" && "($xg>>4)==$mw2" && "($yg>>4)==$mh2}
mg+=0.01
if {$mg>=3} mg=0 xg&=-2 yg&=-2 fi
mg$>=$mg
fi
if {!($xg&15)" && "!($yg&15)}
({u},{u},{u},{u};0,1,2,3)
if {$mg<2}
=. {u(0.6,1)},{if($mg==0,dX0=$xp-$xg;dY0=$yp-$yg;if(abs(dX0)>abs(dY0),if(dX0>0,0,2),if(dY0>0,1,3)),\
dX1=$xp-$xg;dY1=$yp-$yg;if(abs(dX1)<abs(dY1),if(dX1>0,2,0),if(dY1>0,3,1)))}
=. 0,{($dg+2)%4}
if $is_get_ready =. 0.8,{path,i({$xg>>4},{$yg>>4})} fi
else =. 1,{path,i({$xg>>4},{$yg>>4})}
fi
sort. -,x repeat 4 d={i($>,1)} if {can_go,i({$xg>>4},{$yg>>4},$d)} dg=$d break fi done rm.
dg$>=$d
fi
u={D=${dg$>};(D==0)-(D==2)}
v={D=${dg$>};(D==1)-(D==3)}
xg$>={($xg+$u*(1+($mg==0)))%(16*$mw)}
yg$>={($yg+$v*(1+($mg==0)))%(16*$mh)}
done
wait 22
if {!$dying_pacman}
d={if({*,ARROWRIGHT},1,if({*,ARROWDOWN},2,if({*,ARROWLEFT},3,if({*,ARROWUP},4,$dp))))}
if {!($xp&15)" && "!($yp&15)}
i={map,i({$xp>>4},{$yp>>4})}
if {$i==2} score+=10 pacdots-=1
elif {$i==3} pacgum_timer=$| repeat 4 if {!${mg$>}} mg$>=1 dg$>={(${dg$>}+2)%4} fi done
elif {$i>=4} score+={${score{$i-4}}} xscore=$xp yscore={$yp+12} oscore=1 nscore={$i-4}
fi
=[map] 0,{$xp>>4},{$yp>>4}
16,16,1,3 j[visu] .,$xp,{24+$yp} rm.
d={if({can_go,i({$xp>>4},{$yp>>4},{abs($d)-1})},$d,$dp)}
d={if({can_go,i({$xp>>4},{$yp>>4},{abs($d)-1})},$d,-abs($dp))}
dp=$d
else dp={if(abs($d-$dp)==2,$d,$dp)}
fi
is_get_ready={if($dp>0,0,$is_get_ready)}
u={($dp==1)-($dp==3)}
v={($dp==2)-($dp==4)}
xp={($xp+2*$u)%(16*$mw)}
yp={($yp+2*$v)%(16*$mh)}
if {$pacgum_timer>=0" && "$|>$pacgum_timer+10}
repeat 4 xg$>&=-2 yg$>&=-2 mg$>={if(${mg$>}==1,0,${mg$>})} done
pacgum_timer=-1
fi
if {!$is_get_ready" && "($|-$fruit_timer)>=10}
x={round(u(0,{map0,w}))}
y={round(u(0,{map0,h}))}
if {!{map,i($x,$y)}" && "{map0,i($x,$y)}==2}
n={min(3,int(abs(g*1.7)))} =[map] {4+$n},$x,$y j[visu] [fruit$n],{16*$x},{16*$y+24} fruit_timer=$|
fi
fi
fi
if {!{*}" || "{*,Q}" || "{*,ESC}} is_quit=1 fi
while {!$is_quit" && "$pacdots}
if $is_quit break
elif $pacdots
lives-=1
else
level={-$level-1} wait[0] -1
rm[map0,map,can_go,path]
fi
rm[visu,level_N,levelm_N]
while $lives
rm w 0 endl v +
_pacman_ghost_standard_gfx :
_pacman_ghost_base_gfx $4 (0,$1^0,$2^0,$3) map.. . rm.
ellipse. 10,11,3,4,0,1,255 ellipse. 20,11,3,4,0,1,255
r. 16,16,1,3,2 point. 5,{7-($4>=2)},0,1,1 point. 10,{7-($4>=2)},0,1,1
_pacman_ghost_afraid_gfx :
_pacman_ghost_base_gfx $1
if {$1<2} col=255,255,255 (0,0^0,0^0,208) else col=255,0,0 (0,248^0,248^0,248) fi
map.. . rm. r. 16,16,1,3,2
line. 4,4,6,6,1,$col,255 line. 4,6,6,4,1,$col,255
line. 9,4,11,6,1,$col,255 line. 9,6,11,4,1,$col,255
f. 'if(y>=9&&y<=10&&x>=2&&x<=13&&((int((x+1)/2)+y)%2),arg(c+1,$col),i)'
_pacman_pacman_gfx :
32,32,1,1,'X=x-15;Y=y-15;A=atan2(Y,X);R=sqrt(X^2+Y^2);R<15.5&&abs(A)>0.8*0.33*$1'
(0,255^0,255^0,0^0,255) map.. . rm. r. 16,16,1,4,2 s. c,-3
_pacman_pacdots_gfx :
(255^184^151) r. 4,4,1,3 r. 16,16,1,3,0,0,0.5,0.5
_pacman_pacgum_gfx :
16,16,1,3 circle. 7,7,7,1,255,128,64
_pacman_cherry_gfx :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNzYgMSAxIDEgIzU5CnicFYpBCgAxDALVXvv/p5ZtmsgmIMoM7k0Cx/ySYYIXrE5qOgTmE1KGloUW1pp1qVUqmkt3H"\
"j9Whx3SMSAyMCAxIDEgIzI2Cnicc/eNYkjPzUyONwACveTM3PQqBgA+VQX2"
decompress_rle. (0,0,255,255^0,173,0,255^0,0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5
_pacman_strawberry_gfx :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNzIgMSAxIDEgIzYwCnicJYlJDoAwEMOyHOH/H+UANJ0RBaRIlp1tJ4HAd9HFaoUtTNWC1yIPWT5ew5em+lT994guK"\
"HgAoIoa8zEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
decompress_rle. (0,0,255,255^0,173,0,255^0,0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5
_pacman_orange_gfx :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNDQgMSAxIDEgIzQ2CnicBcHBDQAgDAOxXPjC/gsxU4VKi7DnAukKPU6SYjTVptxhbSv8wpVufUwDEZ4xIDIwIDEgM"\
"SAjMjYKeJxz941iSM/NTI43AAK95Mzc9CoGAD5VBfY="
decompress_rle. (0,0,255,255^0,173,173,255^0,0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5
_pacman_banana_gfx :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNzAgMSAxIDEgIzQ4CnicNcqxDQAgDMTANx0S++8aIC9ShObceC6QQoSJ5Ai5vWW2WTI6xr+bvLU/BnUW3jEgMjAgM"\
"SAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
decompress_rle. (0,255,255^0,173,255^0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5
_pacman_map_level1 :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjAxIDEgMSAxICM5Nwp4nGWOUQ6AMAhDKX56Be9/QnWJArEM9MdsGa9QYOsGiOy4FaZYHAo1aMezIJ+QJnszLsq2a"\
"Raf9Q9GiaBnGmEZhSe8wLOdVqO+My+cFdJj9OpVQ0vzRm8l/L954AHE9jnsMSAyMCAxIDEgIzI2Cnicc/eNYkjPzUyONwACveTM3PQqBgA+VQX2"
decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
_rlevel=33 _glevel=33 _blevel=255
_pacman_map_level2 :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjA4IDEgMSAxICMxMDAKeJxljkEOAzEIAxn32C/0/y+MdlUloAKJemgvjAOG+PkCs8ElHsjRQk0iycwS+/2jcuJln"\
"hhhf3SxPKWw9DaJmYsbmLOqmyaXn92UsVV9Y+sweOvb7YB1vQPPDnV4a/ABHS45BDEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
_rlevel=200 _glevel=33 _blevel=33
_pacman_map_level3 :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjA5IDEgMSAxICMxMDEKeJxVTlsOwDAIAve5K+z+N+zStGomeyTdjwIKYT9IoHGAbpOgdQ3n1i1ZinHdnO+20FuKg"\
"3nf4WIO3YolP8QEQ75CEkoKaUIDT3K95w8OZbp4lDcMj1PNUjXyDg+u4LTGC5LiOwAxIDIwIDEgMSAjMjYKeJxz941iSM/NTI43AAK95Mzc9CoGAD5VBfY="
decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
_rlevel=33 _glevel=200 _blevel=255
_pacman_map_level4 :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjEwIDEgMSAxICM5MAp4nHVPQQ6AMAhr8egX/P8TN+cGGSy6TBMTQgqlUPaDBDINLBJZbMQHqmwq7e40eahgy8i/j"\
"DKB1QhlRWBzcPH09Rnr9ALTrHSOuN5N+IFF9LIY9uOPDitcQvExIDIwIDEgMSAjMjYKeJxz941iSM/NTI43AAK95Mzc9CoGAD5VBfY="
decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
_rlevel=200 _glevel=200 _blevel=33
_pacman_map_level5 :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjA3IDEgMSAxICMxMDAKeJxdjlEKxCAMRPOmn3uF3v+ELXRrDE2qwrIgzPB8Mn52MDv4ihBbQyjQyuRBz96RF8NmS"\
"YAb98s65j95Wd0bFqxG1MNV/s1ealMujRHdI5wtf9X0WnWmFWO/7JmJXScPVxI1CjEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
_rlevel=200 _glevel=255 _blevel=33
_pacman_map_level6 :
base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMTgzIDEgMSAxICM5Mgp4nGVO0QqAQAhz67Ff6P+/sK66TNqJUBCozDHn5gUwW9EIBnhi2nmBPQmHCeMwDbuzBNCH1"\
"oZeDBEiPSWiAoXU8Yfhn4PyiNc1X3i99NwUJPMoVyVs3PAASqEr4jEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
_rlevel=255 _glevel=130 _blevel=233
#@cli x_paint
#@cli : Launch the interactive painter.
x_paint :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Interactive painter"$n" -----------------------\n
----\n
---- Use "${c}"mouse"$n" to select color and brush.\n
---- "${c}"Left button"$n" draws a colored stroke.\n
---- "${c}"Right button"$n" fills a colored region.\n
---- "${c}"Arrow keys"$n" or '"${c}"SPACE"$n"' and '"${c}"BACKSPACE"$n"' to swap\n
---- between available images.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------"
v - to_rgb
if {!$!} i[0] 512,512,1,3,255 nm[0] "[New image]" else k[0] fi
1
parallel "_x_paint[]","w[] 400,320,0,Palette x_select_color[] __color,0,0,0" k[0]
v +
_x_paint :
pass[-2,-1] 1 ({'{-2,n}'}) discard. {'~'} nm... {t} rm.
__color={0,if(ia<128,vector3(255),vector3(0))}
brushsize=1
brushopacity=0
brushangle=90
brushthickness=1
image=0
refresh_image=1
refresh_brush=1
ox1=-1
oy1=-1
do
if $refresh_brush
rm. (32,64;64,32) r. 16,16,1,3,1 r. {8*48},{4*48},1,3,0,2
repeat 4,y repeat 8
ellipse. {48*$>+24},{48*$y+24},{2*$>+1},{(2*$>+1)*$brushthickness},$brushangle,{1-$y/4},255
done done
rectangle. {$brushsize*48},{$brushopacity*48},\
{$brushsize*48+47},{$brushopacity*48+47},\
1,0xFFFFFFFF,255,128,128
{w},16,1,3 line. 0,50%,100%,50%,1,0x55555555,128,64,128
bx={$brushangle*w/180}
rectangle. {$bx-16},20%,{$bx+16},80%,1,128
line. {$bx-16},20%,{$bx+16},20%,1,255 line. {$bx+16},20%,{$bx+16},80%,1,255
line. {$bx-16},80%,{$bx+16},80%,1,64 line. {$bx-16},20%,{$bx-16},80%,1,64
a[-2,-1] y
16,{h-16},1,3 line. 50%,0,50%,100%,1,0x55555555,128,64,128
by={$brushthickness*(h-16)}
rectangle. 20%,{$by-16},80%,{$by+16},1,128
line. 20%,{$by-16},80%,{$by-16},1,255 line. 80%,{$by-16},80%,{$by+16},1,255
line. 20%,{$by-16},20%,{$by+16},1,64 line. 20%,{$by+16},80%,{$by+16},1,64
a[-2,-1] x
w3. {w},{h},0,"Brush"
refresh_brush=0
fi
if $refresh_image
w1[$image] {$image,w},{$image,h},0,"Image "#$image" : "{$image,b}.{$image,x}
refresh_image=0
fi
x1={*1,x} y1={*1,y}
x2={*2,x} y2={*2,y}
x3={*3,x} y3={*3,y}
if {$x1>=0}
if {{*1,b}&1}
ox1={if($ox1<0,$x1,$ox1)}
oy1={if($oy1<0,$y1,$oy1)}
delta={max(abs($x1-$ox1),abs($y1-$oy1))}
r1={2*$brushsize+1}
r2={$r1*$brushthickness}
dx={2*($x1-$ox1)/max(1,$delta)}
dy={2*($y1-$oy1)/max(1,$delta)}
o={1-($brushopacity/4)^0.04}
repeat {max(1,($delta+1)/2)}
ellipse[$image] {$ox1+$>*$dx},{$oy1+$>*$dy},$r1,$r2,$brushangle,$o,$__color
done
ox1=$x1 oy1=$y1
refresh_image=1
else
ox1=-1 oy1=-1
if {{*1,b}&2}
flood[$image] $x1,$y1,0,10,0,1,$__color
refresh_image=1
fi
fi
fi
if {{*1,ARROWRIGHT}" || "{*2,ARROWRIGHT}" || "{*3,ARROWRIGHT}" || "\
{*1,ARROWUP}" || "{*2,ARROWUP}" || "{*3,ARROWUP}" || "\
{*1,SPACE}" || "{*2,SPACE}" || "{*3,SPACE}}
image={($image+1)%($!-2)} refresh_image=1
elif {{*1,ARROWLEFT}" || "{*2,ARROWLEFT}" || "{*3,ARROWLEFT}" || "\
{*1,ARROWDOWN}" || "{*2,ARROWDOWN}" || "{*3,ARROWDOWN}" || "\
{*1,BACKSPACE}" || "{*2,BACKSPACE}" || "{*3,BACKSPACE}}
image={($image-1)%($!-2)} refresh_image=1
fi
if {*1,S} o[$image] gmic_paint.png fi
if {{*3,b}" && "$x3>=0}
if {$x3<384" && "$y3>=192} brushangle={$x3*180/(w-16)}
elif {$x3>=384" && "$y3<192} brushthickness={$y3/(h-16)}
elif {$x3<384" && "$y3<192} brushsize={int($x3*8/(w-16))} brushopacity={int($y3*4/(h-16))}
fi
refresh_brush=1
fi
wait
while {{*1}" && "!{*1,Q}" && "!{*1,ESC}}
__color=-1 w1[] 0 w2[] 0 w3[] 0 rm[-2,-1]
#@cli x_plasma
#@cli : Launch the plasma effect demo.
x_plasma :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Plasma effect"$n" ----------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
v - l[]
N=8
repeat $N
320,200,1,3 rand. 0,255 plasma. 1,0,7 n. 0,255
amp={u(-40,40)} freq={round(u(2,6))} dir$>={if(u<0.5,-1,1)*round(u(1,2))}
100%,100%,1,1,'$amp*cos(y*2*pi*$freq/h)'
done
{w+2},100%,1,1,'x' 100%,100%,1,1,'Y=(y-80+15*cos(x/30)+10*sin(x/22));if(Y<0||Y>=50,-1,Y)' a[-2,-1] c
0 t. "** Welcome to G\47MIC, a powerful image processing framework **",0,0,50,1,255
b. 0.5 n. 0,255
M={w}
w[] {0,f=1.5*h<0.5*{*,v}?3:1.5;[w,h]*=f},0,"[G"{`39`}"MIC] Plasma Effect"
t=0 tt={-1.5*{0,w}}
do
tic=$|
a={int($t)} a2={2*$a} a21={$a2+1}
b={($a+1)%$N} b2={2*$b} b21={$b2+1}
+warp[$a2] [$a21],1,0,2
+warp[$b2] [$b21],1,0,2
j.. .,0,0,0,0,{$t-$a} rm.
shift[$a21] 0,${dir$a},0,0,2
shift[$b21] 0,${dir$b},0,0,2
if {int($t+0.005)>int($t)} dir$a={if(u<0.5,-1,1)*round(u(1,3))} fi
t={($t+max(0.005,($|-$tic)))%$N}
+z.. $tt,{$tt+w-1+2}
warp. [-4],0,0,0
r. 100%,100%,1,3
+*. -1 +. 255
j... .,0,0,0,0,1,..,255 rm.
j.. .,-2,-2,0,0,1,.,255 rm.
tt+={max(2,($|-$tic)*250)}
if {$tt>=$M} tt={-1.5*{0,w}} fi
fps=${-fps} if {$fps>0} to. $fps" fps",5,5,16,1,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
rm. wait 20
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm[{-2*$N-2}--1] w[] 0 endl v +
#@cli x_quantize_rgb : _nbcolors>=2
#@cli : Launch the RGB color quantization demo.
x_quantize_rgb : check "isint(${1=16}) && $1>1"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"RGB Quantization"$n" --------------------------------------\n
----\n
---- This demo shows how RGB colors can be quantified using\n
---- the "${c}"k-means algorithm"$n".\n
----\n
---- "${c}"Left mouse button"$n" on 3D view rotates the color cube.\n
---- "${c}"Right mouse button"$n" on 3D view toggles colors/clusters mode.\n
---- "${c}"Left mouse button"$n" on image toggles dithering mode,\n
---- "${c}"Left mouse button"$n" on colormap adds a random color.\n
---- "${c}"Right mouse button"$n" on colormap removes a color.\n
---- Key '"${c}"R"$n"' init colormap with random values.\n
---- Key '"${c}"U"$n"' init colormap with uniform sampling.\n
---- Key '"${c}"M"$n"' init colormap with median-cut algorithm.\n
---- Key '"${c}"SPACE"$n"' does a single iteration of k-means and pauses.\n
---- Key '"${c}"ENTER"$n"' runs k-means algorithm.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
v -
if {!$!} sp ? fi
k[0] to_rgb if {h>300} r2dy 300 round 1 fi nm. img
+r {w*h},1,1,3,-1 r. {min(w,8192)},1,1,3 nm. colors
$1,1,1,3 rand. 0,255 round. 1 nm. centroids
_x_quantize_rgb_3d (1,0,0,0;0,1,0,0;0,0,1,0) nm. pose3d
_x_quantize_rgb_text "Colors",clustering0
_x_quantize_rgb_text "Clusters",clustering1
_x_quantize_rgb_text "Dithering: off",dithering0
_x_quantize_rgb_text "Dithering: on",dithering1
if {img,h<300} +r2dy[img] 300,1 else [img] fi
{w+315},365,1,3,255 rm..
rectangle. 4,4,305,305,1,0xFFFFFFFF,0
rectangle. 309,4,{w-5},305,1,0xFFFFFFFF,0
rectangle. 4,309,{w-5},360,1,0xFFFFFFFF,0
.,.
rectangle. 310,5,{w-6},305,1,1
rectangle. 5,310,{w-6},360,1,2
300,300,1,1,'(y<<11)+(x<<2)+3' j.. .,5,5 rm.
a[-2,-1] c nm. visu
dithering=0 clustering=0 pause=1 s0=off s1=on
do
if {!narg($visu_3d)}
+-[centroids] 2 ++[centroids] 2 a[-2,-1] x permute. cxyz y. -. 128
j[obj3d] .,0,8 rm.
[obj3d]
if $clustering
if {{colors,iM}<256} +index[colors] [centroids] *. 256 +[colors,-1] fi
+channels[colors] 0 >>. 8 map. 2 permute. cxyz y. j.. .,0,{{-2,h}-$_N-h} rm.
fi
pose3d. {pose3d,^} 300,300,1,3 j3d. ..,50%,50%,100,1,2,0,0,300 rm..
j. [clustering$clustering],2,0,0,0,1,[mclustering$clustering],255
nm. visu_3d j[visu] [visu_3d],5,5
fi
if {!narg($visu_img)}
+index[img] [centroids],{0.7*$dithering},1 if {h<300} r2dy. 300,1 fi
j. [dithering$dithering],2,0,0,0,1,[mdithering$dithering],255
nm. visu_img j[visu] [visu_img],310,5
fi
if {!narg($visu_centroids)}
+luminance[centroids] a. [centroids],y sort. +,x rows. 1 r. {visu,w-10},50,1,3
0 t. "Colors: "{centroids,w},2,0,16,1,255,255,255 +dilate. 3 j... ..,2,2,0,0,1,.,255
rm[-2,-1] nm. visu_centroids j[visu] [visu_centroids],5,310
fi
l[visu]
w -1,-1,0,"[G"{`39`}"MIC] RGB Quantization"
if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
endl
x={int({*,x}*{visu,w}/{*,w})}
y={int({*,y}*{visu,h}/{*,h})}
b={*,b}
i={visu,i($x,$y,0,3)}
if {$b&1" && "$i==1}
dithering={!$dithering} rm[visu_img] wait -1
elif {$b&1" && "$i==2}
(${-RGB}) y. c a[centroids,-1] x  _x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait 100
elif {$b&2" && "$i==2" && "{centroids,w}>2}
r[centroids] {centroids,w-1} _x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait 100
elif {$b&2" && "$i>=3}
clustering={!$clustering} rm[visu_3d] wait -1
elif {*,M}
+&[colors] 255 colormap. {centroids,w},0,0 rm[centroids] nm. centroids
_x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait -1
elif {*,R}
rand[centroids] 0,255 round[centroids] 1
_x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait -1
elif {*,U}
uniform_distribution {centroids,w},3 *. 255 rm[centroids] nm. centroids
_x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait -1
elif {*,ENTER}
pause=0
elif {$b&1" && "$i>=3}
coords={visu,i($x,$y,0,3)-3} u1={(($coords>>2)&511)-150} v1={($coords>>11)-150}
if {!narg($u0)} u0=$u1 v0=$v1 fi
if {$u0!=$u1" || "$v0!=$v1}
n0={sqrt(($u0)^2+($v0)^2)}
nu0={if($n0>135,$u0*135/$n0,$u0)} nv0={if($n0>135,$v0*135/$n0,$v0)} nw0={sqrt(max(0,18225-($nu0)^2-($nv0)^2))}
n1={sqrt(($u1)^2+($v1)^2)}
nu1={if($n1>135,$u1*135/$n1,$u1)} nv1={if($n1>135,$v1*135/$n1,$v1)} nw1={sqrt(max(0,18225-($nu1)^2-($nv1)^2))}
u={$nv0*$nw1-$nw0*$nv1} v={$nw0*$nu1-$nu0*$nw1} w={$nv0*$nu1-$nu0*$nv1} n={sqrt(($u)^2+($v)^2+($w)^2)}
rotation3d[] $u,$v,$w,{-asin($n/18225)*180/pi} mv[pose3d] $! m*[-2,-1] nm. pose3d
u0=$u1 v0=$v1 rm[visu_3d]
fi
elif {!($b&1)} u0=
fi
if {!$pause" || "{*,SPACE}}
pause={*,-SPACE}
&[colors] 255 +index[colors] [centroids] *. 256 +[colors,-1]
repeat {colors,s}
sh[colors] $> +histogram. {centroids,w*256},0,{centroids,w*256-1} rm..
i.. 256,1,1,1,'x' r.. {w},1,1,1,0,2 *.. . r[-2,-1] {centroids,w},1,1,1,2 max. 0.01 /[-2,-1]
done a[-{colors,s}--1] c
rm[centroids] nm. centroids
+>>[colors] 8 channels. 0 histogram. {centroids,w},0,{centroids,w-1}
cmax={xM}
repeat {w} if {!i($>)} point[centroids] $>,0,0,1,{centroids,I($cmax)} point[centroids] $>,0,0,-0.001,${-RGB} fi done
rm. c[centroids] 0,255
if $visu_3d rm[visu_3d] fi
if $visu_img rm[visu_img] fi
if $visu_centroids rm[visu_centroids] fi
wait 20
else if $visu_img wait fi
fi
while {{*}" && "!{*,Q}" && "!{*,ESC}}
rm w 0 v +
_x_quantize_rgb_3d :
if $obj3d rm[obj3d] fi
+distribution3d[centroids] circles3d. 5 col3d. 255
colorcube3d p3d. 1
+&[colors] 255 distribution3d. o3d. 0.8 +3d[-3--1]
-3d. 128,128,128 nm. obj3d _N={i[7]}
_x_quantize_rgb_text :
0 t. "$1",0,0,16,1,255 r. {w+2},15,1,1,0,0,0.5,0.5 +dilate. 3 to_rgb..
nm.. $2 nm. m$2
#@cli x_reflection3d
#@cli : Launch the 3D reflection demo.
x_reflection3d :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"3D reflection"$n" ----------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
v -
128,256,1,3 rand. 0,255 plasma. 1,100 blur_xy. 30,2
sh. 0 n. 0,90 rm. sh. 1 n. 0,60 rm. sh. 2 n. 0,180 rm.
+mirror. x [-2,-1] a[-4--1] x
+luminance. mirror. x b. 2 n. 0,255
torus3d 30,10 col3d. 255,200,0
spherical3d 47,34,"80+20*abs(cos(2*theta))" s3d. rm.. i.. 3,{h},1,1,150,220,255,200,255,255 y.. a[-6--1] y
spherical3d 47,34,"100*abs(1+0.6*cos(3*phi)*sin(4*theta))"
r3d[-2,-1] 0,1,0,90 db3d 0
xb,xl,anim=0
w[] 400,400,0,"[G"{`39`}"MIC] 3D Reflection"
do
tic=$|
+rows. 8,{8+3*i[6]-1} +j... .,0,8,0,0,{if($anim<250,0,0.5-0.5*cos(($anim-250)/100))} rm..
+z[-6] $xb,0,{$xb+255},255 j3d. ..,75%,50%,0,1,3,0,0
+z[-6] $xl,0,{$xl+255},255
xf={min(30,$anim-70)+20*cos(1.8*$|)}
yf={50+20*sin(2.7*$|)}
j3d. [-6],{20+$xf}%,$yf%,0,1,4,0,0
l3d . rm. +j3d. ..,75%,50%,0,1,5,0,0 j.. .,0,0,0,0,0.6 rm[-3,-1]
j3d. [-4],$xf%,$yf%,0,1,4,0,0
fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-19},13,1,0.2 fi
w. rm.
if {{*,CTRLLEFT}&&{*,D}} w[] 800,800 elif {{*,CTRLLEFT}&&{*,C}} w[] 400,400 fi
xb={($xb+6)&255}
xl={($xl-6)&255}
anim+=1
r3d[-2,-1] {sin(0.5*$|)},{cos($|)},1,{max(0.005,$|-$tic)*33}
r3d... -1,0.3,0.8,{max(0.005,$|-$tic)*100}
wait 20
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm[-5--1] w[] 0 v +
#@cli x_rubber3d
#@cli : Launch the 3D rubber object demo.
x_rubber3d :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"3D rubber object"$n" -------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
v - rm
sphere3d 150,0 torus3d 70,15 cylinder3d 20,40
col3d... 200,200,200,0.3 col3d.. 128,200,76 col3d. 200,128,76
c3d[-3--1] r3d. 1,0,0,70 +3d[-3--1] +3d. 10,-8,20 *3d. 1.5
400,400,64,3
{w},{h},1,3,'if(c==0,x,if(c==1,y,y*{1,d}/h))'
{w},{h},1,3
w[] {w},{h},0,"[G"{`39`}"MIC] 3D Rubber Object"
frame=0
do
fps=${-fps}
{w},{h},1,3 fc. 16,32,32 j3d. [0],50%,50%,0,1,3,0,0 j[1] .,0,0,$frame rm.
r3d[0] 0.1,1,0.6,{3*cos($|*1.25)} r3d[0] 1,0.2,0.6,-1
+warp[1] [2],0,0 *[3] 0.8 *. 0.2 +[3] . rm.
if {$fps>0} to. $fps" fps",5,{h-29},24,2,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
wait[0] 20
sh[2] 2 -. 1 &. {{1,d}-1} rm.
frame={($frame-1)%{1,d}}
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 v +
#@cli x_segment : _max_resolution={ 0 | >=128 }
#@cli : Segment foreground from background in selected opaque RGB images, interactively.
#@cli : Return RGBA images with binary alpha-channels.
#@cli : Default value: 'max_resolution=1024'.
x_segment : check "${1=1024}==0 || $1>=128"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[^-1] "Extract foreground from background in image$? interactively, with maximum resolution $1."
e[] "\n
----------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" or key '"${c}"F"$n"' create a new foreground control point (or move an existing one).\n
---- "${c}"Right mouse button"$n" or key '"${c}"B"$n"' create a new background control point (or move an existing one).\n
---- "${c}"Mouse wheel"$n", or keys '"${c}"CTRL+arrows UP/DOWN"$n"' zoom view in/out.\n
---- '"${c}"CTRL+mouse wheel"$n"', '"${c}"SHIFT+mouse wheel"$n"' or "${c}"arrow keys"$n" move image in zoomed view.\n
---- Key '"${c}"SPACE"$n"' updates the extraction mask.\n
---- Key '"${c}"TAB"$n"' toggles background view modes.\n
---- Key '"${c}"M"$n"' toggles marker view modes.\n
---- Key '"${c}"BACKSPACE"$n"' deletes the last control point added.\n
---- Key '"${c}"PAGE UP"$n"' increases background opacity.\n
---- Key '"${c}"PAGE DOWN"$n"' decreases background opacity.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
----------------------------------------------------------------------------------------------------"
v - repeat $! l[$>]
name={0,n} title={0,b} if {narg({0,x})} title=$title.{0,x} fi
w={w} h={h} fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
selection=-1 marker_mode=2 xpan=-1 ypan=-1 bg_mode=0 opacity=64
to_rgb nm img
if {narg($_gui_control_points)>=4}  ($_gui_control_points) r. {w/4},4,1,1,-1
else 0
fi
nm. points
if {$1>0} if {$w>$h} +r2dx[img] {min($1,$w)},2 else +r2dy[img] {min($1,$h)},2 fi else [img] fi
_x_segment.
pw={potential,w} ph={potential,h}
do
wait
x={*,x} y={*,y} b={*,b} o={*,-o}
is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
is_shift={{*,SHIFTLEFT}" || "{*,SHIFTRIGHT}}
is_mouseout={$x<0" || "$y<0}
x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1
if {*,r}
nww={*,d} nwh={*,e} m={min($nww,$nwh)}
cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
x0={$cx-$dx/2} x1={$cx+$dx/2}
y0={$cy-$dy/2} y1={$cy+$dy/2}
ww=$nww wh=$nwh
elif {$is_ctrl" && "{*,-D}}
nww={min({*,u},$ww*1.25)} nwh={min({*,v},$wh*1.25)} m={min($nww,$nwh)}
if {$m==$nww} ww=$m wh={$h*$m/$w} else ww={$w*$m/$h} wh=$m fi
elif {$is_ctrl" && "{*,-C}}
nww={$ww/1.25} nwh={$wh/1.25}
if {min($nww,$nwh)>=64} ww=$nww wh=$nwh fi
elif {$is_ctrl" && "{*,-R}}
fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
x0=0 y0=0 x1={$w-1} y1={$h-1}
elif {($is_shift" && "$o<0)" || "{*,ARROWLEFT}}
dx={($x1-$x0)/6} x0-=$dx x1-=$dx
elif {($is_shift" && "$o>0)" || "{*,ARROWRIGHT}}
dx={($x1-$x0)/6} x0+=$dx x1+=$dx
elif {($is_ctrl" && "$o>0)" || "({*,ARROWUP}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0-=$dy y1-=$dy
elif {($is_ctrl" && "$o<0)" || "({*,ARROWDOWN}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0+=$dy y1+=$dy
elif {$o>0" || "($is_ctrl" && "{*,ARROWUP})}
if {$x1-$x0>16" && "$y1-$y0>16}
cx={if($x>=0" && "!{*,ARROWUP},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWUP},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
fi
elif {$o<0" || "($is_ctrl" && "{*,ARROWDOWN})}
zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
if {$zfactor<1.3}
cx={if($x>=0" && "!{*,ARROWDOWN},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWDOWN},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
else
dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
fi
elif {$b&4" && "!$is_mouseout}
if {$panx<0" && "$pany<0} panx=$x pany=$y
else dx={round($panx-$x)} dy={round($pany-$y)} x0+=$dx y0+=$dy x1+=$dx y1+=$dy
fi
else panx=-1 pany=-1
fi
if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} rm[baseview] fi
N={points,w}
is_left_button={$b&1" || "{*,F}} is_right_button={$b&2" || "{*,B}} is_button={$is_left_button" || "$is_right_button}
if {narg($baseview)" && "$is_button" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
if {$selection==-1" && "$N}
($x;$y) r. $N,2 -. [points] *. {max($ww,$wh)/max($x1-$x0,$y1-$y0)} sqr. s. y +[-2,-1]
dmin={im} selection={if($dmin>25,-1,xm)} rm.
fi
if {$selection>=0}
if $marker_mode
+columns[points] $selection ox={i[0]} oy={i[1]}
=. $x =. $y,0,1 =. {1+$is_left_button},0,3
j[points] .,$selection rm. rm[view]
fi
else
($x;$y;0;{1+$is_left_button}) a[points,-1] x selection=$N if {!$marker_mode} marker_mode=2 fi rm[view]
fi
else selection=-1
if {{*,SPACE}" && "narg($labels)} rm[labels]
elif {{*,TAB}" && "narg($baseview)} bg_mode={($bg_mode+1)%6} rm[baseview] wait -1
elif {{*,M}" && "narg($view)} marker_mode={($marker_mode-1)%3} rm[view] wait -1
elif {{*,PAGEDOWN}" && "narg($baseview)} opacity={max(0,$opacity-32)} rm[baseview] wait -1
elif {{*,PAGEUP}" && "narg($baseview)} opacity={min(255,$opacity+32)} rm[baseview] wait -1
elif {{*,BACKSPACE}" && "$N} if {$N>1} z[points] 0,{$N-2} else i=$points rm[points] i[$i] 0 nm[$i] points fi rm[view] wait -1
fi
fi
w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
if {$x0<-$w2} x1-={$x0+$w2} x0=-$w2 fi
if {$y0<-$h2} y1-={$y0+$h2} y0=-$h2 fi
if {$x1>=$w+$w2} x0+={$w-1+$w2-$x1} x1={$w-1+$w2} fi
if {$y1>=$h+$h2} y0+={$h-1+$h2-$y1} y1={$h-1+$h2} fi
if {!narg($labels)}
N={points,w}
if {narg($view)} to[view] "Processing...",5,5,20,2 w[view] fi
if $N
[points]
sh. 0,0,0,0 *. {$pw/$w} rm.
sh. 1,1,0,0 *. {$ph/$h} rm.
pointcloud. -1,$pw,$ph dilate. 3
watershed. [potential] -. 1
else [potential],[potential],1,1,1
fi
nm. labels
if {narg($baseview)} rm[baseview] fi
fi
if {!narg($baseview)}
nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
+z[img] $x0,$y0,$x1,$y1
r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
+z[labels] $nx0,$ny0,$nx1,$ny1
r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
if {$bg_mode>=3} *. -1 +. 1 fi
*. {255-$opacity} +. $opacity a[-2,-1] c
if {$bg_mode%3>=1} i.. 100%,100%,1,3,{(($bg_mode-1)%3)*255} blend[-2,-1] alpha
else drgba.
fi
nm. baseview
if {narg($view)} rm[view] fi
fi
if {!narg($view)}
[baseview] r. 100%,100%,1,3
if $marker_mode
if {$marker_mode==2} rad1=5 rad2=3 opa=1 else rad1=3 rad2=2 opa=0.8 fi
col0=255,0,0 col1=0,255,0
repeat {points,w}
+columns[points] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} l={i[3]-1} rm.
circle. $x,$y,$rad1,1,0 circle. $x,$y,$rad2,$opa,${col$l}
done
fi
nm. view
w[view] $ww,$wh,0,$title
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}
if {narg($view)} to[view] "Processing fullres...",5,5,20,2 w[view] fi
k[img,points]
N={points,w} status=
if $N
status={points,^}
[img] _x_segment. pointcloud[points] -1,$w,$h
zfact={{img,max(w,h)}/{potential,max(w,h)}} dilate[points] {int(3*$zfact)}
watershed[points] [potential] -[points] 1 k[img,points]
*. 255
else k[img] [img],[img],1,1,255
fi
a c nm $name
endl done
u $status
w 0 v +
_x_segment :
b. 0.2% gradient_norm. f. '1/(1+i^2)'
nm. potential
#@cli x_select_color : _variable_name
#@cli : Display a RGB or RGBA color selector.
#@cli : Argument 'variable_name' specifies the variable that contains the selected color values (as R,G,B,[A]) at any time.
#@cli : Its value specifies the initial selected color. Assigning '-1' to it forces the interactive window to close.
#@cli : Default value: 'variable_name=xsc_variable'.
x_select_color : skip ${1=xsc_variable}
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - rm
n={narg($$1)} if {!$n} $1=0,0,0 fi
rgba_mode={$n>=4} R={arg(1,$$1)} G={arg(2,$$1)} B={arg(3,$$1)} A={if($rgba_mode,arg(4,$$1),255)}
v + e[^-1] "Open "${arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget, with variable '$1' and starting color "($$1)"." v -
if {!{*}} w[] {400+24*$rgba_mode},400,0,"Select a color" fi
update_view=1 is_sv=0 is_h=0 is_a=0 colordb=0 is_thread_variable={arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'}
m "add_preset : if {!narg($_xsc_preset$""1)} _xsc_preset$""1=$""2,$""3,$""4 fi"
add_preset 0,0,0,0,0 add_preset 1,255,255,255 add_preset 2,255,0,0 add_preset 3,0,255,0 add_preset 4,0,0,255 add_preset 5,255,255,0
add_preset 6,255,0,255 add_preset 7,0,255,255 add_preset 8,50,50,50 add_preset 9,100,100,100 add_preset 10,150,150,150 add_preset 11,200,200,200
uncommand add_preset
if {!narg($_xsc_preset)} _xsc_preset=11 fi
($R^$G^$B) c. 0,255 rgb2hsv. H={i[0]} S={i[1]} V={i[2]} rm.
do
w={*,d} h={*,e} x={*,x} y={*,y} b={*,b}
if {!$!}
$w,$h,1,3,200
if $rgba_mode x1={w-89} y1={h-57} x2={w-80} else x1={w-49} y1={h-57} x2={w-40} fi
x0=8 y0=8 x3={$x2+31} x4={w-40} x5={$x4+31} x6={max($x0+232+32*$rgba_mode,w-152)} y6={$y1+7}
rectangle {$x0-1},{$y0-1},{$x1+1},{$y1+1},1,0xFFFFFFFF,232 line {$x0-1},{$y0-1},{$x1+1},{$y0-1},1,128 line {$x0-1},{$y0-1},{$x0-1},{$y1+1},1,128
(1;0) (0,1) r[-2,-1] {$x1-$x0+1},{$y1-$y0+1},1,1,3 i... 100%,100%,1,1,$H a[-3--1] c hsv2rgb. j.. .,$x0,$y0 rm.
rectangle {$x2-1},{$y0-1},{$x3+1},{$y1+1},1,0xFFFFFFFF,232 line {$x2-1},{$y0-1},{$x3+1},{$y0-1},1,128 line {$x2-1},{$y0-1},{$x2-1},{$y1+1},1,128
(359;0^1;1^1;1) r. {$x3-$x2+1},{$y1-$y0+1},1,3,3 hsv2rgb. j.. .,$x2,$y0 rm.
if $rgba_mode
rectangle {$x4-1},{$y0-1},{$x5+1},{$y1+1},1,0xFFFFFFFF,232 line {$x4-1},{$y0-1},{$x5+1},{$y0-1},1,128 line {$x4-1},{$y0-1},{$x4-1},{$y1+1},1,128
(1;0) r. {$x5-$x4+1},{$y1-$y0+1},1,4,3 *. 255 drgba. j.. .,$x4,$y0 rm.
fi
t. "Current",$x0,{$y1+12},14,1,0
if {narg($_xsc_old)}
t. "Old",$x0,{$y1+34},14,1,0
($_xsc_old) y. c r. 48,16 drgba. r. {w+2},{h+2},1,3,0,0,0.5,0.5 j.. .,{$x0+55},{$y1+32} rm.
fi
repeat 12
(${_xsc_preset$>}) -. 255 r. 4,1,1,1,0 +. 255
y. c r. 18,18 drgba. frame. 1,1,{255*($>==$_xsc_preset)}
j.. .,{$x6+($>%6)*25},{$y6+($>>=6)*25} rm.
done
update_view=1
fi
if $update_view
.
cx={$x0+$V*($x1-$x0)} cy={$y0+(1-$S)*($y1-$y0)}
if {$cx>$x0} line. {$cx-1},$y0,{$cx-1},$y1,1,200 fi
if {$cx<$x1} line. {$cx+1},$y0,{$cx+1},$y1,1,200 fi
if {$cy>$y0} line. $x0,{$cy-1},$x1,{$cy-1},1,200 fi
if {$cy<$y1} line. $x0,{$cy+1},$x1,{$cy+1},1,200 fi
line. $x0,$cy,$x1,$cy,1,0 line. $cx,$y0,$cx,$y1,1,0
cy={$y0+(359-$H)*($y1-$y0)/359}
if {$cy>$y0} line. $x2,{$cy-1},$x3,{$cy-1},1,200 fi
if {$cy<$y1} line. $x2,{$cy+1},$x3,{$cy+1},1,200 fi
line. $x2,$cy,$x3,$cy,1,0
if $rgba_mode
cy={$y0+(255-$A)*($y1-$y0)/255}
if {$cy>$y0} line. $x4,{$cy-1},$x5,{$cy-1},1,200 fi
if {$cy<$y1} line. $x4,{$cy+1},$x5,{$cy+1},1,200 fi
line. $x4,$cy,$x5,$cy,1,0
fi
($H^$S^$V^$A) sh. 0,2 hsv2rgb. rm. round. R={i[0]} G={i[1]} B={i[2]}
r. 48,16 drgba. r. {w+2},{h+2},1,3,0,0,0.5,0.5 j.. .,{$x0+55},{$y1+10} rm.
t. "HSV ("{round($H)}","{round($S*255)}","{round($V*255)}")",{$x0+115},{$y1+24},14,1,0
if $rgba_mode t. "RGBA ("$R","$G","$B","{round($A)}")",{$x0+115},{$y1+8},14,1,0
else t. "RGB ("$R","$G","$B")",{$x0+115},{$y1+8},14,1,0
fi
({'${dec2hex\ {$R*65536+$G*256+$B}}'}) -. {'0'} r. 6,1,1,1,0,0,1,0 +. {'0'}
f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
t.. "HTML ""#"{t},{$x0+115},{$y1+40},14,1,0 rm.
w. 100%,100%,0 rm.
if $rgba_mode $1=$R,$G,$B,$A else $1=$R,$G,$B fi
update_view=0
fi
if $is_thread_variable wait 50 else wait fi
ww={*,w} wh={*,h}
is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
if {*,r} ww={*,d} wh={*,e}
elif {$is_ctrl" && "{*,-D}} ww={1.25*$ww} wh={1.25*$wh}
elif {$is_ctrl" && "{*,-C}} ww={0.8*$ww} wh={0.8*$wh}
elif {$is_ctrl" && "{*,R}} ww={400+24*$rgba_mode} wh=400
fi
ww={max(200,$ww)} wh={max(200,$wh)}
if {$ww!={*,w}" || "$wh!={*,h}} w[] $ww,$wh rm fi
if {$b&1" && "$x>=0" && "$y>=0}
if {!$is_h" && "!$is_a" && "($is_sv" || "($x>=$x0" && "$x<=$x1" && "$y>=$y0" && "$y<=$y1))}
S={max(0,min(1,1-($y-$y0)/($y1-$y0)))} V={max(0,min(1,($x-$x0)/($x1-$x0)))}
update_view=1 colordb=0 is_sv=1 k[0]
elif {!$is_sv" && "!$is_a" && "($is_h" || "($x>=$x2" && "$x<=$x3" && "$y>=$y0" && "$y<=$y1))}
H={max(0,min(359,359-($y-$y0)*359/($y1-$y0)))}
colordb=0 is_h=1 rm
elif {!$is_sv" && "!$is_h" && "($is_a" || "($x>=$x4" && "$x<=$x5" && "$y>=$y0" && "$y<=$y1))}
A={round(max(0,min(255,255-($y-$y0)*255/($y1-$y0))))}
colordb=0 is_a=1 update_view=1 k[0]
elif {!$is_sv" && "!$is_h" && "!$is_a" && "{narg($_xsc_old)}" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+32" && "$y<=$y1+47}
($_xsc_old) y. c sh. 0,2 rgb2hsv. rm. H={i[0]} S={i[1]} V={i[2]} A={i[3]}
colordb=0 rm
elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x6" && "$x<=$x5" && "$y>=$y6" && "$y<=$y6+50" && "($x-$x6)%25<=20" && "($y-$y6)%25<=20}
p={int(($x-$x6)/25)+6*int(($y-$y6)/25)} (${_xsc_preset$p}) -. 255 r. 4,1,1,1,0 +. 255 y. c sh. 0,2 rgb2hsv. rm.
H={i[0]} S={i[1]} V={i[2]} A={i[3]}
colordb=0 rm
elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+10" && "$y<=$y1+27}
_xsc_old=$R,$G,$B,$A colordb={($colordb+1)%2}
if {!$colordb} _xsc_preset$_xsc_preset=$R,$G,$B,$A _xsc_preset={($_xsc_preset-1)%12} fi
rm wait -1
else colordb=0
fi
elif {!$b} is_sv=0 is_h=0 is_a=0
fi
if {*,ARROWUP} colordb=0 S={min(1,$S+1/256)} update_view=1 k[0] wait -1
elif {*,ARROWDOWN} colordb=0 S={max(0,$S-1/256)} update_view=1 k[0] wait -1
elif {*,ARROWRIGHT} colordb=0 V={min(1,$V+1/256)} update_view=1 k[0] wait -1
elif {*,ARROWLEFT} colordb=0 V={max(0,$V-1/256)} update_view=1 k[0] wait -1
elif {*,PAGEUP} colordb=0 H={min(359,$H+1)} rm wait -1
elif {*,PAGEDOWN} colordb=0 H={max(0,$H-1)} rm wait -1
fi
if {['$$1']=='-1'} break fi
if {(($rgba_mode" && "['$$1']!='$R,$G,$B,$A')" || "(!$rgba_mode" && "['$$1']!='$R,$G,$B'))" && "$x<0" && "$y<0" && "!$is_sv" && "!$is_h" && "!$is_a}
($$1) y. c -. 255 r. 1,1,1,4,0 +. 255 sh. 0,2 rgb2hsv. rm.
H={i[0]} S={i[1]} V={i[2]} A={i[3]} rm
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0
if $rgba_mode u $R,$G,$B,$A else u $R,$G,$B fi
_xsc_old=${}
v +
#@cli x_select_function1d : _variable_name,_background_curve_R,_background_curve_G,_background_curve_B
#@cli : Open an interactive window, where the user can defined its own 1D function.
#@cli : If an image is selected, it is used to display additional information :
#@cli :   - The first row defines the values of a background curve displayed on the window (e.g. an histogram).
#@cli :   - The 2nd, 3rd and 4th rows define the R,G,B color components displayed beside the X and Y axes.
#@cli : Argument 'variable_name' specifies the variable that contains the selected function keypoints at any time.
#@cli : Assigning '-1' to it forces the interactive window to close.
#@cli : Default values: 'variable_name=xsf_variable', 'background_curve_R=220', 'background_curve_G=background_curve_B=background_curve_T'.
x_select_function1d : skip ${1=xsf_variable},${2=220},${3=$2},${4=$2}
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
e[^-1] "Open 1D function widget, with variable name '$1'."
v -
if $! k[0] fi
is_additional_data=$!
if {!{*}} w[] 400,400,0,"Create a 1D function" fi
reset_w={*,w} reset_h={*,h}
if {!narg($$1)} $1=0,0,100,100 fi
i[points] ($$1) y. x r. 2,{w/2},1,1,-1
is_thread_variable={arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} selected=-1 X=-1 Y=-1
do
if {!narg($baseview)}
{{*,d}-48},{{*,e}-48},1,3,255
if $is_additional_data
100%,100% +rows[0] 0 graph.. .,3,0,0,0,1,1 rm. c. 0,1
+fc.. ${2-4} j... .,0,0,0,0,1,.. rm[-2,-1]
fi
grid. {(w-1)/8},{(h-1)/8},0,0,0.2,0xCCCCCCCC,0
line. 0,100%,100%,0,0.2,0
frame. 24,24,200
rectangle. 23,23,{w-24},{h-24},1,0xFFFFFFFF,232 line. 23,23,23,{h-24},1,128 line. 23,23,{w-24},23,1,128
if {$is_additional_data" && "{0,h}>1}
if {{0,h}>2} +rows[0] 1,3 else +rows[0] 1 r. 100%,3 fi
r. {-2,w-48},3,1,1,3 permute. xzcy r. 100%,8 frame. 1,1,0
j.. .,23,{-2,h-19} rotate. -90 j.. .,{-2,w-19},23 rm.
fi
nm. baseview
l rm[view] onfail endl
fi
if {!narg($view)}
+z[baseview] 24,24,{baseview,w-25},{baseview,h-25} r. 200%,200%
function1d[] 1,{points,^}
l. c 0,100 transpose
i[0] ({'CImg3d'},{h},{h-1})
i.. 1,100%,1,1,y 1,100% a[-3--1] x
1,{h-1},1,1,2 +f. y ++. 1 a[-3--1] x
4,100%,1,1,1 y a y col3d 0
endl
*3d. {-2,(w-1)/100},{-2,(1-h)/100}
j3d.. .,0,100%,0,1,1,0,0 rm.
repeat {points,h}
x={points,i(0,$>)} y={100-{points,i(1,$>)}}
circle. $x%,$y%,6,1,0xFFFFFFFF,0
done
if {$selected>=0}
x={points,i(0,$selected)} y={100-{points,i(1,$selected)}}
circle. $x%,$y%,3,1,0
fi
r. 50%,50%,1,3,2
+j[baseview] .,24,24 rm..
if {$X>=0" && "$Y>=0} t. "X: "{min(255,round(255*$X/100))}" Y: "{min(255,round(255*$Y/100))},24,6,12,1 fi
nm. view
w[view]
fi
if $is_thread_variable wait 50 else wait fi
x={*,x} y={*,y} b={*,b} is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
X={($x-24)*100/({*,w}-49)} Y={100-($y-24)*100/({*,h}-49)}
oww={*,w} owh={*,h} ww=$oww wh=$owh
if {*,r} ww={*,d} wh={*,e}
elif {$is_ctrl" && "{*,-D}} ww={view,w*125%} wh={view,h*125%}
elif {$is_ctrl" && "{*,-C}} ww={view,w*75%} wh={view,h*75%}
elif {$is_ctrl" && "{*,R}} ww=$reset_w wh=$reset_h
elif {!$is_ctrl" && "{*,R}} rm[points] i[points] (0,0;100,100) $1={points,^} rm[view]
elif {$b&3}
is_inside={$X>=0" && "$Y>=0" && "$X<=100" && "$Y<=100}
if {$selected<0} +f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*{*,w}%' z. 0,0 selected={if(im>8,-1,ym)} rm. fi
if {$x>=0" && "$b&1" && "$selected>=0}
if {{*,SHIFTLEFT}||{*,SHIFTRIGHT}} X={points,i(0,$selected)} fi
if {{*,CTRLLEFT}||{*,CTRLRIGHT}} Y={points,i(1,$selected)} fi
if {points,$selected>0" && "$selected<h-1}
=[points] {points,max(min($X,i(0,$selected+1)-0.5),i(0,$selected-1)+0.5)},0,$selected
fi
=[points] {min(100,max(0,$Y))},1,$selected $1={points,^} rm[view]
elif {$b&1" && "$is_inside}
($X,$Y) a[points,-1] y sort[points] +,y
+f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*{*,w}%' z. 0,0 selected={if(im>8,-1,ym)} $1={points,^} rm[view,-1]
elif {$b&2" && "$selected>0" && "$selected<{points,h-1}" && "$is_inside}
l[points] s y rm[$selected] a y endl wait -1 selected=-1 $1={points,^} rm[view]
fi
elif {!($b&1)} selected=-1
fi
ww={min(90%*{*,u},max(200,$ww))}
wh={min(90%*{*,v},max(200,$wh))}
if {$oww!=$ww" || "$owh!=$wh} w[] $ww,$wh rm[baseview,view] fi
if {['$$1']=='-1'} break fi
if {['$$1']!=['{points,^}']} rm[points] i[points] ($$1) y. x r. 2,{w/2},1,1,-1 l rm[view] onfail endl fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w[] 0 u {points,^}
if $is_additional_data rm[^0] else rm fi
v +
#@cli x_select_palette : _variable_name,_number_of_columns={ 0=auto | >0 }
#@cli : Open a RGB or RGBA color selector widget from a palette.
#@cli : The palette is given as a selected image.
#@cli : Argument 'variable_name' specifies the variable that contains the selected color values (as R,G,B,[A]) at any time.
#@cli : Assigning '-1' to it forces the interactive window to close.
#@cli : Default values: 'variable_name=xsp_variable' and 'number_of_columns=2'.
x_select_palette : skip ${1=xsp_variable},${2=0}
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
if {!$!} error[0--3] "Command '$0': Missing specified palette image." fi
v - k[0] +r {w*h*d},1,1,{s},-1 to_color. rgba_mode={s==4} to_rgba. nm. palette v +
e[^-1] "Open "${arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget for palette$?, with variable name '$1'."
v -
if {w>1024} v + error[0--3] "Command '$0': Too much colors ("{w}") in selected palette." fi
if {!{*}} w[] 400,400,0,0,-1,-1,"Palette: "{0,b} fi
selected=-1 oselected=-1
do
ww={*,w} wh={*,h}
R={palette,round(i($selected,0,0,0))} G={palette,round(i($selected,0,0,1))}
B={palette,round(i($selected,0,0,2))} A={palette,round(i($selected,0,0,3))}
if {$selected>=0" && "$oselected!=$selected}
if $rgba_mode $1=$R,$G,$B,$A else $1=$R,$G,$B fi
fi
if {['$$1']=='-1'} break fi
if {!narg($baseview)} l[palette]
{w},1,1,1,x +. 1
s. x append_tiles[^0] $2
M={w} N={h} 100%,100%,1,1,1
+r. {$ww-17},100%,1,1,4
r.. 100%,{$wh-57},1,1,4
r[-2,-1] .,.. -|[-2,-1]
line. 100%,0,100%,100%,1,1
line. 0,100%,100%,100%,1,1
-. 1 *. -1
r.. .,.,1,1,1 -.. 1
+map.. [0],0 drgba.
rv[-2,-1] *[-2,-1]
+!=.. -1 dilate. 3
mv... $! +. 1 a[-3--1] c
nm. baseview
endl
if {narg($view)} rm[view] fi
fi
if {!narg($view)}
$ww,$wh,1,3,200
if {$selected<0} sh[baseview] 0,2
else
+channels[baseview] 0,2 +channels[baseview] 4,4
!=. {$selected+1} rectangle. 0,0,100%,100%,1,0xFFFFFFFF,1
+dilate. 5 -[-2,-1] *. -1 +dilate. 5 *.. 255
r.. 100%,100%,1,3 j... ..,0,0,0,0,1,. rm[-2,-1]
if $rgba_mode t.. "RGBA ("$R","$G","$B","$A")",8,{$wh-45},14,1,0
else t.. "RGB ("$R","$G","$B")",8,{$wh-45},14,1,0
fi
($R^$G^$B) rgb2hsv. H={round(i[0])} S={round(i[1]*255)} V={round(i[2]*255)} rm.
t.. "HSV ("$H","$S","$V")",8,{$wh-31},14,1,0
({'${dec2hex\ {$R*65536+$G*256+$B}}'}) -. {'0'} r. 6,1,1,1,0,0,1,0 +. {'0'}
f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
t... "HTML ""#"{t},8,{$wh-17},14,1,0 rm.
fi
sh[baseview] 3 j... ..,8,8,0,0,1,. rm[-2,-1]
nm. view w[view]
fi
if {arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} wait 50 else wait fi
is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
if {*,r} ww={*,d} wh={*,e}
elif {$is_ctrl" && "{*,-D}} ww={1.25*$ww} wh={1.25*$wh}
elif {$is_ctrl" && "{*,-C}} ww={0.8*$ww} wh={0.8*$wh}
elif {$is_ctrl" && "{*,R}} ww=400 wh=400
fi
ww={max(200,$ww)} wh={max(200,$wh)}
if {($ww!={*,w}" || "$wh!={*,h})" && "narg($baseview)} w[] $ww,$wh rm[baseview] fi
oselected=$selected
if {narg($baseview)}
x={*,x} y={*,y} b={*,b}
if {$b&1" && "$x>=0" && "$y>=0}
if {baseview,i($x-8,$y-8,0,4)} selected={baseview,i($x-8,$y-8,0,4)-1} else selected=-1 fi
rm[view] wait -1
elif {{*,ARROWUP}" && "$selected>=$M} selected-=$M rm[view] wait -1
elif {{*,ARROWDOWN}" && "$selected<{0,w-$M}} selected+=$M rm[view] wait -1
elif {{*,ARROWRIGHT}" && "$selected<{0,w-1}} selected+=1 rm[view] wait -1
elif {{*,ARROWLEFT}" && "$selected>0} selected-=1 rm[view] wait -1
fi
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w 0 k[0]
if {$selected>=0} if $rgba_mode u $R,$G,$B,$A else u $R,$G,$B fi else u -1 fi
v +
#@cli x_shadebobs
#@cli : Launch the shade bobs demo.
x_shadebobs :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Shade bobs"$n" -------------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------------"
v - rm t=100 w 512,512,0,"[G"{`39`}"MIC] Shade Bobs"
do
t+=0.015
if {$t>4*pi" || "{*,b}}
rx={u(-1,1)} ry={u(-1,1)} rz={u(-1,1)} rt={u(-1,1)} rcx={u(-0.6*0.6)} t=0
N={20+round(u(80))} R={(2+round(u(40)))*min({*,w},{*,h})/300}
if $obj3d rm[colormap,img,obj3d] fi
{4+round(u(12))},1,1,3 noise[0] 255,2 ==. 1 r[0] 256,1,1,3,3 *[0] 255 shift[0] 1 nm. colormap
(67.5;73.5;109.5;103.5;51.5;100.5;{2*$N};$N) 3,{2*$N},1,1,0
1,$N,1,1,5 2,$N,1,1,'y+x*$N' a[-2--1] x z. 0,5
4,$N,1,1,1 y[-3--1] a[-4--1] y nm. obj3d
{*,w},{*,h} nm. img
wait -1
fi
r={$ry+$rx*cos(6*$rz*$t)+(1-$rx)*sin(6*$rt*$t)}
(0;{30*$ry*($N-1)}) ($t;{2*pi*($N-1)/$N+$t}) r[-2,-1] 1,$N,1,1,3
+.. {360*sin($rz*$t)} *.. {pi/180}
+sin[-2,-1] cos[-4,-3] *[-4,-2] $r *[-3,-1] $rcx +[-4,-3] +[-2,-1]
*.. {{*,w}/2} *. {{*,h}/2} a[-2,-1] x
++. $R -.. $R a[-2,-1] y z. 0,2 y. j[obj3d] .,0,8 rm.
j3d[img] [obj3d],50%,50%,0,-1,2,0,0
&[img] 255 +map[img] [colormap] w. rm. wait 20
if {{*,CTRLLEFT}&&{*,D}} w[] 1024,1024 elif {{*,CTRLLEFT}&&{*,C}} w[] 512,512 fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 v +
#@cli x_spline
#@cli : Launch spline curve editor.
x_spline :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Spline curve editor"$n" --------------------------\n
----\n
---- "${c}"Mouse"$n" to insert/move/delete points.\n
---- Key '"${c}"R"$n"' to reset the curve.\n
---- Key '"${c}"SPACE"$n"' to shows/hide spline curve.\n
---- Key '"${c}"P"$n"' to shows/hide control points.\n
---- Key '"${c}"ENTER"$n"' to shows/hide control polygon.\n
---- Key '"${c}"T"$n"' to shows/hide point tangents.\n
---- Key '"${c}"I"$n"' to shows/hide point indices.\n
---- Key '"${c}"C"$n"' to shows/hide point coordinates.\n
---- Keys '"${c}"+"$n"' and '"${c}"-"$n"' to increase/decrease roundness.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
v -
if $! a x n 0,255 to_rgb else (0;0^0;128^0;0) r. 512,512,1,3,3 nm. "[G"{`39`}"MIC] Spline Editor" fi
w[0] {0,w},{0,h},0,0,-1,-1,{n} r[0] {*,w},{*,h},1,3,1
i[1] 1
roundness=0.5
visuflags=23
nearest=-1
active=-1
do
if {{1,whds}==1}
rm[1] roundness=0.5 nearest=-1 active=-1
i[1] ({0.2*w},{0.2*h};\
{0.2*w},{0.8*h};\
{0.8*w},{0.8*h};\
{0.8*w},{0.2*h})
fi
[1] ({{*,w}/{0,w}},{{*,h}/{0,h}}) *[-2,-1]
+shift[2] 0,-1,0,0,2 +shift[2] 0,1,0,0,2 -[-2,-1] *. $roundness
+s. x sqr[-2,-1] +[-2,-1] sqrt. r. 2 +/[-2,-1] rm..
+r[0] {*,w},{*,h},1,3
if {$visuflags&4} polygon. {2,h},{2,^},0.3,128,200,255 fi
repeat {1,h}
line. {2,@0-3},0.3,255,255,0
if {$visuflags&1} spline. {2,@0-1},{3,@0-1},{2,@2-3},{3,@2-3},1,255 fi
if {$visuflags&8} line. {{2,@0}-{4,@0}*20},{{2,@1}-{4,@1}*20},{{2,@0}+{4,@0}*20},{{2,@1}+{4,@1}*20},1,0,255,0 fi
if {$visuflags&16} t. $>,{{2,@0}-3},{{2,@1}-18},13,1,255,255,0 fi
if {$visuflags&32} t. "("{round({1,@0})}","{round({1,@1})}")",{{2,@0}-16},{{2,@1}+10},13,1,100,200,255 fi
shift[1-4] 0,-1,0,0,2
done
if {$visuflags"&2"} repeat {1,h}
ellipse. {2,@0-1},4,4,0,1,0,0,0 ellipse. {2,@0-1},2,2,0,1,255,100,155 shift[2] 0,1,0,0,2
done fi
w. rm[3,4,-1] wait
if {*,SPACE} visuflags+={if($visuflags&1,-1,1)} wait -1 fi
if {*,P} visuflags+={if($visuflags&2,-2,2)} wait -1 fi
if {*,ENTER} visuflags+={if($visuflags&4,-4,4)} wait -1 fi
if {*,T} visuflags+={if($visuflags&8,-8,8)} wait -1 fi
if {*,I} visuflags+={if($visuflags&16,-16,16)} wait -1 fi
if {{*,C}" && "!{*,CTRLLEFT}" && "!{*,CTRLRIGHT}} visuflags+={if($visuflags&32,-32,32)} wait -1 fi
if {{*,PADADD}" && "$roundness<1} roundness*=1.1 wait -1 fi
if {{*,PADSUB}" && "$roundness>0.1} roundness*=0.9 wait -1 fi
if {{*,R}" && "!{*,CTRLLEFT}" && "!{*,CTRLRIGHT}} rm. i[1] 1 wait -1 fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} fi
if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} fi
if {*,r} w[] fi
if {{*,b}==0} active=-1
elif {{*,x}>=0" && "{*,b}" && "$active==-1}
[2] ({*,x},{*,y}) -[-2,-1] sqr. s. x +[-2,-1]
nearest={ym}
if {im<64} active=$nearest fi
rm.
fi
rm[2]
if {{*,b}&1" && "{*,x}>=0" && "$active!=-1}
=[1] {{*,x}*{0,w}/{*,w}},0,$active
=[1] {{*,y}*{0,h}/{*,h}},1,$active
elif {{*,b}&2" && "{*,x}>=0" && "{1,h}>3}
l[1] s y rm[$nearest] a y endl wait -1
elif {{*,b}&1" && "{*,x}>=0}
xy=({{*,x}*{0,w}/{*,w}},{{*,y}*{0,h}/{*,h}})
+shift[1] 0,-1,0,0,2 +. [1] /. 2
$xy -[-2,-1] sqr. s. x +[-2,-1]
ns={ym} rm.
l[1] s y i[{$ns+1}] $xy a y endl
active={$ns+1}
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
+shift[1] 0,-1,0,0,2 +shift[1] 0,1,0,0,2 -[-2,-1] *. $roundness
[0],[0],1,1,2 rm[0]
repeat {1,h} spline. {0,@0-1},{1,@0-1},{0,@2-3},{1,@2-3},1,1 shift[0] 0,-1,0,0,2 shift[1] 0,-1,0,0,2 done
flood. 0,0,0,0,0,1,0
rm[0,1] w 0 v +
#@cli x_starfield3d
#@cli : Launch the 3D starfield demo.
x_starfield3d :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"3D starfield"$n" ---------------------------------------\n
----\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------"
v - l[]
({'G\47MIC'}) s x
x=0 N=$! repeat $N 0 t. {$>,t},0,0,48,1,1 x$>=$x y$>=0 z$>={-3200-150*$>} x={$x+w+8} done k[50%--1]
expand_xy 6,0 dilate_circ 5 b 0.5 expand_z 1,0 isosurface3d 10% *3d 1,1,5 rv3d
repeat $N col3d[$>] ${-RGB} done
0 t. "Version "${-strver},0,0,48,1,1 r2dy. 18 +f. 255 to_rgb.
random3d 2500 col3d. 255 *3d. 320,200,1000 -3d. 160,100
l3d 0,0,-600
w[] 640,400,0,"[G"{`39`}"MIC] 3D Starfield"
t0=0 t=0
do
320,200,1,3
l.. s3d
r[2] 3,{2,h/3},1,1,-1 s[2] x %[4] 1000
+/[4] 1000 *. -1 n. 0,2 c. 0,1 sqr. j.. . rm.
a[2-4] x
y a y
endl
j3d. ..,50%,50%,-600,1,0,0,0,240 -3d.. 0,0,{min(12,$t0/10-4)}
torus3d 100,30 col3d. 255,64,255
+col3d. 64,64,255 r3d. 1,0,0,-90 +3d. 65,0,0
+3d[-2,-1] c3d.
r3d. 1,1,0,{-6*$t} r3d. 0,0,1,{2*$t}
j3d.. .,{($t-200)*2}%,50%,0,0.25,3,0,0 rm.
repeat $N
+r3d[$>] 1,{$>%4},1,{-${z$>}/2}
j3d.. .,{90+${x$>}},{60+${y$>}},${z$>},1,4,0,0 rm.
z$>={tl=280+6*$<;if($t<tl,min(0,${z$>}+20),-20*($t-tl))}
done
if {$t<280} op={max(0,min(1,($t-200)/20))}
else op={max(0,1-($t-280)/20)}
fi
j. ...,{(w-{-3,w})/2},120,0,0,$op,[-4]
w. wait 30 rm.
t0+=1 t={$t0%350}
if {!$t} x=0 repeat 5 z$>={-3200-150*$>} done fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w[] 0 rm endl v +
#@cli x_tetris
#@cli : Launch tetris game.
x_tetris :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Tetris"$n" --------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the "${g}"Tetris"$n" game.\n
----\n
---- "${c}"Arrow keys"$n" to move/rotate the triominos.\n
---- Key '"${c}"SPACE"$n"' to make the current triomino falling.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
----------------------------------------------------------"
v - rm
i[m0] 4,1,1,1,1,1,1,1
i[m4] 3,2,1,1,1,0,0,1,1,1
i[m8] 3,2,1,1,0,0,1,1,1,1
i[m12] 2,2,1,1,1,1,1,1
i[m16] 3,2,1,1,0,1,1,1,1,0
i[m20] 3,2,1,1,0,1,0,1,1,1
i[m24] 3,2,1,1,1,1,0,0,1,1
if {u<0.25}
i[m28] 2,1,1,1,1,1
i[m32] 2,2,1,1,1,1,0,1
i[m36] 3,1,1,1,1,1,1
i[m40] 1,1,1,1,1
i[m44] 3,2,1,1,1,1,1,1,0,1
i[m48] 3,3,1,1,1,1,1,1,0,1,1,1,1
fi
repeat $! i={4*$>} l[m$i] repeat 3 +rotate[0] {90*($>+1)} nm. m{$i+$>+1} done endl done
N=$!
i[colors] 3,$N,1,1,'u(16,224)' r. 3,400% i[mask] (0,-1,0;1,0,-1;0,1,0) *. 120
repeat $N
+r[m$>] 500%,500%,1,3 +correlate. [mask],0 r. 200%,200%,1,1,3 r.. . *[-2,-1] c. 30%,100%
+r[m$>] .,.,1,3 +replace_color. 0,0,1,1,1,{colors,@{3*$>}-{3*$>+2}} rv[-3,-1] +[-3,-1] c.. 0,255
channels. 0 *. 255 a[-2,-1] c nm. s$>
done
rm[colors,mask]
fact={{s0,w}/{m0,w}}
W=12 H=20
i[board] $W,$H i[curr_board] [board]
i[render] {$fact*$W},{$fact*$H},1,3 i[curr_render] [render] +channels. 0 nm. curr_render_mask
+rows[render] 0,50% plasma. 1,2 noise. 20 blur_y. 40%,1 +mirror. y a[-2,-1] y r. [render]
n. 0,64 blur_x. 1 100%,100% noise. 0.5,2 ==. 1 b. 1 *. 300 +[-2,-1] c. 0,255 nm. background
time=$| score=0 fall_mode=0 gameover=0 n=-1 nn={round(u(0,$N-1))}
do
wait {if($fall_mode,-1,-20)}
if $gameover
+j[background] [curr_render],0,0,0,0,0.7,[curr_render_mask],255
to. "Game\nOver!",22,30%,32,2,1,255 w. rm.
continue
fi
if {$n<0}
l[board] s y i=-1 repeat $! if {$<,im} i=$<,$i fi done
0 rm[$i] a y score+={2^(narg($i)-1)-1} r $W,$H,1,1,0,0,0,1 nm board endl
if {narg($i)>1} l[render] s y,$H 0 rm[$i] a y r {$fact*$W},{$fact*$H},1,3,0,0,0,1 nm render endl fi
n=$nn nn={round(u(0,$N-1))} x={$W/2} y=0 do_render=1 fall_mode=0
fi
if $do_render
rm[curr_board,curr_render,curr_render_mask]
i[curr_board] [board] j[curr_board] [m$n],{$x-int({m$n,w}/2)},$y,0,0,1,[m$n]
i[curr_render] [render] sh[s$n] 3 j[curr_render] [s$n],{$fact*($x-int({m$n,w}/2))},{$fact*$y},0,0,1,.,255 rm.
+*[curr_board] 255 r. [curr_render],[curr_render] nm. curr_render_mask
0 t. "Score : "$score"    Next :",4,0,32,1,164 r. 40%,40%,1,3,2 +!=. 0 *. 255
j[curr_render] ..,0,0,0,0,1,.,255 j[curr_render_mask] .,0,0,0,0,1,.,255 rm[-2,-1]
+*[m$nn] 196 r. 300%,300%,1,3 j[curr_render,curr_render_mask] .,{{curr_render,w}-w-4},3,0,0,1,.,196 rm.
do_render=0
fi
+shift[background] 0,{round(-13*$|*1.04^$score)},0,0,2
j. [curr_render],0,0,0,0,1,[curr_render_mask],255
w. {2.25*w},{2.25*h},0,"[G"{`39`}"MIC] Tetris" rm. cursor[0] 0
if {*,SPACE} fall_mode=1 fi
if {{*,ARROWUP}" || "{*,ARROWLEFT}" || "{*,ARROWRIGHT}}
an={if({*,ARROWUP},n=$n+1;if(n%4,n,n-4),$n)}
nx={w2=int({m$an,w}/2);max(w2,min($x-{*,ARROWLEFT}+{*,ARROWRIGHT},$W-({m$an,w}%2)-w2))}
+j[board] [m$an],{$nx-int({m$an,w}/2)},$y,0,0,-1,[m$an]
if {{iM}==1} x=$nx n=$an fi
rm.
do_render=1
fi
if {{*,ARROWDOWN}" || "$|-$time>0.9^int($score/2)" || "$fall_mode}
y+=1
+j[board] [m$n],{$x-int({m$n,w}/2)},$y,0,0,-1,[m$n]
if {{iM}>1" || "$y+{m$n,h}>$H}
if {$y<=1} gameover=1 fi
j[board] [curr_board] j[render] [curr_render] n=-1
fi
rm.
time=$| do_render=1
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 v +
#@cli x_tictactoe
#@cli : Launch tic-tac-toe game.
x_tictactoe :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Tic-Tac-Toe game"$n" -----------------\n
----\n
---- Use "${c}"mouse"$n" to select positions of the\n
---- symbols. Close window to exit game.\n
----\n
-----------------------------------------"
v -
message=0
counter=0
player=0
state=0
tmp3=0
tmp2=0
tmp1=0
_x_tictactoe2
w. -1,-1,0," "
do
if $player message="Tic-Tac-Toe (O to play)"
else message="Tic-Tac-Toe (X to play)"
fi
do
w[] {w},{h},0,"[G"{`39`}"MIC] "$message wait
if {!{*}" || "{*,ESC}" || "{*,Q}} w[] 0 rm v + return fi
if {{*,b}&1" && "{*,x}>20" && "{*,y}>20" && "{*,x}<400" && "{*,y}<400}
tmp3={int(({*,x}-15)/130)}
tmp2={int(({*,y}-15)/130)}
tmp1={4^($tmp2*3+$tmp3)}
if {int($state/$tmp1)%4} tmp1=-1 fi
else tmp1=-1 fi
while {$tmp1<0}
_x_tictactoe{$player%2}
j... ..,{"130*"$tmp3" + 15+u(-5,5)"},\
{"130*"$tmp2" + 15+u(-5,5)"},0,0,1,.
rm[-2--1]
w.
state+={(1+$player)*$tmp1}
(21,1344,86016,4161,16644,66576,65793,4368;\
0,0,0,0,1,2,0,0;\
0,1,2,0,0,0,0,0;\
3,3,3,4,4,4,5,6)
repeat {w}
tmp1={@$>}
if {($state&$tmp1)==$tmp1||($state&(2*$tmp1))==2*$tmp1}
_x_tictactoe{i($>,3)}
j[-4] ..,{130*{-3,i($>,1)}+u(-5,5)},\
{130*{-3,i($>,2)}+u(-5,5)},0,0,1,. rm[-2--1]
if {($state&$tmp1)==$tmp1} w.. -1,-1,0,"Tic-Tac-Toe (X won!)"
else w.. -1,-1,0,"Tic-Tac-Toe (O won!)"
fi
do wait
if {*} w[] {*,w},{*,h} fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w[] 0 v + return
fi
done
rm.
player={($player+1)%2}
counter+=1
while {$counter<9}
w[] -1,-1,0,0,"Tic-Tac-Toe (Tied game!)"
do wait
if {*} w[] {*,w},{*,h} fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w[] 0 rm v +
_x_tictactoe :
spread. 4 b. 6 sharpen. 0.8 n. 0,1
__x_tictactoe :
+f. 1-i +n.. $2,255 +n... $3,255 n[-4] $1,255 a[-4,-2,-1] c
_x_tictactoe0 :
128,128,1,1,1 line. 15%,15%,85%,85%,1,0 line. 15%,85%,85%,15%,1,0 erode. 12 _x_tictactoe deform. 4 __x_tictactoe 40,40,160
_x_tictactoe1 :
128,128,1,1,1 ellipse. 50%,50%,22%,22%,0,1,0 ellipse. 50%,50%,15%,15%,0,1,1 _x_tictactoe deform. 4 __x_tictactoe 160,40,160
_x_tictactoe2 :
391,391,1,1,"!(x%130) || !(y%130)" r. 421,421,1,1,0,0,0.5,0.5 dilate. 3 _x_tictactoe f. 1-i
100%,100% noise. 10 b. 8,0 sharpen. 1.5 n. 220,255 *[-2,-1] to_rgb.
_x_tictactoe3 :
421,130,1,1,1 line. 10%,60%,90%,60%,1,0 erode. 6 _x_tictactoe rotate. {u(-6,6)},1,1,50%,50% __x_tictactoe 180,10,10
_x_tictactoe4 :
_x_tictactoe3 transpose[-2--1]
_x_tictactoe5 :
421,421,1,1,1 line. 10%,10%,90%,90%,1,0 erode. 6 _x_tictactoe __x_tictactoe 180,10,10
_x_tictactoe6 :
421,421,1,1,1 line. 10%,90%,90%,10%,1,0 erode. 6 _x_tictactoe __x_tictactoe 180,10,10
#@cli x_waves
#@cli : Launch the image waves demo.
x_waves :
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Image waves"$n" --------------------------\n
----\n
---- "${c}"Left mouse button"$n" to drop balls.\n
---- "${c}"Right mouse button"$n" to rotate view.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"CTRL+F"$n"' to switch fullscreen mode.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
---------------------------------------------"
v -
if {!$!} l[]
200,200 x={-1.06-u*0.1} y={-0.26-u*0.1}
mandelbrot $x,$y,{$x+0.1},{$y+0.1},256
16,1,1,3,u r. 256,1,1,3,3 shift. 1
map[0] . rm. r2dx 100
+mirror y +mirror x + n 0,128
shape_fern {2*w},70%,25 r2dx. {-2,3*w/4} to_rgb. r. ..,0,0,0.5,0.5 n. 0,196 +[-2,-1] c. 0,255
endl else k[0] r[0] 100,100,1,3,2 fi
i[0] (20;80;0^20;80;0^20;80;0) r[0] 400,300,1,3,3 water[0] 100,2
w[0] {0,1.25*w},{0,1.25*h},0,"[G"{`39`}"MIC] Image Waves"
w={w} elevation3d. 0 rv3d.
sh. 8,{7+3*i[6]},0,0 r. 3,{h/3},1,1,-1
(0,1,0;1,0,1;0,1,0) /. 2
ball[] 20,200,255,128,1,0.7,3.5
0 $w,$w .
l3d {$w/2},-200,-1000 sl3d 0.4 ss3d 0.8 f3d 500 time0=$|
do
+convolve. [3],1 -. ... rm... b. 0.8 -. {ia}
r. 1,{$w*$w},1,1,-1 j[2] .,2,0 r. $w,$w,1,1,-1
[1]
if {5,h} +l[5] rows 0,2
nb={w}
i[0] ({'CImg3d'}) i[1] ($nb,$nb) transpose[2]
(1,0;1,{$nb-1}) r. 2,$nb,1,1,3 round.
1,{4*$nb},1,1,1 y a y
endl [4] sprites3d.. .,1 rm. +3d[-2,-1] fi
-3d. {$w/2},{$w/2} *3d. {0,0.9*max(w,h)/$w}
r3d. 0,0,1,{if({*,b}&2,{*,x}*360/{*,w},$|*30)} r3d. 1,0,0,120
+j3d[0] .,50%,65%,30,1,3,0,0
fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-22},16,2,0.2 fi
w.
if {{*,CTRLLEFT}&&{*,D}} w[] {2.25*w},{2.25*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.25*w},{1.25*h}
elif {{*,CTRLLEFT}&&{*,F}}
if {!narg($is_fs)} is_fs={*,w},{*,h} fw={min({*,u}*h/w,{*,v}*w/h)} w[] $fw,{$fw*h/w},0,1
else w[] $is_fs,0,0 is_fs=""
fi
fi
rm[-2,-1] wait 20
if {{*,b}&1||($|-$time0)>1} ({u*$w};{u*$w};70;0) a[5,-1] x time0={$|-u} fi
if {5,h} l[5,-1]
sh[0] 2,2,0,0 sh[0] 3,3,0,0 -.. . +. 0.2 rm[-2,-1]
s[0] x repeat {$!-1} coords={$<,@0-1} if {{$<,@2}<i($coords)} =. {80+{i($coords)}},$coords rm[$<] fi done
if {$!==1} i[0] 0 else a[0--2] x fi
endl
fi
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm w 0 v +
#@cli x_whirl : _opacity>=0
#@cli : Launch the fractal whirls demo.
#@cli : Default values: 'opacity=0.2'.
x_whirl : check "${1=0.2}>=0"
if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
e[] "\n
------ "${g}"Fractal whirls"$n" ----------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------"
v -
5,5,1,3 256,256,1,3 [-1] w. 384,384,0,"[G"{`39`}"MIC] Fractal Whirls"
tangle=0 tzoom=0 xc={(w-{-3,w})/2} yc={(h-{-3,h})/2}
do
rand... 0,255 j.. [-3],$xc,$yc,0,0
f.. "*begin(R = rot(8*sin(-"$tangle"))/(1.03+0.02*sin("$tzoom")); C=[w,h]/2); I((R*([x,y]-=C))+=C,0,0)"
tangle+=0.001
tzoom+=0.02
j. [-2],0,0,0,0,$1 w.
if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
wait 20
while {{*}" && "!{*,ESC}" && "!{*,Q}}
rm[-3,-2] w[] 0 v +
__help_end :
gui_filter_sources : skip ${1=0},${2=1}
if {$2}
local=${_path_rc}update$_version.gmic
if $local m $local gui_filter_sources $1,0 return fi
fi
if {u>0.95} l[]
files=${"files "$_path_rc"/update*.gmic"}
repeat {narg($files)}
file=${arg\ 1+$>,$files}
({'$file'}) z. {[w-8,w-6]} ver={t} rm.
if {isval($ver)" && "$ver<$_version} 0 o. raw:$file,uchar rm. fi
done
onfail
endl fi
({'https://gmic.eu/update$_version.gmic'},1)
l[] _gui_filter_sources $1 onfail rm endl
l[] i cimgz:${_path_rc}gui_filter_sources onfail endl
({'{/$_path_user}'})
gui_preview_wh :
u {0$_preview_width?[0$_preview_width,0$_preview_height]:[400,400]}
gui_parallel_overlap :
apo "$1",$3,{if($2,2^($2-1),0)}
gui_preview :
frame 1,1,0,0,0,255 montage B
gui_layer_name :
u ${"_gui_merge_layers[0] name,[unnamed]"}
gui_layer_mode :
u ${"_gui_merge_layers[0] mode,alpha"}
gui_layer_opacity :
u ${"_gui_merge_layers[0] opacity,100"}
gui_layer_pos :
u ${"_gui_merge_layers[0] pos,0,0"}
gui_set_layer_name :
repeat $! l[$>]
opacity=${-gui_layer_opacity} mode=${-gui_layer_mode} pos=${-gui_layer_pos}
nm "name($1),mode("$mode"),opacity("$opacity"),pos("$pos")"
endl done
gui_set_layer_mode :
repeat $! l[$>]
name=${-gui_layer_name} opacity=${-gui_layer_opacity} pos=${-gui_layer_pos}
nm "name("$name"),mode($1),opacity("$opacity"),pos("$pos")"
endl done
gui_set_layer_opacity :
repeat $! l[$>]
name=${-gui_layer_name} mode=${-gui_layer_mode} pos=${-gui_layer_pos}
nm "name("$name"),mode("$mode"),opacity($1),pos("$pos")"
endl done
gui_set_layer_pos :
repeat $! l[$>]
name=${-gui_layer_name} mode=${-gui_layer_mode} opacity=${-gui_layer_opacity}
nm "name("$name"),mode("$mode"),opacity("$opacity"),pos("{round("$1")},{round("$2")}")"
endl done
gui_merge_layers :
if {!$!} return fi
mode0=${"_gui_merge_layers. mode,alpha"}
opacity0=${"_gui_merge_layers. opacity,100"}
pos0=${"_gui_merge_layers. pos,0,0"}
if {$opacity0<100" || "['$pos0']!='0,0'} 100%,100%,1,4 fi
wh0={w},{h}
wh=${-max_wh} r. $wh,1,100%,0
repeat {$!-1} l[-2,-1] rv
mode=${"_gui_merge_layers[1] mode,alpha"}
opacity=${"_gui_merge_layers[1] opacity,100"}
pos=${"_gui_merge_layers[1] pos,0,0"}
to_a[1] r[1] $wh,1,100%,0
shift[1] ${u\ $pos},0,0
to_colormode[0,1] 0
blend $mode,{max(0,min(1,$opacity/100))}
endl done
r $wh0,1,100%,0
_gui_merge_layers :
u {`"
str = ["{'{n}'}"]; const sstr = size(str);
def = ['${2--1}'];
ker = ['$1(']; const sker = size(ker);
const N = max(size(str),size(def));
res = vectorN(0);
p = q = find(str,ker);
p>=0?(
q+=sker;
r = find(str,'),',1,q);
q = r>=0?r:(str[sstr-1]==_')'?sstr-1:-1);
);
q>=0?copy(res,str[p + sker],q - p - sker):(def = ['${2--1}']; copy(res,def,size(def)));
res"`}
gui_split_preview : check "isint(${2=0}) && $2>=0 && $2<=12 && ${5=0}>=0" skip "${3=nan},${4=nan}"
m "_split_preview : $1 k[0]"
is_movable={!isnan($3)" && "!isnan($4)}
posx,posy={$is_movable?cut([$3,$4],0,100):[50,50]}
pw,ph=${-gui_preview_wh}
repeat $! l[$>]
is_timeout=0
+l apply_timeout _split_preview,0$_preview_timeout onfail gui_timeout_preview is_timeout=1 endl
if {$is_timeout" || "!$2} k.
else
drgba rr2d $pw,$ph,0,2
r {[max(w#0,w#1),max(h#0,h#1)]},1,100%,0,0,0.5,0.5
posx,posy={round([$posx,$posy]*([w,h]-1)%)}
if {$2==1" || "$2==3}
1,[0],1,1,'y>=$posy?($2==1):($2==3)' r. [0],[0],1,1 j[0] [1],0,0,0,0,1,.
elif {$2==2" || "$2==4}
[0],1,1,1,'x>=$posx?($2==2):($2==4)' r. [0],[0],1,1 j[0] [1],0,0,0,0,1,.
elif {$2==5}
j[0] [1],0,$posy
elif {$2==6}
j[0] [1],$posx
elif {$2==7}
j[0] [1],0,{$posy-h}
elif {$2==8}
j[0] [1],{$posx-w}
elif {$2==9}
if {!$posy} k. elif {$posy>=h} k.. else r[0] 100%,$posy,1,100%,0,0,0,0.5 r[1] 100%,{h-$posy},1,100%,0,0,0,0.5 a y fi
elif {$2==10}
if {!$posx} k. elif {$posx>=h} k.. else r[0] $posx,100%,1,100%,0,0,0.5 r[1] {w-$posx},100%,1,100%,0,0,0.5 a x fi
elif {$2==11}
1,[0],1,1,'y>=$posy' [0],1,1,1,'x>=$posx' r[-2,-1] [0],[0],1,1 xor[-2,-1]
j[0] [1],0,0,0,0,1,.
elif {$2==12}
1,[0],1,1,'y<=$posy' [0],1,1,1,'x>=$posx' r[-2,-1] [0],[0],1,1 xor[-2,-1]
j[0] [1],0,0,0,0,1,.
fi
k[0]
dir=0
if {isin($2,1,3,5,7,9,11,12)}
dir+=1
line 0,$posy,100%,$posy,0.75,0xF0F0F0F0,255 line 0,$posy,100%,$posy,0.75,0x0F0F0F0F,0
if $is_movable
coords={p=[$posx,$posy];[p+[-10,-1],p+[10,-1],p+[0,-11]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
coords={p=[$posx,$posy];[p+[-10,1],p+[10,1],p+[0,11]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
fi
fi
if {isin($2,2,4,6,8,10,11,12)}
dir+=2
line $posx,0,$posx,100%,0.75,0xF0F0F0F0,255 line $posx,0,$posx,100%,0.75,0x0F0F0F0F,0
if {$2!=9" && "$is_movable}
coords={p=[$posx,$posy];[p+[-1,-10],p+[-1,10],p+[-11,0]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
coords={p=[$posx,$posy];[p+[1,-10],p+[1,10],p+[11,0]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
fi
fi
l[]
0 +t. "After",0,0,20,1,255 t.. "Before",0,0,20,1,255
autocrop 0 z[0] {0,[-1,-1,w,h]} z[1] {1,[-1,-1,w,h]}
if {isin($2,3,4,7,8,12)} rv fi
+dilate[-2,-1] 3 /[-2,-1] 255 r[-4,-3] 100%,100%,1,3
endl
if {-4,"const c1 = "$posx">w+2; const c2 = "$posy">h+2; arg("$dir",c2,c1,c1&&c2)"}
j[0] [-4],2,2,0,0,1,..
fi
if {-3,"const c1 = "$posx"<w#0-w-3; const c2 = $2<11?("$posy"<h#0-h-3):("$posy">h+2); arg("$dir",c2,c1,c1&&c2)"}
j[0] [-3],{[w#0-3-w,isin($2,11,12)?2:h#0-3-h]},0,0,1,.
fi
k[0]
fi
endl done
uncommand _split_preview
gui_print_preview : skip "${1=},${3=}" check "${2=32}>=0 && ${4=20}>=0"
if $! k[0] fi
drgba
siz={0$_preview_width?[0$_preview_width,0$_preview_height]:[${fitscreen\ {[max(w,1),max(h,1)]},1,400}]}
sizw={arg(1,$siz)-8}
if $! rr2d $siz,2,3 drgba else $siz,1,3,128 fi
(1;0.5^1;0.5^0;1)
(0,0.5,0;0.5,1,0.5;0,0.5,0) *. 0.65
r[-2,-1] ...,3 * c 0,255
l[]
0 t. "$1",0,0,$2,1,255 i.. 100%,100%,1,3 fc.. 255,200,120 a[-2,-1] c r2dx. {min(w,arg(1,$sizw)-8)} r. 100%,140%,1,100%,0,0
onfail rm
endl
l[]
0 t. "$3",0,0,$4,1,255 i.. 100%,100%,1,3,255 a c
({'"$3"'}) is_err={"crop(0,4)=='*** '"} rm.
if $is_err
x={"T = crop(0,0,0,3,32,h,1,1);
for (c = 32, c<w, ++c, crop(c,0,0,3,32,h,1,1)==T?break());
c<w?for (0, c<w, ++c, max(crop(#-1,c-2,0,0,3,5,h,1,1))<=0?break());
c<w?c:0"}
if $x +z. {$x+1},100% z.. 0,$x sh.. 0,2 fc. 0,255,0 rm. i.. 1,10 fi
fi
repeat $! l[$<]
for {w>$sizw}
x={"const c0 = "$sizw"-1;
const c02 = c0/2;
for (c = c0, c>=c02, --c, max(crop(#-1,c-2,0,0,3,5,h,1,1))<=0?break());
c<c02?for (c = c0, c>=c02, --c, max(crop(#-1,c,0,0,3,1,h,1,1))<=0?break());
c<c02?c0:c"}
+z. {$x+1},100% z.. 0,$x
done
endl done
a y,0
onfail rm
endl
a[^0] y,0.5
r. [0],[0],1,100%,0,0,0.5,0.5
blend alpha
gui_no_preview : skip "$*"
gui_print_preview "",0,"No preview available",32
gui_timeout_preview :
gui_print_preview "",0,"Preview timeout",32
gui_warning_preview :
gui_print_preview "Preview warning:",32,"$*",22
gui_error_preview :
gui_print_preview "Preview error:",32,"$*",20
gui_check_version :
if {$_version<$1}
gui_error_preview "This filter requires at least version *"${"strver $1"}"* of the G'MIC framework.\n\n"\
"https://gmic.eu/download.shtml"
u 0
else u 1
fi
gui_autocrop_layers :
repeat $! l[$>]
nm=${-gui_layer_name}
mode=${-gui_layer_mode}
opacity=${-gui_layer_opacity}
coords=${autocrop_coords\ auto}
z $coords
nm mode($mode),opacity($opacity),pos({arg(1,$coords)},{arg(2,$coords)}),name($nm)
endl done
#@gui_ja <b>&#12497;&#12479;&#12540;&#12531;</b>
#@gui_ja &#12525;&#12540;&#12523;&#12471;&#12515;&#12483;&#12495;&#22259;&#24418; : fx_rorschach, fx_rorschach
#@gui_ja : &#12473;&#12465;&#12540;&#12523; = float(3,0,10)
#@gui_ja : &#23550;&#31216;&#36600; = choice(1,"&#12394;&#12375;","X &#36600;","Y &#36600;","X &#36600;&#12392; Y &#36600;")
#@gui_ja : &#12473;&#12486;&#12531;&#12471;&#12523;&#12398;&#31278;&#39006; = choice(2,"&#30333;&#40658;","RGB","&#33394;&#20184;&#12365;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2011/03/12</i></small>")
#@gui_ja &#36855;&#24425; : fx_camouflage, fx_camouflage
#@gui_ja : &#12473;&#12465;&#12540;&#12523; = int(9,2,12)
#@gui_ja : Levels = int(12,2,32)
#@gui_ja : Coherence = float(100,0,1000)
#@gui_ja : &#33394; 1 = color(30,46,33)
#@gui_ja : &#33394; 2 = color(75,90,65)
#@gui_ja : &#33394; 3 = color(179,189,117)
#@gui_ja : &#33394; 4 = color(255,246,158)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2016/10/26</i></small>")
#@gui _
#@gui_ja <b>&#12501;&#12451;&#12523;&#12512;&#12456;&#12511;&#12517;&#12524;&#12540;&#12471;&#12519;&#12531;</b>
#@gui_ja &#12452;&#12531;&#12473;&#12479;&#12531;&#12488; [&#26989;&#21209;&#29992;] : fx_emulate_film_instant_pro, fx_emulate_film_instant_pro_preview(1)+
#@gui_ja : &#12503;&#12522;&#12475;&#12483;&#12488; = choice{"&#12394;&#12375;",
#@gui_ja : "FUJIFILM FP-100c --","FUJIFILM FP-100c -","FUJIFILM FP-100c","FUJIFILM FP-100c +","FUJIFILM FP-100c ++","FUJIFILM FP-100c ++a","FUJIFILM FP-100c +++",
#@gui_ja : "FUJIFILM FP-100c Cool --","FUJIFILM FP-100c Cool -","FUJIFILM FP-100c Cool","FUJIFILM FP-100c Cool +","FUJIFILM FP-100c Cool ++",
#@gui_ja : "FUJIFILM FP-100c Negative --","FUJIFILM FP-100c Negative -","FUJIFILM FP-100c Negative","FUJIFILM FP-100c Negative +","FUJIFILM FP-100c Negative ++","FUJIFILM FP-100c Negative ++a","FUJIFILM FP-100c Negative +++",
#@gui_ja : "FUJIFILM FP-3000b --","FUJIFILM FP-3000b -","FUJIFILM FP-3000b","FUJIFILM FP-3000b +","FUJIFILM FP-3000b ++","FUJIFILM FP-3000b +++",
#@gui_ja : "FUJIFILM FP-3000b HC",
#@gui_ja : "FUJIFILM FP-3000b Negative --","FUJIFILM FP-3000b Negative -","FUJIFILM FP-3000b Negative","FUJIFILM FP-3000b Negative +","FUJIFILM FP-3000b Negative ++","FUJIFILM FP-3000b Negative +++",
#@gui_ja : "FUJIFILM FP-3000b Negative Early",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 665 --","&#12509;&#12521;&#12525;&#12452;&#12489; 665 -","&#12509;&#12521;&#12525;&#12452;&#12489; 665","&#12509;&#12521;&#12525;&#12452;&#12489; 665 +","&#12509;&#12521;&#12525;&#12452;&#12489; 665 ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 665 Negative -","&#12509;&#12521;&#12525;&#12452;&#12489; 665 Negative","&#12509;&#12521;&#12525;&#12452;&#12489; 665 Negative +",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 665 Negative HC",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 669 --","&#12509;&#12521;&#12525;&#12452;&#12489; 669 -","&#12509;&#12521;&#12525;&#12452;&#12489; 669","&#12509;&#12521;&#12525;&#12452;&#12489; 669 +","&#12509;&#12521;&#12525;&#12452;&#12489; 669 ++","&#12509;&#12521;&#12525;&#12452;&#12489; 669 +++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 669 Cold --","&#12509;&#12521;&#12525;&#12452;&#12489; 669 Cold -","&#12509;&#12521;&#12525;&#12452;&#12489; 669 Cold","&#12509;&#12521;&#12525;&#12452;&#12489; 669 Cold +",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 690 --","&#12509;&#12521;&#12525;&#12452;&#12489; 690 -","&#12509;&#12521;&#12525;&#12452;&#12489; 690","&#12509;&#12521;&#12525;&#12452;&#12489; 690 +","&#12509;&#12521;&#12525;&#12452;&#12489; 690 ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 690 Cold --","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Cold -","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Cold","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Cold +","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Cold ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; 690 Warm --","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Warm -","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Warm","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Warm +","&#12509;&#12521;&#12525;&#12452;&#12489; 690 Warm ++"}
#@gui_ja : sep = separator()
#@gui_ja : &#19981;&#36879;&#26126;&#24230; = float(1,0,1)
#@gui_ja : &#12460;&#12531;&#12510; = float(0,-1.2,1.2)
#@gui_ja : &#12467;&#12531;&#12488;&#12521;&#12473;&#12488; = float(1,0,4)
#@gui_ja : &#36637;&#24230; = float(0,-255,255)
#@gui_ja : &#33394;&#30456; = float(0,-180,180)
#@gui_ja : &#24425;&#24230; = float(0,-1,1)
#@gui_ja : &#20107;&#21069;&#12395;&#27491;&#35215;&#21270; = bool(0)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small><b>&#27880;:</b> &#12371;&#12398;&#12475;&#12463;&#12471;&#12519;&#12531;&#12391;&#20351;&#29992;&#12373;&#12428;&#12390;&#12356;&#12427;&#12459;&#12521;&#12540; LUT &#12399; <b>Patrick David</b> &#12395;&#12424;&#12426;&#20316;&#25104;&#12373;&#12428;&#12414;&#12375;&#12383;&#12290;&#35443;&#32048;&#12399;&#20197;&#19979;&#12398; Web &#12506;&#12540;&#12472;&#12434;&#12372;&#35239;&#12367;&#12384;&#12373;&#12356;&#12290;</small>")
#@gui_ja : url = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i>Patrick David</i>&#12289;<i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2013/08/29</i></small>")
#@gui_ja &#12452;&#12531;&#12473;&#12479;&#12531;&#12488; [&#27665;&#29983;&#29992;] : fx_emulate_film_instant_consumer, fx_emulate_film_instant_consumer_preview(1)+
#@gui_ja : &#12503;&#12522;&#12475;&#12483;&#12488; = choice{"&#12394;&#12375;",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Cold --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Cold -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Cold","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Cold +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Cold ++","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Cold +++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Warm --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Warm -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Warm","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Warm +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Warm ++","&#12509;&#12521;&#12525;&#12452;&#12489; PX-100UV+ Warm +++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Cold --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Cold -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Cold","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Cold +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Cold ++","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Cold ++a",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Warm --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Warm -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Warm","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Warm +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-680 Warm ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 ++","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 +++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Cold --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Cold -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Cold","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Cold +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Cold ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Warm --","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Warm -","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Warm","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Warm +","&#12509;&#12521;&#12525;&#12452;&#12489; PX-70 Warm ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) ---","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) --","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) -","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;)","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) +","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) ++",
#@gui_ja : "&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) Cold ---","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) Cold --","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) Cold -","&#12509;&#12521;&#12525;&#12452;&#12489; Time Zero (&#32118;&#29256;) Cold"}
#@gui_ja : sep = separator()
#@gui_ja : &#19981;&#36879;&#26126;&#24230; = float(1,0,1)
#@gui_ja : &#12460;&#12531;&#12510; = float(0,-1.2,1.2)
#@gui_ja : &#12467;&#12531;&#12488;&#12521;&#12473;&#12488; = float(1,0,4)
#@gui_ja : &#36637;&#24230; = float(0,-255,255)
#@gui_ja : &#33394;&#30456; = float(0,-180,180)
#@gui_ja : &#24425;&#24230; = float(0,-1,1)
#@gui_ja : &#20107;&#21069;&#12395;&#27491;&#35215;&#21270; = bool(0)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small><b>&#27880;:</b> &#12371;&#12398;&#12475;&#12463;&#12471;&#12519;&#12531;&#12391;&#20351;&#29992;&#12373;&#12428;&#12390;&#12356;&#12427;&#12459;&#12521;&#12540; LUT &#12399; <b>Patrick David</b> &#12395;&#12424;&#12426;&#20316;&#25104;&#12373;&#12428;&#12414;&#12375;&#12383;&#12290;&#35443;&#32048;&#12399;&#20197;&#19979;&#12398; Web &#12506;&#12540;&#12472;&#12434;&#12372;&#35239;&#12367;&#12384;&#12373;&#12356;&#12290;</small>")
#@gui_ja : url = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i>Patrick David</i>&#12289;<i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2013/08/29</i></small>")
#@gui_ja &#12493;&#12460;&#12501;&#12451;&#12523;&#12512; [&#12459;&#12521;&#12540;] : fx_emulate_film_negative_color, fx_emulate_film_negative_color_preview(1)+
#@gui_ja : &#12503;&#12522;&#12475;&#12483;&#12488; = choice{"&#12394;&#12375;",
#@gui_ja : "Agfa Ultra Color 100","Agfa Vista 200","Fuji Superia 200","Fuji Superia HG 1600","Fuji Superia Reala 100","Fuji Superia X-Tra 800",
#@gui_ja : "Kodak Elite 100 XPRO","Kodak Elite Color 200","Kodak Elite Color 400","Kodak Portra 160 NC","Kodak Portra 160 VC","Lomography Redscale 100"}
#@gui_ja : sep = separator()
#@gui_ja : &#24375;&#12373; (%) = float(100,0,100)
#@gui_ja : &#36637;&#24230; (%) = float(0,-100,100)
#@gui_ja : &#12467;&#12531;&#12488;&#12521;&#12473;&#12488; (%) = float(0,-100,100)
#@gui_ja : &#12460;&#12531;&#12510; (%) = float(0,-100,100)
#@gui_ja : &#33394;&#30456; (%) = float(0,-100,100)
#@gui_ja : &#24425;&#24230; (%) = float(0,-100,100)
#@gui_ja : &#33394;&#12434;&#27491;&#35215;&#21270; = choice("&#28961;&#12375;","&#20966;&#29702;&#21069;","&#20966;&#29702;&#24460;","&#20001;&#26041;")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small><b>&#27880;:</b> &#12371;&#12398;&#12475;&#12463;&#12471;&#12519;&#12531;&#12391;&#20351;&#29992;&#12373;&#12428;&#12390;&#12356;&#12427;&#12459;&#12521;&#12540; LUT &#12399; <b>Patrick David</b> &#12395;&#12424;&#12426;&#20316;&#25104;&#12373;&#12428;&#12414;&#12375;&#12383;&#12290;&#35443;&#32048;&#12399;&#20197;&#19979;&#12398; Web &#12506;&#12540;&#12472;&#12434;&#12372;&#35239;&#12367;&#12384;&#12373;&#12356;&#12290;</small>")
#@gui_ja : url = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i>Patrick David</i>&#12289;<i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2016/08/02</i></small>")
#@gui _
#@gui_ja <b>&#12501;&#12524;&#12540;&#12512;</b>
#@gui_ja &#12501;&#12524;&#12540;&#12512; [&#12412;&#12363;&#12375;] : fx_frame_blur, fx_frame_blur(1)
#@gui_ja : &#27700;&#24179;&#12469;&#12452;&#12474; (%) = float(30,0,100)
#@gui_ja : &#22402;&#30452;&#12469;&#12452;&#12474; (%) = float(30,0,100)
#@gui_ja : sep = separator()
#@gui_ja : &#20999;&#12426;&#25244;&#12365; = float(0,0,100)
#@gui_ja : &#12412;&#12363;&#12375; = float(5,0,10)
#@gui_ja : &#20024;&#12415; = float(0,0,1)
#@gui_ja : &#12459;&#12521;&#12540;&#12496;&#12521;&#12531;&#12473;&#12434;&#35519;&#25972; = bool(0)
#@gui_ja : &#30528;&#33394; = color(128,128,128)
#@gui_ja : &#27491;&#35215;&#21270; = choice("&#12394;&#12375;","&#20280;&#24373;","&#24179;&#22343;&#21270;")
#@gui_ja : sep = separator()
#@gui_ja : &#36650;&#37101;&#32218;&#12398;&#12469;&#12452;&#12474; = float(5,0,50)
#@gui_ja : &#36650;&#37101;&#32218;&#12398;&#33394; = color(255,255,255)
#@gui_ja : &#24433;&#12398;&#20301;&#32622; (&#24038;&#21491;) = float(2,-10,10)
#@gui_ja : &#24433;&#12398;&#20301;&#32622; (&#19978;&#19979;) = float(2,-10,10)
#@gui_ja : &#24433;&#12398;&#12412;&#12363;&#12375; = float(1,0,5)
#@gui_ja : &#24433;&#12398;&#12467;&#12531;&#12488;&#12521;&#12473;&#12488; = float(0,0,100)
#@gui_ja : &#30011;&#20687;&#12398;&#20301;&#32622; (&#24038;&#21491;) = float(0.5,0,1)
#@gui_ja : &#30011;&#20687;&#12398;&#20301;&#32622; (&#19978;&#19979;) = float(0.5,0,1)
#@gui_ja : &#35282;&#24230; = float(0,-180,180)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2014/01/19</i></small>")
#@gui _
#@gui_ja <b>&#20462;&#24489;</b>
#@gui_ja &#12450;&#12483;&#12503;&#12473;&#12465;&#12540;&#12523; [Scale2x] : fx_scalenx, fx_scalenx_preview(0)
#@gui_ja : &#25313;&#22823;&#29575; = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gui_ja : &#33394;&#31354;&#38291; = choice(0,"RGB","YCbCr","Lab")
#@gui_ja : note = note{"\n<small><b>&#27880;: </b>
#@gui_ja : &#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12399;&#12289;&#20197;&#19979;&#12398; Web &#12469;&#12452;&#12488;&#12391;&#20844;&#38283;&#12373;&#12428;&#12390;&#12356;&#12427;&#30011;&#20687;&#25313;&#22823;&#12450;&#12523;&#12468;&#12522;&#12474;&#12512;&#12434;&#23455;&#35013;&#12375;&#12383;&#12418;&#12398;&#12391;&#12377;&#12290;
#@gui_ja : </small>"}
#@gui_ja : note = link("http://scale2x.sourceforge.net")
#@gui_ja : note = note{"<small>
#@gui_ja : &#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12399;&#12289;&#12452;&#12531;&#12487;&#12483;&#12463;&#12473;&#30011;&#20687;&#31561;&#12398;&#33394;&#25968;&#12398;&#23569;&#12394;&#12356;&#30011;&#20687;&#12398;&#12522;&#12469;&#12452;&#12474;&#12434;&#30446;&#30340;&#12392;&#12375;&#12383;&#12418;&#12398;&#12391;&#12377;&#12290;
#@gui_ja : &#12501;&#12523;&#12459;&#12521;&#12540;&#30011;&#20687;&#12395;&#23550;&#12375;&#12390;&#12398;&#20351;&#29992;&#12395;&#12399;&#22522;&#26412;&#30340;&#12395;&#36969;&#12375;&#12414;&#12379;&#12435;&#12290;
#@gui_ja : </small>"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#12452;&#12531;&#12479;&#12540;&#12524;&#12540;&#12473;&#38500;&#21435; : deinterlace, fx_deinterlace_preview(0)
#@gui_ja : &#12450;&#12523;&#12468;&#12522;&#12474;&#12512; = choice("&#27161;&#28310;","Motion-compensated")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#12507;&#12483;&#12488;&#12500;&#12463;&#12475;&#12523;&#38500;&#21435; : fx_remove_hotpixels, fx_remove_hotpixels_preview(0)
#@gui_ja : &#12510;&#12473;&#12463;&#12469;&#12452;&#12474; = int(3,3,20)
#@gui_ja : &#38334;&#20516; = float(10,0,200)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i>J&#233;rome Boulanger</i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#35036;&#20462; [&#12497;&#12483;&#12481;&#12505;&#12540;&#12473;] : fx_inpaint_patch, gui_no_preview
#@gui_ja : &#12497;&#12483;&#12481;&#12469;&#12452;&#12474; = _int(7,1,64)
#@gui_ja : &#21442;&#29031;&#12469;&#12452;&#12474; = _float(16,1,32)
#@gui_ja : &#21442;&#29031;&#22522;&#25968; = _float(0.1,0,1)
#@gui_ja : &#12412;&#12363;&#12375;&#12469;&#12452;&#12474; = _float(1.2,0,5)
#@gui_ja : &#12412;&#12363;&#12375;&#12375;&#12365;&#12356;&#20516; = _float(0,0,1)
#@gui_ja : &#12412;&#12363;&#12375;&#28187;&#34928; = _float(0.05,0,0.5)
#@gui_ja : &#12473;&#12465;&#12540;&#12523;&#12398;&#38542;&#23652;&#25968; = _int(10,1,20)
#@gui_ja : &#12510;&#12473;&#12463;&#22806;&#38936;&#22495;&#12398;&#12412;&#12363;&#12375;&#12434;&#35377;&#21487; = _bool(1)
#@gui_ja : &#12510;&#12473;&#12463;&#12398;&#33394; = _color(255,0,0,255)
#@gui_ja : &#12510;&#12473;&#12463;&#12434;&#24195;&#12370;&#12427; = _int(0,0,32)
#@gui_ja : sep = separator(), note = note("<small>&#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12398;&#35443;&#12375;&#12356;&#20351;&#12356;&#26041;&#12399;&#12371;&#12385;&#12425;&#12391;&#21442;&#29031;&#12391;&#12365;&#12414;&#12377;&#12290;</small>")
#@gui_ja : url = link{"Patrick David &#27663;&#12395;&#12424;&#12427;&#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12395;&#12388;&#12356;&#12390;&#12398;&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523; (&#33521;&#35486;)","http://blog.patdavid.net/2014/02/getting-around-in-gimp-gmic-inpainting.html"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>&#12289;<i>Maxime Daisy</i> &#26368;&#32066;&#26356;&#26032;: <i>2015/11/25</i></small>")
#@gui_ja &#35036;&#20462; [&#12510;&#12523;&#12481;&#12473;&#12465;&#12540;&#12523;] : fx_inpaint_matchpatch, fx_inpaint_matchpatch_preview
#@gui_ja : &#12473;&#12465;&#12540;&#12523;&#12398;&#38542;&#23652;&#25968; = _int(0,0,16)
#@gui_ja : note = note{"<small>(&#33258;&#21205;&#12391;&#35373;&#23450;&#12377;&#12427;&#12395;&#12399; <i>0</i> &#12434;&#20837;&#21147;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;)</small>"}
#@gui_ja : &#12497;&#12483;&#12481;&#12469;&#12452;&#12474; = _int(9,1,64)
#@gui_ja : &#12473;&#12465;&#12540;&#12523;&#12372;&#12392;&#12398;&#20966;&#29702;&#22238;&#25968; = _int(10,1,100)
#@gui_ja : &#12412;&#12363;&#12375;&#12469;&#12452;&#12474; = _int(5,0,32)
#@gui_ja : &#12510;&#12473;&#12463;&#22806;&#38936;&#22495;&#12398;&#12412;&#12363;&#12375;&#12434;&#35377;&#21487; = _bool(1)
#@gui_ja : &#12510;&#12473;&#12463;&#12398;&#33394; = _color(255,0,0,255)
#@gui_ja : &#12510;&#12473;&#12463;&#12434;&#24195;&#12370;&#12427; = _int(0,0,32)
#@gui_ja : sep = separator(), &#20966;&#29702;&#20013;&#12395;&#36914;&#25431;&#29366;&#27841;&#12434;&#12503;&#12524;&#12499;&#12517;&#12540; = _bool(0)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2015/11/25</i></small>")
#@gui_ja &#36879;&#26126;&#37096;&#20998;&#12434;&#22475;&#12417;&#12427; : fx_solidify_td, fx_solidify_td_preview(1)
#@gui_ja : &#12394;&#12417;&#12425;&#12363;&#12373; (%) = float(75,0,100)
#@gui_ja : &#27491;&#35215;&#21270; = choice(1,"&#31561;&#26041;&#24615;","Delaunay-oriented","Edge-oriented")
#@gui_ja : &#27491;&#35215;&#21270;&#12398;&#21453;&#24489;&#20966;&#29702; = int(20,0,100)
#@gui_ja : &#25313;&#24373; / &#21454;&#32302; = int(0,-20,20)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#27880;:</b>
#@gui_ja : &#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12399;&#12289;&#36664;&#36865;&#25313;&#25955;&#12450;&#12523;&#12468;&#12522;&#12474;&#12512;&#12434;&#20351;&#29992;&#12375;&#12390;&#30011;&#20687;&#12398;&#36879;&#26126;&#37096;&#20998;&#12434;&#20877;&#27083;&#25104;&#12375;&#12414;&#12377;&#12290;&#12450;&#12523;&#12501;&#12449;&#12481;&#12515;&#12531;&#12493;&#12523;&#12434;&#26377;&#12377;&#12427;&#30011;&#20687;&#12395;&#12398;&#12415;&#21177;&#26524;&#12364;&#12354;&#12426;&#12414;&#12377;&#12290;
#@gui_ja : </small>"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2016/04/07</i></small>")
#@gui_ja Iain &#24335;&#39640;&#36895;&#12494;&#12452;&#12474;&#38500;&#21435; : iain_fast_denoise_p,iain_fast_denoise_p_preview(0)
#@gui_ja : &#36637;&#24230; = float(0,0,3)
#@gui_ja : &#33394;&#24230; = float(0,0,3)
#@gui_ja : &#12460;&#12531;&#12510; = float (1,.5,3)
#@gui_ja : &#26001;&#28857;&#12494;&#12452;&#12474;&#38500;&#21435; = float(0,0,1)
#@gui_ja : &#20986;&#21147;&#32080;&#26524;&#12395;&#12487;&#12451;&#12470;&#12522;&#12531;&#12464;&#12434;&#12363;&#12369;&#12427; = bool(0)
#@gui_ja : &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034; = choice (0,"&#36890;&#24120;","&#36637;&#24230;&#12494;&#12452;&#12474;",  "&#33394;&#24230;&#12494;&#12452;&#12474;")
#@gui_ja : sep = separator ()
#@gui_ja : &#20006;&#21015;&#23455;&#34892; = choice(1,"&#12458;&#12501;","&#33258;&#21205;")
#@gui_ja : sep = separator()
#@gui_ja : note = note("&#12371;&#12398;&#12494;&#12452;&#12474;&#38500;&#21435;&#12501;&#12451;&#12523;&#12479;&#12399;&#39640;&#36895;&#21205;&#20316;&#12434;&#20877;&#20778;&#20808;&#12395;&#35373;&#35336;&#12373;&#12428;&#12390;&#12356;&#12414;&#12377;&#12290;&#30011;&#20687;&#12398;&#12487;&#12451;&#12486;&#12540;&#12523;&#12399;&#25613;&#12394;&#12431;&#12428;&#12427;&#22580;&#21512;&#12364;&#12354;&#12426;&#12414;&#12377;&#12290;")
#@gui_ja : sep = separator ()
#@gui_ja : note = note("<small>&#20316;&#32773;: Iain Fergusson</small>")
#@gui_ja : note = note("<small>&#26356;&#26032; 2015/3/28 - &#30011;&#20687;&#12398;&#20081;&#12428;&#12434;&#35299;&#28040;&#12377;&#12427;&#12383;&#12417;&#12395;&#20006;&#21015;&#23455;&#34892;&#26178;&#12398;&#12458;&#12540;&#12496;&#12540;&#12521;&#12483;&#12503;&#37096;&#20998;&#12434;&#25313;&#22823;</small>")
#@gui_ja : note = note("<small>&#26356;&#26032; 2013/10/26 - &#20006;&#21015;&#23455;&#34892;</small>")
#@gui_ja : note = note("<small>&#12522;&#12522;&#12540;&#12473; 2013/2/22</small>")
#@gui _
#@gui_ja <b>&#20809;&#12392;&#24433;</b>
#@gui_ja &#12521;&#12452;&#12488;&#12522;&#12540;&#12463; : fx_light_leaks, fx_light_leaks_preview(1)
#@gui_ja : &#12521;&#12452;&#12488;&#12522;&#12540;&#12463;&#12398;&#31278;&#39006; = int(0,0,70)
#@gui_ja : &#35282;&#24230; = float(0,-180,180)
#@gui_ja : X &#26041;&#21521;&#12398;&#12473;&#12465;&#12540;&#12523; = float(1,1,10)
#@gui_ja : Y &#26041;&#21521;&#12398;&#12473;&#12465;&#12540;&#12523; = float(1,1,10)
#@gui_ja : &#33394;&#30456; = float(0,-180,180)
#@gui_ja : &#19981;&#36879;&#26126;&#24230; = float(0.85,0,1)
#@gui_ja : &#21512;&#25104;&#12514;&#12540;&#12489; = choice(2,"&#27161;&#28310;","&#26126;&#12427;&#12367;&#12377;&#12427;","&#12473;&#12463;&#12522;&#12540;&#12531;","&#35206;&#12356;&#28988;&#12365;","&#21152;&#31639;","&#26263;&#12367;&#12377;&#12427;","&#20055;&#31639;","&#28988;&#12365;&#36796;&#12415;","&#12458;&#12540;&#12496;&#12540;&#12524;&#12452;","&#12477;&#12501;&#12488;&#12521;&#12452;&#12488;","&#12495;&#12540;&#12489;&#12521;&#12452;&#12488;","&#24046;&#20998;","&#28187;&#31639;","&#24494;&#31890;&#21462;&#12426;&#20986;&#12375;","&#24494;&#31890;&#32080;&#21512;","&#38500;&#31639;","&#33394;&#30456;","&#24425;&#24230;","&#26126;&#24230;")
#@gui_ja : &#21029;&#12398;&#12524;&#12452;&#12516;&#12540;&#12395;&#20986;&#21147; = _bool(1)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note{"<small>&#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12399;&#12289;&#20197;&#19979;&#12398;&#12522;&#12531;&#12463;&#20808;&#12391;&#25552;&#20379;&#12373;&#12428;&#12390;&#12356;&#12427;&#12521;&#12452;&#12488;&#12522;&#12540;&#12463;&#29992;&#12501;&#12522;&#12540;&#32032;&#26448;&#12434;&#20351;&#29992;&#12375;&#12390;&#12356;&#12414;&#12377;&#12290;</small>"}
#@gui_ja : url = link{"Lomo Light Leaks","http://www.photoshoptutorials.ws/downloads/mockups-graphics/lomo-light-leaks/"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2015/07/01</i></small>")
#@gui _
#@gui_ja <b>&#21155;&#21270;</b>
#@gui_ja &#12412;&#12363;&#12375; [&#12460;&#12454;&#12473;] : fx_gaussian_blur, fx_gaussian_blur_preview(0)
#@gui_ja : &#22823;&#12365;&#12373; (X&#12289;Y) = float(3,0,20)
#@gui_ja : &#22823;&#12365;&#12373; (X) = float(0,0,20)
#@gui_ja : &#22823;&#12365;&#12373; (Y) = float(0,0,20)
#@gui_ja : &#30011;&#20687;&#31471;&#12391;&#12398;&#20966;&#29702; = choice(1,"&#40658;&#12434;&#20351;&#29992;","&#26368;&#12418;&#36817;&#12356;&#12500;&#12463;&#12475;&#12523;&#12398;&#33394;&#12434;&#20351;&#29992;")
#@gui_ja : sep = separator(), &#12481;&#12515;&#12531;&#12493;&#12523; = choice("&#12377;&#12409;&#12390;","RGBA [&#12377;&#12409;&#12390;]","RGB [&#12377;&#12409;&#12390;]","RGB [&#36196;]","RGB [&#32209;]","RGB [&#38738;]","RGBA [&#12450;&#12523;&#12501;&#12449;]","&#12522;&#12491;&#12450; RGB [&#12377;&#12409;&#12390;]","&#12522;&#12491;&#12450; RGB [&#36196;]","&#12522;&#12491;&#12450; RGB [&#32209;]","&#12522;&#12491;&#12450; RGB [&#38738;]","YCbCr [&#36637;&#24230;]","YCbCr [&#33394;&#24230;&#12289;&#38738;-&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#38738;]","YCbCr [&#33394;&#24230;&#12289;&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#32209;]","Lab [&#26126;&#24230;]","Lab [&#33394;&#24230;&#12289;ab]","Lab [&#33394;&#24230;&#12289;a]","Lab [&#33394;&#24230;&#12289;b]","Lch [&#33394;&#24230;&#12289;ch]","Lch [&#33394;&#24230;&#12289;c]","Lch [&#33394;&#24230;&#12289;h]","HSV [&#33394;&#30456;]","HSV [&#24425;&#24230;]","HSV [&#26126;&#24230;]","HSI [&#36637;&#24230;]","HSL [&#26126;&#24230;]","CMYK [&#12471;&#12450;&#12531;]","CMYK [&#12510;&#12476;&#12531;&#12479;]","CMYK [&#12452;&#12456;&#12525;&#12540;]","CMYK [&#12461;&#12540;]","YIQ [&#36637;&#24230;]","YIQ [&#33394;&#24230;]")
#@gui_ja : &#31684;&#22258;&#22806;&#12398;&#20516;&#12398;&#20966;&#29702; = choice("&#20309;&#12418;&#12375;&#12394;&#12356;","&#20999;&#12426;&#25448;&#12390;","&#27491;&#35215;&#21270;")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#12412;&#12363;&#12375; [&#12464;&#12525;&#12540;] : fx_glow, fx_glow_preview(0)
#@gui_ja : &#22823;&#12365;&#12373; = float(6,0,20)
#@gui_ja : sep = separator(), &#12481;&#12515;&#12531;&#12493;&#12523; = choice(7,"&#12377;&#12409;&#12390;","RGBA [&#12377;&#12409;&#12390;]","RGB [&#12377;&#12409;&#12390;]","RGB [&#36196;]","RGB [&#32209;]","RGB [&#38738;]","RGBA [&#12450;&#12523;&#12501;&#12449;]","&#12522;&#12491;&#12450; RGB [&#12377;&#12409;&#12390;]","&#12522;&#12491;&#12450; RGB [&#36196;]","&#12522;&#12491;&#12450; RGB [&#32209;]","&#12522;&#12491;&#12450; RGB [&#38738;]","YCbCr [&#36637;&#24230;]","YCbCr [&#33394;&#24230;&#12289;&#38738;-&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#38738;]","YCbCr [&#33394;&#24230;&#12289;&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#32209;]","Lab [&#26126;&#24230;]","Lab [&#33394;&#24230;&#12289;ab]","Lab [&#33394;&#24230;&#12289;a]","Lab [&#33394;&#24230;&#12289;b]","Lch [&#33394;&#24230;&#12289;ch]","Lch [&#33394;&#24230;&#12289;c]","Lch [&#33394;&#24230;&#12289;h]","HSV [&#33394;&#30456;]","HSV [&#24425;&#24230;]","HSV [&#26126;&#24230;]","HSI [&#36637;&#24230;]","HSL [&#26126;&#24230;]","CMYK [&#12471;&#12450;&#12531;]","CMYK [&#12510;&#12476;&#12531;&#12479;]","CMYK [&#12452;&#12456;&#12525;&#12540;]","CMYK [&#12461;&#12540;]","YIQ [&#36637;&#24230;]","YIQ [&#33394;&#24230;]")
#@gui_ja : &#31684;&#22258;&#22806;&#12398;&#20516;&#12398;&#20966;&#29702; = choice("&#20309;&#12418;&#12375;&#12394;&#12356;","&#20999;&#12426;&#25448;&#12390;","&#27491;&#35215;&#21270;")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#12412;&#12363;&#12375; [&#22238;&#36578;] : fx_blur_angular, fx_blur_angular_preview(1)
#@gui_ja : &#22823;&#12365;&#12373; = float(2,0,10)
#@gui_ja : X &#36600;&#26041;&#21521;&#12398;&#20013;&#24515; (%) = float(50,0,100)
#@gui_ja : Y &#36600;&#26041;&#21521;&#12398;&#20013;&#24515; (%) = float(50,0,100)
#@gui_ja : &#12471;&#12515;&#12540;&#12503;&#12493;&#12473; = float(0,0,500)
#@gui_ja : &#12460;&#12452;&#12489;&#12434;&#12503;&#12524;&#12499;&#12517;&#12540;&#12395;&#34920;&#31034; = bool(1)
#@gui_ja : sep = separator(), &#12481;&#12515;&#12531;&#12493;&#12523; = choice(7,"&#12377;&#12409;&#12390;","RGBA [&#12377;&#12409;&#12390;]","RGB [&#12377;&#12409;&#12390;]","RGB [&#36196;]","RGB [&#32209;]","RGB [&#38738;]","RGBA [&#12450;&#12523;&#12501;&#12449;]","&#12522;&#12491;&#12450; RGB [&#12377;&#12409;&#12390;]","&#12522;&#12491;&#12450; RGB [&#36196;]","&#12522;&#12491;&#12450; RGB [&#32209;]","&#12522;&#12491;&#12450; RGB [&#38738;]","YCbCr [&#36637;&#24230;]","YCbCr [&#33394;&#24230;&#12289;&#38738;-&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#38738;]","YCbCr [&#33394;&#24230;&#12289;&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#32209;]","Lab [&#26126;&#24230;]","Lab [&#33394;&#24230;&#12289;ab]","Lab [&#33394;&#24230;&#12289;a]","Lab [&#33394;&#24230;&#12289;b]","Lch [&#33394;&#24230;&#12289;ch]","Lch [&#33394;&#24230;&#12289;c]","Lch [&#33394;&#24230;&#12289;h]","HSV [&#33394;&#30456;]","HSV [&#24425;&#24230;]","HSV [&#26126;&#24230;]","HSI [&#36637;&#24230;]","HSL [&#26126;&#24230;]","CMYK [&#12471;&#12450;&#12531;]","CMYK [&#12510;&#12476;&#12531;&#12479;]","CMYK [&#12452;&#12456;&#12525;&#12540;]","CMYK [&#12461;&#12540;]","YIQ [&#36637;&#24230;]","YIQ [&#33394;&#24230;]")
#@gui_ja : &#31684;&#22258;&#22806;&#12398;&#20516;&#12398;&#20966;&#29702; = choice("&#20309;&#12418;&#12375;&#12394;&#12356;","&#20999;&#12426;&#25448;&#12390;","&#27491;&#35215;&#21270;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2015/1/16</i></small>")
#@gui_ja &#12412;&#12363;&#12375; [&#25918;&#23556;&#29366;] : fx_blur_radial, fx_blur_radial_preview(1)
#@gui_ja : &#22823;&#12365;&#12373; = float(3,0,20)
#@gui_ja : X &#36600;&#26041;&#21521;&#12398;&#20013;&#24515; (%) = float(50,0,100)
#@gui_ja : Y &#36600;&#26041;&#21521;&#12398;&#20013;&#24515; (%) = float(50,0,100)
#@gui_ja : &#12471;&#12515;&#12540;&#12503;&#12493;&#12473; = float(0,0,500)
#@gui_ja : &#12460;&#12452;&#12489;&#12434;&#12503;&#12524;&#12499;&#12517;&#12540;&#12395;&#34920;&#31034; = bool(1)
#@gui_ja : sep = separator(), &#12481;&#12515;&#12531;&#12493;&#12523; = choice(7,"&#12377;&#12409;&#12390;","RGBA [&#12377;&#12409;&#12390;]","RGB [&#12377;&#12409;&#12390;]","RGB [&#36196;]","RGB [&#32209;]","RGB [&#38738;]","RGBA [&#12450;&#12523;&#12501;&#12449;]","&#12522;&#12491;&#12450; RGB [&#12377;&#12409;&#12390;]","&#12522;&#12491;&#12450; RGB [&#36196;]","&#12522;&#12491;&#12450; RGB [&#32209;]","&#12522;&#12491;&#12450; RGB [&#38738;]","YCbCr [&#36637;&#24230;]","YCbCr [&#33394;&#24230;&#12289;&#38738;-&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#38738;]","YCbCr [&#33394;&#24230;&#12289;&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#32209;]","Lab [&#26126;&#24230;]","Lab [&#33394;&#24230;&#12289;ab]","Lab [&#33394;&#24230;&#12289;a]","Lab [&#33394;&#24230;&#12289;b]","Lch [&#33394;&#24230;&#12289;ch]","Lch [&#33394;&#24230;&#12289;c]","Lch [&#33394;&#24230;&#12289;h]","HSV [&#33394;&#30456;]","HSV [&#24425;&#24230;]","HSV [&#26126;&#24230;]","HSI [&#36637;&#24230;]","HSL [&#26126;&#24230;]","CMYK [&#12471;&#12450;&#12531;]","CMYK [&#12510;&#12476;&#12531;&#12479;]","CMYK [&#12452;&#12456;&#12525;&#12540;]","CMYK [&#12461;&#12540;]","YIQ [&#36637;&#24230;]","YIQ [&#33394;&#24230;]")
#@gui_ja : &#31684;&#22258;&#22806;&#12398;&#20516;&#12398;&#20966;&#29702; = choice("&#20309;&#12418;&#12375;&#12394;&#12356;","&#20999;&#12426;&#25448;&#12390;","&#27491;&#35215;&#21270;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2015/1/16</i></small>")
#@gui_ja &#12412;&#12363;&#12375; [&#32218;&#24418;] : fx_blur_linear, fx_blur_linear_preview(1)
#@gui_ja : &#24179;&#34892;&#26041;&#21521;&#12398;&#21322;&#24452; = float(10,0,100)
#@gui_ja : &#30452;&#20132;&#26041;&#21521;&#12398;&#21322;&#24452; = float(0.5,0,100)
#@gui_ja : &#35282;&#24230; = float(0,0,180)
#@gui_ja : &#12471;&#12515;&#12540;&#12503;&#12493;&#12473; = float(0,0,500)
#@gui_ja : &#30011;&#20687;&#31471;&#12391;&#12398;&#20966;&#29702; = choice(1,"&#40658;&#12434;&#20351;&#29992;","&#26368;&#12418;&#36817;&#12356;&#12500;&#12463;&#12475;&#12523;&#12398;&#33394;&#12434;&#20351;&#29992;")
#@gui_ja : sep = separator(), &#12481;&#12515;&#12531;&#12493;&#12523; = choice(7,"&#12377;&#12409;&#12390;","RGBA [&#12377;&#12409;&#12390;]","RGB [&#12377;&#12409;&#12390;]","RGB [&#36196;]","RGB [&#32209;]","RGB [&#38738;]","RGBA [&#12450;&#12523;&#12501;&#12449;]","&#12522;&#12491;&#12450; RGB [&#12377;&#12409;&#12390;]","&#12522;&#12491;&#12450; RGB [&#36196;]","&#12522;&#12491;&#12450; RGB [&#32209;]","&#12522;&#12491;&#12450; RGB [&#38738;]","YCbCr [&#36637;&#24230;]","YCbCr [&#33394;&#24230;&#12289;&#38738;-&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#38738;]","YCbCr [&#33394;&#24230;&#12289;&#36196;]","YCbCr [&#33394;&#24230;&#12289;&#32209;]","Lab [&#26126;&#24230;]","Lab [&#33394;&#24230;&#12289;ab]","Lab [&#33394;&#24230;&#12289;a]","Lab [&#33394;&#24230;&#12289;b]","Lch [&#33394;&#24230;&#12289;ch]","Lch [&#33394;&#24230;&#12289;c]","Lch [&#33394;&#24230;&#12289;h]","HSV [&#33394;&#30456;]","HSV [&#24425;&#24230;]","HSV [&#26126;&#24230;]","HSI [&#36637;&#24230;]","HSL [&#26126;&#24230;]","CMYK [&#12471;&#12450;&#12531;]","CMYK [&#12510;&#12476;&#12531;&#12479;]","CMYK [&#12452;&#12456;&#12525;&#12540;]","CMYK [&#12461;&#12540;]","YIQ [&#36637;&#24230;]","YIQ [&#33394;&#24230;]")
#@gui_ja : &#31684;&#22258;&#22806;&#12398;&#20516;&#12398;&#20966;&#29702; = choice("&#20309;&#12418;&#12375;&#12394;&#12356;","&#20999;&#12426;&#25448;&#12390;","&#27491;&#35215;&#21270;")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#12412;&#12363;&#12375; [&#34987;&#20889;&#30028;&#28145;&#24230;] : fx_blur_dof, fx_blur_dof_preview(1)
#@gui_ja : &#22823;&#12365;&#12373; = float(3,0,20)
#@gui_ja : &#31934;&#24230; = int(16,2,64)
#@gui_ja : &#34987;&#20889;&#30028;&#28145;&#24230;&#12398;&#31278;&#39006; = choice{"&#12460;&#12454;&#12473;","&#12518;&#12540;&#12470;&#12540;&#23450;&#32681; (&#26368;&#32972;&#38754;&#12398;&#12524;&#12452;&#12516;&#12540;)"}
#@gui_ja : &#12412;&#12363;&#12375;&#12434;&#21453;&#36578; = bool(0)
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#34987;&#20889;&#30028;&#28145;&#24230; (&#12460;&#12454;&#12473;):</b></small>"}
#@gui_ja : X &#36600;&#26041;&#21521;&#12398;&#20013;&#24515; = float(50,0,100)
#@gui_ja : Y &#36600;&#26041;&#21521;&#12398;&#20013;&#24515; = float(50,0,100)
#@gui_ja : &#21322;&#24452; 1 = float(30,0,200)
#@gui_ja : &#21322;&#24452; 2 = float(30,0,200)
#@gui_ja : &#35282;&#24230; = float(0,0,180)
#@gui_ja : &#12471;&#12515;&#12540;&#12503;&#12493;&#12473; = float(1,0,8)
#@gui_ja : &#12460;&#12452;&#12489;&#12434;&#12503;&#12524;&#12499;&#12517;&#12540;&#12395;&#34920;&#31034; = bool(1)
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#34987;&#20889;&#30028;&#28145;&#24230; (&#12518;&#12540;&#12470;&#12540;&#23450;&#32681;):</b></small>"}
#@gui_ja : &#12460;&#12531;&#12510; = float(0,-2,2)
#@gui_ja : note = note("<small>&#21508;&#12500;&#12463;&#12475;&#12523;&#12398;&#28145;&#24230;&#12434;&#36637;&#24230;&#12391;&#34920;&#12375;&#12383;&#28145;&#24230;&#12510;&#12483;&#12503;&#30011;&#20687;&#12434;<b>&#26368;&#32972;&#38754;</b>&#12398;&#12524;&#12452;&#12516;&#12540;&#12395;&#37197;&#32622;&#12377;&#12427;&#12371;&#12392;&#12391;&#12501;&#12451;&#12523;&#12479;&#12395;&#20837;&#21147;&#12391;&#12365;&#12414;&#12377;&#12290;
#@gui_ja : &#12300;<b>&#20837;&#21147;&#12524;&#12452;&#12516;&#12540;</b>&#12301;&#12467;&#12531;&#12508;&#12508;&#12483;&#12463;&#12473;&#12391;&#12524;&#12452;&#12516;&#12540;&#12434;&#26377;&#21177;&#21270;&#12377;&#12427;&#12398;&#12434;&#12362;&#24536;&#12428;&#12394;&#12367;&#12290;</small>")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2014/02/25</i></small>")
#@gui_ja &#33394;&#21454;&#24046; : fx_chromatic_aberrations, fx_chromatic_aberrations_preview(0)
#@gui_ja : &#31532; 1 &#33394; = color(255,0,0)
#@gui_ja : X &#36600;&#12471;&#12501;&#12488; = float(2,-16,16)
#@gui_ja : Y &#36600;&#12471;&#12501;&#12488; = float(2,-16,16)
#@gui_ja : sep = separator()
#@gui_ja : &#31532; 2 &#33394; = color(0,255,0)
#@gui_ja : X &#36600;&#12471;&#12501;&#12488; (px) = float(0,-16,16)
#@gui_ja : Y &#36600;&#12471;&#12501;&#12488; (px) = float(0,-16,16)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2015/07/05</i></small>")
#@gui_ja LOMO &#39080; : fx_lomo, fx_lomo_preview(1)
#@gui_ja : &#12499;&#12493;&#12483;&#12488;&#21177;&#26524;&#12398;&#22823;&#12365;&#12373; = float(20,0,100)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i>J&#233;rome Boulanger</i>&#12289;<i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>06/06/2012</i></small>")
#@gui _
#@gui_ja <b>&#22793;&#24418;</b>
#@gui_ja &#12524;&#12531;&#12474;&#27498;&#12415; : fx_distort_lens, fx_distort_lens_preview(1)
#@gui_ja : &#24375;&#24230; = float(0.1,-1,1)
#@gui_ja : &#12450;&#12473;&#12506;&#12463;&#12488;&#27604; = float(0,-2,2)
#@gui_ja : &#12474;&#12540;&#12512; = float(0,-4,4)
#@gui_ja : X &#26041;&#21521;&#12398;&#20013;&#24515; (%) = float(50,0,100)
#@gui_ja : Y &#26041;&#21521;&#12398;&#20013;&#24515; (%) = float(50,0,100)
#@gui_ja : &#30011;&#20687;&#12398;&#22806;&#20596; = choice(0,"&#36879;&#26126;","&#26368;&#36817;&#20621;","&#32368;&#12426;&#36820;&#12375;","&#21453;&#36578;")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2017/02/18</i></small>")
#@gui_ja &#27491;&#36317;&#20870;&#31570;&#22259;&#27861;&#30011;&#20687;&#12363;&#12425;&#22825;&#38914;&#12539;&#22825;&#24213;&#12434;&#29983;&#25104; : fx_equirectangular2nadirzenith, fx_equirectangular2nadirzenith(1)
#@gui_ja : &#12514;&#12540;&#12489; = choice{"&#22825;&#38914;&#12539;&#22825;&#24213;&#12434;&#29983;&#25104;","&#27491;&#36317;&#20870;&#31570;&#22259;&#27861;&#12395;&#25147;&#12377;"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2015/12/29</i></small>")
#@gui _
#@gui_ja <b>&#25551;&#30011;</b>
#@gui_ja &#12461;&#12517;&#12540;&#12500;&#12483;&#12489; : fx_cupid, fx_cupid
#@gui_ja : &#12412;&#12363;&#12375; = float(0,0,10)
#@gui_ja : &#33394; = color(255,0,0,255)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2013/11/13</i></small>")
#@gui_ja &#12464;&#12521;&#12487;&#12540;&#12471;&#12519;&#12531; [&#22235;&#38533;] : fx_corner_gradient, fx_corner_gradient
#@gui_ja : &#33394; 1 (&#24038;&#19978;) = color(255,255,255,128)
#@gui_ja : &#33394; 2 (&#21491;&#19978;) = color(255,0,0,255)
#@gui_ja : &#33394; 3 (&#24038;&#19979;) = color(0,255,0,255)
#@gui_ja : &#33394; 4 (&#21491;&#19979;) = color(0,0,255,255)
#@gui_ja : sep = separator(), &#33394;&#31354;&#38291; = choice(1,"sRGB","Linear RGB","Lab")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#12471;&#12455;&#12523;&#12500;&#12531;&#12473;&#12461;&#12540;&#12398;&#19977;&#35282;&#24418; : fx_sierpinski, fx_sierpinski(1)
#@gui_ja : &#21453;&#24489; = int(6,0,10)
#@gui_ja : &#31532; 1 &#38914;&#28857;&#12398; X &#24231;&#27161; = float(50,0,100)
#@gui_ja : &#31532; 1 &#38914;&#28857;&#12398; Y &#24231;&#27161; = float(0,0,100)
#@gui_ja : &#31532; 2 &#38914;&#28857;&#12398; X &#24231;&#27161; = float(0,0,100)
#@gui_ja : &#31532; 2 &#38914;&#28857;&#12398; Y &#24231;&#27161; = float(100,0,100)
#@gui_ja : &#31532; 3 &#38914;&#28857;&#12398; X &#24231;&#27161; = float(100,0,100)
#@gui_ja : &#31532; 3 &#38914;&#28857;&#12398; Y &#24231;&#27161; = float(100,0,100)
#@gui_ja : &#33394; = color(128,128,128)
#@gui_ja : &#19981;&#36879;&#26126;&#24230; = float(1,0,1)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#12495;&#12540;&#12488;&#12510;&#12540;&#12463; : fx_heart, fx_heart_preview
#@gui_ja : &#12469;&#12452;&#12474; = float(75,0,100)
#@gui_ja : &#12412;&#12363;&#12375; = float(0,0,10)
#@gui_ja : &#33394; = color(255,0,0,255)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2013/11/13</i></small>")
#@gui_ja &#12496;&#12540;&#12531;&#12473;&#12524;&#12452;&#12398;&#12471;&#12480; : fx_barnsley_fern, fx_barnsley_fern_preview(1)
#@gui_ja : &#31278;&#39006; = choice("Asplenium adiantum-nigrum","Thelypteridaceae")
#@gui_ja : &#23494;&#24230; (%) = float(100,0,300)
#@gui_ja : &#35282;&#24230; = float(30,-180,180)
#@gui_ja : &#19981;&#36879;&#26126;&#24230; (%) = float(40,0,100)
#@gui_ja : &#33394; = color(10,178,0,255)
#@gui_ja : &#26032;&#12375;&#12356;&#12524;&#12452;&#12516;&#12540;&#12395;&#20986;&#21147; = _bool(1)
#@gui_ja : sep = separator()
#@gui_ja : note = note("&#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12399;&#12302;&#12496;&#12540;&#12531;&#12473;&#12524;&#12452;&#12398;&#12471;&#12480; (Barnsley fern)&#12303;&#12392;&#21628;&#12400;&#12428;&#12427;&#12501;&#12521;&#12463;&#12479;&#12523;&#22259;&#24418;&#12434;&#25551;&#30011;&#12375;&#12414;&#12377;&#12290;")
#@gui_ja : url = link("https://en.wikipedia.org/wiki/Barnsley_fern")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2016/10/18</i></small>")
#@gui_ja &#12508;&#12540;&#12523; : fx_ball, fx_ball_preview(0)
#@gui_ja : &#21322;&#24452; = int(128,1,1024)
#@gui_ja : &#20809;&#27810;&#12398;&#26126;&#12427;&#12373; = float(0.8,0,8)
#@gui_ja : &#20809;&#27810;&#12398;&#12469;&#12452;&#12474; = float(1,0,8)
#@gui_ja : &#38512;&#24433; = float(1.5,0,4)
#@gui_ja : &#33394; = color(255,0,255)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2013/11/27</i></small>")
#@gui_ja &#26041;&#31243;&#24335;&#12503;&#12525;&#12483;&#12488; [&#12497;&#12521;&#12513;&#12488;&#12522;&#12483;&#12463;] : fx_equation_parametric, fx_equation_parametric
#@gui_ja : X(t) = text{"sin(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gui_ja : Y(t) = text{"cos(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gui_ja : Min-t = float(0,-1000,1000)
#@gui_ja : Max-t = float(100,-1000,1000)
#@gui_ja : &#35299;&#20687;&#24230; = int(4096,2,32768)
#@gui_ja : Outline Opacity = float(1,0,1)
#@gui_ja : Dot Size = int(0,0,16)
#@gui_ja : &#38283;&#22987;&#33394; = color(64,0,0)
#@gui_ja : &#32066;&#20102;&#33394; = color(128,0,0)
#@gui_ja : Colored Outline = bool(1)
#@gui_ja : &#12450;&#12531;&#12481;&#12456;&#12452;&#12522;&#12450;&#12473; = bool(1)
#@gui_ja : Decoration = bool(1)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2013/11/13</i></small>")
#@gui_ja &#34425; : fx_rainbow, fx_rainbow
#@gui_ja : &#24038;&#31471;&#12398;&#20301;&#32622; = float(80,0,100)
#@gui_ja : &#21491;&#31471;&#12398;&#20301;&#32622; = float(80,0,100)
#@gui_ja : &#24038;&#20596;&#12398;&#20670;&#12365; = float(175,0,400)
#@gui_ja : &#21491;&#20596;&#12398;&#20670;&#12365; = float(175,0,400)
#@gui_ja : &#32048;&#12373; = float(3,0.1,8)
#@gui_ja : &#19981;&#36879;&#26126;&#24230; = float(80,0,199)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#38634;&#29255; : fx_snowflake, fx_snowflake(1)
#@gui_ja : &#21453;&#24489; = int(5,0,6)
#@gui_ja : &#19981;&#36879;&#26126;&#24230; = float(1,0,1)
#@gui_ja : &#33394; = color(255,255,255)
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja 3D &#25276;&#12375;&#20986;&#12375; : fx_extrude3d, fx_extrude3d_preview(1)
#@gui_ja : &#22885;&#34892;&#12365; = float(10,1,1024)
#@gui_ja : &#35299;&#20687;&#24230; = int(512,1,1024)
#@gui_ja : &#20024;&#12415; = float(0.6,0,3)
#@gui_ja : sep = separator()
#@gui_ja : &#24133; = _int(1024,1,4096)
#@gui_ja : &#39640;&#12373; = _int(1024,1,4096)
#@gui_ja : &#12469;&#12452;&#12474; = float(0.5,0,3)
#@gui_ja : X &#35282;&#24230; = float(57,0,360)
#@gui_ja : Y &#35282;&#24230; = float(41,0,360)
#@gui_ja : Z &#35282;&#24230; = float(21,0,360)
#@gui_ja : &#12497;&#12540;&#12473; = float(45,1,90)
#@gui_ja : &#20809;&#28304;&#20301;&#32622; X = float(0,-100,100)
#@gui_ja : &#20809;&#28304;&#20301;&#32622; Y = float(0,-100,100)
#@gui_ja : &#20809;&#28304;&#20301;&#32622; Z = float(-100,-100,0)
#@gui_ja : &#20809;&#27810;&#12398;&#22823;&#12365;&#12373; = float(0.5,0,1)
#@gui_ja : &#20809;&#27810;&#12398;&#24375;&#12373; = float(0.7,0,3)
#@gui_ja : &#12524;&#12531;&#12480;&#12522;&#12531;&#12464;&#26041;&#27861; = choice(4,"&#38914;&#28857;","&#12527;&#12452;&#12516;&#12540;&#12501;&#12524;&#12540;&#12512;","&#21336;&#33394;","&#12501;&#12521;&#12483;&#12488;&#12471;&#12455;&#12540;&#12487;&#12451;&#12531;&#12464;","&#12464;&#12540;&#12525;&#12540;&#12471;&#12455;&#12540;&#12487;&#12451;&#12531;&#12464;","&#12501;&#12457;&#12531;&#12471;&#12455;&#12540;&#12487;&#12451;&#12531;&#12464;")
#@gui_ja : &#12450;&#12531;&#12481;&#12456;&#12452;&#12522;&#12450;&#12471;&#12531;&#12464; = bool(1)
#@gui_ja : sep = separator(), note = note{"<small><b>&#27880;:</b> &#26368;&#21069;&#38754;&#12398;&#12524;&#12452;&#12516;&#12540;&#12434;&#12486;&#12463;&#12473;&#12481;&#12515;&#12392;&#12375;&#12390;&#20351;&#29992;&#12391;&#12365;&#12414;&#12377;&#12290;</small>"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui _
#@gui_ja <b>&#30333;&#40658;&#30011;&#20687;&#32232;&#38598;</b>
#@gui_ja &#24425;&#33394; [&#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;] : fx_colorize_interactive, fx_colorize_interactive_preview
#@gui_ja : &#20837;&#21147;&#12479;&#12452;&#12503; = _choice("&#30333;&#40658;&#20889;&#30495;","&#32218;&#30011;")
#@gui_ja : &#20986;&#21147;&#12479;&#12452;&#12503; = _choice{"&#24425;&#33394;&#28168;&#12415;&#30011;&#20687; (1 &#12524;&#12452;&#12516;&#12540;)","&#33394;&#12398;&#12415; (1 &#12524;&#12452;&#12516;&#12540;)","&#30011;&#20687; + &#33394; (2 &#12524;&#12452;&#12516;&#12540;)","&#30011;&#20687; + &#33394; (&#35079;&#25968;&#12524;&#12452;&#12516;&#12540;)"}
#@gui_ja : &#34920;&#31034;&#35299;&#20687;&#24230; = _choice{1,"&#23567; (&#39640;&#36895;)","&#20013;","&#22823; (&#20302;&#36895;)","&#26368;&#22823; (&#26368;&#20302;&#36895;)"}
#@gui_ja : &#36861;&#21152;&#12497;&#12524;&#12483;&#12488; 1 (.gpl &#12501;&#12449;&#12452;&#12523;) = _file("")
#@gui_ja : &#36861;&#21152;&#12497;&#12524;&#12483;&#12488; 2 (.gpl &#12501;&#12449;&#12452;&#12523;) = _file("")
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#35500;&#26126;:</b>\n
#@gui_ja : &#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12391;&#12399;&#12289;&#30333;&#40658;&#20889;&#30495;&#12420;&#32218;&#30011;&#12434;&#31777;&#21336;&#12395;&#24425;&#33394;&#12391;&#12365;&#12414;&#12377;&#12290;
#@gui_ja : &#12454;&#12451;&#12531;&#12489;&#12454;&#19979;&#37096;&#12398;<i>&#36969;&#29992;</i>&#12414;&#12383;&#12399; <i>OK</i> &#12434;&#12463;&#12522;&#12483;&#12463;&#12377;&#12427;&#12392;&#12289;&#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;&#12454;&#12451;&#12531;&#12489;&#12454;&#12364;&#38283;&#12365;&#12289;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#36861;&#21152;&#12391;&#12365;&#12414;&#12377;&#12290;
#@gui_ja : &#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12398;&#37197;&#32622;&#12364;&#23436;&#20102;&#12375;&#12383;&#12425;&#12289;&#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;&#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#32066;&#20102;&#12377;&#12427;&#12392;&#12289;&#24425;&#33394;&#20966;&#29702;&#12364;&#23455;&#34892;&#12373;&#12428;&#32080;&#26524;&#12364; GIMP &#12395;&#20986;&#21147;&#12373;&#12428;&#12414;&#12377;&#12290;\n\n
#@gui_ja : &#20966;&#29702;&#32080;&#26524;&#12364;&#12362;&#27671;&#12395;&#21484;&#12373;&#12394;&#12363;&#12387;&#12383;&#22580;&#21512;&#12399;&#12450;&#12531;&#12489;&#12453; (Ctrl+Z) &#12434;&#34892;&#12387;&#12383;&#12354;&#12392;<i>&#36969;&#29992;</i>&#12434;&#12418;&#12358;&#19968;&#24230;&#12463;&#12522;&#12483;&#12463;&#12375;&#12289;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12398;&#37197;&#32622;&#12434;&#35519;&#25972;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;
#@gui_ja : &#12454;&#12451;&#12531;&#12489;&#12454;&#19979;&#37096;&#12398;<i>&#12522;&#12475;&#12483;&#12488;</i>&#12434;&#12463;&#12522;&#12483;&#12463;&#12377;&#12427;&#12392;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#12377;&#12409;&#12390;&#28040;&#21435;&#12391;&#12365;&#12414;&#12377;&#12290;
#@gui_ja : </small>"}
#@gui_ja : &#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#28040;&#21435; = button(0.5)
#@gui_ja : Last Image Size = const(0,0)
#@gui_ja : Control Points = const(-1)
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#25805;&#20316;&#35500;&#26126;:</b>\n
#@gui_ja : &#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;&#12454;&#12451;&#12531;&#12489;&#12454;&#12391;&#12399;&#20197;&#19979;&#12398;&#12450;&#12463;&#12471;&#12519;&#12531;&#12364;&#21033;&#29992;&#12391;&#12365;&#12414;&#12377;&#12290;\n\n
#@gui_ja : - <b>&#24038;&#12510;&#12454;&#12473;&#12508;&#12479;&#12531;</b> &#12463;&#12522;&#12483;&#12463;&#12391;&#26032;&#12375;&#12356;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#20316;&#25104; (&#12414;&#12383;&#12399;&#12489;&#12521;&#12483;&#12464;&#12391;&#26082;&#23384;&#12398;&#12418;&#12398;&#12434;&#31227;&#21205;)\n
#@gui_ja : - <b>&#21491;&#12510;&#12454;&#12473;&#12508;&#12479;&#12531;</b>&#12414;&#12383;&#12399;<b>X &#12461;&#12540;</b> &#12463;&#12522;&#12483;&#12463;&#12375;&#12383;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#21066;&#38500;\n
#@gui_ja : - <b>&#21491;&#12510;&#12454;&#12473;&#12508;&#12479;&#12531;</b>&#12414;&#12383;&#12399;<b>P &#12461;&#12540;</b> (&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12398;&#12394;&#12356;&#22580;&#25152;&#12391;) &#12463;&#12522;&#12483;&#12463;&#12375;&#12383;&#22580;&#25152;&#12398;&#33394;&#12434;&#21462;&#24471;\n
#@gui_ja : - <b>&#12510;&#12454;&#12473;&#12507;&#12452;&#12540;&#12523;</b>&#12414;&#12383;&#12399;<b>Ctrl+&#30690;&#21360;&#12461;&#12540;&#19978;/&#19979;</b> &#34920;&#31034;&#12434;&#25313;&#22823;/&#32302;&#23567;\n
#@gui_ja : - <b>Ctrl+&#12510;&#12454;&#12473;&#12507;&#12452;&#12540;&#12523;</b>&#12289;<b>Shift+&#12510;&#12454;&#12473;&#12507;&#12452;&#12540;&#12523;</b>&#12414;&#12383;&#12399;&#30690;&#21360;&#12461;&#12540; &#25313;&#22823;&#12375;&#12383;&#30011;&#20687;&#12398;&#34920;&#31034;&#31684;&#22258;&#12434;&#31227;&#21205;\n
#@gui_ja : - <b>&#12473;&#12506;&#12540;&#12473;&#12461;&#12540;</b> &#20966;&#29702;&#32080;&#26524;&#20104;&#28204;&#12398;&#34920;&#31034;&#12434;&#26356;&#26032;\n
#@gui_ja : - <b>Tab &#12461;&#12540;</b> &#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12398;&#34920;&#31034;&#26041;&#27861;&#12434;&#20999;&#12426;&#26367;&#12360;\n
#@gui_ja : - <b>Backspace &#12461;&#12540;</b> &#26368;&#24460;&#12395;&#36861;&#21152;&#12375;&#12383;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#21066;&#38500;\n
#@gui_ja : - <b>PageUp &#12461;&#12540;</b> &#30011;&#20687;&#12398;&#12467;&#12531;&#12488;&#12521;&#12473;&#12488;&#12434;&#19978;&#12370;&#12427;\n
#@gui_ja : - <b>PageDown &#12461;&#12540;</b> &#30011;&#20687;&#12398;&#12467;&#12531;&#12488;&#12521;&#12473;&#12488;&#12434;&#19979;&#12370;&#12427;\n
#@gui_ja : - <b>R &#12461;&#12540;</b> &#33394;&#32622;&#25563;&#12514;&#12540;&#12489;&#12398;&#12458;&#12531;/&#12458;&#12501;&#12434;&#20999;&#12426;&#26367;&#12360;\n
#@gui_ja : - <b>Ctrl+D</b> &#12454;&#12451;&#12531;&#12489;&#12454;&#12469;&#12452;&#12474;&#12434;&#22823;&#12365;&#12367;&#12377;&#12427;\n
#@gui_ja : - <b>Ctrl+C</b> &#12454;&#12451;&#12531;&#12489;&#12454;&#12469;&#12452;&#12474;&#12434;&#23567;&#12373;&#12367;&#12377;&#12427;\n
#@gui_ja : - <b>Ctrl+R</b> &#12454;&#12451;&#12531;&#12489;&#12454;&#12469;&#12452;&#12474;&#12434;&#12522;&#12475;&#12483;&#12488;\n
#@gui_ja : - <b>Esc &#12461;&#12540;</b>&#12289;<b>Q &#12461;&#12540;</b>&#12414;&#12383;&#12399; <b>Enter &#12461;&#12540;</b> &#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;&#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#32066;&#20102;
#@gui_ja : </small>"}
#@gui_ja : sep = separator(), note = note("<small>&#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12398;&#35443;&#12375;&#12356;&#20351;&#12356;&#26041;&#12399;&#20197;&#19979;&#12398; Web &#12506;&#12540;&#12472;&#12391;&#21442;&#29031;&#12391;&#12365;&#12414;&#12377;&#12290;</small>")
#@gui_ja : url = link{"David Revoy &#27663;&#12395;&#12424;&#12427; G'MIC Colorize &#12501;&#12451;&#12523;&#12479;&#12398;&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523; (&#33521;&#35486;)","http://www.davidrevoy.com/article240/gmic-line-art-colorization"}
#@gui_ja : url = link{"&#12368;&#12427;&#12368;&#12427;&#27663;&#12395;&#12424;&#12427;&#19978;&#35352;&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;&#12398;&#26085;&#26412;&#35486;&#32763;&#35379;","http://sp-cute.hatenablog.com/entry/2014/10/12/142939"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2014/12/09</i></small>")
#@gui_ja &#24425;&#33394; [&#12467;&#12511;&#12483;&#12463;] : fx_colorize_comics, fx_colorize_comics_preview(1)
#@gui_ja : note = note("<b>&#12524;&#12452;&#12516;&#12540;&#38918;&#24207;:</b>")
#@gui_ja : &#20837;&#21147;&#12524;&#12452;&#12516;&#12540; = choice{0,"&#12459;&#12521;&#12540;&#12473;&#12509;&#12483;&#12488; + &#32218;&#30011;","&#32218;&#30011; + &#12459;&#12521;&#12540;&#12473;&#12509;&#12483;&#12488;","&#12459;&#12521;&#12540;&#12473;&#12509;&#12483;&#12488; + &#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524; + &#32218;&#30011;","&#32218;&#30011; + &#12459;&#12521;&#12540;&#12473;&#12509;&#12483;&#12488; + &#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524;"}
#@gui_ja : &#20986;&#21147;&#12524;&#12452;&#12516;&#12540; = _choice{1,"1 &#12524;&#12452;&#12516;&#12540;&#12395;&#32113;&#21512;","&#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524; + &#32218;&#30011;","&#32218;&#30011; + &#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524;","&#12459;&#12521;&#12540;&#12473;&#12509;&#12483;&#12488; + &#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524; + &#32218;&#30011;","&#32218;&#30011; + &#12459;&#12521;&#12540;&#12473;&#12509;&#12483;&#12488; + &#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524;"}
#@gui_ja : &#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524;&#12398;&#20986;&#21147; = choice("1 &#12524;&#12452;&#12516;&#12540;","2 &#12524;&#12452;&#12516;&#12540;","3 &#12524;&#12452;&#12516;&#12540;","4 &#12524;&#12452;&#12516;&#12540;","5 &#12524;&#12452;&#12516;&#12540;","6 &#12524;&#12452;&#12516;&#12540;","7 &#12524;&#12452;&#12516;&#12540;","8 &#12524;&#12452;&#12516;&#12540;","9 &#12524;&#12452;&#12516;&#12540;","10 &#12524;&#12452;&#12516;&#12540;","&#33394;&#12372;&#12392;&#12395; 1 &#12524;&#12452;&#12516;&#12540;&#12378;&#12388;","&#31684;&#22258;&#12372;&#12392;&#12395; 1 &#12524;&#12452;&#12516;&#12540;&#12378;&#12388;")
#@gui_ja : sep = separator()
#@gui_ja : &#12394;&#12417;&#12425;&#12363;&#12373; = float(0.05,0,1)
#@gui_ja : sep = separator(), note = note{"<small><b>&#27880;:</b> &#12454;&#12451;&#12531;&#12489;&#12454;&#24038;&#20596;&#12398;&#12300;<i>&#20837;&#21147;&#12524;&#12452;&#12516;&#12540;</i>&#12301;&#12391;&#12300;<i>&#12377;&#12409;&#12390;</i>&#12301;&#12434;&#36984;&#25246;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;\n
#@gui_ja : <i>&#12459;&#12521;&#12540;&#12473;&#12509;&#12483;&#12488;</i> = &#33394;&#25351;&#23450;&#12434;&#25551;&#12365;&#12371;&#12435;&#12384;&#12524;&#12452;&#12516;&#12540;&#12391;&#12377;&#12290;\n
#@gui_ja : <i>&#32218;&#30011;</i> = &#32218;&#30011;&#12398;&#12524;&#12452;&#12516;&#12540; (&#30333;&#40658;&#12414;&#12383;&#12399;&#31354;&#30333;&#37096;&#20998;&#12364;&#36879;&#26126;&#12398;&#12418;&#12398;) &#12391;&#12377;&#12290;\n
#@gui_ja : <i>&#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524;</i> = &#33394;&#20998;&#12369;&#20966;&#29702;&#12398;&#32080;&#26524;&#12364;&#20986;&#21147;&#12373;&#12428;&#12427;&#12524;&#12452;&#12516;&#12540;&#12391;&#12377;&#12290;\n\n
#@gui_ja : <b>&#27880;&#24847;:</b>
#@gui_ja : \n  - &#12503;&#12524;&#12499;&#12517;&#12540;&#12399;&#23455;&#38555;&#12398;&#20966;&#29702;&#32080;&#26524;&#12392;&#30064;&#12394;&#12427;&#22580;&#21512;&#12364;&#12354;&#12426;&#12414;&#12377;&#12290;
#@gui_ja : \n  - &#21313;&#20998;&#12394;&#12513;&#12514;&#12522;&#12434;&#25645;&#36617;&#12375;&#12390;&#12356;&#12394;&#12356; PC &#12391;&#12399;&#12289;&#12300;&#33394;&#20998;&#12369;&#20966;&#29702;&#32080;&#26524;&#12398;&#20986;&#21147;&#12301;&#12391;&#12300;&#33394;&#12372;&#12392;&#12395; 1 &#12524;&#12452;&#12516;&#12540;&#12378;&#12388;&#12301;&#12300;&#31684;&#22258;&#12372;&#12392;&#12395; 1 &#12524;&#12452;&#12516;&#12540;&#12378;&#12388;&#12301;&#12398;&#12458;&#12503;&#12471;&#12519;&#12531;&#12434;&#20351;&#29992;&#12375;&#12394;&#12356;&#12391;&#12367;&#12384;&#12373;&#12356;&#12290;
#@gui_ja : </small>"}
#@gui_ja : sep = separator(), url = link{"&#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12398;&#35443;&#12375;&#12356;&#20351;&#12356;&#26041;&#12399;&#12371;&#12385;&#12425;&#12391;&#21442;&#29031;&#12391;&#12365;&#12414;&#12377;&#12290;(&#33521;&#35486;)","http://www.gimpchat.com/viewtopic.php?f=28&t=7567"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>&#12289;<i>Timoth&#233;e Giet</i>&#12289;<i>David Revoy</i>      &#26368;&#32066;&#26356;&#26032;: <i>2013/06/19</i></small>")
#@gui_ja &#32218;&#30011;&#12434;&#33258;&#21205;&#30340;&#12395;&#33394;&#20998;&#12369; : fx_autofill_lineart, fx_autofill_lineart_preview(0)
#@gui_ja : &#36650;&#37101;&#12398;&#12375;&#12365;&#12356;&#20516; (%) = float(90,0,100)
#@gui_ja : &#36650;&#37101;&#12398;&#27491;&#35215;&#21270; = bool(1)
#@gui_ja : Minimal Region Area = int(8,0,256)
#@gui_ja : Tolerance to Gaps = int(0,0,10)
#@gui_ja : &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#32218;&#30011;&#12392;&#33394;","&#33394;&#12398;&#12415;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2016/11/12</i></small>")
#@gui_ja : &#20351;&#29992;&#12377;&#12427;&#33394; = choice("&#12521;&#12531;&#12480;&#12512;","&#26368;&#21069;&#38754;&#12398;&#33394;&#25351;&#23450;&#12524;&#12452;&#12516;&#12540;")
#@gui_ja : sep = separator(), note = note{"<small><b>Global geometry parameters:</b></small>"}
#@gui_ja : &#36650;&#37101;&#12398;&#26908;&#20986; (%) = float(95,0,100)
#@gui_ja : &#36650;&#37101;&#12398;&#33192;&#12425;&#12414;&#12375; = int(0,-1,10)
#@gui_ja : note = note{"<small>&#36650;&#37101;&#12434;&#33192;&#12425;&#12414;&#12379;&#12427;&#12469;&#12452;&#12474;&#12434;&#33258;&#21205;&#12391;&#35373;&#23450;&#12377;&#12427;&#12395;&#12399;&#12289;&#12300;&#36650;&#37101;&#12398;&#33192;&#12425;&#12414;&#12375;&#12301;&#12434; -1 &#12395;&#35373;&#23450;&#12375;&#12414;&#12377;&#12290;</small>"}
#@gui_ja : Output Region Delimiters = _bool(0)
#@gui_ja : sep = separator(), note = note{"<small><b>&#12300;&#20351;&#29992;&#12377;&#12427;&#33394;&#12301;&#12395;&#12300;&#12521;&#12531;&#12480;&#12512;&#12301;&#12434;&#35373;&#23450;&#12375;&#12383;&#22580;&#21512;&#12398;&#12415;:</b></small>"}
#@gui_ja : &#33394;&#12398;&#26368;&#22823;&#24425;&#24230; = int(32,0,255)
#@gui_ja : &#33394;&#12398;&#26368;&#23567;&#36637;&#24230; = int(200,0,255)
#@gui_ja : sep = separator(), note = note{"<small><b>&#12300;&#20351;&#29992;&#12377;&#12427;&#33394;&#12301;&#12395;&#12300;&#26368;&#21069;&#38754;&#12398;&#33394;&#25351;&#23450;&#12524;&#12452;&#12516;&#12540;&#12301;&#12434;&#35373;&#23450;&#12375;&#12383;&#22580;&#21512;&#12398;&#12415;:</b></small>"}
#@gui_ja : Color Shading (%) = int(0,0,100)
#@gui_ja : sep = separator(), note = note{"<small><b>&#25509;&#32154;&#12497;&#12521;&#12513;&#12540;&#12479;&#12540;:</b></small>"}
#@gui_ja : End Point Rate (%) = float(85,0,100)
#@gui_ja : &#31471;&#28857;&#12398;&#26368;&#22823;&#25509;&#32154;&#25968; = int(2,1,5)
#@gui_ja : &#12473;&#12503;&#12521;&#12452;&#12531;&#26354;&#32218;&#12398;&#38263;&#12373;&#12398;&#19978;&#38480; (px) = float(60,0,256)
#@gui_ja : &#12475;&#12464;&#12513;&#12531;&#12488;&#12398;&#38263;&#12373;&#12398;&#19978;&#38480; (px) = float(20,0,256)
#@gui_ja : &#12473;&#12503;&#12521;&#12452;&#12531;&#26354;&#32218;&#12398;&#35282;&#24230;&#12398;&#19978;&#38480; (&#24230;) = float(90,0,180)
#@gui_ja : Spline Roundness = float(1,0,2)
#@gui_ja : Minimal Region Area = float(10,0,100)
#@gui_ja : &#33258;&#24049;&#20132;&#24046;&#12434;&#35377;&#21487; = bool(1)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#31278;&#39006; = choice(0,"Colored geometry","Colored regions","Colored lineart")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: David Tschumperl&#233;&#12289;S&#233;bastien Fourey&#12289;David Revoy</i> &#26368;&#32066;&#26356;&#26032;: <i>2016/12/13</i></small>")
#@gui _
#@gui_ja <b>&#33394;</b>
#@gui_ja &#12475;&#12500;&#12450; : fx_sepia, fx_sepia_preview
#@gui_ja : &#12460;&#12531;&#12510; = float(0,-1.2,1.2)
#@gui_ja : &#12467;&#12531;&#12488;&#12521;&#12473;&#12488; = float(1,0,4)
#@gui_ja : &#36637;&#24230; = float(0,-255,255)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#33394;&#12434;&#36578;&#20889; [&#22522;&#26412;&#30340;] : fx_transfer_colors, fx_transfer_colors
#@gui_ja : &#36637;&#24230;&#12434;&#36578;&#20889; = bool(0)
#@gui_ja : &#12524;&#12452;&#12516;&#12540;&#38918;&#24207;&#12434;&#21453;&#36578; = bool(0)
#@gui_ja : note = note{"<small><b>&#27880;: </b>
#@gui_ja : &#26368;&#32972;&#38754;&#12398;&#12524;&#12452;&#12516;&#12540;&#12398;&#33394;&#12434;&#21442;&#29031;&#12375;&#12414;&#12377;&#12290;\n
#@gui_ja : &#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12434;&#27491;&#12375;&#12367;&#21205;&#20316;&#12373;&#12379;&#12427;&#12395;&#12399;&#12289;&#26368;&#20302;&#12391;&#12418; 2 &#26522;&#12398;&#12524;&#12452;&#12516;&#12540;&#12364;&#24517;&#35201;&#12392;&#12394;&#12426;&#12414;&#12377;&#12290;&#35079;&#25968;&#12398;&#12524;&#12452;&#12516;&#12540;&#12434;&#20837;&#21147;&#12391;&#12365;&#12427;&#12424;&#12358;&#12289;&#12300;&#20837;&#21147;&#12524;&#12452;&#12516;&#12540;&#12301;&#12458;&#12503;&#12471;&#12519;&#12531;&#12434;&#35519;&#25972;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;
#@gui_ja : </small>"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#33394;&#12434;&#36984;&#25246;&#12375;&#12390;&#32622;&#25563; : fx_select_color, fx_select_color_preview(0)
#@gui_ja : &#33394;&#31354;&#38291; = choice(0,"RGB[A]","RGB","YCbCr","&#36196;","&#32209;","&#38738;","&#19981;&#36879;&#26126;&#24230;","&#36637;&#24230;","&#36196;&#12539;&#38738; &#33394;&#24230;","&#33394;&#30456;","&#24425;&#24230;")
#@gui_ja : &#35377;&#23481;&#35492;&#24046; = float(20,0,100)
#@gui_ja : &#12394;&#12417;&#12425;&#12363;&#12373; = float(0,0,10)
#@gui_ja : &#31348;&#12434;&#22475;&#12417;&#12427; = int(0,0,256)
#@gui_ja : &#36984;&#25246;&#12377;&#12427;&#33394; = color(255,255,255,255)
#@gui_ja : &#20986;&#21147;&#30011;&#20687; = choice(0,"&#36984;&#25246;&#12375;&#12383;&#33394;","&#36984;&#25246;&#12375;&#12383;&#33394;&#12398;&#12510;&#12473;&#12463;","&#38500;&#22806;&#12373;&#12428;&#12383;&#33394;","&#38500;&#22806;&#12373;&#12428;&#12383;&#33394;&#12398;&#12510;&#12473;&#12463;","&#33394;&#12434;&#32622;&#25563;")
#@gui_ja : &#32622;&#25563;&#12395;&#20351;&#12358;&#33394; = color(255,0,0,255)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2010/12/29</i></small>")
#@gui_ja &#36984;&#25246;&#30340;&#33073;&#33394; : fx_selective_desaturation, fx_selective_desaturation_preview(1)
#@gui_ja : &#25351;&#23450;&#12377;&#12427;&#33394; = color(255,255,255)
#@gui_ja : &#33073;&#33394;&#23550;&#35937; = choice("&#25351;&#23450;&#33394;","&#25351;&#23450;&#33394;&#20197;&#22806;&#12398;&#12377;&#12409;&#12390;")
#@gui_ja : &#21177;&#26524;&#12398;&#24375;&#12373; = float(3,0,10)
#@gui_ja : &#27491;&#21063;&#21270; = int(0,0,20)
#@gui_ja : &#24425;&#24230;&#12398;&#19978;&#38480; = choice("&#20837;&#21147;&#30011;&#20687;","&#25351;&#23450;&#33394;","Maximum value")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2015/7/15</i></small>")
#@gui _
#@gui_ja <b>&#33464;&#34899;&#30340;</b>
#@gui_ja &#22235;&#20998;&#26408;&#30011;&#20687;&#20966;&#29702; : fx_quadtree, fx_quadtree_preview(1)
#@gui_ja : &#12514;&#12540;&#12489; = choice("Squares","Sierpinksi design","&#26965;&#20870;&#12502;&#12521;&#12471;&#12391;&#25551;&#30011;")
#@gui_ja : &#31934;&#24230; = int(1024,2,4096)
#@gui_ja : &#22343;&#19968;&#24615; = float(0.5,0,2)
#@gui_ja : &#36650;&#37101;&#32218; = int(0,0,4)
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#12300;&#26965;&#20870;&#12502;&#12521;&#12471;&#12391;&#25551;&#30011;&#12301;&#29992;&#12398;&#35373;&#23450;:</b></small>"}
#@gui_ja : &#31532; 1 &#21322;&#24452; = float(3,0,5)
#@gui_ja : &#31532; 2 &#21322;&#24452; = float(1.5,0,5)
#@gui_ja : &#30064;&#26041;&#24615; = float(1,0,4)
#@gui_ja : Only Leafs = bool(1)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;&#12395;&#36969;&#29992;","&#19979;&#21322;&#20998;&#12395;&#36969;&#29992;","&#21491;&#21322;&#20998;&#12395;&#36969;&#29992;","&#19978;&#21322;&#20998;&#12395;&#36969;&#29992;","&#24038;&#21322;&#20998;&#12395;&#36969;&#29992;","&#35079;&#35069;&#12375;&#12390;&#19978;&#19979;&#12395;&#20006;&#12409;&#12427;","&#35079;&#35069;&#12375;&#12390;&#24038;&#21491;&#12395;&#20006;&#12409;&#12427;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2017/06/15</i></small>")
#@gui _
#@gui_ja <b>&#35443;&#32048;</b>
#@gui_ja &#12471;&#12515;&#12540;&#12503;&#21270; [&#12486;&#12463;&#12473;&#12481;&#12515;] : fx_sharpen_texture, fx_sharpen_texture_preview(0)
#@gui_ja : &#24375;&#12373; = float(1,0,4)
#@gui_ja : &#21322;&#24452; = float(4,0,32)
#@gui_ja : sep = separator(), &#12481;&#12515;&#12531;&#12493;&#12523; = choice(16,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2016/09/20</i></small>")
#@gui_ja DCP &#38686;&#38500;&#21435; : jeje_dehaze,jeje_dehaze_preview
#@gui_ja : &#12473;&#12465;&#12540;&#12523; = int(5,1,20)
#@gui_ja : &#24375;&#12373; = float(1,0,2)
#@gui_ja : &#26368;&#23567; = float(.2,0,1)
#@gui_ja : &#26368;&#22823; = float(1,0,1)
#@gui_ja : &#36637;&#24230; = float(0,-100,100)
#@gui_ja : &#12467;&#12531;&#12488;&#12521;&#12473;&#12488; = float(0,-100,100)
#@gui_ja : &#12460;&#12531;&#12510; = float(0,-100,100)
#@gui_ja : &#36879;&#36942;&#29575;&#12510;&#12483;&#12503; = bool(false)
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note("<small>Dark Channel Prior Author &#12395;&#22522;&#12389;&#12367;&#38686;&#38500;&#21435;&#12501;&#12451;&#12523;&#12479;&#12391;&#12377;&#12290;&#20316;&#32773;: <i>J&#233;r&#244;me Boulanger</i> &#26368;&#32066;&#26356;&#26032;: <i>2016/08/09</i></small>")
#@gui _
#@gui_ja <b>&#36650;&#37101;</b>
#@gui_ja &#21069;&#26223;&#20999;&#12426;&#20986;&#12375; [&#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;] : fx_extract_foreground, gui_no_preview
#@gui_ja : &#32257;&#12398;&#12412;&#12363;&#12375; = _float(0,0,4)
#@gui_ja : &#24195;&#12370; = int(0,-32,32)
#@gui_ja : &#20986;&#21147;&#12514;&#12540;&#12489; = choice{3,"RGBA &#30011;&#20687; (&#32972;&#26223;&#12434;&#23436;&#20840;&#12395;&#36879;&#26126;&#21270; / 1 &#12524;&#12452;&#12516;&#12540;)","RGBA &#30011;&#20687; (&#21487;&#36870;&#30340; / 1 &#12524;&#12452;&#12516;&#12540;)","RGB &#30011;&#20687; + 2 &#20516;&#12510;&#12473;&#12463; (2 &#12524;&#12452;&#12516;&#12540;)","RGBA &#21069;&#26223; + &#32972;&#26223; (2 &#12524;&#12452;&#12516;&#12540;)"}
#@gui_ja : &#34920;&#31034;&#35299;&#20687;&#24230; = _choice{1,"&#23567; (&#39640;&#36895;)","&#20013;","&#22823; (&#20302;&#36895;)","&#26368;&#22823; (&#26368;&#20302;&#36895;)"}
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#35500;&#26126;:</b>\n
#@gui_ja : &#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12391;&#12399;&#12289;&#19981;&#36879;&#26126;&#12394; RGB &#30011;&#20687;&#12363;&#12425;&#21069;&#26223;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12434;&#31777;&#21336;&#12395;&#20999;&#12426;&#20986;&#12377;&#12371;&#12392;&#12364;&#12391;&#12365;&#12414;&#12377;&#12290;
#@gui_ja : &#12454;&#12451;&#12531;&#12489;&#12454;&#19979;&#37096;&#12398;<i>&#36969;&#29992;</i>&#12414;&#12383;&#12399; <i>OK</i> &#12434;&#12463;&#12522;&#12483;&#12463;&#12377;&#12427;&#12392;&#12289;&#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;&#12454;&#12451;&#12531;&#12489;&#12454;&#12364;&#38283;&#12365;&#12289;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#36861;&#21152;&#12391;&#12365;&#12414;&#12377;&#12290;
#@gui_ja : &#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12398;&#37197;&#32622;&#12364;&#23436;&#20102;&#12375;&#12383;&#12425;&#12289;&#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;&#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#32066;&#20102;&#12377;&#12427;&#12392;&#12289;&#20999;&#12426;&#20986;&#12375;&#20966;&#29702;&#12364;&#23455;&#34892;&#12373;&#12428;&#32080;&#26524;&#12364; GIMP &#12395;&#20986;&#21147;&#12373;&#12428;&#12414;&#12377;&#12290;\n\n
#@gui_ja : &#20966;&#29702;&#32080;&#26524;&#12364;&#12362;&#27671;&#12395;&#21484;&#12373;&#12394;&#12363;&#12387;&#12383;&#22580;&#21512;&#12399;&#12289;<i>&#36969;&#29992;</i>&#12434;&#12418;&#12358;&#19968;&#24230;&#12463;&#12522;&#12483;&#12463;&#12375;&#12390;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12398;&#37197;&#32622;&#12434;&#35519;&#25972;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;
#@gui_ja : &#12454;&#12451;&#12531;&#12489;&#12454;&#19979;&#37096;&#12398;<i>&#12522;&#12475;&#12483;&#12488;</i>&#12434;&#12463;&#12522;&#12483;&#12463;&#12377;&#12427;&#12392;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#12377;&#12409;&#12390;&#28040;&#21435;&#12391;&#12365;&#12414;&#12377;&#12290;
#@gui_ja : </small>"}
#@gui_ja : Last Image Size = const(0,0)
#@gui_ja : Control Points = const(-1)
#@gui_ja : sep = separator()
#@gui_ja : note = note{"<small><b>&#25805;&#20316;:</b>\n
#@gui_ja : &#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502; &#12454;&#12451;&#12531;&#12489;&#12454;&#12391;&#12399;&#20197;&#19979;&#12398;&#12450;&#12463;&#12471;&#12519;&#12531;&#12364;&#21033;&#29992;&#12391;&#12365;&#12414;&#12377;&#12290;\n\n
#@gui_ja : - <b>&#24038;&#12510;&#12454;&#12473;&#12508;&#12479;&#12531;</b>&#12414;&#12383;&#12399; <b>F &#12461;&#12540;</b>: &#12463;&#12522;&#12483;&#12463;&#12391;&#26032;&#12375;&#12356;<b>&#21069;&#26223;</b>&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#20316;&#25104; (&#12489;&#12521;&#12483;&#12464;&#12391;&#26082;&#23384;&#12398;&#12418;&#12398;&#12434;&#31227;&#21205;)\n
#@gui_ja : - <b>&#21491;&#12510;&#12454;&#12473;&#12508;&#12479;&#12531;</b>&#12414;&#12383;&#12399; <b>B &#12461;&#12540;</b>: &#12463;&#12522;&#12483;&#12463;&#12391;&#26032;&#12375;&#12356;<b>&#32972;&#26223;</b>&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#20316;&#25104; (&#12489;&#12521;&#12483;&#12464;&#12391;&#26082;&#23384;&#12398;&#12418;&#12398;&#12434;&#31227;&#21205;)\n
#@gui_ja : - <b>&#12510;&#12454;&#12473;&#12507;&#12452;&#12540;&#12523;</b>&#12414;&#12383;&#12399; <b>Ctrl+&#30690;&#21360;&#12461;&#12540;&#19978;/&#19979;</b>: &#34920;&#31034;&#12434;&#25313;&#22823;/&#32302;&#23567;\n
#@gui_ja : - <b>&#12473;&#12506;&#12540;&#12473;&#12461;&#12540;</b>: &#20999;&#12426;&#20986;&#12375;&#12510;&#12473;&#12463;&#12434;&#26356;&#26032;\n
#@gui_ja : - <b>Tab &#12461;&#12540;</b>: &#32972;&#26223;&#12398;&#34920;&#31034;&#12514;&#12540;&#12489;&#12434;&#20999;&#12426;&#26367;&#12360;\n
#@gui_ja : - <b>M &#12461;&#12540;</b>: &#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12398;&#34920;&#31034;&#12514;&#12540;&#12489;&#12434;&#20999;&#12426;&#26367;&#12360;\n
#@gui_ja : - <b>Backspace &#12461;&#12540;</b>: &#26368;&#24460;&#12395;&#36861;&#21152;&#12375;&#12383;&#12467;&#12531;&#12488;&#12525;&#12540;&#12523;&#12509;&#12452;&#12531;&#12488;&#12434;&#21066;&#38500;\n
#@gui_ja : - <b>PageUp &#12461;&#12540;</b>: &#32972;&#26223;&#12398;&#19981;&#36879;&#26126;&#24230;&#12434;&#19978;&#12370;&#12427;\n
#@gui_ja : - <b>PageDown &#12461;&#12540;</b>: &#32972;&#26223;&#12398;&#19981;&#36879;&#26126;&#24230;&#12434;&#19979;&#12370;&#12427;\n
#@gui_ja : - <b>Ctrl+D</b>: &#12454;&#12451;&#12531;&#12489;&#12454;&#12469;&#12452;&#12474;&#12434;&#22823;&#12365;&#12367;&#12377;&#12427;\n
#@gui_ja : - <b>Ctrl+C</b>: &#12454;&#12451;&#12531;&#12489;&#12454;&#12469;&#12452;&#12474;&#12434;&#23567;&#12373;&#12367;&#12377;&#12427;\n
#@gui_ja : - <b>Ctrl+R</b>: &#12454;&#12451;&#12531;&#12489;&#12454;&#12469;&#12452;&#12474;&#12434;&#12522;&#12475;&#12483;&#12488;\n
#@gui_ja : - <b>Esc &#12461;&#12540;</b>&#12289;<b>Q &#12461;&#12540;</b>&#12414;&#12383;&#12399; <b>Enter &#12461;&#12540;</b>: &#12452;&#12531;&#12479;&#12521;&#12463;&#12486;&#12451;&#12502;&#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#32066;&#20102;
#@gui_ja : </small>"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>      &#26368;&#32066;&#26356;&#26032;: <i>2014/09/29</i></small>")
#@gui _
#@gui_ja <b>&#37197;&#21015;&#12392;&#12479;&#12452;&#12522;&#12531;&#12464;</b>
#@gui_ja &#12471;&#12540;&#12512;&#12524;&#12473;&#21270; [&#12497;&#12483;&#12481;&#12505;&#12540;&#12473;] : fx_frame_seamless, fx_frame_seamless_preview(0)
#@gui_ja : &#12501;&#12524;&#12540;&#12512;&#12469;&#12452;&#12474; = int(32,0,256)
#@gui_ja : &#12497;&#12483;&#12481;&#12469;&#12452;&#12474; = int(9,3,64)
#@gui_ja : &#21512;&#25104;&#37096;&#20998;&#12398;&#12469;&#12452;&#12474; = int(0,0,64)
#@gui_ja : Frame Type = choice(1,"Inner","Outer")
#@gui_ja : Equalize Light = float(100,0,100)
#@gui_ja : sep = separator(),
#@gui_ja : Preview Original = bool(0)
#@gui_ja : Tiled Preview = choice(3,"None","2x1","1x2","2x2","3x3","4x4")
#@gui_ja : sep = separator(), &#12503;&#12524;&#12499;&#12517;&#12540;&#12398;&#34920;&#31034;&#26041;&#27861; = choice("&#20840;&#20307;","&#19979;&#21322;&#20998;","&#21491;&#21322;&#20998;","&#19978;&#21322;&#20998;","&#24038;&#21322;&#20998;","&#19978;&#31471;&#37096;&#12434;&#35079;&#35069;","&#24038;&#31471;&#37096;&#12434;&#35079;&#35069;","&#19979;&#31471;&#37096;&#12434;&#35079;&#35069;","&#21491;&#31471;&#37096;&#12434;&#35079;&#35069;")
#@gui_ja : sep = separator(), note = note{"<small><b>&#27880;:</b> &#12371;&#12398;&#12501;&#12451;&#12523;&#12479;&#12434;&#20351;&#29992;&#12377;&#12427;&#12392;&#12289;&#20837;&#21147;&#12375;&#12383;&#30011;&#20687;&#12434;&#12388;&#12394;&#12366;&#30446;&#12398;&#12394;&#12356;&#12497;&#12479;&#12540;&#12531;&#12395;&#31777;&#21336;&#12395;&#22793;&#25563;&#12391;&#12365;&#12414;&#12377;&#12290;</small>"}
#@gui_ja : sep = separator(), note = note("<small>&#20316;&#32773;: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> &#26368;&#32066;&#26356;&#26032;: <i>2015/12/15</i></small>")
#@gui _
#@gui <i>About</i>
#@gui About G'MIC : _none_, _none_
#@gui : note = note{<center><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAAAuCAMAAACRQELNAAAC/VBMVEUAAADq6url4+afoKDj4+bJyMj09fXz8/R2bHHd3t98hoiPk5q5ucGMiIq2s7VxfoPn5+/k4+T09fXPztDc29urp7VUOVGzrLJxZnXNysujnKTNzM68uL3PxNJYXmjZ2d3FxMXQ0NG/wMluapNdbHTFxcrZ1tqUmJikpqeioLROV13Qz9Dp5+zFusJZVGybgZiSdIi/vMHt6/GLgJNzXqOBk6EzGyPc2eGysbuUeIFlV22ko7G0iLO4tLePj47o5Orp6+9fQ3KKg5Zxc4cnIiRlb4V/X3JyeIhBQVasq60gFByMip2/zteSkLNhS7dNUXZVRpP4+/xxQFo8PVM1PEscQFIkSViqqa0wN0MuQEw7OFo0L1YTOUogPmwaKzRHQXSgq6snO0geMEQtS3U5Pk8zLkstVHwHPDJAOWcWNUMMRDuSlpslR28oQWhBRWc3OmZXODkRIS02WIMgQ2MVNVkvOVRHQUtGP14lOVItQXk5MnckL1hPSGk8SFNtE0MnND8OKDYIGCC2ubtkLUgtKzihoqUjHHcsLmMwQVkiMU4QLUI1J0JmPTg/OokZOmJYP0Q9OkQeOkRZKDxOJzNiW4M2RGYoOV57FFIQMU83MDe9rrg6PnYRTUMGKyI8Rn9JK1NmFU69wMRYKFYVVUlaGElGNDdbDjZVLyptfsJqbrWFk5F2SHo3TXMpM3IyI21oO2dNWGZsKVgvIVSKiaFeWpiBb3kbFWc7LGU9L1YWNjuDg5xWS4IwSU4cS0kmI0RNG0AhHiOvma+Qj62UoaJ+ipYtJo0nT2djPVtQKUmko75LRKh/WYckUnhDVFq8tct8c6qTZqOVkZJOW4dWMmUbLGVXTlkZKFQ/LUPO0dFITY+SVYZlen9sUXNIaGyJNWt2SV1FCiqmsrWmaIQdHDaokp2yU4qlO3mHVG52W2eUI2B+KErp5+rBvtWNfbiMoLW3d6FnU1wYFk6QkNxdaaKyYKJYcYo9WXI7ZI9DJiRWWbifoKw6K53Uk8BIeK98O59P6uXMAAAAVXRSTlMAEgfSDZoaJa00/iUb/pH+b1Y8cko2/v398pGFJv7+ysa3Zf7935Hw57qxqGJHG/7+rHtV/v7+99WukGf76ejWk/6EbjPm3tfWzfHD/efm89mw7uycrUNQWgAAEOhJREFUWMPMlnlMkmEcx5EQoszwRCvSclmWiqamqR3WutZ9bG6wRlvm3k0FRweLGH/ElJqSTUQLNkCGJkERisdii2EZGC4JK5czJPNISy2z+1jPC0oXtLba6vuMP56H9/29n/f7OwDxF4VejkH870ITB1eGobwQ/7UwMqlU2pvph/gnwrg9xEUmeK9ZsxznOkmQSysqBgv+zEo0bm1a2gLcbpz/r65CYVE/nMTPRf9wgoxJMcvscqnebu8hEtYEOu9IlUuHbIb4PyBEzUx5dfjI/twj5849TNoW5ofydOG81qiFwCesH9a5DYqPI3zfEMi0jWqNbWBgqEIqra62201xwrVeKARqD5tdkT7LB+OPBsFRv0Xlj8Viv+7SNrzO/vTp05vsttzDR84deZ20ba2HtMwcaY/Yvr0sghDueM66DIslPX0u5hvGlXrbRH//wNBQBVsqZVcD2TmhOEQMh13dVR+PHiwN3rNxY3KQB67lOBwOjrt904YNm6k7k7a4OKIE1hqgT2/o2YdvHs7Nbbt5M2mNe8qF7e0jWiaP+SzAQbTG8vnzZ6UwxcvFmCofmOgfGKhgg1UBGNlA1XZD9MZq9nBcDnbOwCCHI9fXh/8QN4bBYrGo5GunyVdOgi3jPldEo52gXZ02FXl6uWK8puYlPTu7ra3N8cnNHl3tPiNR7eMKJpfZjg90bL3SOz5bDHhXUtDT+7smJmwVUrlcLpXa2FKQYwCp6VtQbx/uvRMZ09tvK9XLTUbhD4Wceq2sXSeicUVcaibYUrXjNWIB9b4LcnpeDUBU5R3MdohOz247Mzrb1x2i13adVstjii43h062V73FojREur6f1vtxYqxXo5HCjFLYzAoAaReuDgzt4wh9EWP9vTaOyaQx9QV83xObdSMjOgpEEXFZMCRlfFwhVqnEU5BRtJoaxYPjuQcBHf0gsPMNPfdm0mK0u/baqn3AY8ILSnY6iQldtYggdM0Z396PY/0fuzQwpcZmA4RDYIFaBEjehNX+6UMD/TaNXq+RE4XfRU5gjYwkJlJoYJXBkBGKmpdisUhU54RMA4w19OPHxQCS/gasbGDkqxmA4Wclt7YyxY0iHo/Z2B6GBN23FonFoAPDpl7Ib3BszKJRqzUauWYsLo5IBKaCouTE4ZFw2WHnDLOH+m1yvZ4jMwq/m+pbMxItFh1Eg2haB2QZU/sAVKXI6aTPTgXwcf/B/XSxdfTGjaSk0aRXR1SjW34CRCJBNsOSWykRiTwepRGq9IOpvp+0UV3pH7v0Jo1MrjSE4ON9Q/F9QuGT6rg7kzW7srp6eGBYry8FrYP/tp4w3RlKi5lFJu+kOJ1kNeoo3EticbMDcr1VoXhQngcq0vpodqZ3eGhmzoHKRzlB3+JhFq5fPydq67oALzR22ZL2dl771brWyrCfZ6hywjKmlgGpiYsDndwLfcOFBfFTHWpnDw8N60vh1nmy6Jvx4V3UoTR3MBhkGkVXlokB3Q1RIC5XxHSkGxWhULwUAEj6q+uzIp3F7+eb4ov6doaeuMu9e9862npySSQCGfDicnNOuLd3gM9PkKnmiS61TC2RSfoKMF/fMdB7qhxW8tnDw9WlfH4ph8MRznOlCBUiUZu7m5pIDNKkk1kkCgTRaE7IBK1CYS3Py6Nbb1z0/9rEyK+9sul+Q8uHS3ebWzMXzY0Gd2Bmzy8IRcTGRs7z8fGBH/CVZrOyS6nuMHd0mIm+CHeaDuh6SktLHZBxy1zngcHAyAxWE5kBQZOQZIhCBV0Epxt9VaFQCMpVuQBygdu4qXcL343fKhQ9i8dOvsDT9+FeMTNm5RQUCFeFL1jnGxmNcToV1K3s6oJ9lBgWo9xDruDzjRxACUM+wbtcWWeSqTMkJAaZBDVCTshDEBXIARmt0760lpeDETm6BO02rrah5d27W4UN1qf+mMnXXuCFCKysfApEMBjMSrMxjhANQ6XKZF3qYIlE0g0mjkfI/Hz+JGZfNJxqIORSk0xpZhxikJog0qST1wCiwOqAXEfRaQUCgYoueOTrPu6uhsKGhpYW3rsHESkJQTE+sbGxPkFBMxc+M9Tf6yyq7TCnp1uUxrjb0WCuK2VKYyeADClAeIQszS8GmKAsOfa+VVP/B553GpUSBglYCdGcTp69xqKeKqfSYMh9tRQdt1ygUl2dgXUfdxEXUBa+47UU8rS1zMQdu3bsSkzUJjbW1jYVSbqJBuFtPN5gIBKTA/yDZWq1SWKSddSv8gT5ln+huLg4n8/nl5Twn6+afOb686ZutYTBIAFRp5ykCY4KTtFA4yA311IoJ1QqVXnrarTD+J/i4ppfFBa2tNxqKQSOAl2G1dh47RCrDk8QFuDDA/yXL5+7LBS/zC9Yr1Qbg409xjveHp28UAwogUpKqkxVwjTn8T1TcLdEcuwYiZSVdZTqgDzGoJKOAkwwzGP31upoJwQHxXk5KVON/WPgtc3cF4DyQ8stXiGshstMXVlE3W3CSTzhNiEM4bovoahDbSYGP3/yJHOeR8ie3uLiC/n5JflVVcHHQsIdpiSU9BiDO4s6sxhZWVlU1nwH5CEW66iACjsZy4DAT9EJkcg6ey7Cg5C4Z3UUkPMW4CUvcWSkufX9+8qnybfrylhlGd2VCJeiHjd1ZDQ1dXeHeIZ82zN4AVDWV1VVlZTkl5yEBxhyY0+PsbOoKIQBO0kmXXHWJAkikclQM4BsqqVAZK5IFFEfjfAo9BdC7DY0iTiOA7i1ERU51tOyJ6OtoEfogdYTUS9Wq70IIpbnXZfz4cZAp7Z25z3ssMmVXrJ50BJuhbAXvihShmtoD4z1zIIWgrZGRZBBe9GLrSii3vQ7dXJvln/mNsWHj9/f73/3080DvvFv48rP+PpVvnf7v40NYYlEIh5P9K3XlFYFIE0YjIW6LUvmQipCuHyZckNPukNapS/Wnfj6cjgYFPqDBCwM6yogU5iCVModTJraEgpSu1QJbe4xfm1VVdXWreNjT97UPfTP+ONsPG56mEzU7VbNCPDmk6gnmdJVlI6SSxoaGvY2wKrNP/dBaEm3kmT/7+tRt9s97FPOaJ+/vqwJBqf7hSARJLBUV6HcnhSBpgBZuXIkYUomOL+/L10o7X+gmurTp/8+h51+le25N8my8STLtj3YrU4Sa0O76jBMhVwz2tRU39TUJKfXFsoN/QjQ6f4Q/IU0DdUg//oJjIJBKxSinEXCoT2VVJIksCTGcZy/Lj1HpdUD76u/f1/B6pnsicXiLHuTjZueqFp5TQ51og/G2hK6UyrkhK5mFBYUtpgk8NzTaa37ujsail45oKkc/vQJOpJKa4M2xVhCzpYbkC6XCMo+7bKyyGpTnFWMLBgzN2MwR7FvxqpUc2tuxOlyok6sy7euhBQePw7VC3J9EfnbDdvaHcqmDVEgRindkQWHaz7UTBCEVmeHWhM2tNiTRB9KoGR+d6OcK8xxNL1JCxunzMf2PdjM5PdXPbFMjIkxP5hIJBK7N6Qqdy2CcgGaRJ2ECkl92TVNUbJcQk6F5BBFpQeycKsgSb7lwxNZiLDLbhgaQQkbSaJ5JAKnRZIT/UMVlbVnRTEcps83f7yzFEaf+f9H5mZityMgzOBMhGEmY0zm3reNqnZASPFGQBRJz5WdJeTE9FRWlmeRC6PyVFSmJMq+XwdGQZC0q+WsR7Dx+lVHnxGk2WbjPQVkDiPJcJhTRrWTdPhSc3Pzi+an22Ho+j+yunvG38NAhjjD4Dj8ijGTP9+p7rApd0OEU1mAXLy6dOwclbOUgFCzyHp5QpYU5IYjkiwggl7vy+oRxIvoDYsaCdFsNPLkYAHpcgVomoOenHfcAsRz585dazkw58YuvWD3DBPBO1p7cavVCkYmk2Hu+tRTnYUURZomSV3+1vn5npSzkld6LRWRoxIlSBTC27efgRxBmbXrbYjZ6LVXaBoRizlgIYvIERf39m0n9wySPATI84C8/37LIk2Z1XjxbYcVd8AFlrW1g8EB2aL6lLMWCUB7i7R50LCioITdLWURGy9R6SJSkBCEtwFyx+Kc4IX/X9v4R2azraVKsw2xiAGLhS4iYa+0X+rdVzGvsvYCICHK8/cHlpdDesj2DuC1drRCkg4HzuCd+K8W1cOWDNKQJOwd49NTBSMgKT2gvHwxSUmioO143r5R8+7iBa8RQRAzXDUuvrNCs81rsZDQ08480gLGzku9SpLHXgMSlLfub9pQ7gu+7sCvu70Oh8Nq7W1vtzpwh7W9M/xH1ZSVjZdpCx0gaR4ZqNXMzyO7jYNmHgKbTVKCGcL7rxXzCW0aiuN4navDrFg39TD/zD+0dag7qAdFcIoiKHoRTG2gfeRlspK0PcRU6GUkKRS6HAo5OHpYD6O34KHXQHLK6Gm9yRiMHnoWvDnBk9+XbtK63fQb2uY1eS+ffn+/X17zhF7hduTsKiGCLlAqeELm19JU5Bb5JEn1ej108oO0g2hrTQY5K7o8L8u+79ri0xFPzh9lfEYq68XllVwxlystfymVitiQM9XIaLxxlQqVKO1tpqbCPFZ7q9SDY85huD8IrDoKmARe6FT3VgXblqQeh6WhW2qlIklrlQMnd5plTStzgIw8oYbtZxXfz3vVe4ePRY/mq0fXY9/Z6W5xm0ECUNOWl0sNWEnnRnL5TtyQ6rIsr1WE1SCMzEXSARQK4xCSZARBX/sAJyPPset5ni3YUoKbZZBWur7WbIaQurHT1DS+HGeQ90TDB6HrtxWXY+POXkzoZqu/CSPGFHtpVUorH7exWJTLMcZiCZRdMprLUw8EK43AoBKpSnrz8x2h57myTekhpIk8FCRJQE5GzmUoKG3q8XYc8UC4Wc9uty+GkFZT6zayIWQk2vP7MFKBWi191SMtJrMA/8d0X1fRrfgzt43CgUrITO3jvsHhBvtHM1Vi81kZlYgYEp3U+/vpNG/btu6cO4Ckn6gsUQY5Oa9KAs6U00KA6MNJPouN74gwKGM1AakZQ8jZgav4ysZGfgNS8q18vsVeBKk/pudEXV9vItiNRq5YaqCCytrKj64Zvzo6m95OGJbFKjEr03r982dUJe5wvkuc6SGkLlTWZEtnkKeeEwrrZNnoiDEGafKsY7rHqkMwms1suivvARK6VGgpG21sSj6vtNt4x36+1Zs7MVY3tztwslEuf23gDWoUG1qZ/7FXHXvKnLyK08I7L+hYSeIDV3Z1Z5ENclNVJUmy7QyDjLxViWwjhc3g9UToJOXlNM/3xG+nZgXDYj1DJ6HJJ1xICcQQU2G7LbMVRMdX/ZIFagAzh4zEwnoZpdeUtt5UkxN/nRY3DYsHJVAZH3bkrE24g8IxVZW4KgkhZxw0bNulhTORENKVDfgqiKcjUxlTNQxDNQF58HQQtPJtBS4yH0NGQDqYgMd06u4bsUMr8BB4lmXx+983C8mjd4HdAYELvIZ/BHCURZA3XCIOIYmpAlNNBIDEqSaBVCd+OoTEvmm4ZuI9LpZRTRNNLwBkqIlrm56SR7yZoUobjiqemFg4slJyOnp1V9zaSyT29uJbweaVV2fuHDfdR+e4jmAgNzFPWIYl9/vz8fe1mfCQWINEcVAL6+h8VRTRfL8wwUy4JqLFDlaRGDjCNBj8+QM9GZ1z+j4rmjyLej/B1ZYuHbsaHUulru9C0Wh08TK6H6tYdFAr4Mf02Y8pOBxXS96IDY9MT1+4kErduDHsO3l5epp9MzSLNRZTWB2JwTc0INYYufqlahA4HEZ1MGjwcBH9/kFT564tLNyElm6efBw9G/lvOp8Mx11aSM6MPDT8Bttuzroj/32EAAAAAElFTkSuQmCC"/>\n
#@gui : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\nis proposed to you by</center>}
#@gui : note = note(<center><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABBCAMAAABW61JJAAADAFBMVEX27vz06viVWEaZZlbz5/Tv3urwxMeFXE2icmuBUT7w4u7QzeKaaFqRVUPs5vWKVEKBRyvr4vKRWEfSj4d/aGWuaVjkqqaca1+ATjnAfHCVWkh7UD/z6Pbv1d6DVUSGUT2TY1ONWUji1ubv0NiHeoaLd3zEgHW8d2qQYFCOX0+LUDri2uvcnpeQen+md3GKYlaYYlGXXk3p3u3Z0uTFyN7nr62Aa2uoaFehYE93Tz/tvb7su7yYf4XIhHqgb2WRZVieY1KKXk/u1+Lvys/uwcPPi4KkZ1eiZladXk2ZW0nn2unXxNHpwMXqtrXntLPfr7DhpqKtk5yHdXuEcXSoc2uSbWeeZlaIWUjj3u/uzdPTvsrdu8LHrrmjipKQfYZ2ZWalbF9zYF+TaV6gaVurZ1aCYFakYlF9WEyJW0uDWUmPUz5yTDyETDTd1efSyNrRt8HOtsG8pK7go52IgpTMlJCbhY+rbF2QXEt7U0RiSTxXQjJ1PiLv5/bx4/Hw2+Xfztvmxs6WpMLlvMHNsbvCp7CalqqkjpuRh5iefX+iene3eW23c2VhXGWpbmKLZl2wa1unZFN0U0hrT0U/OzlRPC5aPCsrKyrKzOHCw9nnzdffx9K3u9KvudKnsszAtca+r76tqL2UnLfcqqp6iqiGjKWxmKK5mZ7VnZmbipbZmpLUlo68jY1rdY3JioC7f3eveXGfdG6wdmxpY2yIbGqxc2ZRTVNkUk9LQTt6STGFSjBHOS8qJR4gHhkWFxLd2ey5wNjGvM2JmrmvobGCka+mnK6Pk6zZpKNpgaJ+g5mtjJB4eo6UgYu4hYHBh3+ZeHl2anBsV1RwSDM9MytmPig7IxPSz+ShsM3lubvetbl4k7TOq7LFoqnSpqd1hKLHnZ9paXmVcm6FaWRMU2F7XVZDRUpeRTZTMBxgMReaqsezrcC8n6mklaKfkaC/l5pbcY+nhoqvhYNMY4Cnfnx3b3xbY3eOc3W1cGFcWGBiVVZbTEliS0O4qbjSoKBQaYhBSFRDMiYCeYKqAAAKU0lEQVRYw42WBVhaaxjH4XDOoUREUhBEBQRFBLu7u2N2TqdzttO56czN3Kauu7u77rq7u7fb3X2/g9db3OeBv/Dg83D+P/7v+d7vPR8OhmE8Jhx4GSLsSuytFYyHceD9l/+fiPFrwD9/0/FjiHEM3tiYMXaZ9vt/+rVULNxfoHE39oH5MTcex8DhYB03EDCmL+z6+NTPVStWLj+xPAoGtH+GGxNAjPPB57/lOPNS/74D+18m7d7d359/3btTCAj/QowVB0LouLGvnbd+8/2Bw7cOHz584Kf9+3+4keSdMAXRvQxE0Amvzb/ss1f7h5tv3Rr5/ffDzc0/zct/kZ2QMAHWJWgpugu17Mt9Tc0HRppHm0dGR9++bX7blP8y4aMOoc5CG4M/XRkv+/LNyEhzU/lUUVrARKKDQ/GNn35smnVxymKK7sX/V8Hdz74ffjdKLi1tJBBS85KTe32uSH840OSQKTTXTWv8P7yH3+w/cFBOAApzcxvY2ysLYSqz9428zqQY1qrOX/7wI9FI6w8NbRjYa2MWwuTEf/5jQSZiEIBx/rf9xSQMkOof6ubG7sMANS5xl1OqFxkEeO/X/te+JMyv9ncLZbP7zMyYTE6MV/vG9Y8M2m4Pn+c7+HIJav9UcAfC3NhsGzOmkhODCk90P55hgP/4+eusAl9QQVhqqFtDQ2gD20bG5Lh4oojd2exoAxIseOq6hwQAqeAWlLiFjiXgeAajCLKkPhM24BY83UMikQYVRAGZrvEPCy3SAoJRAKD2PKLoByzbmkIicec2jb7//m0yFD6nKLShoXfbhlg0EGntemwA4IPnJBWpeG75zZu3D5LpUAm7kJDWVB6wY3MQJfJUpwGAmbt3qmbtKSb67fDzOGgLsWXbjSx5Nz3SemMojmc+MgBwMufai8+/HSwOMJo41YOn+S7u2UTBQQuaenvcDMrZ9QYA1vTv/Mo75fU8oHKBwK8vfhaoR6D29fklg7JqPWxACf2k2df2TJw7r7z8puBguE2NN2tu01uLbXVxbcKVj/QCjFf2sJJJvgUOxLKpHqIyD3ez2E7XufNul+/d4rIoavlivN4usJ+VsgPsJEVpY5qInkYrkcU8uvhyIj2sZvXqzJ+r2/QCloEm2EEqJKghuoUF3RSaI4uPjd+yk7tXpryfuXij/k78QOWbDABhBD5EmwRB4SV9yuDVzO1m25gcNIOS5WmtL8LSr/J2qUh5oe4REA2CNCVFQ/FI9BYwEWqCUSEyIUGmD7Bw1sCu2aS8VPdwQACvkqJN94VbGmxC4tEg6xkZCdtgfXvRPg8DhLlH8EEJ797R2HmjVwfY3/nUoNbW1tHrz+lLcFySl0wiFWIl2NraVlTQbOp2MZPDi8yUwRnW1pkbMvQ++2eqVMmkwtQICAIEMrlizjaO57PC8O+YMWhG0ON4/Z1ot+KiimTkD4EloNF5PAtan9Kz/aI/2ycWRdEn7doK9N7HnVwN1gOgFeg0/lBI7P3Hu9x8OGhQUHQgzgDdrVUZhdPJPBML3qFDkyLYPkrlFzsIZvEAYA0bkoCxlsRVQ4BQMc3E5BDE3hx/pUAcZlaDZgSO+/VM99OkQjUEKjA1nUQDvczxav80ZQCUkAGPGVsWdnbM+BuhC5v5woig4YM+VJta0N3BAnrGbfFhuqBjBeDxH9SqZLGANX5i021newJB3Qjx1RpL8sEKdkgs+uDJBiUHHdsHeOcLKYShDfBfBz1dQPoF8FhpbOTz+TSybbgN08WrPY7DcUG1sc0ZJ7+Va4qYQlhrNsebm//PTQAPRjkxjUa3oEUMhShdUM/ouDgvdLr2YHX3aQqB7w4AY348rAvArykAE4UoIpN5FlCJjdIlGkWjY70QGPPjl1wqEPPdNyEw5ofxxuYtuhuq1k8sJhInepDJZAtoKORce3Bb8APwk1rAUkmBBhriAABsDsPGeGNYdxXsxfIAAJgqwAjuvXWrH7Q/CMJjUUHiBbVG/PC+GCwB3MLAw/8F4BlLan3VmlIsgQfIwKMXXa17sjpa+OdpFLa7QIhwt8EA5uCkyzBnMIBpvL9aIiuXbH3lQNBAjUTR1LkeHgIyT6BW1f0SgyIUBA8DAmy3JiVijpknBYbh6S3TGY7gsA1WogWhWFm1RmV19fT8Np8M8fmNpSKBQHCTTBaQ1bvqXLxiAx0roygYIP00FyrZ5oVMh7VuR0dHnFNr1ASgqhWf5OS4SoeP3qZBfFNLOkYANYgK6+I80csJFKvjkaAKSvoabvicTVgiBoNh55iezsBNAerI6ly3MTExKTf36LE7h2iQKd80TUTmlfMEctBIKPrxDSF1uqMdSEC9IIaKNnkhiB0jMjLdzsrODldVVZXVvTGhW+LqmpSbf+TYHZMKGoSFEIl4ZNO9Sk8UDTrzZrWTFeVuZIvxaVeyRYQsVohgXiuryZOtcFkd1R9vrM++LGW5uubemH/s2DSTCjCQTC1NIRotXAYGOprRtefqs+qsrI4JCy8Npvn3bj7XBqxO4AWE6zy1rt47J8dbwmK5sjDA+yYmk0ACrcAo8vIK/vQayTc5WUXaqbpy5eoGl/uZ0dZWVKoV1cmJSnXCJdRftgfyTsQA+fNvHQUAWzpkSoNABnaIC4cDxqQvF6iggEtKlm2KRgIXzYCXfeh4nIoJJ5FIpVJ7b3vpdUDInX/k6DsT8FyEsIliCRUx489tAac2LtihRlyuEbeQa8MxpyAIbunZVvMxQE99vSRJai+1T8rPZwHAkTsmh2xtaYBgSYfmMDfXzeYSjLTy8xODUeHuEwgjM6Y7nZxCXagFdHd3f5KTKJV6S3YXu+4ePnLrzjQTW1ADEI3G9pEpr2lP3sCuKA5QyBXQ3hgKskgYebJj5konZ2olrn7FihVnahMT7bt357KuDx89CgAmFSCCRgNBYQ1mLi8xO8FPEUAEe0xhaem/yTqwdfHi89UPOxnOzlSc9/qoyhMf1kq9O7bmsr59M3/fkWKyCbYQ7AECBJWEfDWSJldYitJ4PB65jEgUiSCzGCRwwpTn1acDcZOdnXE52YuWUyvPSj+PWvM1K2ff4a3De1hTsYluI/NtpLtvfk0QK0rp4LwzelsgArtcpOj1QiitWd+cWgkz0gFgbXbb2irqPUm29UmJq/T7fScubEzCCJPMNs8qtXD3zzMCBWAjoqwMBAgQc7c/80QolMpLH0Y5Uo2PO+POZEedX9e6tKfe+t7axKTrw9Vbq2pZL/wqbIdqvnCg204jgFvvJ5djQ6ZULh64uiGuLRBBKJEnVlktWMrAOePWfVL19LJwydps6/fWSpKS3kz49Yvll1gklT+bOTuAZzJNQxAPOsjFAQqxQk4gpPadC0LwAECx6oq8t9IRPxnn3fPRWUnWkq51Ue+tkiQmvqr+LP/TrueslO2y7XLgt9wpHhx0cCBiUmBrwAxGhEIEyGrBw+WRduk4+5yEVZL1lavOLHZeJZEmvlp3vn/2qa9zWbOvXCsDgCdfOwz6OWgJZZallnS+j+eitqBABHTjvTWVTlTGH/5VIUZ4CClbAAAAAElFTkSuQmCC" />&nbsp;&nbsp;<a href="https://tschumperle.users.greyc.fr/">David Tschumperl&#233;</a> &nbsp;&nbsp;&nbsp; and &nbsp;&nbsp;&nbsp;
#@gui : <img src ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAC/VBMVEW3xMQAAADUqJoDAwEICALFmozFqIwGBQG1jYA7O0EfICUdHiMPDAoODASth3svLzYFBQQoKS8LCQM1NTwaGx0SDg0bHSEHBgYJDQTRpZfCmIpuVk4XFxh5XlU3N0C+lIemgnaif3OPcGZ2XFM/P0clJSoXHAoUFQfAloi4kINrVE0QFAgJCAece3BZRj9WQz03LCYODw8UFRjNo5WXdmuEaF6AY1plTkYpKysuJSEYGBwlHhsYFRELEAWotbWxin2ffXEyMzlPPjhMOzVHODMkJi4yJyILCQi0wcGTnp6CZlxPVVVDQ1VxWE9oUUopKzQsLTJDNC8iIyUrIh9nbm6LbWRZWGOGaWBJU15eS0IxMT0gJCkgGhYSEhUUEg8XFguyv7+Ejo7Ep4u7koWphHibeW6ZeG2VdGqJa2JzWlJERE00O0NSQjouMzkhGxkfJgocFgkQEARBQUk3P0diU0ZBREQxNj4uLzoqMDZAMyoyKSY1PyEQERMcIQ8LCwwiGwgYEgYSDwSturqfqqrKoJOvlX2UfmpXW1tJSVFHR1BIT087O0hhTEVZS0UiHxsoIA8nMA6wvLyMlpZ+iIh9YVhPT1hFT1h7aVc6QUlHR0c3OEVdRz86PDwxMzMpJyQnIR4qLxoeGBMcHAocIwjHnZDCpYpubXpvdnZvcnJkZG9XVmyTc2leXWhWVWBOTk5LS0srKzA/Ni47LyovNRofIBQkKxEQGwq8oIVcYmJcXl5RUVtWV1dMS1VHPzgrKRSXoqJhY3iljHVbWnGbhG5naWVQW2WIc2BNTWBTUl0+P0xFSkk4OTZ6hIR4gYFze3ungHFQUGVjYmGDb1xoXlVdWVA+SFBAQFA9QEE4MjIuLy80Lyo5LRmFhJG6k4d1dIC0mX9vbm5UU2eNd2NJSVtGSi04RBYyPRQ6LQ+lsbGapaWAf4tsb4Z5eIVYY299aWlDSlN0Y1JvX09RSEBMQz5CPz4/SxinrKyVmZmNjIufeWF2Z12ObFYuJgeXgXY+PimhEuIiAAAMWklEQVRYw7yTX2hSURzHPZ57UeIqcvE2/IdOiZz5Z+OqUxRnc/iXDUrHGJhOlpuDMIN8mA+p0xJGU2a9jDlXIRgEjUYPG6PtZU+tFVHQ/hD0EKxeeqgoiIqu+1Mrrce+cO49f+75nO/5/X6X9h808O/lMcvfVjKumjIZT3HsX4C3RRrN2eDYR7enNrjE1tbHucTG4rXJ0F995KouZ7XOxcraxw/laDlh8psD0Y1o28yZ238DHPGUxkJ/enT52ogNP4SEFygJwDFjDliyvMk0BAjX45bxT79fovgxYOZgsw6oNI4qIXaTg2EQlnIrDQEGD3fhczF0eOrN3GmHIOJ1MxX6qLHrqk5hw0x+AGYsjQHjuaXqo98cWB4qFWQky6PzeJJmhUqalbrJl60AxC2NAa9y48Xf9zsUZ3t5Ffq+Xko7SOrZa1YWnZb6hHnGF0vVMdehMPowQUXWjUoPALzs3ksVzQ08ri+J0NTdBd9YaPUnemWzhxSPnqWTJP0PWVcbVdTjtuq4J+OJHxTKpIGI8BQROr1Zsntuyy9Atmu1AeDFyczk5NuFjPMAIGwdtSp0tQjubrpDQX5aWGtQCty7S5MZn8+zvnIAGNX0yw8Zp8K3F4MKKdM8qg/i2sy19Zm7S4uPB/YBs9PRTt5hAG8vGJUIaRVw6zP5HBoMU9y5tYMYWPJGwka2qLL0OvE7JVt/Any055e4r0qbc679n9DlafLrjFKyIiLrAD32ygMK4Mw497+lkl+irT4vx59Oeaq1SeeAL795U0u6+3gkX7Vr//BltApFIrRwO3Qst1CdHHAVPZeowqCVVg2LL3IzPgpgcVXj5bI3q4tIVa1aZm1PM/uwhYr6jA84hADi5pnNo7OngXDFQ1szTJWE3IcLb9/QckueYlnozarYIjMw6/v6OujkvgPenb5aZkYuxQN5IlbY3i4AvMAAwOygGcvxMnZm3VdcsVwz5F5wgDc7JOoSCLqvtzq8CrK3km05Zzun9tpPySlAk8GfD2zfYuDpGJ5kJHGHktYUJHAEaVMKuaeFTW2Y0pEYmieIU10Jqa5HOMJDeb3XE8b3l7/NG9UUgPPgCwZYOzvpFJLGWTuxJItmBgDHY0kGUH6/ceOGn0jkmzp7ulVqAnb15LF+Se+dL1cmavpgktBHsGf3TIBRSMfArWQhCWMpQLOD4wAGWRAoX7++HyBknd3XO1qmNRrO1jNp74h/3mS6N/EuqmwavWgy2bTGAHSkYoVYGsdBOgVvAkCj2p5uvl7ehq3t04RdEtaEZecmnmkiNuZgpJ1te/dudjpiPyuax6IExmDFGAA5j4DkDmRRAFATQvXMy4UglMkEmLq7Y1DhZrL1IzKvGB02Dl2fmNA163SivmbbVZGdEWQdh6kLt1iprxCnABACKh0QAYXtWAz49e6AWn1V6pZq+eI+tUksVykEeiYTbRmShZvl7m6RLQU5QQAhA0my0pACpBCIBzngAtgV8eRJoF9uVQgEonBYpjGKmV2Doqtn+WK2VNRuZfcLhqNgXwiCfK1dgWrgxv0TjAPAtEOAarUoKrcyVWa7uOWcTDrUYu206SUSvs6mkAEIaoLwAkgjNQdBanSLFYMIYw9wyjSI8vkoynSjEuMwija3C6xsvlgsR9lhk1qur3llMBgsiOMQT1OAPLXt/vJyAUGOU732jlOz4kE+WhM/3MMcVqHtw2zm7jgik/Uz7YASC+5eASJpqpB+sFQ2IUqEYRyfl/eVmUCHYSt8UQcdrRlnRx0NP1piUFxxwVAwMxEqCb8SpMGFDrUNdSk6SAjZIaIvpSA2otbVW12KDtWlCIqIiKg9dIqgQ3TpHet3GIYXnv888/z/zwyacWCzVjtrQ9BKzwVkVZ4XMJl00O22MGrdMof1tDKCFdA2MAfSEk0UKKQhSYREdcFKhO2F4tFK/FrU7Y67k8XlYpzpX+P9Fj/pJzbstDZaVrKKCIDeAqDRuYWRDVCTrW+DgaTBmlSDgKzYzrzP39m3L1zOlxL5kvVEqcwKbJ6xMMEU0+onreTRBJpkyNbrIShRmqSL+tYWtiFAqEn2ht/h57vHPdalnSuZdNpZDW2UU4V4pxLzt6os6YDkEAEaggUk2UCPAhCLhoIh+I+d9fvqFn89tJLrqDmejzqj+bjcXWowwXTscBb2SCmBXMjUEXFBGejKE2KANUCOFmjI5YjhQsoZVePxYW69HE9Z8jud6rrF4k62AxDUaKDR/6YooXM0oNBYMaSRSHMcGQ+EHLgZDVa8+X5TCPed/VKp0FrMqnJIIInwdlEPmOGh//tAxggoHSARYGIE0nVNH+NZoOBsMJmkW24W98VzsWFiI1RgTIE6exhIpl+kXsEaNCXMV9BmmjLDioY1DWJzkmHWwWQc3mjQE1oOrKSvNRx1byxJglDeCfB870ww/ndHYaRhPJvNtKORCJ4ZSFRE35BJy6lKxuNgvd6kzDgYdZElM8gAhMF/FwDqQWhDCFEAcBo5VeDJy69cylQUp8al4w5vnlUTxfbGkA8XCkIydpptNBJ28A+MTZ3BVP9FIkTdIkwVZQIjr465ADD1Nh+32KjcZsLZ5cCyM7GeYCu8pameDq9IY4I+GG8NpoNfv6a6CEVqjfB1bbImGq4XR0j9Gdeex4+dAsmCp+KRfesCry42u4ybf37h/JufNzYREgfit2+SJo7GYm+MKQNCaEynhkE+ChC+2//g84Mdp085vUmhWiqwQaERdft9xTr/5cfShQ+rn+6u7lrdZud0BU0MGkqiQhlmCxOMUGTTRf57By+/DB3OJoqynBTasQRbDfssjlCx8+VOeOnp+107rnzfdv/jvUNXIpGjoydPJkQAcByHJ2uTva+fXd2z48Dlt7//3M5mni+m2zmmwjc8cpPxpLtf7twJP6puX3149+HFQ9/v7vr+8eO967vRaC7wt6ayCW0aDsN4RCzm/xfTP4kpaA0eEhDxq0Fwxh2MGi8GEouWmFjBXoTUeGhr20npraVd1Yu0q1URD461tm47FWuFtqNrK6hzuokgzrGjil/gB17MBH/393ne530Or8uVvPHg0cQlsRi31HNXn/8Z3nS6PnN0+v7mzee3bVy36/zhx7MBR/3xi4M1b7nJ8SaLr0KW3+WzZ+3XduP9i0cTLx5xghGlw+jck9/7nWvuphztO8Ondq3fuP3QvgPDtn878msikc28/fguDzPVqm+8AbkpUP2IY7ceTg6h1wzo1xi6q8UvPdty89iZg18DgZnIhU0njl05Ox2Zvee4F7n9EOpUtWaaRSZcZHNsbnm5NRhkxrHjbpgh+zhrIXf8U7AIT04c2ToyMhZwBJaW0mPz6XTKYZN6+fMNIng2iVpdujColJTeoqCaZCOEsURTzTA0Ho2rYAHQweT1oZGRvXvvOQLz7bELewKOf/PTvyY5hrGPqHygmVxFknOyXFSrPuYjNi4KUBV8FKHQyHDdjtOj1717926YrQcCS/PtmVWBQGp68pIR7FUk2I9+HsC5FkBRXQZ4iDHLWI0RcC8xjnhe6vqHRqkSGL3+fWRDZEfd8Z/Uq8kbKEfKHbgTfYrmvKUWSBpSh1Y1/F0ZIxmzLzTIMmuAIE0kaDgHnpz7dvd0atV76XSkbuf/8cA1V4JzDFqrFTslmJPXUD2dgTWg9msYp2bjkunJQpcnGPYwxJSuJ0afnrw2vbpBfWa2PT8TGeL1SrArkoSzEPsAPSvyWkCQeeQjCZLF8q6MXQNu22tEMpGFMQU0p+DDB7vbY6tEvqYj1NTKSicXRAS91hYQhF6MJgS/iji7liZGSXiIoqNRCLUoT3hdJGMgnFtz8UL6y90NZ76mD1/DG6GerNe8Ccbr0oTlxVIlyQJfk8jbvfqqmCto1TjNWIiDoEYRIuFnOUjGPUn/cGQs/eXOxZ1ixvtZIX0myWQF65PSEphlvMHhoawPiawdwSTDMLxgRAsgXOAJXZY4WpQVxIeAy3V5WJEInGM/A1+ZdJMiwAuxFX+PMxEtIicNRESSGBJBtBi3V0gYQYHhdcMUqVJUkaBVXLCCMUlnGI4uNTiax1XCFlAkmcapAZ53rnGzXreFAcPSDAXGw0OEpWYggfwxmZclq4AoIRyWlQrQKyLbcIfjRYvktDBoDZrqYg6nPHzflzU5DAF/AqeUboxPJCQ9V4LOWMW/KFmwKcbU7KKkzHWE/DjhmSpoCcLZ1fQO7uMId1VI+rM4zXr/AnoH9FcRhS6kAAAAAElFTkSuQmCC" />&nbsp;&nbsp;<a href="https://foureys.users.greyc.fr/">S&#233;bastien Fourey</a></center>\n\n)
#@gui : url = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","https://www.greyc.fr/?page_id=443&lang=en"}
#@gui : note = note{"\n
#@gui : This plug-in is based on our open-source libraries <b>G'MIC</b> and <b>CImg</b> (C++ Template Image Processing Library),
#@gui : available at:"}
#@gui : note = note(<center><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA/CAMAAABnwz74AAAC/VBMVEUCAwMBAQEDBgcPExQIDQ4KFBcGCwwQGRsPISjxhycoS1YZNT7rgCEkP0g2PTiOVzXidSJ4OxgXGBg3XGkTLDQbEw4eHRxCa3gyGw0aHB/uchSHPxlYVlNwNxkdHRtNKhNNeYgvMT8XEAnvn2vhjkjQfUi2hGWMZEo1SkzXbiQjISAmIiAcGRlnjZoTExM/IArWw7TnhWfti0igTjYmJzKlVizpcyeoqqOoRhfIZR8jIiBmMxQqJyqFpa9VLxhhhI8mIyno3cC8vJqJiHvkqGzujWbukle5e1CBRyyEn6I7XGN/RSJBPj0iICFnOR1aY2SgVBl5nKciIyFEJhRcLg7DvK7nqH3vr22lZ0qsY0TeZT1kOSerSyKTRiHg3NeESSd5VT6PsLuLr7tGRESFiIN0OBM+TlwyGgwODQ1XMhM6QVprSDzSdjloj5suMy6lfWE6VVxxSC2QPROUcFePbVSJjojTx720zdXDazPGurA2U12bgnFybWhjW1YkISAnJCNFM1Tzdx32exgyNzMhHx75liH7nyH4jiFMM1UtMi/5kiDpfS/ZrowrKSf0ih/2za9JRkX8pB+aXj9EQD8rLirteR3ncxz68Obz1sD1wZjUo4DBjWlRNVg6K0D6mSP3hRxsNxe/URb56t7muprtvZjhr4lqa2gyLy70jinwgx/1gBvpx6/uxKbzyKXztITcqYBKcH1mT3hmRGpgOVxOM0w+NzV5QiTuciCmUB/8qhzfZhbVWRP65NPgwp3btJn4yYrOoILBkXL7yW7QjmxaNlZOTEpBLknxjDkvKDLQZSDgbR59ao11XYT3xH14dXNycG/Wm25RP2fCiGCKblw7V1yhdlVtXVJEMVBTUE+daky5ckkyQkFVRz/5oC3CWiKwyL2Rsbn0xai+o47714byp31kYmGvfl1fXV36uVrmmFR2WkayYzSXSCJJMSG1ThfW5+PE1tL72pPmvopxWH9WS3adg3FYT1v7s00+OUX7rDJkj5mrlYVSaG9uaWbbdTHVCtkHAAAAfnRSTlMDAQkhFRoPLij+Vj7+Sf7+/v53aTRHm3pkXf79/LSsqIh4PP7+/v38+/v5zb2ahk7+/v7+/v7+/Pz38uXBr56QU/7+/v7+/v7+/f368N3Yx7enkYtw/v7+/v7+/vzp5uPMu7u3sJuXcGZd/v7+9uzo5OLg39zb2NXUy62ggmXEYn5YAAAF/0lEQVRIx+2UVVAbURSGl92NJ00guBeKFau7u7u7u7tmG0KSxiGQYC0ORQu0RVociksp7nV39053aR+g02VgOn3r95DcmTvny7n/PTfAf/7zbyD9TTGBCOhM2Yy7DRqYzRo+H8CH6MgGR0k1df64qQHo782WZkiZ+rh+MpFKA9aEKIdbAL+ALJy3OkO/ts2SfKVhobFSM9z+R5OpbGh/jF+gJvYj8II5Q9VqdXExy27OAggAZ2kqrf3CfGIzRgF4wATztbQD3tKkQM350Ea6XC6WC/n+4kh1pJw1Z5RRUlIgM85HkY13BMYGCCQxYBNvaUOgptFQuUql4kZFBbhwVfJIVqSqOEUzMFDpo1AwYZwEBr/YgH3rp1cqNTVb5WKBQBCACoQCd4HAn66KSkYNfgrFfTOcesLsly+x+Im77xsZPQ8Q+IsDAtwvowjkqki5MEDlkpzCjFFkDyfgjA9bb+qLg1h3OtZ+KZGClk/u7kJ3d1QhEPP5LREBUVyu+mlNw3ASzgRQR46cPfXmJhAzrC7yb8m5k/OJzxegCjn/Q1lmWYELl8ttnW4G480AzXw0dc/NnW1+Z7r/w1ev7uS0qNAc+OoPdzIzM8uiuC4uV1ai44QDpE0jGFR/1cXWJmL/nNc1NWUP6f4Cf35kTpxNVVhmASooHuLc2TsggQ4ebhaoK0gc8aj2tsfjh3Q+Cn2CTWKhR5gE6+C5CYAPw5FMktXbA8CCVD6fOXbwgEIrihiFMrnPgAEftw/CBEErYHwBRIUB3cR6LQ2TVDG/l9cNXiETFQiFFN+FogHbqpJRQWrQE338p0rEhnlY3gzCviAhJhg/3iZCiEKRjguPj49D6w1TgxpxzwAxqNir23LOWNcoiCWMSB87bnAlJpBTKtDlwsVY/ZWg3NUA3hzMHcnAhsB+fJ+MoXZ01uL0dKkVvd+kXgWSXq9j00MfqQ1TDQ2HxE0n4hi09cy1sX+NE17BaZPpdIrdI0s7yd1bdy0nFrB2TJhgVaS+4mIY9MR3Fu4l0kgwAGsTDwV7eXk/oURESFgsy74TJ/bNDe1lV1Sk5nLRS0yR2mzGSRAmUEkQzJ5LW+WFCu4PlFAoFMn5RX3Rep8KFhelKOXp0rgaM9xJZjuyCSBDj3w0ODgtuoo5cJBEIjnvc36RT6xPxaDk5ORBQxt9s5jzAdwERq5ypMIgDJwMDg7uk+jn12jVzzLU13p5Q25W2PlJkyzjQrJsRpHwh0DbfK0eBGAcV4TWNjdnh8TExipirPv375+lUNyKkVqv0cfyxxeQ9cjkn+utR6Y3Nw9sbfTLkoaEWC3zjQnLbphiAmn8BNcAQG2fbcD28yDnjSsHKpV+vrm+S5ICjYYMQQWdGjAIZAYBe++gjpPpzN4cjmz5EqVSyZyStGKZpPjZMHtTLQugUwXZfK42oGFh2qO6iSfyRDgc16rKyUv7P22V9OsnecZBPEW8XbokPAGBBjPWHWYT502znTY1vkmEIKjhS0hFZcYt9DYLUAEHEfF4PXpo/dkAstcxyFQ9Glx9Mz7+xmdbHtYBp09oWIi3d1pa2t3vCCJrq+cNwxEwHGkgDAEaWtOabOOrm3qg8HjGtY9vR0dHe3tHP0Y8eSgiz2EGOGcACSCRTUNDgpxsRSJbT5FIhAXhmvjuXUb07VqOTOQpQzgznQidhAiPpgKogTzaoOexmTJXV1eOazuQwhEGELYP4EME23qByNrmPS9cuHj10qX8s23k558+c/1tT6DLgNCYhISECxcvXj1z+hTGaRwBPmPelJaihvaChG4JDEpLSt78JtjUHYHW+5KS0vaC03Uf13dHYJr34MH7Syh1dXX5aJSFCEdmDHa9Hp5hHH7P7RzCaQfiNqYbJ3C7dy0cE7Tn3PpuNJAXfi3c4zeBLK/LLeh6GF8rf+Dh2VGA8GaDXbxDD/QE5fWJMk5HZG5dHIURHvXh5d/ceMhvAuTcvC7Va5BGuIWXG2MRdKS3E9g1gQagMyLPLVGGdCzXhYBuAGk59G5fba9FALoL0WKLk6mDg4OprpYOEfgPPj8AH7GtomieWx8AAAAASUVORK5CYII=" />&nbsp;&nbsp;<a href="https://gmic.eu/">https://gmic.eu</a> &nbsp;&nbsp;&nbsp; and &nbsp;&nbsp;&nbsp;
#@gui : <img src ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA/CAMAAABnwz74AAADAFBMVEUAAAD8+/v77u/9+/v8/Pz47vT25Of04+aYbXL03eD+/fzx2tz89/v99/n98PHDn6ns4OnQtLqshov88PP/8/T51NT46evz4evguLmlYWn56PDgwMK7govXp6u0YG/CjZWUd5Dt1tqTXGWIWWLx0eLl0NrAcnnIeYDw4Onlxtf54e3z1+Xs0d/rzNvz5+704ev33ejt2ePdv87vt7ngqqyoconZpqSoUlpwPFndxdHgsbTGorHDm6zMg4XBbHPPaGqjOUW0NUTxzN/jv9PSl7PMj46zYWmfTFv+/P7YvcjuwMLOsLzmvrq1i5/WjZe3Z22oRk6UQk359vf77/TuutbkuM/brsPQqLrXuLXMpbXrrbCxbYi3cHaqWGOEQ2LDT1e8RU+YLDykLDqPHDD17/Lgs8nWqr70oKi+kqa0gpnKf43AdoWVXnvMc3qSU3DEYWTNXGKSQ1WbSVScP0uAJDj66fLrxt3sxNfw2dbqvtPdusvfxcPWoLnKkqq+i57hhZHTfYSpZoK8enqsbnauXGv66ez93N7qzNbrycjJkZ6xeJLTiZHDiIm/gYSxeICjYXudWHfCYG+OUGl6QmB/N1a5T1WvQVCsMj9eHzz0x9/wwNr8zc/VtMPhnaPsmqHYlKHVnp27mZy9fJKYYoSld3yLWXmET3GEXGyZVFqGOU+PNki8g5zkkpvRlJiihI7Xh4yLaHqYb3nbbnFlMU2pP0lxLUn44t7rttDKhpXhkZCaeoavZXSjZ22AS2iXX2ezU2GPTlq7HjH61unt1M/irMuMcoGfWm+bT2mlUWa5WF3psc7/q7fXm6yrfIuzhInfe4Sjb4LafHb98vrm0MvgpMPBiafLn5+ieZW/kZGXcYueZoeQZG2OQ2OiXWKJRFR8Lz+cIjH5zuXhtNP9t7zSnqWUf46kaY17OkX91dj+xMGsjZTth5GFOT5RFjGGEybjxsz7wMjks8H5r7HMrarJgqHjoJhvDinu4NrWjn7NgXOhO12uTFzKaYJvHzpyRElCABtwx6DiAAAAJHRSTlMA/pTZ66c8G5RtyJC8rw7PnpSQfSTMUfTllM/Ev6+U7Ojg3lN8FIp+AAANFUlEQVRIx5SUaYhSURzFm4pWKlopiqB4+hz35ZW4jFuluTsjjUuZa2pOpqVONlZO5VYThZFKuLRQUUMRyCRtYBZUUmBT0AItQn0oilbaC7pWEEHrvV/el/fjnPP/nztgfhsRQ8KSiCRiwKYePGjU+ElDB/zXaWqyETEYEgaLJRIDAaLNZmtrGzV8yL9TmuY3qUlkFANFDpBI0WhUrY6+DV4LnQtOHD5h6L8CsAQGSyyOM3BkHCkQjZbOyZDd8+btZiLPJw4fOvrvgKsBfBebynqWo1IZDBQeFUzI9CdOvHe7e32tBzfuZk4cPvqPGcy/GsB1saXSuJjKQDGaUahn2tmv373r7+da6vxMqsoRoo/MZk4c+RtDg9vagIK4VEqNSxlUMZCASsgA4H0/l5vJ8DN8L9dT4xYKwkUb5s2ePHLCLwA2GwlHwOGwZBQFJQYaxN8BHq4lw+ebvEWvscjl1rj9bg6cP/Jg8tThE34GXFWTCRCOTMZRMJgoMUokBSXI6/fcfi/XwjfxTUVwU7Uat1blcAo1hwJ9Z7fk2Ywx44f8UIAld86R5iAsNkAkkjCkaCyrf30COChmgAdjQ8FjT/fjWjfncPhxOBx2oyWlEFusDs2cNm4IADTWoNPudOp0bDEZhcJSsDEJonjXX+QWLXxwvF6jN9XvDnMO5/NKpbs7XDs8O1R6FlNLOpLhg8MGDJ5vowjmtMvtTl2XLicVU6Xirk1bWtwej7cByFhMIIKiJ4k+qqfRnm84fCn5mE47F4xKEzHFY751CgA0BQhdGjkbAFgEqpQq7tKs27qIrkoZjfV6I0RwTSn3iRZEwpQ87KGXU+H7D2OhZ4novEzFAgBt8wNQczOLpdGwdAxxjioW6zZtRQtTRpPRWgcCjOAjk3KvhPOIJMt83uFL1+4jDyQS3cNsvWKZDjJoImJw+LNnsTiIQkGh8GJqbh0AqFIpk9ViMaWNANHnKbsPL5qt1Say2TvJpGNDXu/qyDoqlToAgDpT8DgIwoJJYkkULBYbZx5xcarVlNds5qV5fV6eiefhhIV3dstC50pBJp3j0AsdPc8vWSoNC4NAnYnYs805AoQnYzBqUgPw4Djs8XC5X/9PeXjpZBKNRu+SyELBUCmWF74s+OFHDiu/UvGPHDCozRbFE3LyWXa2XNecyzFY1FUvNvXASo+nmE4DAM9hNnpVwpY8IpMltKVSKbbxudLfq79kqlTMtIEAACycXdW+dA1b49SwWFKpxr53I5qu6uNxLWZeX5/qcR9QAPeAemuvnwuGrgUfKI7eo8Xo9UolnAWApiY1WbC6/coap12+wM6ya+z2y4tgukpVNVqt5ow53e3pU3E2tMxDZt+UyWSht+C12CjLxgpWS12vBQAbhoKDBAvk7Ro5a06OlWPp2h9shQ1gEbwWqyVj4Z3wqHxHWza0HDmyezYTSVy7ppU8TJQeRqxWh+QcyICIAVNEQZ0QhIdwBDw+3ryaedylLFf7uDyruW5WHe2mG2B40aKefB7Zpadd1wIXz2JZvzXtkES/KYDwBAIoJJglmQxqHX9xWdHidnP7eT4QAd3RQleiOUL46CmXS7HrCMIMXgvGafetfEf+YfxriBSwiasWCATNAogAEORVLy73wG530cNT+T76Vr58Xz0BRzifPn24ePHQva3MxLVgjIl+DABbJHFgYf5VEkSw3zrgdN6yy+Xs9j063daNLoMqBSyYfb1ldMtr+lEDPenzv+ldETn9PBE6Jzvd4Xj6NFM4gkgHAsB8NRlaNXd5+5qlc+V2uY5tX7vpVKRVxUtVn75pvWeAnxTovarkB/+HD2/8EdorbQg5H770lP/0koJ2Mza2AQhQCF26ZWvsm9cs1TjbWRrnplMdIrq5Wu31X1xpQCtfCn2f/G8+fOr1H9rFZO5JZA+G39SemmFaNqH9qiCKau7S7LfrbrCdJ9k5to51ZaNLtNLn8/haRfcMPSsLSrT/jf/zvQuHjh+fvU8meSQqm3lW/0s9DQkNHDCiqY2EwxM6d67u7OyEGq8jBEJUuNAwp1vUGllhUHYbOi7cu33o0IUzrl278gjt0f1I2ZyuXtIj93ftGdkAEPGEuEAggCBCM+jk2bNzXjxQuODublgkuigyRJStC2/vWHzhwpmN+gJaqXikv6/ipY28S3n9S/SDsQCgjuLjccGSnau7Vgk6VwkIAqDgOAxGD9NFEZGho+PgofXHlm87cxc53PqkzDnhKFvNaevTw4oejgH5CiDh57Q7t69bN2udRi7XyZ1rNp8/taK17BP6ey9+6bzcQ5OKozgewaKo6AUVPSgoXfaedu1WGpHXrefKUltdE6KsTBO02rLUpkY15yuVUHv6dtlMEXM5Nam9sJRRura5LVa01Wj/1KA/osdPiCDoQX25f104n3M4v985v3OEL+wmsylsNptfsI6sP1l2bjWZfHnDgQcHPt24cbe3vhDBrt2LllH2qAw+lQxCfFzpUdlRe0uj6MSnnQ9OioTCPrYpDL7P4bo72PXV1Xewd28cP/jg8qcbd4rJVOKlQhLBRbLSJeycKteOSLmIzCepSbQIaZevXD5JE8pNsBEOGcPhOl4pDXvnRvWO44/PndhZLTqCvU5ddeEeAGwCr7uYI40jkIvLJG1fx+VyZO1Koaj003FaUmcwup8DAD+UvEnbX333/v0d6x/f9dbVJ2sJ+251fPg4HgAOYXAUirjK+vBhVWWVpb/fwmRKGzQ8HqgeHjcYaO6Co56gJx3zsooBgFX8+Hoi1qElrFq7dtvp06NHTQC1AB71h2cebsQt3Gixbux/WMUh1dgzGo1aq00Hml+/bg4EAtGhoFOrBlOHun5fR8Zms21ZW1FxoQJEMGF5oStTzjDFnL0cDukwh7SOeTQtcwJlnEE/sPe/9vv9tuiQf8hm6yASCQTb0Afb1rMVFR8enf4IIlhUgqEwSXx+OwRBKgjazk3L0u3pYDDvzAQBoLkQQrM/Gh2K+jOdnWrqrY50dN2QreLsow/3nm0GgJI1eA5TKlDp5XYdxIW4XK5M1p4J5vNarTMf9bwONDd7SEFPwB90ao6do1LrO50AXbPtQoXt3rNHAHBo+eJKSc7gE0A+HZRu50KQ1KfTJhKxmFprb3c97wp0RbcHAkP+fIxXfY5892bCmcgr6+s7nJltbyqmjpqwa/eSqqac0QipDEfXbV8n3rOHIZE22Btqy8sbUb4j8BxonScYzeeTCWwx9g5rUBvLJM8r1J2dV7d4CoBTJRQGI5Wiiy1Vy0BPAx36MCJrsJcfq21EHS5Xt+P5c09B7eB2rS5dT1YMJnvPHyvX9N4i9MbGjpq4e8XCjRRGhG6JWMXi/v6N/RZ6BHlyE+WVFreajHA8Hne5XSEY9kAtwv2rsaW1VEJisJdXo1YSropYU0dNLMHgGJamVDabQp48gVTS7m7IwG6pqytrEwnDRiMMO9wudwiADJ+FIixZoSYStwwm9l3tUL+NiWrHjipatNTSn0XYbD1qQuWoQSVHdXp9S2udsIzWZmYbBaEQ7BowwiDFfWU77lA16lvEbQkl4RLx7Vsv9nwBsFCczY6YULbdgOpQvRyVy3UCua6v9XYbb3gAdoMQunNcd7evRVSGPULWqNW31mqUhLWxV69oJwBg4tNTliwyYrL3SA2o3MFX8XU+Pl9q1zXwykf0Pr6D73IP5LrdcYNQVFZaW8sqDJzEmFJDxr5/t5oFAIdWVkYkqDksRxy5FJ0eSUXodElO+qQBdED9gANyGd3xeAg2ht+JRPt3lO8AI+stgtf7glb97t3+5FQAWNJPjzQ1NUWs1hTdQgfnEYk0IYj0ZtuxRrPAPGwOhcxG2BwO006sXs9i7fD2Ulft03jf9ZG9ClpjIQcYPIPBsVotVrqVHrHSU1kJJLC3DJbdvl33VcBmmz3Dbjg0zAY/VpM1peRiBXUfgapOeoV9XuUXAFgB2gGDwwH2OUQq0CNyA2pgG0yDdW2324b1PewQbObDIbiv7Hxp8X2qQqHRaIhE4pdEYs7YBYUBvgizhoITM6FheY/A1KrvsaMCVCDQ64BDYYs5zh9wG0EW2YY+0N/J5RqFQtn5YebsaWN+DNyTMSVLlzFk8LC+VWfqkfeMjAhUbDYqTzbuP2YXOLoH+G6Xgxvvaz3fyFJmOifNHTdm1E8qOlWy9CKnCTHLe/QmvUkgkaoQnw+paSg/dlMFzPl8h6OrK55Pz5s091cLHQAsXojjZEfCOj3bJ5VJrHQxg8OUPKkBSnc7XIFAV9f8SVOA299o8qIllS9TWUTVBOqxiiG2VlLObN2zh0SqsZH8Uf/2SX9cmAoAXGXlS3ANXnIYFMY1PIWCB9Pyta1bt66ZUfTd7V8AJRsrXxZEweHOnMFv3roGU7Ji1rQf297fAZilOByFcwaPW4MHtjOKpgPbf9HoRUtxeDwes3TRLHC4wPZfVbTp6fIZRYVl+T81fdwY4Pb/9Q3i0ArjHjdFFQAAAABJRU5ErkJggg==" />&nbsp;&nbsp;<a href="http://cimg.eu/">http://cimg.eu</a></center>)
#@gui : note = note{"\n
#@gui : If you appreciate <b>G'MIC</b>, you are welcome to send us a nice postcard from your place, at:\n\n
#@gui : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gui :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gui : Postcards senders automatically enter the <i>Friends Hall of Fame</i> :) !
#@gui : "}
#@gui_fr A Propos De G'MIC : _none_, fx_logo_fr
#@gui_fr : note = note{"
#@gui_fr : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\nvous est propos&#233; par"}
#@gui_fr : url = link("David Tschumperl&#233;","https://tschumperle.users.greyc.fr/")
#@gui_fr : url = link("S&#233;bastien Fourey","https://foureys.users.greyc.fr/")
#@gui_fr : url = link{"( Equipe IMAGE / Laboratoire GREYC - CNRS UMR 6072 )","https://www.greyc.fr/image"}
#@gui_fr : note = note{"
#@gui_fr : Ce greffon est bas&#233; sur nos biblioth&#232;ques libres <b>G'MIC</b> et <b>CImg</b> (C++ Template Image Processing Library),
#@gui_fr : disponibles aux adresses :"}
#@gui_fr : url = link("https://gmic.eu/")
#@gui_fr : note = note{"et"}
#@gui_fr : url = link("https://cimg.eu/")
#@gui_fr : note = note{"\n
#@gui_fr : Si vous appr&#233;ciez <b>G'MIC</b>, vous pouvez nous le faire savoir en nous envoyant une jolie carte
#@gui_fr : postale de votre ville ou r&#233;gion, &#224; l'adresse :\n\n
#@gui_fr : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gui_fr :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gui_fr : Envoyer une carte postale vous fera rentrer <i>de facto</i> dans le <i>Friends Hall of Fame</i> :) !
#@gui_fr : "}
fx_logo_fr :
fx_logo "Greffon GUI\n    [ "${-strver}" ]","     Greffon GUI\n[ "${-strver}" pre-release ""#"$_prerelease"]"
#@gui Contributors : _none_, _none_
#@gui : note = note{"
#@gui : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gui : A big hug to : \n\n
#@gui : <b> -</b> <i>Sylvie Alexandre</i> <small>(packaging, testing &amp; filters)</small>
#@gui : <b> -</b> <i>Partha Bagchi</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Daniel P. Berrang&#233;</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>S&#233;bastien Bougleux</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>J&#233;rome Boulanger</i> <small>(testing &amp; code)</small>
#@gui : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Aur&#233;lien Ceyden</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(testing)</small>
#@gui : <b> -</b> <i>Patrick David</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Maxime Daisy</i> <small>(code &amp; testing)</small>
#@gui : <b> -</b> <i>Fr&#233;d&#233;ric Devernay</i> <small>(code)</small>
#@gui : <b> -</b> <i>Iain Fergusson</i> <small>(filters)</small>
#@gui : <b> -</b> <i>Tobias Fleischer</i> <small>(testing &amp; code)</small>
#@gui : <b> -</b> <i>Roberto Ferramosca</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(testing, code &amp; tutorials)</small>
#@gui : <b> -</b> <i>Andrea Ferrero</i> <small>(testing, code)</small>
#@gui : <b> -</b> <i>Chris Fiedler</i> <small>(gfx)</small>
#@gui : <b> -</b> <i>S&#233;bastien Fourey</i> <small>(G'MIC-Qt, ZArt code &amp; G'MIC online)</small>
#@gui : <b> -</b> <i>Gentlemanbeggar</i> <small>(filters)</small>
#@gui : <b> -</b> <i>David Gowers</i> <small>(testing)</small>
#@gui : <b> -</b> <i>Claes Holmerson</i> <small>(tutorials)</small>
#@gui : <b> -</b> <i>Arto Huotari</i> <small>(filters)</small>
#@gui : <b> -</b> <i>Dan Leinir Turthra Jensen</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Tom Keil</i> <small>(testing, filters &amp; tutorials)</small>
#@gui : <b> -</b> <i>Andy Kelday</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Alan Kwan</i> (afre) <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Angelo Lama</i> <small>(testing &amp; EKD integration)</small>
#@gui : <b> -</b> <i>John Lakkas</i> <small>(filters)</small>
#@gui : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gui : <b> -</b> <i>Mark</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Mahvin</i> <small>(testing &amp; design)</small>
#@gui : <b> -</b> <i>MareroQ</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Ramon Miranda</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Tou Omiya</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Mauro Quercia</i> <small>(translation)</small>
#@gui : <b> -</b> <i>PhotoComiX</i> <small>(testing, translation &amp; filters)</small>
#@gui : <b> -</b> <i>Garry Osgood</i> <small>(documentation &amp; filters)</small>
#@gui : <b> -</b> <i>Jehan Pages</i> <small>(testing &amp; code)</small>
#@gui : <b> -</b> <i>Andreas P&#229;hlsson</i> <small>(filters)</small>
#@gui : <b> -</b> <i>James Prichard</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Guilherme Razgriz</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Karsten Rodenacker</i> <small>(packaging &amp; code)</small>
#@gui : <b> -</b> <i>Marc Roovers</i> <small>(clut data)</small>
#@gui : <b> -</b> <i>Dani Sard&#224;</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Yuri Shemanin</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Silvio Grosso</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Stepanekos</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Thorsten "otto" Stettin</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Lukas Tvrdy</i> <small>(Krita integration)</small>
#@gui : <b> -</b> <i>Martin Wolff</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Bernd Zeimetz</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Matthias Zepper</i> <small>(testing)</small>
#@gui : <b> -</b>"}
#@gui Download External Data : gui_download_all_data, gui_no_preview(1)
#@gui : note = note{"This filter will download all external data files used by some filters of the <i>G'MIC</i> plug-in (<i>film emulation</i>, <i>light leaks</i>, <i>grain</i>, etc...),
#@gui : and will install them as persistent files on your hard drive. After this operation, you won't need a permanent
#@gui : internet connection anymore in order to use some of the G'MIC filters."}
#@gui : note = note()
#@gui : note = note{"<b><span color="red">Warning:</span></b> A <b>lot of data</b> will be downloaded by this filter. This can take a long time !"}
#@gui : sep = separator()
#@gui : Force re-Download from Scratch = _bool(0)
#@gui : sep = separator()
#@gui : note = note{"<b><span color="red">Alternative (manual) method:</span></b>\nIf, for any reasons, your plug-in is unable to retrieve data from the Internet, you can download all
#@gui : those data files manually (as a single .zip file) at this address :"}
#@gui : url = link{"https://gmic.eu/gmic_all_data.zip"}
#@gui : note = note{"You must then decompress all files contained in this archive at the following location:\n
#@gui : - for <b>Unix</b>-like systems : <span color="blue"><tt>$HOME/.config/gmic/</tt></span>\n
#@gui : - for <b>Windows</b> systems : <span color="blue"><tt>%APPDATA/gmic/</tt></span>
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/16/04</i>.</small>")
gui_download_all_data :
l[] clut foo rm onfail rm endl
_filenames_grain=${-_fx_emulate_grain}
_url_grain=https://gmic.eu/data_film_presets
_prefix_grain=grain_
_ext_grain=cimgz
_filenames_lightleak=${-_fx_light_leaks}
_url_lightleak=https://gmic.eu/data_lightleaks
_prefix_lightleak=
_ext_lightleak=cimgz
_filenames_sample=${-__sample}
_url_sample=https://gmic.eu/img
_prefix_sample=sample_
_ext_sample=png
_filenames_demo=gmic_demos
_url_demo=https://gmic.eu/img
_prefix_demo=
_ext_demo=cimgz
_n=0
_N={narg($_filenames_grain,$_filenames_lightleak,$_filenames_logo,$_filenames_sample)}
progress 0
_gui_download_all_data[] grain,$1
_gui_download_all_data[] lightleak,$1
_gui_download_all_data[] logo,$1
_gui_download_all_data[] sample,$1
_gui_download_all_data[] demo,$1
progress 100
_gui_download_all_data :
repeat {narg(${_filenames_$1})}
filename=${_prefix_$1}${arg\ 1+$>,${_filenames_$1}}.${_ext_$1}
v + e[] "Download "$filename v -
if {$2" || "!isfile(${_path_rc}$filename)} l[] ${_url_$1}/$filename o ${_path_rc}$filename rm onfail endl fi
progress {100*$_n/$_N}
_n+=1
done
#@gui Filter Design : _none_, _none_
#@gui : note = note{"
#@gui : <b>G'MIC</b> is an <b>open</b> image processing framework. Thus, including
#@gui : <b>user-defined filters</b> into this plug-in is possible.\n\n
#@gui : To do so, you need to create a <span foreground="purple" style="italic">.gmic</span>
#@gui : file in your <i>$HOME/</i> folder (or <i>%APPDATA%/user.gmic</i> on Windows).
#@gui : It will be read each time the plug-in is launched, or when the <i>Refresh</i>
#@gui : button (under the central pane) is pressed. It must be a regular ascii file, containing the declarations and
#@gui : implementations of the filters (written in the <b>G'MIC</b> language) that will be added
#@gui : to the list of available ones."}
#@gui : note = note{"
#@gui : Existing filters are already defined this way.
#@gui : Writing a filter from scratch in <b>G'MIC</b> requires some skills, but
#@gui : can be generally done in very few lines.\n\n
#@gui : <span foreground="purple" underline="single">Example of a valid <i>.gmic</i> entry :</span>"}
#@gui : note = note{"<tt>#@gui My effect : my_effect, my_effect</tt>"}
#@gui : note = note{"<tt>#@gui : Sigma = float(2,0,10)</tt>"}
#@gui : note = note{"<tt>my_effect :\n     +blur $1 n 0,255 xor</tt>"}
#@gui : note = note{"
#@gui : Look at the reference documentation and the tutorial whose links are given below, to learn more.
#@gui : By the way, you are encouraged to share your nice custom filters with us on our forums,
#@gui : for inclusion into next releases of <b>G'MIC</b>.
#@gui : "}
#@gui : sep = separator()
#@gui : url = link(0,"[1] G'MIC reference documentation","https://gmic.eu/reference.shtml")
#@gui : url = link(0,"[2] G'MIC scripting tutorial","https://gmic.eu/tutorial/index.shtml")
#@gui : url = link(0,"[3] G'MIC filter template","https://gmic.eu/template.gmic")
#@gui Friends Hall of Fame : _none_, fx_friends
#@gui : note = note{"\n<span foreground="purple" underline="single">Supporters:</span>"}
#@gui : note = note{" <b>-</b> A big hug goes to these friends who supported the project:"}
#@gui : note = note{"<i>
#@gui : Margaret Wong,
#@gui : Adrian Bottomley,
#@gui : Pamela Young,
#@gui : <a href ="http://chrisbowness.com/">Chris Bowness</a>,
#@gui : Peter Howarth,
#@gui : Marlon Montalvo,
#@gui : Christian Freiherr von Malchus,
#@gui : Nolan Tyrrell,
#@gui : Gilles Bouquerel,
#@gui : Mihail Balabanov,
#@gui : Rolf Niepraschk,
#@gui : Volkmar Geske,
#@gui : Menno Tjoelker,
#@gui : <a href ="https://borkarabhijeet05.blogspot.com/p/about-me.html">Abhijeet Borkar</a>,
#@gui : <a href ="https://www.behance.net/kontaktarl1e0a">Arleta Lesniewska</a>,
#@gui : Nicola Giaccobe,
#@gui : Helmut M&#252;hleisen,
#@gui : Paul Buckley,
#@gui : <a href ="http://www.flickr.com/newmikey">Mike Bing</a>,
#@gui : Olivier Lecarme,
#@gui : Edward Ingram,
#@gui : <a href ="http://www.gus-verlag.de/verlag/Artelier/">Stefan St&#228;dtler-Ley</a>,
#@gui : Michel Pastor,
#@gui : Sz.U,
#@gui : Sven Kraft,
#@gui : Frederik Elwert,
#@gui : Jessica Leonard,
#@gui : <a href ="https://www.viewbug.com/member/KennZaney">Kenneth Simons</a>,
#@gui : <a href ="https://www.flickr.com/photos/114936163@N05/">Milos Ciuk</a>,
#@gui : Manlio Barolo,
#@gui : John Lewandowski,
#@gui : <a href ="http://mediaklan.com/">Didier Lima</a>,
#@gui : &#381;ygimantas Tauras,
#@gui : Massimo Ferri,
#@gui : <a href ="https://github.com/sina-ht">Hiroshi Takekawa</a>,
#@gui : Freelance writer,
#@gui : <a href ="https://www.flickr.com/photos/49284009@N04/">Elaine Hutchings</a>,
#@gui : Andr&#225;s Somogyi,
#@gui : <a href ="https://www.flickr.com/photos/tonurics">Jason Dora</a>,
#@gui : Boris Hajdukovic,
#@gui : <a href ="https://mappish.com/pages/about-us">Jeff Combs / Mappish</a>,
#@gui : <a href ="http://flickr.com/photos/btraven">BTraven</a>,
#@gui : <a href ="https://500px.com/spodeworld">Steven Brener</a>,
#@gui : Susanne Gabrielski,
#@gui : Andrea Correani,
#@gui : Mads Thomsen,
#@gui : Djek Eykhout,
#@gui : Michael Calabrese,
#@gui : Joachim Steiert
#@gui : Christian Dubettier,
#@gui : J. Casseur,
#@gui : <a href ="http://www.gnomelibre.fr/">Okki</a>,
#@gui : Dariusz Duma,
#@gui : <a href ="http://www.mahvin.com/">Mahvin</a>,
#@gui : Elleen Hennessy,
#@gui : BluffStuffPlus,
#@gui : <a href ="http://www.bertrandchan.eu">Bertrand Chan</a>,
#@gui : Mirella Scotto,
#@gui : <a href ="http://www.photopablo.com">Paul Sauve</a>,
#@gui : <a href ="https://darktablemaster.de">Lars Mielke</a>,
#@gui : Devin Sorell,
#@gui : <a href ="http://www.quesepuedehacerenlinux.net">Pepe Baeza</a>,
#@gui : <a href =" http://www.lesnoy-tanets.com">Andrey Pivovarova</a>,
#@gui : <a href ="http://doliver.co.uk/">David Oliver</a>,
#@gui : <a href ="https://ello.co/errore">errore</a>,
#@gui : <a href ="http://www.anudai.de">Anudai</a>,
#@gui : James Stalnaker,
#@gui : <a href ="https://plus.google.com/u/0/b/117441237982283011318/112547676857320288448/about">Paolo Finetti</a>,
#@gui : Luigi Scarselli,
#@gui : <a href ="http://blog.patdavid.net/">Pat David</a>,
#@gui : Juan Jose Rodriguez Vela,
#@gui : Thomas Jakob,
#@gui : Kim Bartholomew,
#@gui : <a href ="http://www.captivemoment.com">Sudi</a>,
#@gui : Michael Prostka,
#@gui : Arkadi Gelfond,
#@gui : <a href ="https://joeysl.wordpress.com/">Sabine Sch&#228;fers</a>,
#@gui : <a href ="http://www.viewbug.com/member/KennZaney">Bull O'Woods</a>,
#@gui : Jost Jakob Schaper,
#@gui : Dominik Wefers,
#@gui : Frank McLaughlin,
#@gui : <a href ="https://29a.ch/">Jonas Wagner</a>,
#@gui : <a href ="www.ixaarii.com">Void lon iXaarii</a>,
#@gui : Mark Boadey,
#@gui : Laura Haglund,
#@gui : Lee Elliott,
#@gui : Bernard Desenclos,
#@gui : Randy Gordon-Gilmore,
#@gui : Eddie Dedrick,
#@gui : <a href ="http://mindprints.org/">Greg FitzPatrick</a>,
#@gui : Zsolt Szabo,
#@gui : Daniel Hanna,
#@gui : Peter Bengtsson,
#@gui : Diego Nassetti,
#@gui : William Tweedy,
#@gui : Shawnee Horn,
#@gui : Stephan Munsch,
#@gui : <a href ="http://www.mysticali3n-wear.com">MysticAli3n-Wear</a>,
#@gui : Mika Mantere,
#@gui : Christian Beuschel,
#@gui : Tore Busch,
#@gui : Douc McGregor.
#@gui : Marcel Dahm,
#@gui : Susan Voitel,
#@gui : <a href ="https://www.flickr.com/photos/henkkoning">Henk Koning</a>,
#@gui : Arnie Jordan,
#@gui : Carol Jennings,
#@gui : S&#233;bastien Huart,
#@gui : <a href ="http://www.jessstryker.com/">Jess Stryker</a>,
#@gui : Rui Luis,
#@gui : <a href ="https://www.flickr.com/photos/sallesrenato/">Renato Salles</a>,
#@gui : <a href ="http://www.viewbug.com/member/alef0"> Petr Zagalak</a>,
#@gui : <a href ="http://www.antonio.cat">Antonio Vici&#233;n Faure</a>,
#@gui : Vincent Bermel,
#@gui : Christian Stocco,
#@gui : <a href ="https://www.flickr.com/photos/136307651@N04/">Richard Benedict</a>,
#@gui : Dr. Helmut Jarausch,
#@gui : <a href ="http://www.michaeljamesbeck.com">Michael Beck</a>,
#@gui : <a href ="http://rickleone.tumblr.com/">Riccardo Leone</a>,
#@gui : Gisela Looram,
#@gui : <a href ="https://plus.google.com/u/0/+FrankTegtmeyer/posts">Frank Tegtmeyer</a>,
#@gui : David Kettrey,
#@gui : <a href ="https://www.youtube.com/user/kncpt1">Peter Hoge</a>,
#@gui : Alexander Heitmann,
#@gui : <a href ="http://harlequin.webcomics.fr/page/episode-1-page-1">Olivier Larski</a>,
#@gui : <a href ="http://victorfandrey.blogspot.ca">Victor Fandrey</a>,
#@gui : Stefan Peter,
#@gui : <a href ="https://plus.google.com/u/0/+DimitriosPsychogios">Dimitrios Psychogios</a>,
#@gui : <a href ="https://plus.google.com/+AnttiLuoma">Antti Luoma</a>,
#@gui : <a href ="https://twitter.com/jeyoung">Eddy Young Tie Yang</a>,
#@gui : Thomas Elfstrom,
#@gui : Valentine Boyce,
#@gui : George Harnett,
#@gui : Darius Manka,
#@gui : Chris Knox,
#@gui : <a href ="http://tomtappingphotoblog.blogspot.fr/">Thomas Tapping</a>,
#@gui : Phillip R Ziesemer,
#@gui : Jean Francois.
#@gui : Franz Ziereis,
#@gui : Alessandro Renzi,
#@gui : Tsuda Koshi,
#@gui : <a href ="http://www.boxrec.com">Boxrec Ltd</a>,
#@gui : <a href ="http://www.wolfgangschweizer.com/">Wolfgang Schweizer</a>,
#@gui : <a href ="http://www.ramonmiranda.com/">Ramon Miranda</a>,
#@gui : Volker Bradley,
#@gui : <a href ="http://plus.google.com/+MarcoZara">Marco Zara</a>,
#@gui : <a href ="http://plus.google.com/+MarcoTedaldi">Marco Tedaldi</a>,
#@gui : <a href ="http://cybertographer.com">Rodney Lee</a>,
#@gui : Konstantinos Blatzonis,
#@gui : Simon Chanson,
#@gui : Herbert Malle,
#@gui : <a href ="http://www.matthias-zepper.de/">Matthias Zepper</a>,
#@gui : Christian Mariucci,
#@gui : M. R.,
#@gui : Mark Link,
#@gui : <a href ="http://blog.meetthegimp.org/">Rolf Steinort</a>,
#@gui : <a href ="https://plus.google.com/112357088505488756823/posts">Daniel Tauro</a>,
#@gui : <a href ="http://geniisoft.com/">Ben Langhinrichs</a>,
#@gui : <a href ="http://www.openlabs.it/">Paolo Pedaletti</a>,
#@gui : <a href ="http://blog.photomontager.com">Ricardo Corin</a>,
#@gui : <a href ="https://plus.google.com/115953666279509959258">James Prichard</a>,
#@gui : <a href ="https://plus.google.com/116658221461047313647">Matt Jones</a>,
#@gui : <a href ="http://www.flickr.com/people/twekkel/">Eddy Vervest</a>,
#@gui : <a href ="http://www.flickr.com/photos/ssshupe/">Steven Shupe</a>,
#@gui : <a href ="http://www.flaviocdc.net/wiki/">Flavio Casadei Della Chiesa</a>,
#@gui : <a href ="http://www.artwanted.com/artist.cfm?artid=10918">Lyle Kroll</a>.
#@gui : </i>"}
#@gui : sep = separator()
#@gui : note = note{"\n<span foreground="purple" underline="single">Postcard senders:</span>"}
#@gui : note = note{" <b>-</b> We've received <b>44</b> postcards from <b>G'MIC</b> enthusiasts so far.
#@gui :               You could be the <b>45rd</b> sender :)"}
#@gui : note = note{" <b>-</b> A big hug goes to these postcard senders (recently received first) :"}
#@gui : note = note{"<i>
#@gui : <a href ="https://cimg.eu/img/postcard70.jpg">Patrick Wanters</a> (USA),
#@gui : <a href ="https://cimg.eu/img/postcard69.jpg">Josep Febrer</a> (Pregonda/Menorca),
#@gui : <a href ="https://cimg.eu/img/postcard68.jpg">Richard Gledson</a> (Newcastle upon tyne/England),
#@gui : <a href ="https://cimg.eu/img/postcard67.jpg">James Jaworski</a> (Winnipeg/Canada),
#@gui : <a href ="https://cimg.eu/img/postcard66.jpg">Powlux</a> (France),
#@gui : <a href ="https://cimg.eu/img/postcard65.jpg">Volker Doebel</a> (Haldern/Germany),
#@gui : <a href ="https://cimg.eu/img/postcard64.jpg">Patrick Wauters</a> (Bilbao/Spain),
#@gui : <a href ="https://cimg.eu/img/postcard63.jpg">Sebastien Fourey</a> (Konstanz/Germany),
#@gui : <a href ="https://cimg.eu/img/postcard62.jpg">David Revoy</a> (Toulouse/France),
#@gui : <a href ="https://cimg.eu/img/postcard61.jpg">Giulio Canevari</a> (Pavia/Italy),
#@gui : <a href ="https://cimg.eu/img/postcard60.jpg">Bruno Steinbach</a> (Pondicherry/India),
#@gui : <a href ="https://cimg.eu/img/postcard59.jpg">Steve Gillow</a> (Fort Worth/Texas/USA),
#@gui : <a href ="https://cimg.eu/img/postcard58.jpg">Peter Neave</a> (Sydney/Australia),
#@gui : <a href ="https://cimg.eu/img/postcard57.jpg">Andrea [Photoflow]</a> (Italy),
#@gui : <a href ="https://cimg.eu/img/postcard56.jpg">Garry R. Osgood</a> (New York/USA),
#@gui : <a href ="https://cimg.eu/img/postcard55.jpg">Justin Pletzfeld</a> (Germany),
#@gui : <a href ="https://cimg.eu/img/postcard54.jpg">Werner Meier</a> (Germany),
#@gui : <a href ="https://cimg.eu/img/postcard53.jpg">Patrick Wauters</a> (Roma/Italy),
#@gui : <a href ="https://cimg.eu/img/postcard52.jpg">Marc Lis</a> (Belgium),
#@gui : <a href ="https://cimg.eu/img/postcard51.jpg">ZondeR</a> (France),
#@gui : <a href ="https://cimg.eu/img/postcard50.jpg">Bill C.</a> (USA),
#@gui : <a href ="https://cimg.eu/img/postcard49.jpg">Michael T.</a> (France),
#@gui : <a href ="https://cimg.eu/img/postcard48.jpg">Patrick Wauters</a> (Lisboa),
#@gui : <a href ="https://cimg.eu/img/postcard47.jpg">Akky [Gimpchat]</a> (Australia),
#@gui : <a href ="https://cimg.eu/img/postcard45.jpg">Michel Thomas</a> (Germany),
#@gui : <a href ="https://cimg.eu/img/postcard44.jpg">Pierre-Yves</a> (Ile de Batz/France),
#@gui : <a href ="https://cimg.eu/img/postcard43.jpg">Family Hamacher</a> (Trier/Germany),
#@gui : <a href ="https://cimg.eu/img/postcard41.jpg">Benoit Gauzere and Francois Lozes</a> (Hokusai/Japan),
#@gui : <a href ="https://cimg.eu/img/postcard40.jpg">Dr. Rainer Teubner</a> (Seligenstadt/Germany),
#@gui : <a href ="https://cimg.eu/img/postcard39.jpg">Mauro Mitrino</a> (Mantova/Italy),
#@gui : <a href ="https://cimg.eu/img/postcard37.jpg">Werner Meier</a> (Mettlach/Germany),
#@gui : <a href ="https://cimg.eu/img/postcard36.jpg">Arto Huotari</a> (Helsinki/Finland),
#@gui : <a href ="https://cimg.eu/img/postcard33.jpg">Benoit Gauzere</a> (California/USA),
#@gui : <a href ="https://cimg.eu/img/postcard30.jpg">Arkadi Gelfond</a> (Foster City - California/USA),
#@gui : <a href ="https://cimg.eu/img/postcard29.jpg">Corinne Masimann</a> (Neuchatel/Switzerland),
#@gui : <a href ="https://cimg.eu/img/postcard27.jpg">Mahvin</a> (Portland/USA),
#@gui : <a href ="https://cimg.eu/img/postcard26.jpg">Vincent Roullier</a> (Caen/France),
#@gui : <a href ="https://cimg.eu/img/postcard24.jpg">M????</a> (Munich/Germany),
#@gui : <a href ="https://cimg.eu/img/postcard23.jpg">F. Albior</a> (Jaca/Spain),
#@gui : <a href ="https://cimg.eu/img/postcard22.jpg">PhotoComIX</a> (Frascati/Italy),
#@gui : <a href ="https://cimg.eu/img/postcard21.jpg">Guy Poizat</a> (Cabestany/France),
#@gui : <a href ="https://cimg.eu/img/postcard20.jpg">Institut for Biomathematik und Biometrie</a> (Neuherberg/Germany),
#@gui : <a href ="https://cimg.eu/img/postcard15.jpg">Jean-Michel Webbe</a> (Guadeloupe/France),
#@gui : <a href ="https://cimg.eu/img/postcard14.jpg">Jaime</a> (Barcelona/Spain).
#@gui : </i>"}
#@gui : sep = separator()
#@gui : note = note{"\nMay the force be with you!"}
fx_friends :
if $! ratio={w/h} else ratio=1 fi
rm _heart80x73 scale3x r 150%,150%,1,1,0,0,0.5,0.5
+*. 70 +*.. 110 +*... 255 *[-4] 255 a c
blur_radial 4 sharpen 300
i.. ${fitratio_wh\ {w},{h},$ratio},1,3
rand.. 0,255 sh.. 1,2 /. 2 rm.
blur_radial.. 20 sharpen.. 50
r. ..,..,1,4,0,0,0.5,0.5 blend alpha
143,80,1,1,0 t. "Greetings to\n  all G\47MIC\n  friends!",2,-2,27,1,1
+dilate. 3 *.. 255 to_rgb.. j... ..,{[w#-3-w#-2,h#-3-h#-2]/2},0,0,1,.
rm[-2,-1]
_heart80x73 :
40,73,1,1,0 ellipse 22,22,20,20,0,1,1 polygon 3,7,37,42,72,42,27,1,1 +mirror x a x
#@gui_ca G'MIC per Al GIMP : _none_, fx_logo_ca
#@gui_ca : note = note{"
#@gui_ca : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\n &#233;s una gentilesa de"}
#@gui_ca : url = link("David Tschumperl&#233;","https://tschumperle.users.greyc.fr/")
#@gui_ca : url = link("S&#233;bastien Fourey","https://foureys.users.greyc.fr/")
#@gui_ca : url = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","https://www.greyc.fr/node/36"}
#@gui_ca : note = note{"
#@gui_ca : Aquest connector est&#224; basat en les biblioteques de codi obert <b>G'MIC</b> i <b>CImg</b> (C++ Template Image Processing Library),
#@gui_ca : disponibles a :"}
#@gui_ca : url = link("https://gmic.eu/")
#@gui_ca : note = note{"i"}
#@gui_ca : url = link("https://cimg.eu/")
#@gui_ca : note = note{"\n
#@gui_ca : Si t'agrada el <b>G'MIC</b>, pots enviar-nos una postal del lloc on vius, a :\n\n
#@gui_ca : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gui_ca :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gui_ca : Tot aquell que envi&#239; una postal apareixer&#224; al <i>Friends Hall of Fame</i> :) !
#@gui_ca : "}
fx_logo_ca :
fx_logo "per al GIMP\n  [ "${-strver}" ]","         per al GIMP\n[ "${-strver}" pre-release ""#"$_prerelease"]"
#@gui_fr hide(/About/About G'MIC)
#@gui Gmicky - Roddy : fx_gmicky, fx_gmicky_preview
#@gui : Mascot Image = choice{"Gmicky (by Deevad)","Gmicky (by Mahvin)","Gmicky &amp; Wilber (by Mahvin)","Roddy (by Mahvin)"}
#@gui : sep = separator()
#@gui : note = note{"<b><i>Gmicky</i></b> is the name of the <b>G'MIC</b> mascot. He is a small and cute tiger who knows how to do magic.
#@gui : <b><i>Gmicky</i></b> is a tiger, i.e. fast, agile and elegant, just as the <b>G'MIC</b> code is :).
#@gui : As many magicians, <b><i>Gmicky</i></b> knows lot of <b>gimmicks</b>, and he is a direct and friendly competitor of
#@gui : the ImageMagick's wizard, or the GraphicMagick's frog."}
#@gui : note = note{"<b><i>Roddy</i></b> is another mascot designed specifically for the <i>Artistic / Rodilius</i> filter of <b>G'MIC</b>.\n"}
#@gui : note = note{"<b><i>Gmicky</i></b> and <b><i>Roddy</i></b> have been both created and drawn by "}
#@gui : url = link("Mahvelous Mahvin","http://www.mahvin.com/")
#@gui : note = note{"and"}
#@gui : url = link{"David Revoy (Deevad)","http://www.davidrevoy.com/"}
fx_gmicky :
rm
if {$1==0} sp gmicky nm "name(Gmicky)"
elif {$1==1} sp gmicky_mahvin nm "name(Gmicky)"
elif {$1==2} sp gmicky_wilber nm "name(Gmicky & Wilber)"
else sp roddy nm "name(Roddy)"
fi
fx_gmicky_preview :
fx_gmicky $* rr2d $_preview_width,$_preview_height,0,2
#@gui Privacy Notice : _none_, _none_
#@gui : note = note{"This plugin may download up-to-date filter definitions from the <a href="https://gmic.eu">gmic.eu</a> server.\n\n
#@gui : It is the case when first launched after a fresh installation, and periodically
#@gui : with a frequency which can be set in the settings dialog.
#@gui : The user should be aware that the following information may be retrieved
#@gui : from the server logs: <i>IP address of the client; date and time of the request;</i>
#@gui : as well as a short string, supplied through the HTTP protocol <i>"User Agent"</i> header
#@gui : field, which describes the full plugin version as shown in the window title
#@gui : (e.g. "<i>G'MIC-Qt for GIMP 2.8 - Linux 64 bits - 2.2.1_pre#180301</i>").\n\n
#@gui : Note that this information may solely be used for purely anonymous
#@gui : statistical purposes.
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i>S&#233;bastien Fourey</i>.      Latest Update: <i>2018/03/01</i>.</small>")
#@gui Release Notes : _none_, _none_
#@gui : note = note{"
#@gui : - <b>2009/01/13</b> : version <i>1.3.0</i> (initial plug-in release).\n
#@gui : - <b>2010/09/03</b> : version <i>1.4.0</i>.\n
#@gui : - <b>2011/07/07</b> : version <i>1.5.0</i>.\n
#@gui : - <b>2014/08/20</b> : version <i>1.6.0</i>.\n
#@gui : - <b>2016/03/25</b> : version <i>1.7.0</i>.\n
#@gui : - <b>2017/05/29</b> : version <i>2.0.0</i>.\n
#@gui : - <b>2017/10/09</b> : version <i>2.1.0</i>.\n
#@gui : - <b>2018/02/15</b> : version <i>2.2.0</i>.\n
#@gui : - <b>2018/06/21</b> : version <i>2.3.0</i>.\n
#@gui : - <span foreground="purple"><b>2019/01/11</b> : version <i>2.4.5</i> (Current stable).</span>\n
#@gui : - <b>2019/01/18</b> : version <i>2.5.0_pre</i> (Current pre-release).</span>\n
#@gui : "}
#@gui : sep = separator()
#@gui : url = link{"View changelog to upcoming major version (2.5.0)","https://discuss.pixls.us/t/on-the-road-to-2-5-0"}
#@gui : url = link{"View latest minor changelog (2.4.0)","https://discuss.pixls.us/t/release-of-gmic-2-4-0"}
#@gui : url = link{"View latest major changelog (2.0.0)","https://discuss.pixls.us/t/release-of-gmic-2-0-0"}
#@gui _
#@gui <b>Arrays &amp; Tiles</b>
#@gui Annular Steiner Chain Round Tile : Annular_Steiner_Chain_Round_Tile, Annular_Steiner_Chain_Round_Tile(1)
#@gui : note = note("<span foreground="orangered">Annular Steiner Chain Round Tiles</span>")
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Image Finale</small></span>")
#@gui : Dimension En Pixels = int(800,256,1920)
#@gui : Supprimer Calque Origine = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Image</small></span>")
#@gui : Position X Origine (%) = float(0,0,100)
#@gui : Position Y Origine (%) = float(0,0,100)
#@gui : Dimension (%) = float(100,1,100)
#@gui : Angle D\303\251calage Image Contour = float(0,0,360)
#@gui : Image Contour Dimension = float(100,1,100)
#@gui : Nb Cercles Ext\303\251rieurs / Circles Surrounding = int(12,3,180)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Couleurs Formes</small></span>")
#@gui : Activer Couleurs Formes = bool(1)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = choice(0,"Sans","A","B","C","D","E","F","G")
#@gui : Cercle / Circle C = color(255,255,0,127)
#@gui : Cercle / Circle D = color(0,0,255,127)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
Annular_Steiner_Chain_Round_Tile:
Dimension_Finale=$1
Supprimer_Calque_Origine=$2
X={round({{w}*{$3/100}})}
Y={round({{h}*{$4/100}})}
Dimension_Image=$5
Decalage_Angle_Images_Contour=$6
Image_Contour_Dimension=$7
Nb_Circles_Surrounding=$8
Angle_inclinaison=$9
Activer_Couleurs_Formes=$10
R_Contours=$11
V_Contours=$12
B_Contours=$13
A_Contours=$14
Affichage_Contours=$15
R_c=$16
V_c=$17
B_c=$18
A_c=$19
R_d=$20
V_d=$21
B_d=$22
A_d=$23
Couleurs_aleatoires=$24
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Theta={pi/$Nb_Circles_Surrounding}
# variables dimensions
Rayon_Cercle_Exterieur_Final={$Dimension_Finale/2}
Rayon_Cercle_Centre_Final={{$Rayon_Cercle_Exterieur_Final*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
Rayon_Cercles_Ext_Final={{$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final}/2}
Rayon_Centres_C_Ext_Final={$Rayon_Cercle_Centre_Final+$Rayon_Cercles_Ext_Final}
Rayon_Tang_Final={{{$Rayon_Centres_C_Ext_Final*$Rayon_Centres_C_Ext_Final}-{$Rayon_Cercles_Ext_Final*$Rayon_Cercles_Ext_Final}}^0.5}
Fin_X={round({{{w}-$X}*$Dimension_Image/{100}})}
Fin_Y={round({{{h}-$Y}*$Dimension_Image/{100}})}
-if {$Fin_X>$Fin_Y}
Rayon_Cercle_Centre_Origine={$Fin_Y/2}
-else
Rayon_Cercle_Centre_Origine={$Fin_X/2}
-endif
-to_rgb[-1]
# masque image extrieure
{$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},{$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,{{w}/2},1,0,0,0,255
# image extrieure
--Je_passe_l_hiver_en_Floride[0]
-crop[-1] $X,$Y,{$X+{$Rayon_Cercle_Centre_Origine*2}},{$Y+{$Rayon_Cercle_Centre_Origine*2}}
-resize2dy[-1] {$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100}
-blend[-1,-2] alpha
# masque image centrale
{$Rayon_Cercle_Centre_Final*2},{$Rayon_Cercle_Centre_Final*2},1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,{{w}/2},1,0,0,0,255
# image centrale
--Je_passe_l_hiver_en_Floride[0]
-crop[-1] $X,$Y,{$X+{$Rayon_Cercle_Centre_Origine*2}},{$Y+{$Rayon_Cercle_Centre_Origine*2}}
-resize2dy[-1] {$Rayon_Cercle_Centre_Final*2}
-blend[-1,-2] alpha,1,1
-expand_xy[-1] {$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final},0
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Dimension_Img_pivotee=0
X_Deplacement=0
Y_Deplacement=0
-repeat $Nb_Circles_Surrounding
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{cos({pi/180*{$Angle+$Angle_inclinaison}})}}}
Y_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{sin({pi/180*{$Angle+$Angle_inclinaison}})}}}
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
-endif
-if {$Activer_Couleurs_Formes==1}
-if {{($Nb_Circles_Surrounding%2)}==0}
-if {{($Nb_boucles%2)}==0}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_c,$V_c,$B_c,$A_c
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_d,$V_d,$B_d,$A_d
-endif
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_c,$V_c,$B_c,$A_c
-endif
-if {$Affichage_Contours>0}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
--Je_passe_l_hiver_en_Floride[-2]
-rotate[-1] {$Angle+$Decalage_Angle_Images_Contour}
-crop[-1] {{{w}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{{w}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}},{{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}}
X_Deplacement={$X_ext-$Rayon_Cercles_Ext_Final}
Y_Deplacement={$Y_ext-$Rayon_Cercles_Ext_Final}
-crop[-1] {-$X_Deplacement},{-$Y_Deplacement},{{2*$Rayon_Cercle_Exterieur_Final}-$X_Deplacement-1},{{2*$Rayon_Cercle_Exterieur_Final}-$Y_Deplacement-1},0
-blend[-1,-2] alpha,1,1
-done
-if {$Activer_Couleurs_Formes==1}
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-ellipse[-1] 50%,50%,$Rayon_Cercle_Exterieur_Final,$Rayon_Cercle_Exterieur_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-ellipse[-1] 50%,50%,$Rayon_Cercle_Centre_Final,$Rayon_Cercle_Centre_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==2}||{$Affichage_Contours==3}}
-ellipse[-1] 50%,50%,$Rayon_Centres_C_Ext_Final,$Rayon_Centres_C_Ext_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==3}||{$Affichage_Contours==4}}
-ellipse[-1] 50%,50%,$Rayon_Tang_Final,$Rayon_Tang_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
-rm[-2]
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-else
-reverse[0,-1]
-endif
#-text_outline[-1] {2*$Rayon_Cercle_Exterieur_Final},10,10,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercles_Ext_Final},10,60,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Centres_C_Ext_Final},10,110,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Tang_Final},10,160,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercle_Centre_Final},10,210,64,1,1,255,255,255
#@gui Array [Faded] : fx_array_fade, fx_array_fade_preview(1)
#@gui : X-Tiles = int(2,1,10)
#@gui : Y-Tiles = int(2,1,10)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Fade Start (%) = float(80,1,100)
#@gui : Fade End (%) = float(90,1,100)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axes")
#@gui : Size = _choice("Shrink", "Expand", "Repeat [Memory Consuming!]")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array_fade :
if {$7&1} mirror x fi if {$7>1} mirror y fi
array_fade $1,$2,$5,$6,$8
shift -$3%,-$4%,0,0,2
fx_array_fade_preview :
fx_array_fade $1,$2,$3,$4,$5,$6,$7,0
#@gui Array [Mirrored] : fx_array_mirror, fx_array_mirror_preview(1)
#@gui : Iterations = int(1,1,10)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Array Mode = choice(2,"X-Axis","Y-Axis","XY-Axes","2XY-Axes")
#@gui : Initialization = choice("Original","Mirror X","Mirror Y","Rotate 90 deg.","Rotate 180 deg.","Rotate 270 deg.")
#@gui : Expand Size = _bool(false)
#@gui : Crop (%) = int(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array_mirror : skip ${7=0}
if {$5==1} mirror x
elif {$5==2} mirror y
elif {$5==3} rotate 90
elif {$5==4} rotate 180
elif {$5==5} rotate 270
fi
if $7
if {$4==0} columns 0,{100-$7}%
elif {$4==1} rows 0,{100-$7}%
elif {$4==2} z 0,0,{100-$7}%,{100-$7}%
elif {$4==3} z {$7/2}%,{$7/2}%,{100-$7/2}%,{100-$7/2}%
fi
fi
shift -$2%,-$3%,0,0,2
array_mirror $1,$4,$6
fx_array_mirror_preview :
fx_array_mirror $1,$2,$3,$4,$5,0,$7
#@gui Array [Random] : array_random, array_random(1)
#@gui : Source X-Tiles = int(5,1,20)
#@gui : Source Y-Tiles = int(5,1,20)
#@gui : Destination X-Tiles = int(7,1,20)
#@gui : Destination Y-Tiles = int(7,1,20)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Array [Random Colors] : fx_array_color, fx_array_color(1)
#@gui : X-Tiles = int(5,1,20)
#@gui : Y-Tiles = int(5,1,20)
#@gui : Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array_color :
repeat $! l.
$1,$2,1,3 rand. 0,255 to_colormode. {-2,s} r. .. *. $3 *.. {1-$3} +[-2,-1]
endl mv. 0 done
#@gui Array [Regular] : fx_array, fx_array_preview(1)
#@gui : X-Tiles = int(2,1,10)
#@gui : Y-Tiles = int(2,1,10)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axes")
#@gui : Size = _choice("Shrink", "Expand", "Repeat [Memory Consuming!]")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array :
shift -$3%,-$4%,0,0,2
if {$5&1} mirror x fi if {$5>1} mirror y fi
array $1,$2,$6
fx_array_preview :
fx_array $1,$2,$3,$4,$5,0
#@gui Ascii Art : fx_asciiart, fx_asciiart_preview(0)+
#@gui : Charset = choice(5,"Custom","Binary Digits","Digits","Lowercase Letters","Uppercase Letters","Ascii","Card Suits","Math Symbols")
#@gui : Custom Dictionary = text{" .oO0"}
#@gui : Analysis Scale = int(16,8,103)
#@gui : Analysis Smoothness = float(15,0,100)
#@gui : Synthesis Scale = int(16,8,103)
#@gui : Result Type = choice(2,"White on Black","Black on White","Colored on Black","Colored on Transparent")
#@gui : sep = separator()
#@gui : Gamma = float(0,-3,3)
#@gui : Smoothness = float(0.2,0,5)
#@gui : Colors = choice("Full Colors","2 Colors","3 Colors","4 Colors","8 Colors","12 Colors","16 Colors",
#@gui :                 "Grayscale","2 Grays","3 Grays","4 Grays","8 Grays","12 Grays","16 Grays")
#@gui : sep = separator()
#@gui : Output Ascii File = _bool(0)
#@gui : Output Folder = _folder()
#@gui : Output Filename = _text("gmic_asciiart.txt")
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=10047")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/27/03</i>.</small>")
fx_asciiart : skip ${10=},"${11=}","${12=}"
repeat $! l[$>] to_rgb
apply_gamma {10^$7} b $8% n 0,255
if {$1==0} dict="$2"
elif {$1==1} dict=" 01"
elif {$1==2} dict=" 0123456789"
elif {$1==3} dict=" abcdefghijklmnopqrstuvwxyz"
elif {$1==4} dict=" ABCDEFGHIJKLMNOPQRSTUVWXYZ"
elif {$1==5} dict=" !\042#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~"
elif {$1==6} dict=" \16\17\20\21"
elif {$1==7} dict=" \200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231"
fi
if {$6==1} negate fi
if $-3 +img2ascii $dict,$3,$4%,$5,"$-2"/"$-1"
else +img2ascii $dict,$3,$4%,$5
fi
wh=${}
if {$6==0} k. n 0,255
elif {$6==1} k. negate n 0,255
elif {$6==2||$6==3}
r[0] $wh,1,100%,1
if {$9>=7} luminance[0] fi
if {$9%7} quantize[0] {arg($9%7,2,3,4,8,12,16)-1},1,0 fi
r[0] [1],[1],1,100% *[0] [1]
if {$6==2} rm[1]
else *[1] 255 a c
fi
fi
endl done
fx_asciiart_preview :
repeat $! l[$>]
w={w} h={h}
fx_asciiart $1,"$2",${3-9},0,foo,foo
r $w,$h,1,100%,0,0,0.5,0.5
endl done
#@gui Chessboard : fx_chessboard, fx_chessboard_preview(0)
#@gui : First Size = int(64,1,512)
#@gui : Second Size = int(64,1,512)
#@gui : First Offset = int(0,0,512)
#@gui : Second Offset = int(0,0,512)
#@gui : Angle = float(0,0,180)
#@gui : Opacity = float(0.5,0,1)
#@gui : First Color = color(0,0,0,255)
#@gui : Second Color = color(255,255,255,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_chessboard :
to_rgba chessboard ${1-14}
fx_chessboard_preview :
gui_split_preview "fx_chessboard $*",${-3--1}
#@gui Dices : fx_dices, fx_dices(0)
#@gui : Resolution = float(2,1,10)
#@gui : Size = int(24,8,64)
#@gui : Color Model = choice(1,"Black Dices","White Dices","Dices with Colored Numbers","Dices with Colored Sides")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/06</i>.</small>")
fx_dices :
repeat 6 {2*$2},{2*$2} _dice$> done
if {$3%2} negate[-6--1] fi
frame_round[-6--1] 10,10,0,0,128,128,128,0
r2dy[-6--1] $2 a[-6--1] x
repeat {$!-1} l[$>,-1]
+luminance[0] rv[1,2] r[0,1] {100*$1/$2}%,{100*$1/$2}%,1,100%,2 quantize[1] 6,0
*.. $2 channels.. 0,1 r.. {$2*100}%,{$2*100}%
$2,$2,1,2,'if(c,y,x)' r. ...,...,1,2,0,2 +[-3,-1] +warp. ..,0,0 rm...
if {$3<2} rm[0] mv. 0
else r[0] [2],[2],1,100% rv[0,-1] blend[0,-1] multiply
fi
endl done rm.
_dice0 : ellipse. 50%,50%,5.2%,5.2%,0,1,255
_dice1 : ellipse. 25%,25%,5.2%,5.2%,0,1,255 ellipse. 75%,75%,5.2%,5.2%,0,1,255
_dice2 : _dice1 _dice0
_dice3 : _dice1 ellipse. 25%,75%,5.2%,5.2%,0,1,255 ellipse. 75%,25%,5.2%,5.2%,0,1,255
_dice4 : _dice3 _dice0
_dice5 : _dice3 ellipse. 25%,50%,5.2%,5.2%,0,1,255 ellipse. 75%,50%,5.2%,5.2%,0,1,255
#@gui Drawn Montage : fx_drawn_montage, fx_drawn_montage_preview(1)
#@gui : Layer = choice("1st","2nd","3rd","4th","5th","6th","7th","8th","9th","10th","11th","12th","13th","14th","15th","16th")
#@gui : Associated Color = color(0,0,0)
#@gui : Zoom = float(-10,0,10)
#@gui : X-Centering (%) = float(50,0,100)
#@gui : Y-Centering (%) = float(50,0,100)
#@gui : Angle = choice("0 deg.","90 deg.","180 deg.","270 deg.")
#@gui : Pargs = value(-1)
#@gui : Args0 = value(0:0:0:0:50:50:0)
#@gui : Args1 = value(0:0:0:0:50:50:0)
#@gui : Args2 = value(0:0:0:0:50:50:0)
#@gui : Args3 = value(0:0:0:0:50:50:0)
#@gui : Args4 = value(0:0:0:0:50:50:0)
#@gui : Args5 = value(0:0:0:0:50:50:0)
#@gui : Args6 = value(0:0:0:0:50:50:0)
#@gui : Args7 = value(0:0:0:0:50:50:0)
#@gui : Args8 = value(0:0:0:0:50:50:0)
#@gui : Args9 = value(0:0:0:0:50:50:0)
#@gui : Args10 = value(0:0:0:0:50:50:0)
#@gui : Args11 = value(0:0:0:0:50:50:0)
#@gui : Args12 = value(0:0:0:0:50:50:0)
#@gui : Args13 = value(0:0:0:0:50:50:0)
#@gui : Args14 = value(0:0:0:0:50:50:0)
#@gui : Args15 = value(0:0:0:0:50:50:0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter requires a top layer containing the desired montage layout defined as free-form shapes of different colors. You can then assign each
#@gui : layer to a layout color to create the montage.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/01/29</i>.</small>")
_fx_drawn_montage :
nb_layers={min(16,$!-1)}
if {!$nb_layers}
error="A top layout layer is missing for this filter to make it work properly!"
if $-1 gui_warning_preview $error return
else error $error
fi
fi
pargs,args0,args1,args2,args3,args4,args5,args6,args7,args8,args9,args10,args11,args12,args13,args14,args15=${9-25}
if {$1!=$pargs}
({'${args$1}'}) replace. {':'},{','} arg_R,arg_G,arg_B,arg_zoom,arg_xcenter,arg_ycenter,arg_angle=${u\ {t}} rm.
else
arg_R,arg_G,arg_B,arg_zoom,arg_xcenter,arg_ycenter,arg_angle=${2-8}
fi
args$1=$arg_R:$arg_G:$arg_B:$arg_zoom:$arg_xcenter:$arg_ycenter:$arg_angle
status=\{$1\}\{$arg_R,$arg_G,$arg_B\}\{$arg_zoom\}\{$arg_xcenter\}\{$arg_ycenter\}\{$arg_angle\}\{$1\}\{$args0\}\{$args1\}\{$args2\}\{$args3\}\{$args4\}\{$args5\}\{$args6\}\{$args7\}\{$args8\}\{$args9\}\{$args10\}\{$args11\}\{$args12\}\{$args13\}\{$args14\}\{$args15\}
c= repeat $nb_layers ({'${args$>}'}) replace. {':'},{','} R$>,G$>,B$>,zoom$>,xcenter$>,ycenter$>,angle$>=${u\ {t}} cols=$cols$c${R$>},${G$>},${B$>} c=, rm. rotate[{1+$>}] {90*${angle$>}} done
to_rgb[0] to_rgba[^0] $nb_layers,1,1,4,[inf,inf,-inf,-inf] [0],[0]
f[0] "
begin(colors = [ "$cols" ]);
for (l = 0, l<"$nb_layers", ++l,
I==colors[3*l,3]?(
if (x<i(#-2,l,0,0,0), i(#-2,l,0,0,0) = x);
if (y<i(#-2,l,0,0,1), i(#-2,l,0,0,1) = y);
if (x>i(#-2,l,0,0,2), i(#-2,l,0,0,2) = x);
if (y>i(#-2,l,0,0,3), i(#-2,l,0,0,3) = y);
i(#-1,x,y) = l + 1;
);
); I"
thumbnail=0 boundaries=0
if $-1
l={1+$1}
if {$l<=$nb_layers}
if {$l,w>h} +r2dx[$l] {(0$_preview_width?0$_preview_width:400)/6}
else +r2dy[$l] {(0$_preview_height?0$_preview_height:400)/6} fi
frame. 1,1,0,0,0,255 drgba. to. "#"$l,0,-2,13 to_rgba.
mv. -3
thumbnail=1
fi
+f. "const boundaries = 1; V = crop(x-2,y-2,5,5); if (min(V)==max(V),0,i)"
(0,0,0,$cols) r. 3,{$nb_layers+1},1,1,-1 1,100%,1,1,y?255:0 a[-2,-1] x permute. yzcx map.. . rm.
repeat $nb_layers
xmin,ymin,xmax,ymax={-3,I[$>]}
if {!isinf($xmin)" && "!isinf($ymin)" && "!isinf($xmax)" && "!isinf($ymax)}
xc$>,yc$>={0,0.5*([$xmin,$ymin]+[$xmax,$ymax]-6)*100/[w,h]}
else xc$>,yc$>=-1024
fi
done
mv. -3
boundaries=1
fi
if {iM>0}
repeat $nb_layers
l={$>+1} xmin,ymin,xmax,ymax={-2,I[$>]}
if {!isinf($xmin)" && "!isinf($ymin)" && "!isinf($xmax)" && "!isinf($ymax)}
dx={$xmax-$xmin+1}
dy={$ymax-$ymin+1}
nw,nh={$l,round(min(w/$dx,h/$dy)*[$dx,$dy]/(1+3*(${zoom$>}/10)^2))}
r[$l] $nw,$nh,1,100%,0,0,{(100-${xcenter$>})%},{(100-${ycenter$>})%}
r[$l] $dx,$dy,1,100%,6
else r[$l] 1,1
fi
done
to_rgba[0]
f[0] "
l = i#-1;
l1 = l - 1;
l<=0?I:(
xmin = i(#-2,l1,0,0,0);
ymin = i(#-2,l1,0,0,1);
rx = x - xmin;
ry = y - ymin;
crop(#l,rx,ry,0,0,1,1,1,4);
)"
fi
rm[-2,-1]
if $boundaries blend[0,-1] alpha fi
if $thumbnail
drgba[0] rr2d[0] ${-gui_preview_wh}
j[0] .,3,3,0,0,0.75
rm.
fi
if $-1 repeat $nb_layers
to "#"{1+$>},${xc$>}%,${yc$>}%,13,1,0.75
done fi
k[0] c 0,255
u $status
fx_drawn_montage :
_fx_drawn_montage $*,0
fx_drawn_montage_preview :
_fx_drawn_montage $*,1
#@gui Extract Objects : fx_extract_objects, fx_extract_objects_preview(1)
#@gui : Background Point (%) = point(0,0)
#@gui : sep = separator()
#@gui : Color Tolerance = int(20,0,256)
#@gui : Opacity Threshold (%) = int(50,0,100)
#@gui : Minimal Area = float(0.3,0,5)
#@gui : Connectivity = choice("Low","High")
#@gui : Output As = _choice(0,"Crop","Segmentation")
#@gui : sep = separator()
#@gui : Preview Guides = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/23/02</i>.</small>")
#@gui : url = link("Filter explained here","http://gimpchat.com/viewtopic.php?f=28&t=7905")
fx_extract_objects :
if $5 min_area=$5% else min_area=6 fi
repeat $! l[$<] to_rgba
nm=${-gui_layer_name}
w={w} h={h}
x={$1%*(w-1)}
y={$2%*(h-1)}
color={I($x,$y)}
if {$7==0}
+replace_color $3,0,$color,0,0,0,0 autocrop_components. $4%,$min_area,$6,2
repeat {w}
+z[0] {1,i($>,0)},{1,i($>,1)},{1,i($>,3)},{1,i($>,4)}
nm. pos({1,i($>,0)},{1,i($>,1)}),name($nm" "[$>])
done rm[0,1]
elif {$7==1}
replace_color $3,0,$color,0,0,0,0
+autocrop_components[0] $4%,$min_area,$6,2
autocrop_components[0] $4%,$min_area,$6,1
repeat {w} nm[$>] pos({i($>,0)},{i($>,1)}),name($nm" "[$>]) done rm.
fi
$w,$h,1,4 fc. $color nm. name($nm" [background]")
endl done
fx_extract_objects_preview :
x0,y0=${1,2}
if $5 min_area=$5% else min_area=5 fi
repeat $! l[$>] to_rgba
x={$x0%*(w-1)}
y={$y0%*(h-1)}
color={I($x,$y)}
+replace_color $3,0,$color,0,0,0,0
autocrop_components. $4%,$min_area,$6,2
repeat {w}
xycoords={1,i($>,0)},{1,i($>,1)},{1,i($>,3)},{1,i($>,4)}
rectangle[0] $xycoords,0.3,0,0,255,255
rectangle[0] $xycoords,1,0xFFFFFFFF,0,0,0,255
done
drgba[0]
to[0] {w}" objects",2,2,13,2,0.3,255,255,255,255
k[0]
if $8
line 0,$y0%,100%,$y0%,0.5,0xF0F0F0F0,255 line 0,$y0%,100%,$y0%,0.5,0x0F0F0F0F,0
line $x0%,0,$x0%,100%,0.5,0xF0F0F0F0,255 line $x0%,0,$x0%,100%,0.5,0x0F0F0F0F,0
fi
circle $x,$y,3,1,0,255,0 circle $x,$y,3,1,0xFFFFFFFF,0
endl done
#@gui Grid [Cartesian] : fx_imagegrid, fx_imagegrid(0)
#@gui : X-Size = int(10,2,100)
#@gui : Y-Size = int(10,2,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_imagegrid :
imagegrid $1,$2
#@gui Grid [Hexagonal] : fx_imagegrid_hexagonal, fx_imagegrid_hexagonal(1)
#@gui : Resolution = int(32,1,128)
#@gui : Outline = float(0.1,0,0.5)
#@gui : Anti-Aliasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/12/01</i>.</small>")
fx_imagegrid_hexagonal :
repeat $! l[$>]
if $3 r 200%,200%,1,100% fi
imagegrid_hexagonal $1,$2
if $3 r 50%,50%,1,100%,2 fi
endl done
#@gui Grid [Triangular] : fx_imagegrid_triangular, fx_imagegrid_triangular(0)
#@gui : Pattern Width = int(10,8,128)
#@gui : Pattern Height = int(18,8,128)
#@gui : Pattern Type = choice(0,"Horizontal","Vertical","Crossed","Cube","Decreasing","Increasing")
#@gui : Outline Color = color(255,255,255,128)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/08/07</i>.</small>")
fx_imagegrid_triangular :
repeat $! l[$>] split_opacity l[0] to_rgb
imagegrid_triangular ${1-3},{$7/255},${4-6}
endl a c endl done
#@gui Make Seamless [Diffusion] : fx_make_seamless, fx_make_seamless_preview(1)
#@gui : Equalize Light = float(0,0,100)
#@gui : sep = separator(),
#@gui : Preview Original = bool(0)
#@gui : Tiled Preview = choice(3,"None","2x1","1x2","2x2","3x3","4x4")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> This filter helps in converting your input pattern as a <b>seamless</b> (a.k.a periodic) texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/24/02</i>.</small>")
fx_make_seamless :
repeat $! l[$>]
if $1 +b {20.5-$1/50}% -[0] [1] fc. ${average_colors.} + fi
endl done
periodize_poisson c 0,255
fx_make_seamless_preview :
u={arg($3,2,1,2,3,4)} v={arg($3,1,2,2,3,4)}
gui_split_preview "if {!$2} fx_make_seamless $* fi if $3 array "$u","$v" fi",${-3--1}
#@gui Make Seamless [Patch-Based] : fx_frame_seamless, fx_frame_seamless_preview(0)
#@gui : Frame Size = int(32,0,256)
#@gui : Patch Size = int(9,3,64)
#@gui : Blend Size = int(0,0,64)
#@gui : Frame Type = choice(1,"Inner","Outer")
#@gui : Equalize Light = float(100,0,100)
#@gui : sep = separator(),
#@gui : Preview Original = bool(0)
#@gui : Tiled Preview = choice(3,"None","2x1","1x2","2x2","3x3","4x4")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> This filter helps in converting your input pattern as a <b>seamless</b> (a.k.a periodic) texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/15/12</i>.</small>")
fx_frame_seamless :
repeat $! l[$>]
if $5 +b {20.5-$5/50}% -[0] [1] fc. ${average_colors.} + fi
endl done
frame_seamless ${1-4} c 0,255
fx_frame_seamless_preview :
u={arg($7,2,1,2,3,4)} v={arg($7,1,2,2,3,4)}
gui_split_preview "if {!$6} fx_frame_seamless $* fi if $7 array "$u","$v" fi",${-3--1}
#@gui Ministeck : fx_ministeck, fx_ministeck_preview(1)
#@gui : Number of Colors = int(8,2,24)
#@gui : Resolution (px) = int(64,16,256)
#@gui : Piece Size (px) = int(8,1,64)
#@gui : Piece Complexity = int(2,1,10)
#@gui : Relief Amplitude = float(100,0,256)
#@gui : Relief Size = float(0.3,0,1)
#@gui : Add 1px Outline = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/14/01</i>.</small>")
fx_ministeck :
repeat $! l[$>]
if {w>h} r2dx {min($2,w)} else r2dy {min($2,h)} fi
split_opacity l[0]
+colormap. $1 index.. .
[0],[0],1,1 rand[2] 0,1 dilate[2] $4 +[0,2]
r[0] $3""00%,$3""00%
+g[0] xy,1 !=[-2,-1] 0 +f[0] 'i(x+1,y+1)-i(x,y)' !=[-3--1] 0 -|[-3--1]
z[0,-1] 0,0,{w-2},{h-2}
if $7 . fi
+shift. 1,1 *.. -1 +[-2,-1] b. {$6*$3/5} n. -$5,$5
map[0] [1] rm[1] +[0,-1]
if $7 ==[1] 0 * fi
endl r. [0],[0],1,100% a c
endl done
c 0,255
fx_ministeck_preview :
repeat $! l[$>]
w={w} h={h}
fx_ministeck $*
r $w,$h,1,100%,0,0,0.5,0.5
endl done
#@gui Montage : fx_montage, fx_montage_preview(1)
#@gui : Montage Type = choice("Auto","Custom Layout","Horizontal","Vertical","Horizontal Array","Vertical Array")
#@gui : Custom Layout = text{"V(H(0,1),H(2,V(3,4)))"}
#@gui : Merging Mode = choice(1,"Aligned","Scaled")
#@gui : Centering / Scale = float(0.5,0,1)
#@gui : Padding (px) = int(0,0,128)
#@gui : sep = separator()
#@gui : Frame (px) = int(0,0,128)
#@gui : Frame Color = color(0,0,0,255)
#@gui : sep = separator()
#@gui : Angle = float(0,0,360)
#@gui : Angle Variations = float(0,0,180)
#@gui : sep = separator()
#@gui : Cycle Layers = int(0,-255,255)
#@gui : Revert Layer Order = bool()
#@gui : Output As = _choice("Single Layer","Multiple Layers")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Instructions:</b>\n
#@gui : - Don't forget to set the <i>Input layers...</i> option on the left if you have multiple input layers for your montage.\n
#@gui : - The <i>Custom layout</i> parameter is only active when <i>Montage type</i> is set to <i>Custom layout</i>.
#@gui : This is basically a string containing expressions such as:\n
#@gui : \n     . <i>H(a,b)</i> or <i>V(a,b)</i> stand respectively for an horizontal and vertical merge of two blocks <i>a</i> and <i>b</i>.
#@gui : \n     . <i>R(a)</i>, stands for a 90-deg. rotated version of a block <i>a</i>. Use <i>RR(a)</i> and <i>RRR(a)</i> for resp. 180-deg and 270-deg. rotations.
#@gui : \n     . <i>M(a)</i>, stands for a X-mirrored version of a block <i>a</i>. Use <i>MRR(a)</i> for a Y-mirrored version of <i>a</i>.\n\n
#@gui : - A block <i>a</i> can be a layer index or a nested montage expression itself.\n
#@gui : - Layer indices start from <i>0 (top layer)</i> and are treated periodically.
#@gui : </small>"}
#@gui : url = link("Click here for a tutorial","http://blog.patdavid.net/2014/05/gmic-montage.html")
#@gui : url = link("+ video tutorial","http://www.youtube.com/watch?v=iM42vx22gwg")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/22/12</i>.</small>")
fx_montage : skip "${2=A}"
if {!$!} return fi
code0=X code1="$2" code2=H code3=V code4=A code5=B
if {$3==1&&$4<0.5} r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 fi
to_rgba if $14 rv fi if {$13%$!} mv[{$13%$!}--1] 0 fi
if {$11||$12} repeat $! rotate[$>] {$11+u(-$12,$12)},1,0 done fi
montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},$15,\
"if {$""7%2} mirror x fi if {$""8%2} mirror y fi "\
"rotate {90*$""6} "\
"if {$5||$6} "\
"r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 "\
"frame $6,$6,${7-10} "\
"r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
"else r $""4,$""5,1,100%,2 fi "
if $15 gui_autocrop_layers fi
gui_set_layer_name "[Montage]"
fx_montage_preview : skip "${2=A}"
if {!$!} return fi
w={w} h={h}
if {$3==1&&$4<0.5} r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 fi
drgba
code0=X code1="$2" code2=H code3=V code4=A code5=B
to_rgba if $14 rv fi if {$13%$!} mv[{$13%$!}--1] 0 fi
if {$11||$12} repeat $! rotate[$>] {$11+u(-$12,$12)},1,0 done fi
montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},0,\
"if {$""7%2} mirror x fi if {$""8%2} mirror y fi "\
"rotate {90*$""6} "\
"if {$5||$6} "\
"  r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 fs={min(53,max(w,h)/3)} "\
"  frame $6,$6,${7-10} "\
"  r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
"  0 t. \#$""1,0,0,$fs,1,255 expand_xy. 3,0 [-1]x3 a[-4--2] c dilate. {3+2*$fs/20} a.. .,c j[0] [1],{5+$5+$6},{$5+$6},0,0,1,[2],255 k[0] "\
"else "\
"  r $""4,$""5,1,100%,2 fs={min(53,max(w,h)/3)} "\
"  0 t. \#$""1,0,0,$fs,1,255 expand_xy. 3,0 [-1]x3 a[-4--2] c dilate. {3+2*$fs/20} a.. .,c j[0] [1],5,0,0,0,1,[2],255 k[0] "\
"fi "
nw={w} nh={h}
resize_ratio2d $w,{$h-16},2,2
drgba
i[0] 100%,15,1,3,240 t[0] "Estimated size : "{round(100*$nw/$w)}%" x "{round(100*$nh/$h)}%,2,0,16 r[0] 100%,16,1,3,0
a y
#@gui Puzzle : fx_puzzle, fx_puzzle_preview(1)
#@gui : note = note("<small><b>Pattern parameters:</b></small>")
#@gui : X-Tiles = int(5,2,32)
#@gui : Y-Tiles = int(5,2,32)
#@gui : Curvature = float(0.5,0,1.5)
#@gui : Connectors Centering = float(0,0,1)
#@gui : Connectors Variability = float(0,0,2)
#@gui : sep = separator()
#@gui : note = note("<small><b>Blending parameters:</b></small>")
#@gui : Relief Smoothness = float(0.3,0,3)
#@gui : Relief Contrast = float(100,0,255)
#@gui : Outline Smoothness = float(0.2,0,3)
#@gui : Outline Contrast = float(255,0,255)
#@gui : sep = separator()
#@gui : note = note("<small><b>Recomposition parameters:</b></small>")
#@gui : Scale = float(100,0,150)
#@gui : Scale Variations = float(0,0,100)
#@gui : Angle = float(0,-180,180)
#@gui : Angle Variations = float(0,0,180)
#@gui : Shuffle Pieces = bool(0)
#@gui : Additional Outline = bool(0)
#@gui : Output Each Piece on a Different Layer = _bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/06/01</i>.</small>")
fx_puzzle :
repeat $! l[$<]
w={w} h={h} to_rgb
puzzle $w,$h,$1,$2,$3,$4,$5
+b. $6%,0 g. xy +[-2,-1] n. -$7,$7 +[0,-1]
+b. $8%,0 n. 0,1 *. -1 +. 1 n. {(255-$9)/255},1 *[0,-1] c 0,255
if {$10!=100||$11||$12||$13||$14||$15||$16}
+-. 1 label_fg. 0
+area_fg. 0,0 <. 50% -|... . ==. 0 *[-2,-1]
distance.. 0 *.. -1 watershed. .. rm.. label. 0,0
repeat {iM+1}
+==[1] $>
coords=${autocrop_coords.\ 0}
+z[0] $coords z.. $coords rv[-2,-1] *.. . *. 255 a[-2,-1] c
x$>={arg(1,$coords)+round(w/2)} y$>={arg(2,$coords)+round(h/2)}
done
rm[0,1]
if $14 sort_list +,u fi
if $16
repeat $! l[$<]
r2dy {max(0.1,$10+$11*u(-1,1))}% rotate {$12+$13*u(-1,1)}
if $15 expand_xy 1,0 fi
cx={round(w/2)} cy={round(h/2)}
sh 100% if $15 dilate. 3 fi
i[0] $w,$h,1,4
j[0] ..,{${x$<}-$cx},{${y$<}-$cy},0,0,1,.,255 rm[-2,-1]
endl done
else
i[0] $w,$h,1,{s}
repeat {$!-1}
r2dy. {max(0.1,$10+$11*u(-1,1))}% rotate. {$12+$13*u(-1,1)}
if $15 expand_xy. 1,0 fi
cx={round(w/2)} cy={round(h/2)}
sh. 100% if $15 dilate. 3 fi
j[0] ..,{${x$<}-$cx},{${y$<}-$cy},0,0,1,.,255 rm[-2,-1]
done
fi
else rm.
fi
endl done
fx_puzzle_preview :
fx_puzzle ${1-15},0
#@gui Taquin : fx_taquin, fx_taquin(1)
#@gui : X-Tiles = int(7,1,20)
#@gui : Y-Tiles = int(7,1,20)
#@gui : Remove Tile = choice("None","First","Last","Random")
#@gui : sep = separator()
#@gui : Relief = float(50,0,255)
#@gui : Border Thickness (%) = float(5,0,100)
#@gui : Border Outline = int(0,0,16)
#@gui : Ouline Color = color(0,0,0,255)
#@gui : sep = separator()
#@gui : Random Seed = int(0,0,65535)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/13/01</i>.</small>")
fx_taquin :
to_a repeat $! l[$>] srand $11 taquin $1,$2,$3,$4,$5%,$6,${7-10} endl done
#@gui Tileable Rotation : fx_rotate_tileable, fx_rotate_tileable_preview(1)
#@gui : Angle = float(45,0,360)
#@gui : Maximum Size Factor = int(8,0,20)
#@gui : Array Mode = choice(0,"None","x-axis","y-axis","xy-axes","2xy-axes")
#@gui : sep = separator(), note = note("<small><b>Note:</b> This filter implements the tileable rotation technique described by <b>Peter Yu</b>, at:</small>")
#@gui : url = link("[Peter Yu] Create rotated tileable patterns","http://www.peteryu.ca/tutorials/gimp/rotate_tileable_patterns")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/26/05</i>.</small>")
fx_rotate_tileable :
if $3 array_mirror 1,{$3-1},1 fi
rotate_tileable $1,{if($3==0,$2,$2/2)}
fx_rotate_tileable_preview :
l fx_rotate_tileable $*
onfail gui_warning_preview "Invalid image size" endl
#@gui Tiled Isolation : fx_isolate_tiles, fx_isolate_tiles(0)
#@gui : X-Size = float(10,0,100)
#@gui : Y-Size = float(10,0,100)
#@gui : X-Border = float(5,0,100)
#@gui : Y-Border = float(5,0,100)
#@gui : Keep Tiles Square = bool(1)
#@gui : Keep Borders Square = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/13/04</i>.</small>")
fx_isolate_tiles :
repeat $! l[$>] to_rgba
if $5 sx={round(min(w,h)*max($1,$2)/100)} sy=$sx else sx={round(w*$1/100)} sy={round(h*$2/100)} fi
if $6 bx={max($3,$4)} by=$bx else bx=$3 by=$4 fi
s x,-$sx
repeat $! l[$>] s y,-$sy r 100%,{100+$by}%,1,100%,0,0,0.5,0.5 a y endl done
r {100+$bx}%,100%,1,100%,0,0,0.5,0.5 a x
endl done
#@gui Tiled Normalization : fx_normalize_tiles, fx_normalize_tiles(1)
#@gui : X-Tiles = int(25,1,80)
#@gui : Y-Tiles = int(25,1,80)
#@gui : Minimal Value = float(0,0,255)
#@gui : Maximal Value = float(255,0,255)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_normalize_tiles :
repeat $! l. split_tiles $1,$2 n $3,$4 append_tiles $1,$2 endl mv. 0 done
fx_normalize_tiles :
ac "_fx_normalize_tiles ${1-4}",$-1
#@gui Tiled Parameterization : fx_parameterize_tiles, fx_parameterize_tiles(1)
#@gui : X-Tiles = int(10,1,30)
#@gui : Y-Tiles = int(10,1,30)
#@gui : Fitting Function = choice("Linear","Quadratic")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_parameterize_tiles :
if $3
quadratize_tiles $1,$2
else
linearize_tiles $1,$2
fi
c 0,255
#@gui Tiled Random Shifts : fx_shift_tiles, fx_shift_tiles(1)
#@gui : X-Tiles = int(10,1,30)
#@gui : Y-Tiles = int(10,1,30)
#@gui : Amplitude = float(10,0,100)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_shift_tiles :
to_rgba shift_tiles $1,$2,$3
if {$4<1} repeat $! s. c *. $4 a[-4--1] c mv. 0 done fi
#@gui Tiled Rotation : fx_rotate_tiles, fx_rotate_tiles(1)
#@gui : X-Tiles = int(5,1,80)
#@gui : Y-Tiles = int(5,1,80)
#@gui : Angle = float(15,0,360)
#@gui : X-Shadow = float(3,-20,20)
#@gui : Y-Shadow = float(3,-20,20)
#@gui : Smoothness = float(1.8,0,5)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_rotate_tiles :
to_rgba rotate_tiles $3,$1,$2 drop_shadow $4%,$5%,$6%
#@gui _
#@gui <b>Artistic</b>
#@gui Anguish : samj_Angoisse_en, samj_Angoisse_en(1)
#@gui : note = note("<small><b>Iterations</b></small>")
#@gui : Iterations = int(1,1,3)
#@gui : note = note("<small><b>Dog</b></small>")
#@gui : Sigma 1 = float(5,0,10)
#@gui : Sigma 2 = float(0,0,10)
#@gui : note = note("<small><b>Segment Watershed</b></small>")
#@gui : Threshold = float(5,0,10)
#@gui : note = note("<small><b>Smooth</b></small>")
#@gui : Amplitude = float(100,0,200)
#@gui : note = note("<small><b>Noise</b></small>")
#@gui : Amplitude = float(2,0,10)
#@gui : Type = choice(4,"Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : note = note("<small><b>Blend</b></small>")
#@gui : Opacity = float(1,0,1)
#@gui : note = note("<small><b>Sharpen</b></small>")
#@gui : Amplitude = int(250,0,500)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.        Latest Update: <i>2015/03/27</i>.</small>")
samj_Angoisse_en :
-samj_Angoisse $1,$2,$3,$4,$5,$6,$7,$8,$9
#@gui Aurora : gcd_aurora, gcd_aurora(1)
#@gui : note = note("<i>Simple aurora effect filter</i>"), sep = separator()
#@gui : Vertical Amount = float(6,0,50)
#@gui : Horizontal Amount = float(1,0,50)
#@gui : Blend Mode = choice(0,"None","Average")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_aurora : -skip ${1=6},${2=1},${3=0}
-repeat $! -l[$>]
-to_rgb --deriche $1%,2,y -deriche[-1] $2%,0,x
-c[-1] 0,255 -n[-1] 0,255
-if $3 -blend average -else -k[-1] -endif
-endl -done
#@gui Black Crayon Graffiti : fx_crayongraffiti2, fx_crayongraffiti2_preview(0)
#@gui : Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(1,0,10)
#@gui : Opacity = float(0.4,0,1)
#@gui : Edge = float(12,0,50)
#@gui : Fast Approximation = bool(1)
#@gui : Color Smoothness =float(2,1,30)
#@gui : Mixer Style = choice(2,"Lightness","Value","Color Doping")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/07/12</i>.</small>")
fx_crayongraffiti2 :
-repeat $! -l[$>] -split_opacity -l[0]
--blur $3 -hardsketchbw[-1] $1,$2,$4,$5,$6 -to_rgb
-negate[-1] -blur_xy[-2] $7,$7 -reverse
-if {$8==0} -compose_lightness
-elif {$8==1} -compose_value
-elif {$8==2} -fx_compose_colordoping 1,1 -endif
-endl -a c -endl -done
fx_crayongraffiti2_preview :
-gui_split_preview "-fx_crayongraffiti2 ${1--2}",$-1
#@gui Blockism : fx_blockism, fx_blockism_preview(1)
#@gui : note =note("Renders rectangles on to the image.")
#@gui : note =note("Parameters")
#@gui : Relative Size = float(3,0,20)
#@gui : Ratio = float(1.6,1,10)
#@gui : Size Variance = float(0.5,0,10)
#@gui : Relative Block Count = int(50,0,500)
#@gui : Opacity = float(0.5,0,1)
#@gui : Flip Tolerance = int(64,0,255)
#@gui : Reverse Flip = bool(0)
#@gui : Quick = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/8063058705/")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2012/10/07</i>.</small>")
fx_blockism:
XSize={int($1/100*w)}
-if {$XSize==0} XSize=1 -endif
Ratio=$2
Variance={int($3*$XSize)}
Randomness=-1,1
Repeats={int($4/100*max(w,h))}
Opacity=$5
FlipTol=$6
ReverseFlip=$7
LAB=1-$8
YSize={int($Ratio*$XSize)}
MaxXSize={int($XSize+$Variance)}
MaxYSize={int($MaxXSize*$Ratio)}
-to_rgb[0]
-if {$LAB}
-rgb2lab[0]
-split[0] c
-endif
-repeat $!
#Take copy of the last image in the stack for grey value checking
[-1]
-repeat $Repeats
X={int(u(-1,w))}
Y={int(u(-1,h))}
-if {$ReverseFlip==0}
-if {i($X,$Y,0,0)>$FlipTol}
BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-if {i($X,$Y,0,0)<=$FlipTol}
BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-endif
-if {$ReverseFlip==1}
-if {i($X,$Y,0,0)<$FlipTol}
BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-if {i($X,$Y,0,0)>=$FlipTol}
BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-endif
x0={int($X-$BW/2)}
y0={int($Y-$BH/2)}
x1={int($x0+$BW)}
y1={int($y0+$BH)}
-rectangle[-2] $x0,$y0,$x1,$y1,$Opacity,{i($X,$Y,0,0)},{i($X,$Y,0,1)},{i($X,$Y,0,2)},{i($X,$Y,0,3)}
-done
-remove[-1]
-mv[-1] 0
-done
-if {$LAB}
-append[-3,-2,-1] c
-lab2rgb[-1]
-endif
fx_blockism_preview :
-gui_split_preview "-fx_blockism $1,$2,$3,{$4*10},$5,$6,$7,$8",$-1
#@gui Bokeh : fx_bokeh, fx_bokeh_preview(1)
#@gui : Number of Scales = int(3,1,10)
#@gui : Shape = choice(8,"Triangle","Square","Diamond","Pentagon","Hexagon","Octogon","Decagon","Star","Circular")
#@gui : Random Seed = int(0,0,65535)
#@gui : sep = separator(), note = note{"<small><b>Starting parameters:</b></small>"}
#@gui : Density = int(30,1,256)
#@gui : Radius (%) = float(8,0,50)
#@gui : Outline (%) = float(4,0,100)
#@gui : Inner Shade = float(0.3,0,1)
#@gui : Smoothness = float(0.2,0,8)
#@gui : Color = color(210,210,80,160)
#@gui : Color Dispersion = float(0.7,0,1)
#@gui : sep = separator(), note = note{"<small><b>Ending parameters:</b></small>"}
#@gui : Density = int(30,1,256)
#@gui : Radius (%) = float(20,0,50)
#@gui : Outline (%) = float(20,0,100)
#@gui : Inner Shade = float(1,0,1)
#@gui : Smoothness = float(2,0,8)
#@gui : Color = color(170,130,20,110)
#@gui : Color Dispersion = float(0.15,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/02/07</i>.</small>")
fx_bokeh :
_shape=$2
srand $3
repeat $! l[$<] nm=${-gui_layer_name} pos=${-gui_layer_pos}
100%,100%,1,3
(${4-13};${14-23}) if {$1>2} r. 100%,$1,1,1,3 fi
repeat $1
+rows. $> _fx_bokeh... {^} rm.
done
rm. nm. name($nm),opacity(100),mode(screen),pos($pos)
rv
if {0$_output_mode==0} gui_merge_layers
elif {0$_output_mode<2} rm.
fi
endl done
_fx_bokeh0 : shape_star $1,3
_fx_bokeh1 : $1,$1,1,1,1
_fx_bokeh2 : shape_diamond $1
_fx_bokeh3 : shape_polygon $1,5,45
_fx_bokeh4 : shape_polygon $1,6,45
_fx_bokeh5 : shape_polygon $1,8,45
_fx_bokeh6 : shape_polygon $1,10,45
_fx_bokeh7 : shape_star $1,5
_fx_bokeh8 : shape_circle $1
fx_bokeh_preview :
gui_split_preview "_output_mode=0 fx_bokeh $*",${-3--1}
_fx_bokeh :
radius1={r=max(w,h)*$2%;r+1-(r%2)}
radius2={r=$radius1-($radius1*$3%);r+1-(r%2)}
random3d $1 *3d. {-2,w},{-2,h},0
_fx_bokeh$_shape $radius1
if {$radius2>=1} _fx_bokeh$_shape $radius2 r. ..,0,0,0.5,0.5 *. {max(0,min(1,1-$4))} -[-2,-1] fi
sigma={-3,$5%*w}
r. {w+5*$sigma},{h+5*$sigma},1,1,0,0,0.5,0.5
b. $sigma,0 n. 0,255
sprites3d[1] [2],1 rm[2]
l.
s3d r.. 3,{-2,h/3},1,1,-1 s.. x
d={$10*255}
rand[-4] {$6-$d},{$6+$d}
rand... {$7-$d},{$7+$d}
rand.. {$8-$d},{$8+$d}
a[-4--2] x c.. 0,255 y a y
endl
j3d[0] [1],0,0,0,{$9/255},1,0,0 rm[1]
#@gui Brushify : fx_brushify, fx_brushify_preview(0)
#@gui : note = note("<small><b>Brush parameters:</b></small>")
#@gui : Shape = choice(7,"Bottom layer","Top layer","Rectangle","Diamond","Pentagon","Hexagon","Octogon","Ellipse","Gaussian","Star","Heart")
#@gui : Ratio = float(0.25,0,1)
#@gui : Number of Sizes = int(4,1,16)
#@gui : Maximal Size = int(64,1,128)
#@gui : Minimal Size (%) = float(25,0,100)
#@gui : Number of Orientations = int(12,1,24)
#@gui : Fuzzyness = float(0,0,10)
#@gui : Smoothness = float(2,0,10)
#@gui : Light Type = choice(4,"None","Flat","Darken","Lighten","Full")
#@gui : Light Strength = float(0.2,0,1)
#@gui : Opacity = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Painting parameters:</b></small>")
#@gui : Density (%) = float(30,0,100)
#@gui : Contour Coherence = float(1,0,1)
#@gui : Orientation Coherence = float(1,0,1)
#@gui : Gradient Smoothness = float(1,0,10)
#@gui : Structure Smoothness = float(5,0,10)
#@gui : Primary Angle = float(0,-180,180)
#@gui : Angle Dispersion = float(0.2,0,1)
#@gui : sep = separator()
#@gui : Preview Brush = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/22/04</i>.</small>")
fx_brushify :
_fx_brushify $*
s0=0--3 s1=1--2 s2=0--2
l[${s{$1==0?0:$1==1?1:2}},-1] brushify[^-1] .,$3,{$5%},$6,$9,$10,$11,$12%,$13,$14,$15,$16,$17,$18 rm. endl
_fx_brushify :
N={0.9*$4}
if {$1==0} +autocrop. i.. 100%,100%,1,3,1 blend[-2,-1] alpha rr2d. $N,$N,0,3
elif {$1==1} +autocrop[0] i.. 100%,100%,1,3,1 blend[-2,-1] alpha rr2d. $N,$N,0,3
elif {$1==2} $4,$4 rectangle. 10%,10%,90%,90%,1,1
elif {$1==3} shape_diamond. $N
elif {$1==4} shape_polygon $N,5
elif {$1==5} shape_polygon $N,6
elif {$1==6} shape_polygon $N,8
elif {$1==7} shape_circle. $N
elif {$1==8} $4,$4 gaussian. 30%,30%,0
elif {$1==9} shape_star $N
elif {$1==10} shape_heart $N
fi
norm. r. 100%,{max(0.01,100*$2)}%,1,1,2 r. $4,$4,1,1,0,0,0.5,0.5
spread. $7 b. $8% n. 0,1
fx_brushify_preview :
if {$1<2" && "$!<2}
gui_error_preview "When a custom brush (bottom or top layer) is specified, at least two layers are required for this filter to work.In this case, don't forget to set the 'Input layers' option!"
return
fi
fx_brushify $*
if $19
_fx_brushify $*
if {$1==0} rm.. elif {$1==1} rm[0] fi
rr2d. {0,max(1,w/5)},{0,max(1,h/5)},0,2 n. 0,255
frame. 3,3,0 frame. 1,1,255 frame. 1,1,0
to_rgb. to. "Brush",4,2,13,2,1,255,255,0 to_a.
j[^-1] .,2,2 rm.
else
if {$1==0} rm. elif {$1==1} rm[0] fi
fi
#@gui Cartoon : cartoon, fx_cartoon_preview(0)
#@gui : Smoothness = float(3,0,10)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge Threshold = float(20,1,30)
#@gui : Edge Thickness = float(0.25,0,1)
#@gui : Color Strength = float(1.5,0,3)
#@gui : Color Quantization = int(8,2,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_cartoon_preview :
gui_split_preview "cartoon $*",${-3--1}
#@gui Chalk It Up : samj_en_chalkitup, samj_en_chalkitup_preview
#@gui : note = note("Inspired by the tutorial proposed by Lylejk")
#@gui : note = link("http://justpaste.it/chalk_it_up","http://justpaste.it/chalk_it_up")
#@gui : sep = separator(), note = note("<small>Painting parameters</small>")
#@gui : Abstraction = int(5,0,10)
#@gui : Details Scale = float(2.5,0,10)
#@gui : Color = float(1.5,0,5)
#@gui : Smoothness = float(50,0,200)
#@gui : Sharpen Shades = bool(1)
#@gui : sep = separator(), note = note("<small>Morpho parameters</small>")
#@gui : Action = choice(5,"Erosion","Dilation","Opening","Closing","Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gui : Size = int(5,0,32)
#@gui : Invert Colors = bool(0)
#@gui : Shape = int(0,0,1)
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator(), note = note("<small>Param\303\250tres filtre Spread / Spread parameters</small>")
#@gui : X-Variations = float(0.8,-5,5)
#@gui : Y-Variations = float(1.9,-5,5)
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Auteurs / Authors : <i>Lylejk/samj/Ronounours</i>.        Latest Update: <i>2015/04/01</i>.</small>")
samj_en_chalkitup :
-samj_chalkitup $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13
samj_en_chalkitup_preview :
-gui_split_preview "-samj_en_chalkitup ${1--2}",$-1
#@gui Circle Abstraction : fx_circle_abstraction, fx_circle_abstraction_preview(1)
#@gui : Number of Colors = int(8,2,16)
#@gui : Density = int(5,1,100)
#@gui : Opacity = float(0.8,0,1)
#@gui : Smoothness = float(0,0,4)
#@gui : Filled Circles = bool(1)
#@gui : Fill Transparent Holes = bool(1)
#@gui : Normalize Colors = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/16/06</i>.</small>")
fx_circle_abstraction :
repeat $! l[$>]
b $4%
+colormap $1 index[0] [1],0,0
[0],[0],1,4,0
repeat $1
rprogress {$>*100/$1}
+==[0] $>
skeleton3d. 2,2,0,1,0
if {@7}
s3d. l[-6--1]
r[2] 3,{2,h/3},1,1,-1
1,{2,h/2*$2%},1,1,1 r. 1,{2,h/2},1,1,4 r. 3,200% *[2,-1] y
endl
a[-6--1] y col3d. {1,I($>)}
[0],[0],1,4,0
j3d. ..,0,0,0,1,{1+$5},0,0
sh. 3 col3d... 255 j3d. ...,0,0,0,$3,{1+$5},0,0 rm.
rm..
blend[2,-1] alpha
fi
done
k[2]
if $6 +channels 3 <. 1 inpaint[0] [1],0,1 rm. channels. 0,2 fi
if $7 n 0,255 fi
rprogress 100
endl done
fx_circle_abstraction_preview :
gui_split_preview "fx_circle_abstraction $*",${-3--1}
#@gui Colored Pencils : fx_cpencil, fx_cpencil_preview(0)
#@gui : Size = float(1.3,0,5)
#@gui : Amplitude = float(50,0,200)
#@gui : Quantize Colors = int (20,2,255)
#@gui : Color Smoothness = float(2,0,30)
#@gui : Mixer Mode = choice(2,"Color Doping","Darken","Hard Light","Grain Merge","Lightness","Multiply","Soft Light","Value")
#@gui : Color Intensity =float (1,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2010/29/12</i>.</small>")
fx_cpencil :
-repeat $! -l[$>] -split_opacity -l[0]
--pencilbw $1,$2 -blur_xy[-1] 0.4,0.4
-quantize[-2] $3 -normalize 0,255 -to_rgb
-blur_xy[-2] $4,$4
-if {$5==0} -fx_compose_colordoping $6,0
-elif {$5==1} -fx_compose_darken $6,1
-elif {$5==2} -fx_compose_hardlight $6,0
-elif {$5==3} -fx_compose_grainmerge $6,0
-elif {$5==4} -fx_compose_lightness $6,1
-elif {$5==5} -fx_compose_multiply $6,0
-elif {$5==6} -fx_compose_softlight $6,0
-elif {$5==7} -fx_compose_value $6,1 -endif
-endl -a c -endl -done
fx_cpencil_preview :
-gui_split_preview "-fx_cpencil ${1--2}",$-1
#@gui Color Abstraction Paint : fx_ColorAbstractionPaint, fx_ColorAbstractionPaint_Preview(0)
#@gui : Abstraction = int(5,1,10)
#@gui : Ellipse Ratio = float(10,1,100)
#@gui : sep = separator(),note = note("Opacities, try 0 to see individual effect layers")
#@gui : Ellipsionism Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : Use as Hue = bool(0)
#@gui : Painting Opacity = float(1,-1,1)
#@gui : sep = separator()
#@gui : Use as Saturation = bool(0)
#@gui : Color Abstraction Opacity = float(1,-1,1)
#@gui : Negative Color Abstraction = bool(0)
#@gui : Cubism on Color Abstraction = bool(0)
#@gui : Kuwahara on Painting = bool(0)
#@gui : Soften = float(0,0,100)
#@gui : Soften All Channels = bool(0)
#@gui : DoNotMergeLayers = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = link("Sample art here","http://www.flickr.com/photos/naggobot/6640743133/")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2014/02/23</i>.</small>")
fx_ColorAbstractionPaint :
-to_rgb
pAbstraction=$1
EllipseRatio=$2
ValueOpacity=$3
UseHue=$4
MultiplyOpacity=$5
UseSaturation=$6
GrainMergeOpacity=$7
NCA=$8
CubeIt=$9
KuwaIt=$10
Soften=$11
SoftenAll=$12
DoNotCompose=$13
ReverseOrder0=1
ReverseOrder1=1
ReverseOrder2=1
eSmoothness=1
eOpacity=0.8
eOutline=1
eDensity={1.5*$eSmoothness/10}
pDetailsScale={$pAbstraction/2}
pColor=1.5
pSmoothness={10*$pAbstraction}
eSmoothness={10+($pAbstraction-1)*(1-10)/(10-1)}
ePrimaryRadius={0,($pAbstraction/5)*($pAbstraction/5)*sqrt(h)}
eSecondaryRadius={$EllipseRatio/100*$ePrimaryRadius}
cAbstraction={2+($pAbstraction-1)*(10-2)/(10-1)}
CubeSize={4+($pAbstraction-1)*(10-4)/(10-1)}
--fx_ellipsionism[0] $ePrimaryRadius,$eSecondaryRadius,$eSmoothness,$eOpacity,1,$eDensity,0
-if {$SoftenAll==1" && "$Soften>0} -blur[-1] $Soften,0 -endif
--fx_painting[0] $pAbstraction,$pDetailsScale,$pColor,$pSmoothness,1,0
-if {$KuwaIt==1} -fx_kuwahara[-1] 2,$pAbstraction,0,0 -endif
-if {$Soften>0} -blur[-1] $Soften,0 -endif
--fx_color_abstraction[0] $cAbstraction,45,0.35,0
-if {$NCA==1} -negate[-1] -endif
-if {$CubeIt==1} -cubism[-1] 600,$CubeSize,40,0.7,0 -endif
-if {$Soften>0} -blur[-1] $Soften,0 -endif
-if {$DoNotCompose==0}
#Compose Original and Ellipsionism with value
-blend[0,1] value,$ValueOpacity,$ReverseOrder0
#Compose Original+Ellipsionism with painting
-if {$MultiplyOpacity<0}
ReverseOrder1=0
MultiplyOpacity={-1*$MultiplyOpacity}
-endif
-if {$UseHue==0}
-blend[0,1] multiply,$MultiplyOpacity,$ReverseOrder1
-elif {$UseHue==1}
-blend[0,1] hue,$MultiplyOpacity,$ReverseOrder1
-endif
#Compose Original+Ellipsionism+Painting with Color abstraction
-if {$GrainMergeOpacity<0}
ReverseOrder2=0
GrainMergeOpacity={-1*$GrainMergeOpacity}
-endif
-if {$UseSaturation==0}
-blend[0,1] grainmerge,$GrainMergeOpacity,$ReverseOrder2
-elif {$UseSaturation==1}
-blend[0,1] saturation,$GrainMergeOpacity,$ReverseOrder2
-endif
-keep[0]
-endif
-if {$DoNotCompose==1} -remove[0] -endif
fx_ColorAbstractionPaint_Preview :
-gui_split_preview "-fx_ColorAbstractionPaint ${1--2}",$-1
#@gui Cubism : fx_cubism, fx_cubism_preview(1)
#@gui : Iterations = int(2,0,10)
#@gui : Density = float(50,0,200)
#@gui : Thickness = float(10,0,50)
#@gui : Angle = float(90,0,360)
#@gui : Opacity = float(0.7,0.01,1)
#@gui : Smoothness = float(0,0,5)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/05/06</i>.</small>")
fx_cubism :
repeat $1 cubism ${2--1} done
fx_cubism_preview :
gui_split_preview "fx_cubism $*",${-3--1}
#@gui Cutout : fx_cutout, fx_cutout_preview(1)
#@gui : Number of Levels = int(4,2,32)
#@gui : Edge Simplicity = float(0.5,0,3)
#@gui : Edge Fidelity = int(4,0,10)
#@gui : Normalize = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>Garagecoder</i>.      Latest Update: <i>2014/03/06</i>.</small>")
fx_cutout :
repeat $! l[$>] split_opacity l[0]
median {10-$3}
quantize $1
+area. 0,1 med=${-med} rm.
inpaint_holes {$med*$2%},0,1
if $4 n 0,255 fi
endl a c endl done
fx_cutout_preview :
gui_split_preview "fx_cutout $*",${-3--1}
#@gui Diffusion Tensors : fx_diffusiontensors, fx_diffusiontensors_preview(0)
#@gui : Resolution (%) = float(10,0,20)
#@gui : Size = float(5,0,16)
#@gui : Color Mode = choice(3,"Monochrome","Grayscale","Orientation","Color")
#@gui : Outline = int(1,0,16)
#@gui : sep = separator()
#@gui : Sharpness = float(0.15,0,1)
#@gui : Anisotropy = float(1,0,1)
#@gui : Gradient Smoothness = float(0,0,10)
#@gui : Tensor Smoothness = float(3,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/19/10</i>.</small>")
fx_diffusiontensors :
repeat $! l[$>]
wh={[w,h]}
+diffusiontensors ${5-8}
r2dx. $1%
dt. {round(125/$1)},$2,{$3<3?$3:0},$4
if {$3==3}
remove_opacity.. r.. .,.,1,100%,3 blend[0] [1],shapeaverage0 dilate. {1+2*$4} a c
else k. fi
r. $wh,1,100%,2
endl done
fx_diffusiontensors_preview :
gui_split_preview "fx_diffusiontensors $*",${-3--1}
#@gui Dream Smoothing : fx_dreamsmooth, fx_dreamsmooth_preview(0)
#@gui : note = note("Updated for 1.5.4.0")
#@gui : note = note("A relatively slow filter that uses anisotropic filtering to smooth an image. More iterations produces softer image as does lower opacity values. Practical modes for merging are Alpha and Average. Note that results are resolution dependent.")
#@gui : sep = separator(), note = note("General settings")
#@gui : Iterations = int(3,1,10)
#@gui : Equalize at Each Step = bool(1)
#@gui : sep = separator(), note = note("Merging of iterations")
#@gui : Merging Option = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor","edges")
#@gui : Opacity = float(0.8,0,1)
#@gui : Reverse Order = bool(0)
#@gui : note = note("Settings for layer mode edges")
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator()
#@gui : note = note("Parallel processing settings. Increase spatial overlap if vertical bands appear.")
#@gui : Parallel Processing = choice(1,"Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gui : Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2014/02/20</i>.</small>")
#@gui : note = link("Sample processing here","http://www.flickr.com/photos/naggobot/7644006608/")
fx_dreamsmooth :
-m "MergeChoise : $""=_mode" -MergeChoise "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
-to_rgb
Iterations=$1
Eqa=$2
MergingOption=$3
Opacity=$4
ReverseOrder=$5
Smoothness=$6
Threads=$7
Overlap=$8
-repeat $! -l[$>]
-repeat $Iterations
#Calculate width and height
IWidth={0,round(w/($<+1))}
IHeight={0,round(h/($<+1))}
#Resize previously processed image. Not done on first repeat loop since there is no such image yet.
-if {$>!=0}
-r[-1] $IWidth,$IHeight,1,3,5,1
-endif
#Resize and make a copy
--r[0] $IWidth,$IHeight,1,3,5,1
#Smoothing
-fx_smooth_anisotropic[-1] {430/$Iterations*($<+1)},0.4,0.5,0.6,2,0.8,30,2,0,0,1,0,$Threads,$Overlap,0
-fx_smooth_anisotropic[-1] {600/$Iterations*($<+1)},0.4,1,0.6,4,0.8,15,5,0,1,1,0,$Threads,$Overlap,0
#Combine images if not first round
-if {$>!=0}
-if {$3!=42}
-blend[-1,-2] ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
-endif
-if {$3==42}
-blend_edges[-1,-2] $Opacity,$Smoothness,$ReverseOrder
-endif
-if {$Eqa}
-equalize[-1] 256
-endif
-endif
-done
-keep[-1]
-endl -done
fx_dreamsmooth_preview :
-gui_split_preview "-fx_dreamsmooth ${1--2}",$-1
#@gui Ellipsionism : fx_ellipsionism, fx_ellipsionism_preview(0)
#@gui : Primary Radius = float(20,1,100)
#@gui : Secondary Radius = float(10,1,100)
#@gui : Smoothness = float(0.5,0,10)
#@gui : Opacity = float(0.7,0,1)
#@gui : Outline = float(3,1,3)
#@gui : Density = float(0.5,0.1,2)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_ellipsionism :
ellipsionism ${^0}
fx_ellipsionism_preview :
gui_split_preview "fx_ellipsionism $*",${-3--1}
#@gui Felt Pen : fx_feltpen, fx_feltpen_preview(0)
#@gui : Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(1,0,10)
#@gui : Opacity = float(0.1,0,1)
#@gui : Edge = float(20,0,100)
#@gui : Thickness = int(5,2,32)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/25/10</i>.</small>")
fx_feltpen :
repeat $! l[$>] +fx_hardsketchbw ${1-5},0,0 blend hardlight erode_oct $6 endl done
fx_feltpen_preview :
gui_split_preview "fx_feltpen $*",${-3--1}
#@gui Finger Paint : gtutor_fpaint, gtutor_fpaint_preview(0)
#@gui : note = note("<b>Paint Detail</b>")
#@gui : Finger Size = float(0.5,0,1)
#@gui : Keep Detail = float(0.5,0,1)
#@gui : Bristle Size = float(0.0,0,1)
#@gui : Edge Detect Includes Chroma = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Render Detail</b>")
#@gui : Light Direction = float(45.0,0,360.0)
#@gui : Shadow = float(0.5,0,1)
#@gui : Highlight = float(0.5,0,1)
#@gui : Specular = float(0.5,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Garry R. Osgood</i>. Latest update: <i>2015/02/26</i>.</small>")
#@gui : note = link("Finger paint instructions and tutorial.","http://gmic.eu/tutorial/fingerpainting.shtml")
gtutor_fpaint :
-repeat $!
-local[$>]
hasalpha={s>3}
-if {$hasalpha}
-split_opacity[-1]
-reverse[-2,-1]
-endif
lh={h}
--blur[-1] {$1/1.25}%
-if $4
--luminance[-1]
-rgb2hsl[-2]
-split[-2] c
-rm[-4,-2]
-quantize[-2,-1] {round(5+15*(1-$1))},1,1
-gradient_norm[-2,-1]
-normalize[-2,-1] 0,255
-add[-2,-1]
-else
-quantize[-1] {round(5+15*(1-$1))},1,1
-gradient_norm[-1]
-normalize[-1] 0,255
-endif
-threshold[-1] {80-60*$2}%
-dilate_circ[-1] 8
-thinning[-1]
-dilate_circ[-1] 3
--diffusiontensors[-1] 0.1,0.85,0.3,{4+8*$1}
-if {$2<1}
[-1]
-resize2dy[-3,-1] {$lh*(0.25+0.75*$2)},5
-repeat 2
-smooth[-3] [-1],{400*(1-$2)}
-done
-rm[-1]
-resize[-2] [-3],[-3],[-2],[-2],5,0
-endif
-eigen[-1]
-split[-2] c
-fill_color[-3] {1-0.15*$3}
-fill_color[-2] {0.15*$3}
-append[-3,-2] c
-eigen2tensor[-2,-1]
98%,98%,1,1 -noise[-1] {20-10*$3},2 ==. 1
-resize[-1] [-2],[-2],[-1],[-1],0,0,0.5,0.5,0.5,0.5
-to_rgb[-1]
-mul[-1] [-4]
--ac[-4] "-mul 0.6","hsl_s"
-ac[-1]  "-mul 0.85","hsl_l"
-repeat 2
-smooth[-2,-1] [-3],{100*(6-5*$2)}
-done
--luminance[-2]
-normalize[-1] 0,0.7
--normalize[-5] 0,1
-add[-2,-1]
-normalize[-1] 0,1
-blend[-3,-2] add
-gradient[-1]
-append[-2,-1] c
100%,100%,1,2
-if $6
-fill_color[-1] {cos(2*((180+$5)%360)*pi/360)},{sin(2*((180+$5)%360)*pi/360)}
--mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-normalize[-1] 0,1
-to_rgb[-1]
-mul[-1] [-7]
-negate[-1]
-normalize[-1] 0,255
-blend[-4,-1] multiply,$6
-endif
-if $7
-fill_color[-1] {cos(2*$5*pi/360)},{sin(2*$5*pi/360)}
--mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-normalize[-1] 0,1
-to_rgb[-1]
-mul[-1] [-7]
-normalize[-1] 0,255
-blend[-4,-1] screen,$7
-endif
-if $8
-fill_color[-1] {cos(2*$5*pi/360)},{sin(2*$5*pi/360)}
--mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-to_rgb[-1]
-normalize[-1] 0,255
-blend[-4,-1] screen,$8
-endif
-rm[-1,-2,-4,-5,-6]
-ac[-1] "-apply_curve 1,0,32,127,180,255,255","hsl_s"
-apply_gamma[-1] 1.4
-if {$hasalpha}
-reverse[-2,-1]
-append[-2,-1] c
-endif
-endlocal
-done
gtutor_fpaint_preview :
-gui_split_preview "-gtutor_fpaint ${^0}",$-1
#@gui Fractalize : fractalize, fractalize(1)
#@gui : Detail Level = float(0.8,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Note:</b> This filter uses lot of random values to generate its result, so running it twice will give you different results !</small>")
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=10036")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/25/04</i>.</small>")
#@gui Graphic Boost : fx_graphic_boost4, fx_graphic_boost4(0)
#@gui : sep = separator ()
#@gui : note = note("Unsharp Mask controls")
#@gui : Radius = float(1.25,0,20)
#@gui : Darken = float(2,0,10)
#@gui : sep = separator()
#@gui : Skip Others Steps = bool(false)
#@gui : note = note("Check for visual control, UNcheck to reactivate the other controls")
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("BW_Pencil Controls")
#@gui : Pencil Size = float(0.15,0,4)
#@gui : Pencil Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : Skip Others Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator ()
#@gui : Activate "Pencil Smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : Pencil Smoother Sharpness = float(0.5,0,2)
#@gui : Pencil Smoother Edge Protection = float(0.45,0,1)
#@gui : Pencil Smoother Smoothness = float (2,0,10)
#@gui : sep = separator()
#@gui : Skip Others Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator ()
#@gui : note = note("Merging Options")
#@gui : SWAP Layers = bool (True)
#@gui : note = note (""Swap" change the effect of Merging and Intesity")
#@gui : Merging Option = choice( "Hard Light","Grain Merge","Multiply","Color Burn","Overlay" ,"Value","Darken" ,"Lightness", "Luminance","*Colors Doping*","Comix Colors" ,"Graphic Colours","Graphix Colors","Vivid Edges*","Dark Edges","Dark Screen","Vivid Screen","Interpolate")
#@gui : Opacity = float(1,0,1)
#@gui : Intensity = float(1,0,1)
#@gui : sep = separator ()
#@gui : Add Painter's Touch = bool(true)
#@gui : note = note("If unchecked the 3 sliders below are disabled")
#@gui : sep = separator ()
#@gui : Painter's Touch Sharpness = float(0.5,0,2)
#@gui : Painter's Edge Protection Flow = float(0.45,0,1)
#@gui : Painter's Smoothness =float(1,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>. Latest update : <i>2011/13/11 </i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=775")
fx_graphic_boost4 :
-repeat $! -l[$>] -split_opacity -l[0]
-fx_unsharp 1,$1,30,3,0,$2,0.40,1,0,0,0
-if {$3==1} -break -endif
--fx_pencilbw $4,$5,0,0,0
-if {$6==1} -keep[-1] -break -endif
-if {$7==1} -fx_smooth_anisotropic[1] 60,$8,$9,$10,1.1,0.8,30,2,0,1,1,0 -endif
-if {$11==1} -keep[-1] -break -endif
-if {$12==1}  -reverse -endif
-if {$13==0} -fx_compose_hardlight $14,0
-elif {$13==1} -fx_compose_grainmerge $14,0
-elif {$13==2} -fx_compose_multiply $14,0
-elif {$13==3} -fx_compose_colorburn $14,0
-elif {$13==4} -fx_compose_overlay $14,0
-elif {$13==5} -fx_compose_value $14,1
-elif {$13==6} -fx_compose_darken $14,0
-elif {$13==7} -fx_compose_lightness $14,1
-elif {$13==8} -fx_compose_luminance $14,1
-elif {$13==9} -fx_compose_colordoping $14,0
-elif {$13==10} -fx_compose_comix_color $14,0,$15
-elif {$13==11} -fx_compose_graphicolor $14,0,$15
-elif {$13==12} -fx_compose_graphixcolor $14,0
-elif {$13==13} -fx_compose_vividedges $14,0.50,0,$15
-elif {$13==14} -fx_compose_darkedges $14,0.50,0,$15
-elif {$13==15} -fx_compose_vividscreen $14,0,$15
-elif {$13==16} -fx_compose_darkscreen $14,0,$15
-elif {$13==17} -fx_compose_interpolation $14,0 -endif
-if {$16==1} -fx_smooth_anisotropic 60,$17,$18,$19,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
#@gui Graphic Novel : fx_graphic_novelfxl, fx_graphic_novelfxl(0)
#@gui : sep = separator ()
#@gui : note = note("Apply Local Normalization")
#@gui : SKIP This Step = bool(false)
#@gui : sep = separator ()
#@gui : note = note(" Local Normalization Controls")
#@gui : LN Amplititude = float(2,0,60)
#@gui : LN Size = float(6,0,64)
#@gui : LN Neightborhood-Smoothness = float(5,0,40)
#@gui : LN Average-Smoothness = float(20,0,40)
#@gui : sep = separator()
#@gui : SKIP All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note(" Pencil Options")
#@gui : Pencil Size = float(0.62,0,4)
#@gui : Pencil Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : SKIP All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : Activate "Pencil Smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : sep = separator()
#@gui : Pencil Smoother Sharpness = float(0.5,0,2)
#@gui : Pencil Smoother Edge Protection = float(0.78,0,1)
#@gui : Pencil Smoother Smoothness = float(1.92,0,10)
#@gui : sep = separator()
#@gui : SKIP All Other Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator()
#@gui : note = note ("Boost Merging Options")
#@gui : Swap Layers = bool (false)
#@gui : MIxer = choice("Overlay","Multiply","Soft light","Color Burn","Darken","Stamp","Hard Light","Value","Grain Merge","Freeze","Lightness", "Luminance","*Colors Doping","*Comix Colors*" ,"Graphic Colours","*Graphix Colors","*Vivid Edges*","*Dark Edges*","*Dark Screen*","*Vivid Screen*","Interpolate")
#@gui : Opacity = float(1,0,1)
#@gui : Intensity = float(1,0,1)
#@gui : sep = separator ()
#@gui : Add Painter's Touch = bool(true)
#@gui : sep = separator ()
#@gui : Painter's Touch Sharpness = float(0.5,0,2)
#@gui : Painter's Edge Protection Flow = float(0.8,0,1)
#@gui : Painter's Smoothness =float(1.28,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>. Latest update : <i>2011/13/11</i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=1582")
fx_graphic_novelfxl :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0} -fx_normalize_local $2,$3,$4,$5,1,3,0 -endif
-if {$6==0} --fx_pencilbw $7,$8,0,0,0 -endif
-if {$9==1} -keep[-1] -break -endif
-if {$10==1} -fx_smooth_anisotropic[-1] 60,$11,$12,$13,1.1,0.8,30,2,0,1,1,0 -endif
-if {$14==1} -keep[-1] -break -endif
-if {$15==1} -reverse -endif
-if {$16==0} -fx_compose_overlay $17,0
-elif {$16==1} -fx_compose_multiply $17,0
-elif {$16==2} -fx_compose_softlight $17,0
-elif {$16==3} -fx_compose_colorburn $17,0
-elif {$16==4} -fx_compose_darken $17,0
-elif {$16==5} -fx_compose_stamp $17,0
-elif {$16==6} -fx_compose_hardlight $17,0
-elif {$16==7} -fx_compose_value $17,1
-elif {$16==8} -fx_compose_grainmerge $17,0
-elif {$16==9} -fx_compose_freeze $17,0
-elif {$16==10} -fx_compose_lightness $17,1
-elif {$16==11} -fx_compose_luminance $17,1
-elif {$16==12} -fx_compose_colordoping $17,0
-elif {$16==13} -fx_compose_comix_color $17,0,$18
-elif {$16==14} -fx_compose_graphicolor $17,0,$18
-elif {$16==15} -fx_compose_graphixcolor $17,0
-elif {$16==16} -fx_compose_vividedges $17,0.50,0,$18
-elif {$16==17} -fx_compose_darkedges $17,0.50,0,$18
-elif {$16==18} -fx_compose_vividscreen $17,0,$18
-elif {$16==19} -fx_compose_darkscreen $17,0,$18
-elif {$16==20} -fx_compose_interpolation $17,0 -endif
-if {$19==1} -fx_smooth_anisotropic 60,$20,$21,$22,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
#@gui Hard Sketch : fx_hardsketchbw, fx_hardsketchbw_preview(0)
#@gui : Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(1,0,10)
#@gui : Opacity = float(0.1,0,1)
#@gui : Edge = float(20,0,100)
#@gui : Fast Approximation = bool(0)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_hardsketchbw :
b $3
if {$7==4} repeat $! l[$>] +hardsketchbw $1,$2,$4,$5,$6 blend hardlight endl done return fi
hardsketchbw $1,$2,$4,$5,$6
if {$7&1} negate fi
if {$7==2} r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
elif {$7==3} r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
fi
fx_hardsketchbw_preview :
gui_split_preview "fx_hardsketchbw $*",${-3--1}
#@gui Highlight Bloom : fx_highlight_bloom, fx_highlight_bloom_preview(0)
#@gui : Details Strength (%) = float(90,0,400)
#@gui : Details Scale = float(60,0,255)
#@gui : Smoothness = float(60,0,255)
#@gui : Highlight (%) = int(30,0,100)
#@gui : Contrast (%) = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/24/10</i>.</small>")
#@gui : sep = separator(), note = note("This effect has been inspired by:")
#@gui : url = link("This tutorial by Sebastien Guyader and Patrick David","https://pixls.us/articles/highlight-bloom-and-photoillustration-look/")
fx_highlight_bloom :
repeat $! l[$>] split_opacity l[0]
+smooth $2,0.3,0.8,1,2
-.. .
amp=$3 do smooth. {min(50,$amp)},0.1,1,1,2 amp-=50 while {$amp>0}
+retinex. 16,lab,0,15 j.. .,0,0,0,0,{$4%} rm.
ac. "normalize_local {$5%},5",lab_l
*.. {$1%}
+ c 0,255
endl a c endl done
fx_highlight_bloom_preview :
gui_split_preview "fx_highlight_bloom $*",${-3--1}
#@gui Hope Poster : fx_poster_hope, fx_poster_hope_preview(0)+
#@gui : Gamma = float(0,-3,3)
#@gui : Smoothness = float(3,0,20)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/07/11</i>.</small>")
fx_poster_hope :
repeat $! l[$>] split_opacity l[0]
apply_gamma {10^$1} poster_hope $2
endl a c endl done
fx_poster_hope_preview :
gui_split_preview "fx_poster_hope $*",${-3--1}
#@gui Hough Sketch : fx_houghsketchbw, fx_houghsketchbw_preview(0)
#@gui : Smoothness = float(1.25,0,10)
#@gui : Density = float(10,0,70)
#@gui : Radius = int(5,0,30)
#@gui : Threshold = float(80,0,100)
#@gui : Opacity = float(0.1,0,1)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/18/05</i>.</small>")
fx_houghsketchbw :
b $1 n 0,255
if {$6==4} repeat $! l[$>] +houghsketchbw ${2-5} blend hardlight endl done return fi
houghsketchbw ${2-5}
if {$6&1} negate fi
if {$6==2} r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
elif {$6==3} r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
fi
fx_houghsketchbw_preview :
gui_split_preview "fx_houghsketchbw $*",${-3--1}
#@gui Illustration Look : fx_illustration_look,fx_illustration_look_preview(0)
#@gui : Tone Mapping (%) = float(100,0,100)
#@gui : Desaturate (%) = float(0,0,100)
#@gui : Vintage Tone (%) = float(0,0,100)
#@gui : Output as Multiple Layers = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i>S&#233;bastien Guyader</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2017/05/01</i>.</small>")
fx_illustration_look :
repeat $! l[$>] nm=${-gui_layer_name}
to_rgb nm. base_layer
+fx_smooth_anisotropic[base_layer] 20,0.16,0.63,0.6,2.35,0.8,30,2,0,1,1,0,1,24 nm. blur_layer
+blend[base_layer,blur_layer] grainextract nm. detail_layer
if $2 rgb2hsv[blur_layer] sh[blur_layer] 1 -. {$2%} c. 0,1 rm. hsv2rgb[blur_layer] fi
if $3 +fx_mix_rgb[blur_layer] 1,10,0,1,0,0,0.7,-10,0,0,10,0 j[blur_layer] .,0,0,0,0,{$3%} rm. fi
if $1 +fx_map_tones_fast[blur_layer] 20,0.2,11,0 j[blur_layer] .,0,0,0,0,{$1%} rm. fi
simplelocalcontrast_p[blur_layer] 25,1,50,1,1,1,1,1,1,1,1,1
+fx_graphic_novelfxl[blur_layer] 1,2,6,5,20,0,1.02857,200,0,1,0.0761905,0.0857143,0,0,0,2,1,1,1,1.25714,0.371429,1.04762 nm. graphicnovel_layer
mv[detail_layer] 0 nm[detail_layer] "name("$nm" [Detail]),mode(grainmerge),opacity(100)"
mv[graphicnovel_layer] 1 nm[graphicnovel_layer] "name("$nm" [Paint]),mode(normal),opacity(50)"
mv[blur_layer] 2 nm[blur_layer] "name("$nm" [Base]),mode(normal),opacity(100)"
rm[base_layer]
if {!$4} gui_merge_layers nm "name("$nm"),mode(normal),opacity(100)" fi
endl done
fx_illustration_look_preview :
gui_split_preview "fx_illustration_look ${1-3},0",$-1
jl_hsv_to_rgb :
({360*$1}^$2^$3) hsv2rgb. u {^} rm.
levels :
_inplow={int($1)}
_inphigh={int($2)}
_gamma=$3
_outlow={int($4)}
_outhigh={int($5)}
_tmp2=""
if {$_gamma!=1}
_tmp2="-apply_gamma "$_gamma
apply_channels $_tmp2,$6,0
fi
_curve1="0,"
if {$_inplow>0}
_tmp1="0,"
_curve1=$_curve1$_tmp1$_outlow","
fi
_curve1=$_curve1$_inplow","$_outlow","$_inphigh","$_outhigh
if {$_inphigh<255}
_curve1=$_curve1",255,"$_outhigh
fi
if {['$_curve1']!='0,0,0,255,255'}
_tmp2="-apply_curve "$_curve1
apply_channels $_tmp2,$6,0
fi
fx_equalize_s :
repeat $! l[$>] split_opacity l[0] to_rgb
rgb2hsv sh 1,1 *. $1 +. $2 c. 0,1 rm. hsv2rgb
endl a c endl done
#@gui Kuwahara : fx_kuwahara, fx_kuwahara_preview(0)
#@gui : Iterations = int(2,1,20)
#@gui : Radius = int(5,1,30)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/31/05</i>.</small>")
fx_kuwahara :
ac "repeat $1 kuwahara $2 done",$3,$4
fx_kuwahara_preview :
gui_split_preview "fx_kuwahara $*",${-3--1}
#@gui Linify : fx_linify, fx_linify_preview(0)
#@gui : Density = float(40,0,100)
#@gui : Spreading = float(2,0,10)
#@gui : Resolution (%) = float(40,0,100)
#@gui : Line Opacity = float(10,0,30)
#@gui : Line Precision = int(24,1,128)
#@gui : Color Mode = choice(0,"Subtractive","Additive")
#@gui : sep = separator(), Preview Progression While Running = _bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<b>Note:</b>\n\n
#@gui : - This filter is our own implementation of the nice algorithm proposed on the webpage
#@gui : <a href ="http://linify.me">http://linify.me</a>.\n
#@gui : - This is a quite resource-demanding filter, so please be patient when running it.\n
#@gui : - It actually renders better when applied on small images (&lt;1024).
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/11/21</i>.</small>")
fx_linify :
repeat $! l[$>]
if $7 _debug=1 w ${-fitscreen\ {[w,h]}},0,"[Preview] G'MIC: Linify" fi
linify $1,$2,$3%,$4,$5,$6
endl done
fx_linify_preview :
if {!${"-gui_check_version 216"}} return fi
gui_split_preview "fx_linify ${1-6},0",${-3--1}
#@gui Lylejk's Painting : fx_lylejk_painting, fx_lylejk_painting_preview(0)
#@gui : Iterations = int(10,1,20)
#@gui : Abstraction = int(2,1,20)
#@gui : Radius = int(4,1,30)
#@gui : Canvas = float(10,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/23/02</i>.</small>")
#@gui : url = link("Filter Explained here","http://www.gimpchat.com/viewtopic.php?f=10&t=2624")
fx_lylejk_painting :
repeat $! l[$>]
nm={0,n}
+l repeat $1 b 0.75 unsharp 0.75,10.49 c 0,255 mv. 0 done endl
smooth. 300,0.26,1,0,7
. rv[-3--1]
blend[-2,-1] lighten,0.5
blend[-2,-1] grainmerge,1
fx_kuwahara. $2,$3,0,0
texturize_canvas. $4,4
nm $nm
endl done
fx_lylejk_painting_preview :
gui_split_preview "fx_lylejk_painting $*",${-3--1}
#@gui Make Squiggly : fx_Squiggly, fx_Squiggly_Preview(0)
#@gui : note = note("Squigles an image")
#@gui : note = note("Squigle parameters")
#@gui : Spread Noise Amount = float(2,0,20)
#@gui : Segmentation Edge Threshold = float(12,0,15)
#@gui : Segmentation Smoothness = float(0.8,0,5)
#@gui : GradienNormSmoothness = float(0,0,10)
#@gui : GradienNormLinearity = float(0.5,0,1.5)
#@gui : Invert Luminance = bool(1)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("<b>Optional color enhancement</b>")
#@gui : note = note("Note that the effect of sliders depends on the merge setting.")
#@gui : Activate Color Enhancement = bool(0)
#@gui : Toggle to View Base Image = bool(0), note = note("Check this to view base image")
#@gui : IncreaseChroma1 = float(3,1,4)
#@gui : Tone Threshold = float(0.2,0,1)
#@gui : Tone Gamma = float(0.4,0,1)
#@gui : note = note("Select merging mode to original")
#@gui : Merging Option = choice("Alpha","And","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain extract","Grain merge",
#@gui : "Hard light","Hue","Interpolation","Lighten","Lightness","Luminance","Multiply","Negation","Or","Overlay","Reflect","Saturation",
#@gui : "Soft light","Screen","Stamp","Value","Xor")
#@gui : Opacity = float(1,0,1)
#@gui : Reverse Order = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6667673847/")
fx_Squiggly :
SpreadNoiseAmount=$1
SEgThrshld=$2
SegSmooth=$3
GNSmooth=$4
GNLin=$5
InvertLuminance=$6
EnhanceColors=$7
ToggleOrg=$8
Chroma=$9
ToneTr=$10
ToneGm=$11
OrgMergeCh=$12
OrgOpacity=$13
OrgReverseorder=$14
repeat $! l[$>]
-if {$ToggleOrg==1}
OrgMergeCh=30
OrgReverseorder=1
-endif
-to_rgb
--fx_spread[0] $SpreadNoiseAmount,$SpreadNoiseAmount,0,0
-fx_segment_watershed[1] $SEgThrshld,$SegSmooth,0,0
--fx_gradient_norm[1] $GNSmooth,$GNLin,0,100,0,0
--blend[2,1] multiply
-if {$InvertLuminance==1}
#Convert to LAB
-rgb2lab[-1]
#Split channels
-split[-1] c
-negate[-3]
-append[-3--1] c
-lab2rgb[-1]
-endif
-if {$EnhanceColors==1}
#Increase chroma
-fx_mix_ycbcr[3] 1,0,0,$Chroma,0,0,$Chroma,0,0,0,2,0
#Tonemap original
-fx_map_tones[0] $ToneTr,$ToneGm,0.1,30,0,0
#-fx_apply_curve[0] 0,30,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
#Compose Squigglies to original
-fx_blend[0,3] $OrgMergeCh,0,$OrgOpacity,$OrgReverseorder
-keep[0]
-endif
-keep[-1]
endl done
fx_Squiggly_Preview :
-gui_split_preview "-fx_Squiggly ${1--2}",$-1
#@gui Morphology Painting : fx_MorphoPaint, fx_MorphoPaint_preview(0)
#@gui : sep = separator()
#@gui : note = note("Creates a painting using Morphology-, Segmentation- and Painting- filters. CPU intensive filter that may take long.")
#@gui : sep = separator()
#@gui : note = note("Morphology settings")
#@gui : sep = separator()
#@gui : Method = choice(1,"Erosion","Dilation","Opening","Closing")
#@gui : MorphoStrenght = int(18,2,60)
#@gui : Shape = choice(2,"Square","Octagonal","Circular")
#@gui : sep = separator()
#@gui : note = note("Lightness for Morpholayer")
#@gui : Black Point = int(25,0,50)
#@gui : Expand Shadows = int(100,50,255)
#@gui : Compress Highlights = int(230,200,255)
#@gui : sep = separator()
#@gui : note = note("Smoothing strength")
#@gui : Spread Amount = int(8,0,20)
#@gui : Blurr Strength = int(3,0,10)
#@gui : sep = separator()
#@gui : note = note("Segmentation settings")
#@gui : Edge Threshold = float(4,0,15)
#@gui : Smoothness = float(0.5,0,5)
#@gui : sep = separator()
#@gui : note = note("Painting Settings")
#@gui : Abstraction = int(2,1,10)
#@gui : Details Scale = float(0.5,0,5)
#@gui : Smoothness = float(200,0,1000)
#@gui : sep = separator()
#@gui : Merge Layers? = bool(1)
#@gui : note = note("When unchecked the filter will output layers separately for manual composing. Set G'Mic output to new layers.")
#@gui : sep = separator()
#@gui : Enable Paintstroke = bool(1)
#@gui : Stroke Strength = float(1,0,1)
#@gui : Enable Segmentation = bool(1)
#@gui : Segments Strength = float(1,0,1)
#@gui : Enable Morphology = bool(1)
#@gui : Morphology Strength = float(1,0,1)
#@gui : Normalize = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6108637935/")
fx_MorphoPaint :
-to_rgb[0]
--fx_morpho[0] $1,$2,0,2,0,$3,0
--fx_apply_curve[1] $4,50,$5,200,$6,-1,128,-1,128,-1,128,255,1,3,0,0,0
-fx_spread[1] $7,$7,0,0
-fx_gaussian_blur[2] $8,0,0,1,0,0,0
-fx_segment_watershed[1] $9,$10,0,0
--fx_painting[0] $11,$12,1.5,$13,1,0
-remove[0]
-reverse[0,2]
-reverse[1,2]
-if $14
-if {$19==0} MorphoStrength={0} -elif {$19==1} MorphoStrength={$20} -endif
-mul[2] {$MorphoStrength/3}
-if {$15==0} StrokeStrength={0} -elif {$15==1} StrokeStrength={$16} -endif
-mul[0] {$StrokeStrength/3}
-if {$17==0} SegmentStrength={0} -elif {$17==1} SegmentStrength={$18} -endif
-mul[1] {$SegmentStrength/3}
-add[1] [2]
-add[1] [0]
-if $21 -normalize[1] 0,255 -endif
-remove[0,2]
-endif
fx_MorphoPaint_preview :
-gui_split_preview "-fx_MorphoPaint ${1--2}",$-1
#@gui Painting : fx_painting, fx_painting_preview(0)+
#@gui : Abstraction = int(5,1,10)
#@gui : Details Scale = float(2.5,0,5)
#@gui : Color = float(1.5,0,4)
#@gui : Smoothness = float(50,0,1000)
#@gui : Sharpen Shades = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i>, <i>Angelo Lama</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.\nLatest Update: <i>2011/28/02</i>.</small>")
fx_painting : skip ${4=0},${5=0}
repeat $! l[$>]
to_colormode {max(3,s)} split_opacity rv
repeat $1 fx_normalize_local. 10,6,5,20,1,11 done
fx_smooth_anisotropic. {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
fx_mix_lab. 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
if $5 fx_segment_watershed. 10,1,0 fi
smooth. $4,0,1,1,1
rv a c
endl done
fx_painting_preview :
gui_split_preview "fx_painting $*",${-3--1}
#@gui Paint Daub : samj_Barbouillage_Paint_Daub_en, samj_Barbouillage_Paint_Daub_en(1)
#@gui : note = note("<span foreground="blue">Paint Daub - Barbouillage</span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Gradient Norm</small></span>")
#@gui : Iterations = int(2,1,3)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Smooth</small></span>")
#@gui : Amplitude = int(2,1,5)
#@gui : Sharpness = int(100,0,500)
#@gui : Anisotropy = float(0.2,0,0.5)
#@gui : Sigma = float(1,0,10)
#@gui : Dl = float(4,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Equalize</small></span>")
#@gui : Equalize = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Random Plasma</small></span>")
#@gui : Plasma = choice(0,"Without","Colors A","Colors B")
#@gui : Scale Plasma = int(8,1,30)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.        Latest Update: <i>2015/04/17</i>.</small>")
samj_Barbouillage_Paint_Daub_en :
-samj_Barbouillage_Paint_Daub $1,$2,$3,$4,$5,$6,$7,$8,$9
#@gui Pastell Art : fx_pastell, fx_pastell_preview(1)
#@gui : MasterOpacity = float(0.6,0.3,1)
#@gui : Bg Textured = bool(1)
#@gui : Reverse Effect = bool(0)
#@gui : sep = separator(),note = note("Rodilius settings")
#@gui : Amplitude = float(20,0,30)
#@gui : Thickness = float(30,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(1,1,36)
#@gui : Offset = float(30,0,180)
#@gui : Color Mode = choice(1,"Darker","Lighter")
#@gui : sep = separator(),note = note("Gradient settings")
#@gui : Smoothness = float(1,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(),Activate Shakes = bool(0)
#@gui : Amount = float(10,0,30)
#@gui : Strenth = float(3,1,300)
#@gui : sep = separator(),Activate Lizards = bool(0)
#@gui : Toes = float(9,0,300)
#@gui : Shivers = float(3,0,4)
#@gui : sep = separator(),Activate Pink elephants = bool(0)
#@gui : Trunks = float(12,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6294075073/")
fx_pastell :
MasterOpacity=$1
BgTextured=$2
ReverseEffect=$3
RAmplitude=$4
RThickness=$5
RSharpness=$6
ROrientations=$7
ROffset=$8
RColormode=$9
GSmoothness=$10
GLinearity=$11
GNegativeColors=$12
ActivateShakes=$13
RiAmplitude=$14
RiSize=$15
ActivateLizards=$16
WAmplitude=$17
WSmoothness=$18
ActivatePink=$19
RDeform=$20
RChannels=0
GMinThreshold=0
GMaxThreshold=100
RiShape=3
RiAngle=135
-if {$ActivatePink==1} -deform[0] $RDeform -endif
--fx_rodilius[0] $RAmplitude,$RThickness,$RSharpness,$ROrientations,$ROffset,0,$RColormode,$RChannels,0
--fx_gradient_norm[0] $GSmoothness,$GLinearity,$GMinThreshold,$GMaxThreshold,$GNegativeColors,0
-fx_smooth_bilateral[0] 15,10,3,3,0
-if {$ActivateLizards==1} -water[0,2] $WAmplitude,$WSmoothness -endif
-if {$ActivateShakes==1} -ripple[0,2] $RiAmplitude,$RiSize,$RiShape,$RiAngle,0 -endif
-if {$ReverseEffect==1} -reverse[0,2] -endif
--blend[0,2] divide,1,0
-reverse[1,3]
-blend[1,3] value,1,0
-if {$BgTextured==1} -fx_ellipsionism[0] 20,2,10,0.5,1,1,0 -endif
-blend[0,1] alpha,$MasterOpacity,0
-keep[0]
fx_pastell_preview :
-gui_split_preview "-fx_pastell ${1--2}",$-1
#@gui Pen Drawing : fx_pen_drawing, fx_pen_drawing_preview(0)+
#@gui : Amplitude = float(10,0,30)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_pen_drawing :
drawing $1
fx_pen_drawing_preview :
gui_split_preview "fx_pen_drawing $*",${-3--1}
#@gui Photoillustration : fx_tk_photoillustration,  fx_tk_photoillustration_preview(0)
#@gui : note = note("adding an illustrative effect to any photograph")
#@gui : sep = separator()
#@gui : Local Contrast Style = choice("tone mapping","tone mapping soft","tone mapping fast","local  normalisation","unsharp mask","global mapping","dynamic range increase","none")
#@gui : Local Contrast Effect = float(0.25,0.00,2.5)
#@gui : Smoothing Style = choice("anisotropic","bilateral","color channel  smoothing","segmentation","morphological closing","selective gaussian","wavelet","Kuwahara","none")
#@gui : Contour Precision = float(0.30,0.00,1.00)
#@gui : Area Smoothness = float(0.50,0.00,10.00)
#@gui : Sharpening Radius = float(0.50,0.00,10.00)
#@gui : Sharpening Strength = float(1.00,0.00,5.00)
#@gui : Special Effects = choice("none","soft glow","dusty","Orton glow","extra  smooth","bloom","paintstroke")
#@gui : Effect Strength = float(5.00,0.00,20.00)
#@gui : Overall Lightness = float(0,-50,50)
#@gui : Overall Contrast = float(1,0.5,1.5)
#@gui : Shadows Lightness = float(0,-100,100)
#@gui : Highlights Lightness = float(0,-100,100)
#@gui : Mid Tone Contrast = float(1,0.5,4)
#@gui : Color Green-Magenta = float(0,-20,20)
#@gui : Color Blue-Yellow = float(0,-20,20)
#@gui : Color Boost = float(1.2,0,4)
#@gui : Detail Reconstruction Detection = float (98.5,50,100)
#@gui : Detail Reconstruction Smoothness = float(5,0,10)
#@gui : Detail Reconstruction Strength = float(0.5,0,1)
#@gui : Detail Reconstruction Style = choice("micro/macro details  adjusted","fine","strong","high pass","artistic round","artistic hard","artistic  modern","comic Style","gritty","none")
#@gui : Keep Detail Layer Seperate = bool(0)
#@gui : Remove Artifacts from Micro/Macro Detail = bool(0)
#@gui : Skin Tone Protection = bool(0)
#@gui : Sharpen Edges Only = bool(0)
#@gui : Computation Mode = choice(1,"high quality","normal","high speed")
#@gui : sep = separator(), Preview type = choice("Full","Forward  horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>        Latest update: <i>2012/08/28</i>.</small>")
fx_tk_photoillustration :
-repeat $! -l[$>]
-if {$26==1} scdo=50 scup=200 -endif
-if {$26==2} scdo=25 scup=400 -endif
-if {$26!=0} -r $scdo%,$scdo% -else -endif
-if {$21==0} [^] --negate[1]  [0] --negate[0]
-fx_gaussian_blur[2] {{{100-$18}/5}+0.5},0,0,1,0,0,0  -fx_compose_dodge[1,2] 1
-if {$23==1} -fx_gaussian_blur[1] {{{100-$18}/10}+0.5},0,0,1,0,0,0 -endif
-fx_gaussian_blur[3] {{{{{100-$18}/5}+1}*10}+10},0,0,1,0,0,0
-fx_compose_dodge[2,3] 1
-if {$23==1} -fx_gaussian_blur[2] {{{{100-$18}/10}+0.5}*3},0,0,1,0,0,0 -endif
-reverse[1,2] -fx_compose_multiply[1,2] {1-{$19/10}}
-tk_fx_channel_processing[1] {{1-$20}+0.1},1,0,0,0,0,100,256,0,0,0,2,7,0
-elif {$21==1} --fx_laplacian $19,{99.99-$18},$18,1,1,0
-elif {$21==2} --fx_gradient_norm $19,0.5,{99.99-$18},$18,1,0
-elif {$21==3} --fx_highpass {-{$18-100.3}},{{10-$19}*0.7},0,1,0
-elif {$21==4} --fx_pencilbw {100-$18},{$19*20},0,0,0
-elif {$21==5}
--fx_hardsketchbw {300+{{$18-50}*15}},{$19*10},$19,1,{50-{$18/2}},0,0,0
-elif {$21==6} --fx_thin_edges $19,{{$18/5}-10},0,0
-elif {$21==7} --fx_edges {$19/3.5},{95-$18},0,0
--fx_mix_hsv[0] 1,0,0,1,-1,0,1,0,0,0,2,0
-tk_fx_channel_processing[2] 1,1,0,{$19/10},4,{{$18-50}*2},100,256,0,0,0,2,7,0
-reverse[1,2] -fx_compose_multiply[1,2] {0.5+{$20/2}}
-elif {$21==8} --channels 2
-if {$19<=5}   -fx_unsharp[1]  1,{2-{{$19*0.3}+0.5}},20,{5-$19},0.00,1.00,0.5,1,0,7,0
-else -fx_gaussian_blur[1] {$19-5},0,0,1,0,0,0  -endif
-endif
-if {$1!=3}
-tk_fx_channel_processing[0] 1,1,$12,0,0,0,100,256,0,0,1,{abs($12/10)},7,0
-tk_fx_channel_processing[0] 1,1,$13,0,0,0,100,256,0,0,3,{abs($12/10)},7,0      -endif
-if {$24==0}
-if {$1==0} -fx_map_tones[0] {$2/2.5},{1-{$2/2.5}},$2,{2+{$2*80}},3,0
-elif {$1==1} -fx_map_tones[0] {$2/10},0.5,{10-{$2*2}},300,3,0
-elif {$1==2} -fx_map_tones_fast[0] {$2*2},{$2/2.5},3,0
-elif {$1==3}
-fx_normalize_local[0] {$2*2},{1+{$2*25.2}},{$2*16},{$2*16},0,3,0
-elif {$1==4} -fx_unsharp[0] 0,{{w+h}/100},0,$2,0,1,1,1,0,7,0
-elif {$1==5} --negate[0]
-if {$21!=9} -reverse[1,2] -endif
-fx_gaussian_blur[1] {{{w+h}/5}-{$2*{{w+h}/12.5}}},0,0,1,0,0,0
-to_gray[1] -reverse[0,1] -fx_compose_softlight[0,1] {$2/2.5}
-elif {$1==6} -fx_tk_dri[0] {$2/2.5},{$2/5},{$2/2.5},{$2*2},{$2/2.5},1,1,0
-endif
-else
--to_rgba[0] --channels[0] 0 -if {$21!=9} -move[1] 4 -endif
-negate[2]
-tk_fx_channel_processing[2] 1,1,2,0,0,0,100,256,0,0,0,2,7,0
-fx_gaussian_blur[2] {{w+h}/500},0,0,1,0,0,0
-to_gray[2]
-if {$1==0} -fx_map_tones[1] {$2/2.5},{1-{$2/2.5}},$2,{2+{$2*80}},3,0
-elif {$1==1} -fx_map_tones[1] {$2/10},0.5,{10-{$2*2}},300,3,0
-elif {$1==2} -fx_map_tones_fast[1] {$2*2},{$2/2.5},3,0
-elif {$1==3}   -fx_normalize_local[1]  {$2*2},{1+{$2*25.2}},{$2*16},{$2*16},0,3,0
-elif {$1==4} -fx_unsharp[1] 0,100,0,$2,0,1,1,1,0,7,0
-elif {$1==5} -negate[1] -fx_gaussian_blur[1]  {{{w+h}/5}-{$2*{{w+h}/12.5}}},0,0,1,0,0,0
-to_gray[1] -to_rgba[1]
-elif {$1==6} -fx_tk_dri[1] {$2/2.5},{$2/5},{$2/2.5},{$2*2},{$2/2.5},1,1,0    -to_rgba[1]
-endif
-split[1] c
-if {$21!=9} -reverse[4,5] -compose_multiply[4,5] -append[-5,-4,-3,-2] c
-else -reverse[3,4] -compose_multiply[3,4] -append[-4,-3,-2,-1] c -endif
-if {$1!=3} -compose_rgba[0,1] -else -reverse[0,1]
-fx_compose_softlight[0,1] {$2/2.5} -endif
-endif
-tk_fx_channel_processing[0] 1,$11,$10,0,0,0,100,256,0,0,0,2,7,0
-tk_fx_channel_processing[0] 1,$14,0,0,0,0,100,256,0,0,2,{abs($14*2.5)},7,0
-if {$1==3}
-tk_fx_channel_processing[0] 1,1,$12,0,0,0,100,256,0,0,1,{abs($12/10)},7,0
-tk_fx_channel_processing[0] 1,1,$13,0,0,0,100,256,0,0,3,{abs($12/10)},7,0
-endif
-if {$3==0} -fx_smooth_anisotropic[0]  {$5*100},{$4*2},$4,$5,$5,0.80,30.00,2.0,0,1,1,0,1,0
-elif {$3==1} -fx_smooth_bilateral[0] {100-{$4*100}},{$5*25},1,0,0
-elif {$3==2} -fx_gaussian_blur[0] {$5*10},0,0,1,8,0,0
-elif {$3==3} -fx_segment_watershed[0] {$4*5},{$5/2},0,0
-elif {$3==4} -fx_morpho[0] 3,{$5*2+2},0,2,0,1,0
-elif {$3==5} -fx_smooth_selective[0] {$5*4},{$4*2},10,10,0,1,0
-elif {$3==6} -fx_smooth_haar[0] {10-{$4*10}},{round($5*5,1)},0,0,1,0
-elif {$3==7} -to_rgb[0] -fx_kuwahara[0] {6-{$4*5}},{1+{$5*2.9}},0,0
-endif
-fx_mix_lab[0] 1,0,0,$17,$15,0,$17,$16,0,0,2,0
-if {$25==0}
-fx_unsharp[0] 1,$6,20,$7,0.00,1.00,0.5,1,0,7,0
-else
--to_rgba[0] --fx_edges[0] $6,{30-{$7*5}},1,0 -if {$21!=9} -move[1] 4 -endif
-fx_unsharp[1] 1,$6,20,$7,0.00,1.00,0.5,1,0,7,0
-fx_gaussian_blur[2] {{w+h}/500},0,0,1,0,0,0
-to_gray[2]
-split[1] c
-if {$21!=9} -reverse[4,5] -compose_multiply[4,5] -append[-5,-4,-3,-2] c
-else -reverse[3,4] -compose_multiply[3,4] -append[-4,-3,-2,-1] c -endif
-compose_rgba[0,1]
-endif
-if {$22==0}
-if {$21==3}  -reverse -fx_compose_overlay $20
-elif {$21==8} -reverse -fx_compose_hardlight $20
-elif {$21!=9} -reverse -fx_compose_multiply $20
-endif -endif
-if {$8==1}
-fx_glow[0] $9,0,0
-elif {$8==2} --fx_highpass[0] {$9*3},2,1,0,0
-if {{$22==1}&&{$21!=9}} -reverse[1,2] -endif
-reverse[0,1] -fx_compose_overlay[0,1] {$9/40}
-elif {$8==3} [0] [0]
-if {{$22==1}&&{$21!=9}} -reverse[1,3] -endif
-fx_compose_screen[1,2] 1  -fx_gaussian_blur[1] {$9*3},0,0,1,0,0,0
-reverse[0,1] -fx_compose_softlight[0,1] {$9/20}
-elif {$8==4}
-fx_smooth_anisotropic[0] 0,1.5,0.3,{$9/4},1.10,0.80,30.00,2.0,0,1,1,0,1,0
-elif {$8==5}
--fx_mix_hsv[0] 1,0,0,1,-1,0,1,0,0,0,2,0
-if {{$22==1}&&{$21!=9}} -reverse[1,2] -endif
-tk_fx_channel_processing[1] 1,1,0,0,4,0,{100-{$9*2.5}},256,0,1,0,2,0,0
-fx_gaussian_blur[1] $9,0,0,1,0,0,0
-tk_fx_channel_processing[1] 1,1,0,0,4,0,{50-{$9*2}},256,0,1,0,2,0,0
-tk_fx_replace_color[1] 1,0,0,0,0,255,0,0,0,0
-fx_gaussian_blur[1] {$9*2},0,0,1,0,0,0
-reverse[0,1] -fx_compose_softlight[0,1] {0.25+{$9/150}}
-elif {$8==6}
-fx_smooth_anisotropic[0]  60,0.16,{{$9/50}+0.6},{{$9/9}+0.6},2.35,0.8,30,2,0,1,1,0,1
-endif
-if {$26!=0} -r $scup%,$scup% -endif
-endl -done
fx_tk_photoillustration_preview :
-gui_split_preview "-fx_tk_photoillustration ${1--2}",$-1
#@gui Polygonize [Delaunay] : fx_polygonize_delaunay, fx_polygonize_delaunay_preview(0)
#@gui : Density (%) = float(40,0,100)
#@gui : Edges = float(5,0,100)
#@gui : Boundaries (%) = float(75,0,100)
#@gui : Smoothness = float(0.5,0,8)
#@gui : Filling = choice(3,"Black","White","Random","Average","Linear")
#@gui : Outline (%) = float(50,0,100)
#@gui : Outline Color = color(0,0,0,255)
#@gui : Anti-Aliasing = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/06/05</i>.</small>")
fx_polygonize_delaunay :
repeat $! l[$>] to_rgba
wh={[w,h]} if $11 r 150%,150%,1,100%,3 fi
mM={[im,iM]} b $4 n $mM
+to_rgb. gradient_norm. ge. $2 f. "!x || !y || x==w-1 || y==h-1?(u^0.25<$3%):(u^0.25<$1%?i:0)" {is+1},1,1,2 f.. ">begin(p = 0); i?(I[#-1,++p] = [x,y];p):0"
delaunay..
if {$5==4}
+f[0] 0 f... "*i?(
p = I(#1); P0 = I[#2,p[0]]; P1 = I[#2,p[1]]; P2 = I[#2,p[2]];
W = solve([P0[0],P1[0],P2[0],P0[1],P1[1],P2[1],1,1,1],[x,y,1]);
I(#-1) = cut(W[0]*I(#0,P0) + W[1]*I(#0,P1) + W[2]*I(#0,P2),0,255);
);I"
elif {$5==3}
+f[0] 0 f... "*i?(
p = I(#1); P0 = I[#2,p[0]]; P1 = I[#2,p[1]]; P2 = I[#2,p[2]];
I(#-1) = (I(#0,P0) + I(#0,P1) + I(#0,P2))/3;
);I"
elif {$5==2}
+norm[1] label_fg. 0 {iM+1},1,1,3 rand. 0,255 to_rgba. point. 0 map.. . rm.
else
+norm[1] !=. 0 *. 255 channels. -3,0
if $5 sh. 0,2 f. 255 rm. fi
fi
rm[0,2]
if $6
norm[0] f[0] "i!=j(1) || i!=j(0,1)"
+fc. ${7-10} j.. .,0,0,0,0,{$6%},... rm.
fi
k.
if $11 r $wh,1,100%,2 fi
endl done
fx_polygonize_delaunay_preview :
gui_split_preview "fx_polygonize_delaunay $*",${-3--1}
#@gui Polygonize [Energy] : fx_polygonize, fx_polygonize_preview(0)
#@gui : Amplitude = int(300,0,2000)
#@gui : Smoothness = float(10,0,100)
#@gui : Minimal Area = float(10,0,100)
#@gui : X-Resolution = float(10,1,256)
#@gui : Y-Resolution = float(10,1,256)
#@gui : Outline Color = color(0,0,0,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=9174")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/02/12</i>.</small>")
fx_polygonize :
polygonize $1,$2,{$3^2},$4,$5
if $9 repeat $! l[$>]
+norm g. xy,1 !=[-2,-1] 0 -|[-2,-1] r. 100%,100%,1,4
replace_color. 0,0,1,1,1,1,$6,$7,$8,$9
blend alpha
endl done fi
fx_polygonize_preview :
gui_split_preview "fx_polygonize $*",${-3--1}
#@gui Posterize : fx_posterize, fx_posterize_preview(0)
#@gui : Smoothness = float(150,0,800)
#@gui : Edges (%) = float(30,0,100)
#@gui : Paint = float(1,0,10)
#@gui : Colors = int(12,2,32)
#@gui : Minimal Area = int(0,0,64)
#@gui : Outline (%) = float(0,0,100)
#@gui : Normalize Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/25/10</i>.</small>")
fx_posterize :
repeat $! l[$>] split_opacity l[0]
. amp=$1 do smooth. {min(50,$amp)},{$2%},1,$3,{2*$3} amp-=50 while {$amp>0}
bilateral.. .,5,10 rm.
srgb2rgb +colormap $4 rgb2srgb
index.. .,0,0
if $5 +area.. 0,0 <. $5 inpaint... .,0,3 rm. fi
map.. . rm.
if $6 +norm (0,1,0;1,1,1;0,1,0) +dilate.. . rm.. -[-2,-1] !=. 0 100%,100%,1,{0,s} j... .,0,0,0,0,{$6%},.. rm[-2,-1] fi
if $7 n 0,255 fi
endl a c endl done
fx_posterize_preview :
gui_split_preview "fx_posterize $*",${-3--1}
#@gui Posterized Dithering : fx_pdithered, fx_pdithered_preview(0)
#@gui : Gamma = float(1,0.01,5)
#@gui : Contrast = float(1,0,4)
#@gui : Brightness = float(0,-255,255)
#@gui : Smoothness = float(0,0,10)
#@gui : Quantize Colors = int(20,2,255)
#@gui : Smooth Colors =float(1,0,30)
#@gui : Mixer Mode = choice( "Color Doping", "Darken","Soft Light","Grain Merge", "Multiply","Value")
#@gui : Color Intensity =float (1,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2010/29/12</i>.</small>")
fx_pdithered :
--apply_gamma[-1] $1 -- 128 -* $2 -+ 128 -+ $3 -blur[-1] $4 -c[-1] 0,255 -ditheredbw[-1]
-quantize[-2] $5 -to_rgb -blur_xy[-2] $6,$6
-if {$7==0} -fx_compose_colordoping $8,0
-elif {$7==1} -fx_compose_darken $8,0
-elif {$7==2} -fx_compose_softlight $8,0
-elif {$7==3} -fx_compose_grainmerge $8,0
-elif {$7==4} -fx_compose_multiply $8,1
-elif {$7==5} -fx_compose_value $8,1 -endif
fx_pdithered_preview :
-gui_split_preview "-fx_pdithered ${1--2}",$-1
#@gui Poster Edges : fx_poster_edges, fx_poster_edges_preview(0)
#@gui : Image Smoothness = float(20,0,100)
#@gui : Edge Threshold = float(60,0,100)
#@gui : Edge Shade = float(5,0,30)
#@gui : Edge Thickness = float(0,0,5)
#@gui : Edge Antialiasing = float(10,0,100)
#@gui : Posterization Level = int(0,0,15)
#@gui : Posterization Antialiasing = float(0,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.davidrevoy.com/article147/gmic-new-filter-poster-edges")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>David Revoy</i>.      Latest Update: <i>2012/30/11</i>.</small>")
fx_poster_edges :
if $1 bilateral 10,$1 fi
poster_edges ${2-7}
fx_poster_edges_preview :
gui_split_preview "fx_poster_edges $*",${-3--1}
#@gui Quadtree Variations : fx_quadtree, fx_quadtree_preview(1)
#@gui : Mode = choice("Squares","Sierpinksi Design","Ellipse Painting")
#@gui : Precision = int(1024,2,4096)
#@gui : Homogeneity = float(0.5,0,2)
#@gui : Outline = int(0,0,4)
#@gui : sep = separator()
#@gui : note = note{"<small><b>For 'Ellipse painting' only:</b></small>"}
#@gui : Primary Radius = float(3,0,5)
#@gui : Secondary Radius = float(1.5,0,5)
#@gui : Anisotropy = float(1,0,4)
#@gui : Only Leafs = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/15/06</i>.</small>")
fx_quadtree :
mode,precision,homogeneity,outline,radius1,radius2,anisotropy,only_leafs=${1-8}
m "_qt : sh 3 u {w>1&&h>1?iv*(w*h)^"$homogeneity":-0.1} k[0]"
repeat $! l[$>]
to_rgb
keep_only_leafs={$mode!=2" || "$only_leafs}
+norm. a c
_qt ({d=max(w,h);[0,0,d-1,d-1]},0,${})
repeat $precision
+columns. 100% n={yM} rm.
x0,y0,x1,y1,level={crop(0,$n,5,1)}
xc={round(($x1+$x0)/2)} yc={round(($y1+$y0)/2)}
xc1,yc1={[$xc,$yc]-1}
level1={$level+1}
B0=$x0,$y0,$xc1,$yc1 +crop[0] $B0,3 _qt. B0.=,$level1,${} rm.
B1=$xc,$y0,$x1,$yc1 +crop[0] $B1,3 _qt. B1.=,$level1,${} rm.
B2=$x0,$yc,$xc1,$y1 +crop[0] $B2,3 _qt. B2.=,$level1,${} rm.
B3=$xc,$yc,$x1,$y1 +crop[0] $B3,3 _qt. B3.=,$level1,${} rm.
if $keep_only_leafs
sh. $n,$n,0,0 f. $B0 rm.
($B1;$B2;$B3) a[-2,-1] y
else
=. -1,5,$n
($B0;$B1;$B2;$B3) a[-2,-1] y
else
fi
done
shift. 2,0,0,0,2 sort. +,y levelmax={i(0,h-1)} shift. -2,0,0,0,2
channels[0] 0,2 +structuretensors[0] a[0,-1] c
r. {w+6},100%,1,1,0
repeat {h}
x0,y0,x1,y1={crop(0,$>,4,1)}
+crop[0] $x0,$y0,$x1,$y1,3 r. 1,1,1,100%,2 y. x
j.. .,{-2,w-6},$> rm.
done
permute. cyzx
channels[0] 0,3 f[0] 0
if {$mode==0}
f. ">
rectangle(ind,P0,P1,opacity,color) = (
_P0 = P0;
_P2 = P1;
_P1 = [ _P2[0], _P0[1] ];
_P3 = [ _P0[0], _P2[1] ];
polygon(#ind,4,_P0,_P1,_P2,_P3,opacity,color);
);
begin(colo = [ 0,0,0,255 ]);
P = I;
Xpp = P[0,2];
Xnn = P[2,2];
col = [ P[6,3],255 ];
if ("$outline"<=0,
rectangle(#0,Xpp,Xnn,1,col);
_(else),
rectangle(#0,Xpp,Xnn,1,colo);
rectangle(#0,Xpp + "$outline",Xnn - "$outline",1,col);
);
I"
elif {$mode==1}
f. ">
P = I;
Xpp = P[0,2];
Xnn = P[2,2];
Xnp = [ Xnn[0],Xpp[1] ];
Xpn = [ Xpp[0],Xnn[1] ];
col1 = [ P[6,3],255 ];
col2 = [ P[6,3],64 ];
T = [ P[9],P[10],P[10],P[11] ];
eig = eig(T);
angle = atan2(eig[5],eig[4])*180/pi;
if ((angle>=0 && angle<90) || angle<-90,
polygon(#0,3,Xpp,Xnp,Xnn,1,col1);
polygon(#0,3,Xpp,Xnn,Xpn,1,col2);
_(else),
polygon(#0,3,Xnp,Xnn,Xpn,1,col1);
polygon(#0,3,Xnp,Xpp,Xpn,1,col2)
);
I"
else
f. ">
begin(colo = [ 0,0,0,255 ]);
P = I;
Xpp = P[0,2];
Xnn = P[2,2];
Xcc = (Xpp + Xnn)/2;
R = (Xnn[0] - Xpp[0])/2;
col = [ P[6,3],255 ];
r = "$radius2"*R;
R*="$radius1";
T = [ P[9],P[10],P[10],P[11] ];
eig = eig(T);
anisotropy = (1 + eig[1])/(1 + eig[0]);
r*=anisotropy^"$anisotropy";
angle = atan2(eig[5],eig[4])*180/pi;
if ("$outline">0, ellipse(#0,Xcc,R,r,angle,1,colo));
ellipse(#0,Xcc,R - "$outline",r - "$outline",angle,1,col);
I"
if {!$outline} sh[0] 100% if {!im} solidify[0] 10% fi fi
fi
k[0]
endl done
uncommand _qt
fx_quadtree_preview :
gui_split_preview "fx_quadtree $*",${-3--1}
#@gui Rodilius : fx_rodilius, fx_rodilius_preview(1)
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(5,2,36)
#@gui : Offset = float(30,0,180)
#@gui : Smoothness = int(0,0,5)
#@gui : Color Mode = choice(1,"Darker","Lighter")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=RC07VUpzwGc")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>Rod/GimpChat</i>.      Latest Update: <i>2013/05/03</i>.</small>")
fx_rodilius :
ac "rodilius ${1-5,7} repeat $6 smooth 10,0,1,1,1,0.8,45 sharpen 30 done c 0,255",$8,$9
fx_rodilius_preview :
gui_split_preview "fx_rodilius $*",${-3--1}
#@gui Shapeism : fx_shapeism, fx_shapeism_preview(0)+
#@gui : Shape = choice(2,"Squares","Triangles","Circles","Diamond","Hexagon","Octagon","Stars","Custom")
#@gui : Branches = int(7,3,16)
#@gui : Thickness = float(0.38,0,1)
#@gui : Angle = float(0,0,360)
#@gui : note = note("<small><b>Note:</b> Parameters <i>Branches</i>, <i>Thickness</i> and <i>Angle</i> are used only for <i>Custom</i> shapes.</small>")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator()
#@gui : Scales = int(5,1,16)
#@gui : Maximal Size = int(32,1,256)
#@gui : Minimal Size = int(8,1,256)
#@gui : Allow Angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gui : Spacing = int(1,-5,5)
#@gui : Precision = int(5,1,10)
#@gui : Edges = float(0.5,0,2)
#@gui : Smoothness = float(1,0,10)
#@gui : Background = color(0,0,0,255)
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=7500&sid=5b483979826903b8f8fc8fdaf1767dae")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/11/06</i>.</small>")
fx_shapeism :
repeat $! l[$>]
to_rgb
+gradient_norm b. $13% ^. $12 quantize. $6,0,0
100%,100%,1,2
repeat $6
+channels[2] 100% +>[1] $> !=.. 0 -|[-2,-1] a[2,-1] c
size={if($6<=1,$7,$7+($8-$7)*$>/($6-1))}
if {$size<1} break fi
if $5 {2*$size},{2*$size} _fx_shapeism$1. ${2-4} r2dy. $size
else $size,$size _fx_shapeism$1. ${2-4}
fi
+!=. 0 expand_xy[-2,-1] 1,0 n[-2,-1] 0,1
if {$10<1} dilate. 3 fi
. a[-3--1] c
rprogress "pack_sprites[-2,-1] 1,100,$9,$10,$11",{$>*100/$6},{($>+1)*100/$6}
channels. 0,1
done
rprogress 97
rm[1]
channels. 0 +!=. 0 blend[0,-1] shapeaverage0 *[1] 255 a c
i[0] 100%,100%,1,4 fc[0] $14,$15,$16,$17
blend alpha
rprogress 100
endl done
fx_shapeism_preview :
gui_print_preview ""
50%,50% _fx_shapeism$1. ${2-4} frame. 1,1,0 >=. 50% n. 0,255 r. 100%,100%,1,4
r. [0],0,0,0.5,0.5 -|
_fx_shapeism0 :
f 255 skip $*
_fx_shapeism1 :
polygon 3,50%,0,0,100%,100%,100%,1,1 skip $*
_fx_shapeism2 :
shape_circle {w} rm.. skip $*
_fx_shapeism3 :
shape_diamond {w} rm.. skip $*
_fx_shapeism4 :
star3d 3,1 *3d. {0,min(w,h)/2} j3d[0] .,50%,50%,0,1,2,0 k[0] skip $*
_fx_shapeism5 :
star3d 4,1 *3d. {0,min(w,h)/2} j3d[0] .,50%,50%,0,1,2,0 k[0] skip $*
_fx_shapeism6 :
star3d 5 *3d. {0,min(w,h)/2} j3d[0] .,50%,50%,0,1,2,0 k[0] skip $*
_fx_shapeism7 :
star3d $1,$2 *3d. {0,min(w,h)/2} r3d. 0,0,1,$3 j3d[0] .,50%,50%,0,1,2,0 k[0]
#@gui Sharp Abstract : fx_sharp_abstract, fx_sharp_abstract_preview(0)
#@gui : Spatial Scale = float(4,0,32)
#@gui : Value Scale = float(10,0,16)
#@gui : Precision = float(0.5,0,2)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/09</i>.</small>")
fx_sharp_abstract :
ac "rolling_guidance ${1-3}",$4
fx_sharp_abstract_preview :
gui_split_preview "fx_sharp_abstract $*",${-3--1}
#@gui Simple Noise Canvas : fx_SimpleNoiseCanvas, fx_SimpleNoiseCanvasPreview(0)
#@gui : note = note("Simpe noise based xy canvas effect. Preserve canvas and bumpmap image with canvas after filtering for best results. Merge option DoNothing outputs only original image if Preserve canvas option is not selected.")
#@gui : sep = separator()
#@gui : Scale Factor = float(0,0,1)
#@gui : sep = separator()
#@gui : note = note("Noise parameters")
#@gui : Amplitude = float(3,0,20)
#@gui : Noise Type = choice(2,"Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : sep = separator()
#@gui : note = note("Thread length")
#@gui : Horisontal Length = float(5,2,15)
#@gui : Vertical Length = float(5,2,15)
#@gui : Over All Blurr = float(0,0,15)
#@gui : Canvas Brightness = float(255,230,255)
#@gui : Canvas Darkness = float(0,0,255)
#@gui : sep = separator()
#@gui : note = note("How to combine XY threads")
#@gui : Merging Option = choice(2,"Average","Multiply","Darken","Edges")
#@gui : Invert Canvas Colors = bool(0)
#@gui : Invert Image Colors = bool(0)
#@gui : note = note("How to combine image + canvas")
#@gui : Reverse Order = bool(0)
#@gui : Merging Option = choice (1,"Avg","Multiply","Scr","Darken","Lighten","Dif","Negation","Exclusion","Overlay","Hardlight","Softlight","Dodge","Colorburn","Reflect","Freeze","Stamp","Interpolate","Grainext","Grainmerge","Xor","Edges","DoNothing")
#@gui : Preserve Canvas for Post Bump Mapping = bool(0)
#@gui : Canvas Color = color(255,255,255,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6152040642/")
fx_SimpleNoiseCanvas :
CanvasScale={$1}
NoiseAmplitude=$2
NoiseType=$3
ThreadHorizLen=$4
ThreadVertLen=$5
OverAllBlurr=$6
HighCut=$7
LowCut=$8
CanvasMergeChoice=$9
InvertCanvasColors=$10
InvertImageColors=$11
ReverseChoice=$12
MergeChoice=$13
PreserveCanvas=$14
-to_rgb[0]
CanvasScale={1.2-$CanvasScale}
(255^255^255)
-r[-1] [0]
-r[1] {100*$CanvasScale}%,{100*$CanvasScale}%
-if {$NoiseType!=2} NoiseAmplitude={($NoiseAmplitude*10)} -endif
-fx_noise[1] $NoiseAmplitude,$NoiseType,0,1,0
-fx_ditheredbw[1] 1,1,0,0,0,0
--fx_gaussian_blur[1] 0,$ThreadHorizLen,0,1,0,0,0
--fx_gaussian_blur[1] 0,0,$ThreadVertLen,1,0,0,0
-normalize[2] 0,255
-normalize[3] 0,255
-if {$CanvasMergeChoice==0} -blend[2,3] average
-elif {$CanvasMergeChoice==1} -blend[2,3] multiply
-elif {$CanvasMergeChoice==2} -blend[2,3] darken
-elif {$CanvasMergeChoice==3} -blend_edges[2,3] 0.9
-endif
-fx_gaussian_blur[2] $OverAllBlurr,0,0,1,0,0,0
-remove[1]
-r[1] [0]
($15^$16^$17)
-r[2] [0]
-blend[1,2] multiply
-fx_apply_curve {$LowCut},-1,128,-1,128,-1,128,-1,128,-1,128,{$HighCut},1,3,0,0,0
-if {$ReverseChoice==1} -reverse[0,1] -endif
-if {$InvertCanvasColors==1} -negate[1] -endif
-if {$InvertImageColors==1} -negate[0] -endif
-if {$MergeChoice==0} --blend[1,0] average
-elif {$MergeChoice==1} --blend[1,0] multiply
-elif {$MergeChoice==2} --blend[1,0] screen
-elif {$MergeChoice==3} --blend[1,0] darken
-elif {$MergeChoice==4} --blend[1,0] lighten
-elif {$MergeChoice==5} --blend[1,0] difference
-elif {$MergeChoice==6} --blend[1,0] negation
-elif {$MergeChoice==7} --blend[1,0] exclusion
-elif {$MergeChoice==8} --blend[1,0] overlay
-elif {$MergeChoice==9} --blend[1,0] hardlight
-elif {$MergeChoice==10} --blend[1,0] softlight
-elif {$MergeChoice==11} --blend[1,0] dodge
-elif {$MergeChoice==12} --blend[1,0] colorburn
-elif {$MergeChoice==13} --blend[1,0] reflect
-elif {$MergeChoice==14} --blend[1,0] freeze
-elif {$MergeChoice==15} --blend[1,0] stamp
-elif {$MergeChoice==16} --blend[1,0] interpolation
-elif {$MergeChoice==17} --blend[1,0] grainextract
-elif {$MergeChoice==18} --blend[1,0] grainmerge
-elif {$MergeChoice==19} --blend[1,0] xor
-elif {$MergeChoice==20} --blend_edges[1,0] 0.8
-endif
-if {$ReverseChoice==1} -reverse[0,1] -endif
-if {$PreserveCanvas==0} -remove[1]  -endif
-if {$PreserveCanvas==1" && "$MergeChoice!=21} -reverse[1,2]  -endif
-if {$MergeChoice!=21} -remove[0] -endif
-if {$MergeChoice!=21" && "$PreserveCanvas==1} -reverse[0,1] -endif
fx_SimpleNoiseCanvasPreview :
-gui_split_preview "-fx_SimpleNoiseCanvas ${1--2}",$-1
#@gui Sketch : fx_sketchbw, fx_sketchbw_preview(0)
#@gui : Number of Orientations = int(3,1,16)
#@gui : Starting Angle = float(45,0,180)
#@gui : Angle Range = float(180,0,180)
#@gui : Stroke Length = float(30,0,1000)
#@gui : Contour Threshold = float(1.75,0,10)
#@gui : Opacity = float(0.02,0,0.3)
#@gui : Background Intensity = float(0.5,0,2)
#@gui : Density = float(0.75,0,5)
#@gui : Sharpness = float(0.1,0,1)
#@gui : Anisotropy = float(0.7,0,1)
#@gui : Smoothness = float(3,0,10)
#@gui : Coherence = float(6,0,10)
#@gui : Boost Stroke = bool(0)
#@gui : Curved Stroke = bool(1)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/05/11</i>.</small>")
fx_sketchbw :
if {$15==4} repeat $! l[$>] +sketchbw ${1-14} blend hardlight endl done return fi
sketchbw ${1-14}
if {$15&1} negate fi
if {$15==2} r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
elif {$15==3} r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
fi
fx_sketchbw_preview :
gui_split_preview "fx_sketchbw $*",${-3--1}
#@gui Smooth Abstract : fx_smooth_abstract, fx_smooth_abstract_preview(0)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(0,"Isotropic","Delaunay-oriented","Edge-oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Geometry = float(1,0,5)
#@gui : Details = float(30,0,50)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/06/04</i>.</small>")
fx_smooth_abstract :
repeat $! l[$>] split_opacity l[0]
srgb2rgb
mM={[im,iM]} +b $4 n. $mM gradient_norm. <=. {50-$5}
inpaint_diffusion[0] [1],$1%,$2,$3 rm.
rgb2srgb c 0,255
endl a c endl done
fx_smooth_abstract_preview :
gui_split_preview "fx_smooth_abstract $*",${-3--1}
#@gui Stylize : fx_stylize,fx_stylize_preview
#@gui : Style = choice{0,"Custom Style (Top Layer)","Custom Style (Bottom Layer)",
#@gui : "Braque: Landscape near Antwerp",
#@gui : "Braque: Le Viaduc &agrave; l'Estaque",
#@gui : "Braque: Little Bay at La Ciotat",
#@gui : "Braque: The Mandola",
#@gui : "Delaunay: Windows Open Simultaneously",
#@gui : "Delaunay: Portrait de Metzinger",
#@gui : "Hokusai: The Great Wave",
#@gui : "Kandinsky: Squares with Concentric Circles",
#@gui : "Kandinsky: Yellow-Red-Blue",
#@gui : "Klee: Death and Fire",
#@gui : "Klee: In the Style of Kairouan",
#@gui : "Klee: Oriental Pleasure Garden Anagoria",
#@gui : "Klee: Polyphony 2",
#@gui : "Klee: Red waistcoat",
#@gui : "Klimt: The Kiss",
#@gui : "Mondrian: Composition in Red-Yellow-Blue",
#@gui : "Mondrian: Evening; Red Tree",
#@gui : "Mondrian: Gray Tree",
#@gui : "Monet: San Giorgio Maggiore at Dusk",
#@gui : "Monet: Water-Lily Pond",
#@gui : "Monet: Wheatstacks - End of Summer",
#@gui : "Munch: The Scream",
#@gui : "Picabia: Udnie",
#@gui : "Picasso: Les Demoiselles d'Avignon",
#@gui : "Picasso: Seated Woman",
#@gui : "Picasso: The Reservoir - Horta de Ebro",
#@gui : "Pollock: Convergence",
#@gui : "Pollock: Summertime Number 9A",
#@gui : "Van Gogh; Almond Blossom",
#@gui : "Van Gogh; Irises",
#@gui : "Van Gogh: The Starry Night",
#@gui : "Van Gogh: Wheat Field with Crows"}
#@gui : Scale Style to Fit Target Resolution = choice(6,"No rescaling","10%","20%","30%","50%","75%","100%","150%","200%","250%","300%")
#@gui : Style Variations = choice("None","All XY-flips","All 90&deg; rotations","All 45&deg; rotations")
#@gui : Preview Progression While Running = bool(1)
#@gui : sep = separator(), note = note{"<small><b><span color="red">Important note:</span></b>\n\n
#@gui : This filter tries to transfer colors and textures from a style image, to given input layers (a.k.a. target images). Please be aware of the following, before using this filter:\n
#@gui : \n&nbsp;&nbsp; - This filter is still in <b>alpha stage</b>. Use it at your own risk!
#@gui : \n&nbsp;&nbsp; - The transfer algorithm is <b>computationally demanding</b>, and use all available CPU cores.
#@gui : \n&nbsp;&nbsp; - For this reason, <b>no filter preview</b> can be calculated and displayed in a reasonable time.
#@gui : \n&nbsp;&nbsp; - This is also a good reason for testing the filter first on relatively small images (e.g. <i>resolution&lt;1024</i>).
#@gui : \n&nbsp;&nbsp; - The quality of the result depends on how both target and style images may match...
#@gui : \n&nbsp;&nbsp; - ..so sometimes, the filter just renders crap. Don't be surprised.
#@gui : </small>"}
#@gui : sep = separator(), note = note{"<small><b><span color="blue">Style/Target Parameters:</span></b></small>"}
#@gui : Fidelity to Target (Finest) = float(0.5,0,5)
#@gui : Fidelity to Target (Coarsest) = float(3,0,5)
#@gui : Fidelity Smoothness (Finest) = float(3,0,5)
#@gui : Fidelity Smoothness (Coarsest) = float(0.5,0,5)
#@gui : Fidelity Chromaticity = float(0.1,0,1)
#@gui : sep = separator(), note = note{"<small><b><span color="blue">Image Matching Parameters:</span></b></small>"}
#@gui : Match Colors With = choice(2,"Nothing","Gamma Balance","Histogram Transfer")
#@gui : Colorspace = choice{5,"sRGB","Linear RGB","YCbCr","YCbCr (Luma Only)","YCbCr (Chroma Only)","Lab","Lab (Luma Only)","Lab (Chroma Only)"}
#@gui : Keep Color Channels = choice{"All","Luminance Only (YCbCr)","Luminance Only (Lab)","Chrominances Only (CbCr)","Chrominances Only (ab)"}
#@gui : Smoothness = float(0.7,0,5)
#@gui : Also Match Gradients = float(1,0,5)
#@gui : sep = separator(), note = note{"<small><b><span color="blue">Advanced Parameters:</span></b></small>"}
#@gui : Init. Type = choice("Best Match","Identity","Randomized")
#@gui : Init. Resolution = choice(1,"8px","16px","32px","64px","128px","256px")
#@gui : Init. With High Gradients Only = float(0,0,100)
#@gui : Patch Size for Analysis = int(5,2,16)
#@gui : Patch Size for Synthesis = int(5,2,16)
#@gui : Patch Size for Synthesis (Final) = int(7,2,16)
#@gui : Number of Matches (Finest) = int(1,0,10)
#@gui : Number of Matches (Coarsest) = int(30,0,200)
#@gui : Penalize Patch Repetitions = int(1000,0,2000)
#@gui : Matching Precision (Smaller Is Faster) = float(2,0,10)
#@gui : Scale Factor = float(1.85,1.1,4)
#@gui : Skip Finest Scales = int(0,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/12/04</i>.</small>")
fx_stylize : l[] if {!narg($$stylize)} _fx_stylize_ fi onfail endl
init_resolution={arg(1+$16,8,16,32,64,128,256)}
colorspace=${"arg 1+$11,all,lrgb,ycbcr,ycbcr_y,ycbcr_cbcr,lab,lab_l,lab_ab"}
match_colors="s c,-3 mv[1] 3 b[-2,-1] 1% negate[-2,-1] n[-2,-1] 0,1"
if {$10==1} match_colors=$match_colors" ac[0,1] \"balance_gamma ,\","$colorspace
elif {$10==2} match_colors=$match_colors" transfer_histogram[0] [1],256,"$colorspace
fi
if {$12==1} match_colors=$match_colors" rgb2ycbcr[0,1] sh[0,1] 1,2 f[-2,-1] 128 rm[-2,-1] ycbcr2rgb[0,1]"
elif {$12==2} match_colors=$match_colors" srgb2lab[0,1] sh[0,1] 1,2 f[-2,-1] 0 rm[-2,-1] lab2srgb[0,1]"
elif {$12==3} match_colors=$match_colors" rgb2ycbcr[0,1] sh[0,1] 0 f[-2,-1] 128 rm[-2,-1] ycbcr2rgb[0,1]"
elif {$12==4} match_colors=$match_colors" srgb2lab[0,1] sh[0,1] 0 f[-2,-1] 50 rm[-2,-1] lab2srgb[0,1]"
fi
match_colors=$match_colors" b[0,1] xy,$13 repeat 2 l[$>] s c n 0,255 a c endl done *[-2,-1] {$14*255} a[0,-2] c a[1,-1] c"
if {$1<2}
if {$!<2} error "At least two layers are required in this mode." fi
ind_first={$1==0?1:0} ind_style={$1==0?0:-1} N={$!-1} sh[$ind_style]
else
ind_first=0 N=$! ind_style= _fx_stylize {$1-2}
fi
is_window=0
repeat $N l[{$ind_first+$>},-1] nm={0,n}
if $2 +rr2d[1] {0,[w,h]*arg($2,0.1,0.2,0.3,0.5,0.75,1,1.5,2,2.5,3)},1,2 fi
if {$3==1} . +mirror. x +mirror[-2,-1] y a[-4--1] z
elif {$3==2} +l. r {u={max(w,h)};[u,u]},1,100%,0,3,0.5,0.5 repeat 3 +rotate[0] {90*$>},1,3,50%,50% done a z endl
elif {$3==3} +l. r {u={max(w,h)};[u,u]},1,100%,0,3,0.5,0.5 repeat 7 +rotate[0] {45*$>},1,3,50%,50% done a z endl
fi
if $4 wsiz=${"fitscreen "{0,[w,h]}} w[0] $wsiz is_window={*} fi
stylize[0] .,${5-9},$15,$init_resolution,${17-26},$match_colors
k[0,1] nm[0] $nm0
if {$is_window" && "!{*}} break fi
endl done
rm.
if {0$_output_mode}
if {narg($ind_style)} rm[$ind_style] fi
if {$is_window" && "!{*}} rm fi
fi
fx_stylize_preview :
if {$1<2}
if {$!<2} gui_warning_preview "At least two layers are required when specifying a custom style." return fi
ind_first={$1==0?1:0} ind_style={$1==0?0:-1} N={$!-1} sh[$ind_style]
else
ind_first=0 N=$! ind_style= _fx_stylize {$1-2}
fi
repeat $N l[{$ind_first+$>},-1]
gui_no_preview[0] ,
+rr2d[1] {0,[w,h]*2/3},0,2 frame. 1,1,255 frame. 1,1,0,0,0,255 j[0] .,1%,30 rm. to[0] "Style:",1%,0,24
endl done rm.
if {narg($ind_style)} rm[$ind_style] fi
_fx_stylize :
if {isval($1)}
name=${"arg 1+$1,landscapenearantwerp,leviaducalestaque,littlebayatlaciotat,themandola,windowsopensimultaneously,portraitdemetzinger,\
greatwave,squareswithconcentriccircles,yellowredblue,deathandfire,inthestyleofkairouan,orientalpleasuregardenanagoria,\
polyphony2,redwaistcoat,thekiss,\
compositionredyellowblue,redtree,graytree,sangiorgiomaggioreatdusk,waterlilypond,\
wheatstacksendofsummer,scream,udnie,lesdemoisellesdavignon,seatedwoman,reservoirhortadeebro,convergence,summertime9a,\
almondblossom,irises,starrynight,wheatfieldwithcrows"}
else name="$1"
fi
filename=${_path_rc}style_$name.png
if $filename $filename
else i https://gmic.eu/img/style_$name.png o. $filename
fi
_fx_stylize_ :
m _b:base642img\ $""1 m _r:run\ \{t\}\ rm _b MiB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KMTIwMzkgMSAxIDEgIzkxMjYKeJwVmcWuhFgARH9l9iSD07DE3WlsM8Hdna+ffquWEOBKVZ2C/9J/9IaB09GYYwTvY4FqE1F4ZPGec8nZYp/q08GZowBTDS5CDJa+ZY6vdJdu9feL6PSMjXwQ7h+Vh5iBC4EQaeUiY+uyGznTqPErDDi5OD9n2Ke7N8Kgq+AwCILtxwfxMWefrCSv3inpWyg6oCMdqSuIvjegnSu6e6SuvvE4g1TasJDhFIvCgQIwA8UEIyZ5IKnb/neTqUZTE0VJDrV/42VYh3zzY0CoDZj1PjKIZLLbt+sjd53W557ATon8eLEu3FhkANOBtDMyQNAp3pFnP/4sGJXymvbDaVNZKs7+iefJOqXFCaG25JXi45rLSIlpxb8ZcB4yeZLjHA3cjoiNgRfiYHlWDulDh4danY0MOuMfmj00p+Ra8Kt0Y0c1RkzEVx1UfBwRfQljkqTWz8aOxFeqiE/hXzFt0oYz8wmfLhP/gplFx3lmlRl564WOejvMpXlngfDU97VhK3wIw9qG2ncKbAthObrsDqHJx9s3rZVjvmEry4OrM23P+L5uUTTwakyls7LyyqSMfhsWhe4D2CRi2IKu6e9A1ulkXUUDvza1ShlOcC9esXiLQZoHkZCXJx+Lkgbz6i5a36OGD+RetedGUZsrcw14HtNZ+Aa0D2XJduWpku8eAHz3YX2u6dPtUbUw+4E5K6nbQlHVEt4OHkSNMhdiYJSShJnP4fxl8omuo9Rb39PpbOcbTr+Z1+5mO5+GHyTBiPrK5hC8u6H368sUA0txYQ95XqoRY8HLLRncY6nO1jSb1zm9MhMH93r4MRZUhdCm1P6ucmT4t2FVHXn1vN3M9kQxoh3HMidr3kcMEeeXD5docygAqWKkWXe2q3DR+HtAPl+hOQfRWO28UkbM78SFHgB6jV6HODYEIXzlW/7cNiEisxdvTmuifdPyYMyd9SLgw2feDYxJmzqG8GvDBBFbsFA4aq4kyxhw/YdoSIMOfyu0F9xV00yiij1F37OLH+vghCytdXMncjdxKTHKB0gKFSh9gJrd9PdJ6XjqvsJHC6epHEUY9vGn2xrN/GSf7gIzkPHc28JMY83tR9ReQrShLO9aqZ/NBfvIt5ZvIrTTFAnWE8uubdE1l4HARyL4jakG0J6nubA/BV5L+/dkI1LMxxlODutBGYVIbzPDWFGIH4qjz7twyfLbsYXn7t/E9Einilx3reQbQKEadV66MKilA3bugiOdP6uvrKw0pnXfNCbtpfF76akA9og1+RmTgCn7td9D3ZcAg+/1JABGNbDdmbHC07FGC5s7CMt2pMWsFY2jRfM/WHXz90pwhHKWxtMz32tY1DWbiEgbvjJovYDqeG+fPrHUtaQvIvgA7Ift7HJSCz8rUhIe0J7ulh7QOQyqseJ4L2vAyfv9s3rmmnuDfVllgluM5y9s4zdtZd113FFMdFmjqZsyFJ3QVY9eU4iMCzg46yQMuypOcUUG5SFlmuFVqTTRmkdlDkg2AMr327YOjW8vpx8X8kJCQEXmoRt63XqsLjga8v3MwE0RUf8sSidMDnJ8MRpvEKy/tjIzla+jEGLJQ/6AS8+K9Wgta+B3NRggXqTKkEGWxyqnxdQ2YKBbZAbQ2nidsIGZ0oFHaLoPkbej8X3cr2V+JOOdO7DNsUVKh+udotrVGpex+BFk5M/D3fTNdXr11kUd2xN4WN3QkuoOL5xvVu5stRw0180mWcnC3AzTAJXDLu9hnKnSVi8r/sT6S50hD3on3I48sRxz7EjQRb3iM0i6ovWYNtnvSgug9LUF5wOXfAVp+jtDREgspKV7X0rQAIJj6E9fDYUd6ShwQOc2EYMg20s0NMtmZGEj5hYzBJdaUBT38x1ecAl3VNHaWsukRGNnilDkilF6gpc99bKCgTJYf9VjvIbXQybgA6WV+pW7b517DE4fgwBAnmoZKz7KzuCKlYY2wfeDB0FtG9mHVIhT3EAX9sIcX9jYzP1XTGF+UpckIliBV6GyalVunu09asfmm0sX+/n9+zLti1M+aTQnDlE3006TgLC7yBdr4R+UbqwqTUUMDCAkua8rQUytPsUEz6fnF/5MCvRuScR9RUawcdbcxVXYz2+/L3N6dyfEnlVClyfKFfrFh8VbOs3a8N5AZZkWawIawXhmBNq0QXxPbEmF0lIJxpM/zF7j1+ELth2MbYlt0ll8cEGYl1g5wUDrURy4oTPdWsCNVMvbGLa0h72K/jx5E3Oz1ppkYLAYqDasjar5NLqSktgUqZva9MejAmS8/O5NeMt85S9u+20wCOSvV3SsgmL8yFvSbNdobntnO3oIDGxphMn5hNKL025APNGjVcAPtM2wZmIPIOlsrifmR9b9mHcXQFqx6QDQIqFw18UbVbtSVzd/MY9uTOChAE7TL/yWz55G91xxiUTuO4jehtJjP6+VrCaPJHBFwueVOIUkkpWoAFdNP+d6YRb0fdKELwuEqCOINzPd3bpPwnco+imvGykiMd0dlXVdQ/RoB5JEhuEBVOpmvugKOLcD/Len8rY33mw+7FxrPtWYoihmwljR59+fOLHcM2tjsFIomzpe4J5saG5ifK7u2gCYaqNpHQNSoFaKmz9gS81bEEHoAjXu4g26El086vqrj//8379q0ESQ345tS4IPl0wQLukVW/GVb6bLQbaXkRkzLfWWn43XKiL2C616IQ6VM7sEav2iv8xDyilav6b2AYbZpf2OA7SakGu8YKlWgUD3Zqo1PkiAmKaGi9/gPa7AgjlZ9PdrpsO1ta09yt4kisdHyvtODd5n0YnnTFf+WnkUaPfLNr2WlU8wfgf2a3g9UhFCubvTDeiEayxZ4qBfrqd5UYzgr+2ywKgR2/X0TShm9uUylLixHvMZg85LSjoWlm3kJWpujv49WdC6WcZ9OHJAwpXIrLROOBuNh5sld5GzHdgB5QUgPKNZFTWr13mVYCz8xUmUII0WD9XMd0rW92Q89EtOzo7pCOY2vy6WRcXpmH382ZPkp1WOkbvP+MJfFM2+OlXaMODqshVzybePNLoSlTnQAXdT14JeBdVfhnPJAYRCNHonlG5VrfUj4KHXllzdYS/WCG1U+7w63D2rBW80yZPxgRPq7Pmg584hRQeydMZTyWJgqvzkgeggXKnOLRsaqSYLVFjmlosH9Y8JUMih+nz4CXljXHVohKbZn+gj5FMEhSlFCBq8YjkEwU71Yn4c0izy+jCXKjD5ZRmaIQrGhJGVYM5YpEkxaa/os6tdW36HNvg7ECPyt/90zoUQ86Jn0hVA7JamKRSijnIhe6Xr7QH0bV9+FcHhzPBCkKiUGRdWP8H1WNGPhsMk+mT4SS11R64eFemvULyu+rObiTix6ZEUqAIFl/WMN1rinucky3UQuOcifpu3XuxlC1qVn7LeBDpSIBXOn4PIxLfdjIIdiIqARhO8te2ZpGa+XcTLzjC/DQj9yFAe65ptopSW1tx1tBT9rZvSnDcxHjH5fgJYKEtzk4HDvqofIhLUBjB4f/1AV8J9ErUH1j384DWDeR7bmVtQ58M+1z6+goZCRZsPINOODowHe57xDaE/jl+w7hfGkrw8nsk8epLdOz6yfbtwQZOAlbx6t8q+a7r+kNeRkdx7ZbkE1DUsH1Iv7Kj76cKkFzDqthESkgNeoUD08+RJ6G5MlOb723Z1/Kj6OAIk1hztfQpEsnlwse2KeNRBpHsYtxvfNetPLz4oIL2NH69X6a8Pgkuv+s5BcmCMcDdXBwkeRCc2nKBHkMm7ls3BGwyDXafejyYCmNoXOM2sl4dT8dnUmh7i6LZ2gsuiG9szdNtxU1M+uTanMBAnwofRm1tDe96eUJkdfocA2/nI4Ip9KbRMfVx0Bf1XX3ciFWm/F8QffarIgzE8aGapJnNzPehVoIS7qkQ6d72ryWCEpTv2vNpPXe3dB58O2w77RCtTHD+dpBXxjXZ1qZcwaa5nMQu+5MD4IvQ+puTQd6h9BtsEj5abaWsG3S0YafpblJpB8fJJv0pu0DSkX9Fr4PrBsiDWNF3FbkUni6t1FlTLVOUUHer0HOca09LKBoprb9qmxP51/poMzaiHHRGPL18y1dmCNZZ2PJLXHNy80bUcAs4hQ7veb8YUB4XrD1yUwzyb4UGY+y+cDaM+SxiYrQJLjOz257wBPmZoODW5M2ji/qq0p20nQ28vzn/n9yFwCNC/EJZCieoQ7W69L/PEbO6Gs/fjIpEAJG8N6PyjPaxCwSDxqK2BScKvJTSsP+KpSAVF2/iBffHyXgO7vyUXTvI9JODg9iD4hnnSt1W/yfwl2FHeSYdtgP58RfMOc8a2GLql6QXDK8wKITWZdDnmS/CMUIpvUx01P2hBiUR0nmjJHU8pI59Skk/VDxPM8Kc1vNGvwZqxJiKekWQU/NzcefqBa0UKPBZ3KcLJHvU1cuqBuMgiqAINFrzVdjgvimt9NSdH+xsMf4PcD0BCKR8SQOIWZmqdKHlGImH6mmc8BmvKop3KbC6QGsNhb13bXtpsDRV4fQIXpmlyahyosOmHidoYrHQUbsNBcyoELnmXnqp6DS6A0T/ZMU9I1v54YUbIlqkt0Cnc5ShwaRKHdCPMjuqAOzl7YwgcZfAKSJMu6gdDpzqbzIT72Cr1A//5WYV+GWg0SpLz0IPCuKRu/VA+cxnmgFiehoKiGoc+Y5fdD9t0ctE30W1tCUnxDN3zlk7Ly8RtAudA1M2G/UicflNY1vhR9U6BW76kX83+FtY0+kI4gJ7bZ0PBzJlHXBpsSL91pnq/RggzpHevFaDx5LPJrwFdzFxCnHYrABEgd736XdaQhZ4xfLjdm5p6Kj+vZSiI1l48n8MLYhyvUyw6NnZY4TvTb9af5QYjgMhWFARIBCQAsATGD3hSUgnQJSnojpyEHl/9sB8xvOzv+dQts/qP1DucHZus9nelOyCsXd42V0ahWmyZbm9mLSa2LAFuNyuOCjU/bslX3rGqc7kq45oKBF+0BEHY+qAh+lpAPL/gj6NSgLPe9VNiAbCfn9NwPwB0vhiI6r9PdAQtAOOJEvA+NzhCv0PwHkRJNCs/2NuD1G+u5vxTcBgBFiO4ZinuNxS5hBq8/zYrgJ3QDgJKbse3AFsmiq2Q6gN2+fFvCs7B5E/lIwlQzVuDrwYuMSCdzU6V7+C3GX2+qNVQV3h6ywry6P6bpN/20d6izODsGMod7OF2XDEERLsDFN4W3Mz19Y4dVEnSj2Xwvfbe0KwLC3Acw5AbGbXvd68/45qa00aEY2p6OcC+iSlxUv6C8DAspQhF4IOiJxliN2kqHxgsy4LoX7hoIzTdzvIcc4KbRXRc9+ubqAg6gWT+wUpXSsJQqcdXApWGSA2+rF/0l3UO1Y9OpjItBVJcaoXh0sJ2fpDJ5zoNdBJNMESbI79znLN2iuCAaFsREcfBk7ylrf01STwl1Z9k5CeEjlxISRCdDtBEW/QcReCO0KAIT+7Uc9LUO1On9A9NldKScVqLGK1jHz/gGOD0QSYM9koar1LzGQtgbhss3byzz7CjcIvI6sz9XULCLJoPIbsKGpsG4t8Sw2XsCdbTlpX4p8+Z6LPl9pmzZymFt67Np1lk6HYC3LoDF4i8p4XeG2wJFvcNR6Ndyi0jylE3Yw6FqYLdUA50C0AsLuIAwMs0nxSA6dL6Oq9ktR8k7Mifvb2klcwok/mWhFJFTFmQ8mlNk9lNxyKCzi4yMLOft6QPy7KDzAwjliTsRuNRScZQg/Y4lEuBoByGLynfBA2e/OqRxkczm4xFPtR5amT2MQFC/o3EoojY+8WoyBYHeeA9X6VWQL0TA2oqZ7CKQNvw9aVJuqM/rqhUEu2fr9YBfMpMUGk7eHtuW0vg/HaTZYrkeF226S7wnGAyEyAcJaN2dc0qrgF5UtzRAp91d40dQzg8fBxPptRngOp8+CvGhJPfxC4iqhH9HpIZNadyUZAVeTCpmyixFT0QuLT4aMIMZ7xKq8d7IsiX1j7Sr5WRMsN/ARPKCII6+QnVcFLOPGZSLWsjfu6o9pEdJmCGKeuofpmKEbQqYFua8Cyywfzv9+CT10bWz8R8i7z94BCysQ72kBIEH5xYx6dVk6egXEZotYMItxjOnQCdWqyfQ6PkZRPyGwxCsmurbONLowzKT/a1ugeOa749PSR0N8TJclsjigrx2Ld3gxjfWApEi980eDsAiRuS3uMo+rrMZoefsfgYlsTajAhW0C+/P40nKr2mBvHTjPaxYfjFtzxNWDjBQ2Jka2vjyaWnsVPPb4rrKT3O2fsqhfb+Ca07eSSYenzu4SBvV3skzby5qhwFdxPIXcl3LNvPxJFsRj+w7OluA7jtO/9gUtbRFTJ4lGYeQL8hBUfROkebH/A2D/+We6Z9vZl0/Sn0Wy3+aVCQjxncOHOTWklrb9KLyRNtg2MOYzrVrw7d5sNBNCOSG9O/oaqMcQLyAH+jww96yCzMoFga9Ynq1fdGDQfYsVsnc+sPwpV5KIl2Sg7nl05ZhmEOP3I1WZ2cnExMbTZtTYNyGpB8mgWefwpbLbGReRIEK5mNcl6mtX/LZrqqZGbSIwnNPQ4u2dpBjYSOg+1k7A34z8cm3aErTPqrWx7+jqH4VzM9Q6bf6QqUGs9rRXm0W7a66uWVdcUoASEO+xEwPEKkMuPWI7l1/jHcjFK6XUNwyKQ3w9TAvCqJvB0gH/qUB835ou6YL4PuafyU4yObzq9lVk3aphcUm7M0I/heS78v+tpG1a18RqlqDuFr46kiG5n78OiTB2LXViTFoRgyymz3Ak51DLYTsqUX9aRVVTSmZQ3j0aYho8MaWD7F38Uv2NXe7kJBajlqQ6WlXERW8Qc/KJyjnycy8Cjbo6aZd3Vm0nnoVNaHDiRXcF72DgMzLnpHUhCHeg3PTb8ek4ZG22EIn4SB96iOpaZJ4SzXdNfF6s9lI4yJoFuA0IXVbBzK1NqBDTzJ+5MamebJCpCslDUHsgsBDf7wxD5njPZDWty672XwgGMi9nl4oMJ5ffgIISt8H4/tZ0NwXdMvpGrG3dMNToO0ST7EAbDv8D7iRhczgPPrZjKaorfxERMohXX6arzFqTnj+rra/gt7sWVspV58r8nRZXhGK1rnFZ/jJBWz9H1VGGVTxs8nwpVU3iZIqAfolkTY2JYgv9zfLV19GaqOaaTHlY+9fq0C9RQWcyx/djHtpVeEja159yOvKq7QRatvQ0i3T5UNH4mdKrI0fEW+mNWdlYPj4bGZIGSQ8bBgSAGocA1Qogdl8SRqNwkjB+cjGaDedsvqb2qwR3hztYkg9HUg1FI4CqMtfazwEJp+g8Be97jsMHW7IiGQtdGAYIdbb69M4wFjivHsweB0hiFRmt1I7oRy2ZVAkbX0OjafbO7Ko6UoEDL/o4Q/4t50UZshKAB3NuZPyRWZpjJwh8kFowAmb7OdkvbaOvSFlw8UW48sfKZdRzaqiUFzVuT3do6U1wi+zNNNG2fr7HvHTBLLSK0C1M/kciHG4RzxO/I4ET+Hld+95SIJx9O3vdhvSudIyrJNUNvTkk2WnJbz13ocYONZW17s0L3jPQZ24Wc4l33H3teI3IPcnDtNea0ZcjmC/Kxp8Oh+4NvPtAxIH4pIu4F3Cimk1OZl1isj5vt5/W3o7Dq9ijramLPbwg+mLOE0UG/vXsv1AyacDZDRb+K3q0qdIXXhevamqA1TaGnSb4VONtlk89utgA5SnXJo/nHwT5Z0+eoNBMxN1dfGNMI7nQtQpNYK3mmJSb0ZTkO2kklBIN+1TW8ZdWTXdAJa4S7BYqwn6aeUJKtO8olrs5eA29snvpoe5geMXeJ/A7jMhL6TZp2IsRLUxaEVrIYen9FlaaRmWr9wuQkHOwhtzOPav5BWcYTX12ZJP4nHDknYY0UnuRUIdUh4cw8fGGqBfjuL1kM7uJY7UhkI6xrOs2XFS3w53QaCREVTpk4r9/mjHOuWwOQ2iHDGB3e3mcY2+cpPX6Rvhz233VUIgvlYPTRuz7yqN2g/1e/7ZQ9nVkzdj1rZSXKmI1vw1JiNIssVZ9aXioCmPuBOt/e+38DuySH9GdQAKqH/YLl5BBJpRqMzOHI45/xw4iIzQ27yrYBKqhQ4spbe/RKrTLZy+zivjK2/IjhNA5Za+EE/Ne2am/4Em68obY1NBdGMhpskCnAIdE/aMbKqu/jIwk5UPfKVzIeU6aT+e2XKt7W4A/ws77MP5bSTx9X7s0etaTbUEaHnORcs7Tbtrm7UgOdvv3B0EnsGa3j2rTg64eTpt/IHeuLcNlklTugTjBV8EEz0YLJyS8dAAFQqyGzh9ddrNihAXIXvWndyXWwjqiFqATdA7e9TlU7ATpq/LcZc+3wfjdUk11K8/Vrp8jpzmAzg9+oNOoTD5OLRuJeztH9cz2DkK/3NW0t2Uyx13XzHCLqOewS5vMyL6Z6PN7VwvOvaAbbLuwkZU3paoCA1gvk9XpwhQ11XQWVH6WpJylKCyWK321JpLeVuGitFMrNcUpo/eEd5HOdzHPcy5oO9uh7kdrIfSRmmp4JBXYtsf5Z8FFrDzlo2V371kH5jshe0zD5Sd51E43yz99AhM36h12qY1Ih5O7iJQPs2XLQBLiYGohXBsuF42JD6VMuvSBPMGG4bs7M5cWVCZhSzttsb+eIud09B2AwUTdsk1faa2JSw3E9nhKAs8XPV35LlC3TjCxiJkA4e5c6c4NATY7arCrLVaTpHD7aGU/l0eNjpfkFYZYj6+qqYm/2wSMPa8FIv8I1O/9DA9JgZPiAniG5ZkM/joD1+hQE45+NnZgPe8gmHez0JdZCSmO4Ief2xUemwmQEVUtmg4CW15rsLYYMo9xnmEeEjIps+3xjpIAaJMjS6d6MbKANiWVhViPezV+Cfji6kxxaV9jEK0hF58yfljYw+6tYDffFIj2AC+5Cr5Awt1rPqeURHTw2mN8/yUvR5EsHWmE2qtMGHtXV41STI0vbr4i0/0d+FCb1Uca44X6nNdaxoFkHllROxlEzQI6kDQM2M5oUGclYr8zK8WNMsilFoIc4UWSXTRXQxgsNXCSFhLGyv9AjJd1CKq0k+6oAlSZqZhgpFi9FtpUclqwuihNPeHjiArYNuVt1BFlKzLI31RzBk/oYuXbtynDiRkBqapJAWLwQ5oGVGFZx84dsG08mgp9jY7yAuqpkUwwbxC7tB9ZDC85bKtB/Gey7TG26kiFiIwefNcaDKuUlf3E2yBF6nnMNaE8bueykXeUzbhZP+y7bh5oBq787I/bXbWnmGKbDePHxuc8u7wYwmlI1AFj5ySHUykUFQUm2rdSjPr51KDgS86xs+ULJDO/EVG+3Tc03gR4T+kLr+Az8FWVLIz0lDHb8OZ+afYTr4uFaYvb791VD8uITgKWDdWtE9fq/wn0/s8YcQ7ZvGGc/N6uW5ISoF7PVszVbCxjSRMeUHiaf3LlepBuyqVuJ6IBjXvGl439MEu7f3IQOG25KfjNMsfN27/GzMgvjDyjDoon9p+7penRmz7ERzTaOQ35AIf4BUhGg+DHWON5/DH+kAFZ5+lTeOSyHUI8JfZGbs+3VKyZ4XX0GVeZD58Di0z8P9A/jZgPYa9gMXNgrJlWxiznocDgxjuzXaXUd5g3EU5zkzDI0nJSeOkEWb1jiX02qUrnHYRZMctXpoZrzfWSLCmnUKK1s9miFhaYqR/nuX0bNzV7Xn3l8+XacG9OyvwW04mbKoCX1fZMLbSYy0H274sN02ohF+ipnb+ycMbB/pUdgm5ZQn3CyLeR7hlEWL2GPkZbF6nmPvAKAL+XHM8GSnXuLQzJlzKqwi6RYQC66pmcR1xdDG/DbA2b3sPhnFFxQaEQsI7lZDpCQycfHnSFiDacKQVVWbjfQTGjE7cLqPm3dwkq2pWgeW8qrypA+7vF0+cM0FP+oziPV02tEb+GS+mW3cgv1afi4OeC/nQXgzI/bzRxVEemhHBQ4a2PEjIIorLQ39gVO4OzXQeD90ZwHdj6fy1jQ4A0mhX0kAxemjxfLmGmdPGvSP8k9HUrtFiztcy3pn+Wqd/9kwaySeO8Whfs77zxgwyHSZno8ydMV2w/Os5TKDlEWp+quUZh9qhX7EaiTaKi2RuGDNWOan5AZLmnOE0XDpleXDr2c9q/vBjcTdOVaj8p9TvdYPuAhxCUfgZfTAzIgQbmjk4/ksyldkMrYvCUi3W1P6WuerFfAD3tgLH4xZUJWCU/qZl3V1sbRPB/eCpc1C7B/CW5A3Y5kr4Wrdc26vo44T7AUAMeWfTrwfogsZa0IOt9vmKW8y357Qx/7s1AgrKSBP6UjDlYJQzcHn3o6oB8lPKHbzwTYpqubOyy+Q9e2oBR2wbS7x5s/r/hD3882LVP6iyVqw0WEDeuSSisS3MXrgdDr0nKoirOCYVgMqyegjmNwcdDe7IgcrKnmoOG96g4vyTTgL+407l1c9+S3zz3RFfagetzvNxn2Lih6GFfIdInV8O14rpALwDF8FR//XX2Q5zB9UGgU/YJv7B5OZLFLQtZjtPKpfjVTndX0gcnKPXzs5WfvipDAPyhdMDAzc+GsfRe23oF6+sWlIfF3xHkPkh47H+6Om9q1txRmOUDqDCYzaUWBg/bv+WGShCkVJ12bqS7lGV+tdoCNS28b8o9OEDeFfRUQbnbF84wfZRDx21Hew5CFXlUmu8FGCKbcWKg3Tf3VG6u7mO8r5IGPmiVIRMg110ejNAE8mn19QVGq7AHhLh6e0oMax+53s1KBJc+MnASfb4TsaVrAwWNyaSsT2SN+m6N+jdRKkUx+BD2JHfRkfVPfh8gOy3LmQLIQCd4hyYy9gMnTQQEWyZQ+e3wLNCy2IM9NkIY8xpNwgal/Mg4GXN7w71izzEzdQ6M3+aLif1BF9o4Qla83uvW11R7mDhbAbx/Ikd4DgCCKNTJMkkACNyZsdzoBLPzsRs5mkLMW99IAxkFrKF+ng6SaSs9IGBMv0q+PVXiXr0V07rQQJeRiipgyNw8rtj+sz2dTyx+kp7Ai8ceYLCIm6SZLAAU6OjqW+Vsk8RKHKIR7yRvTNLY9HZMDSnsc0ZBhXhiRVlQP6LXH/5JsVPX01C7js3iykgDHaIUQk/bLW/AWYMA96bpQylMvJ/MWtqwBkjIVOILndV8eZlPzm95bgw1QUhC+aIUolUGkUSbPmmPgCuejlpS/1oyJvhzxqWs8tEyeqlLlTEndvB/UN0er7NSrSKpgY15JveqIYpDluBoQvZX1hDJ/Ma5iHy90gnHzv4Bkl9AuIhDUMgLRUKhtBA9HiUcMrEhXdL01izhjBCsdTJInQH/TH5pAF/H4qbHvLRPlrCgbMcHm5wc0deR9mFw5jpT5ae2uxKxs0H5uLv0nJD88PDWPsMXaDMKU/WsMF6gzMtGHJlOU6wQ/Ttx8OpECt5DLZgdp99nsNRllgbf2hPG7h7zrCNwufN0YAct8g4/H9DTt8S+ZhxIVdkpXOcEsHPCAdWvNYVNP5u08FRoyfuGKLjHH5zWsgDLXy4Zc2KW5kYCztBZem4ZHjvyB+lKJU9AVZ5O9nwBSzdCe/xzyy5gXLi12iAyfehqguC5RRvIpLh6nSHZznh0tvr4rYlTy2ZHQoqZA5D+yHiNJ8cCsDfzafMdKKovvwcrj2szZjHnJ1u+jvfriZKEYmCdt/618ZnbuHPANac0rkI9ScOUGQp6bxKidAvX3ZcaltRwoqpF4ShCUCabkdx/tIZUTIwzy9pMV2aZh72bnos97LKtS8GQeXt5h9LLaf6gf0FoQqOtHWgkaROMQo0j4301AYrzRqG3qwddxT5DUCZCv0+IJoM6bUf7i7BXvgZk1G6O4ELjtwhOHLGa2igtvbe4/5xJyCmr7RZzNHkwG9GvbUjd4z9jGLGzGoKjCAnellFPhdH5A4ORgrxgEnguyzVrbSv1BtcW+uVm67VMUlK/AYH6fxY5tP245e7pBxxL0aYkaf0Y1bAOSeYTGJnEbxCWlfSKDDeCDSr6nK45qCw5vibtq11wWaIuyh9pJ6OxAzJz57r2NIfkKlcs84Q+NlydrnNnd0Hd46Xevcj8ZDYAvsMtkoot0OhhoiNjqXn5w5EhruNsNrQg7/qF/MiFaBiFMYDxYhHP3ylSDN9dQRoq6Bu/tU6L/56X/C4wDL+3No1hu9F5FwF/0pxb1+cVKabgA8kRO8dHrK0fKf/9Z//welMb0hMSA0MDQ4OCAxIDEgIzEzNDAyCnicXZ1ZkuW8coO9HDuiHkiJQ3IFfvIGvP+FWEp8SJ12xP1vd1edQQOZA4CE/vt//vc//vPMvxN/9/W3919v82+tv3HeH/Xe/vb7x/V32t98/nc/L4j3H/v5x/vq9Xf23+7vv/v1/HG//+hXyzf19rzw+ovnb32+74qld0V+ejv61fOK52/7bz5HMN8vXPH+ZOaXr/23Zn7i89nPL9Z53ni/hxp3/uY5hPe4r+dTZr5Hb3g+dV55Bis/PN7zeL5+vt/x/GjEe57vMbzfFn/jfv//eX9+4Hue/e+c9+t7G89/79lsfV787ZPX5fnFe0X6ed/6fMf7G72z93i/6v3j/WJO+Pn+GPkZz/UdeQY7P0L/1P/e73/e+lyq5x/58S0v5HskVx7TezBz5fe+n/xew+cnvkpNB/Ac7Ljzj+elz0s2J/D8bo583/vfcxZDB7ai3qfbpxvMd7zL4jn0le94PnCPPM7Qm/bNgpm6lbq3M4/gvanPL3r+Je/ou5RW3oL7XTy6vEtfU8vk+bC93nPKg+jvH8//tJjyR+u93ec90Du/rfehP1vLj3k/o71fkRdk5Jnm7XxO410Ed17e9l7P5+9xc5pLH6SlrAu23yPRb9v77q178RzUu/TvfPHz45NLL/dB40LsXFbvK3vfXlu5Mlse6+DqhzfNe/HGX3R9pl6ri5ZrfuQyfxYfr1h5kfLzmxbB85LcUrmEDrvw+X00fc2V1+t5Seir87pf783IO9pz5d3vV+R11SJ4Du7oCN7N9xzBOTqvyPN6LkGuxtAfzTuavZUH0/IMW+7uqS2SPzjvkb2nrDX+HFLGoKOFm1syL/7Idf9uvvWupbyG93uwzwrJm5E3yTtBJ/ZusKnz2uyirfAzvQyHrtHJb4jtczx5J2qbXO/KmbmFdoaoXLJXz3W29NnPi98vu/IjZi6x9yRD2/T5wOdAn6u68quJeu837fz/4HJ3X+Hn2E9em6Xb2Br/fo/m+dt7pa+mi9XfP2ZXaMnQvYivOuXnXW9kOSyU4L/cEs9Cei7Qyj37BqGjBTXz87QmD4t45jHOvFeRucL7Jt/9ntzR5Zy5NfmOkTcn1+GVcS+aYljLC951q7WmQ8c0Fc2JpE0LZ2iLZzrSes+rON4b8G7C928ZNhb5ILdN5ALOFaNgP3T/lbTiWyi55vNurYxLHFZGT0Wou9a0g40Wws4YpbsaDp533o1MBPrr8weR8ygYjPcYiOLved9cp9zmJ3RxdIbvlXh/vuruPSf0fuFSiG/6spuTJF50Hd3xpdGlPtp+jSV5FK2vPPSlrBPvT9/AnLdct+oNx4PYmkns+eI3Y866sA6b+Y7etQEI1Ieju3UcS1eg7uDMOxb9y123jv3SweoL3i8NxX7XApEZ5719yj7rvazbOeBSzs+6YC1+2FUzDN6St0ZhNXO1kuS7FPNtodX2BcCtfZf3viu/50m3qcLkZITQ0nPmvN/PW1H1k9bICNcskfXGc2Kqu/alHa8N6IzWtPWfxfZ87vPCaNoRt1b6RdmUeaPly1R0aZXqaEOhME9S9/MNo9qgi8OhonHA7AqY93vwimAZ4tbv5X1ffXJdhb7r3ZEz905Twtocv0JL3iASRpYFkwKgN75VlSM7b+W+VDH43IipLNQV/SN3ch3OzoyvxbozCLKR80aR3LdC/ltb3Nz5/d6OWC4u33jRstB7q8SZhWRTZr0yBxxlh37x/s5qZGNsXeqpMx+5Tm99imvRvHlftZJ/XhQBWaG9p8oqHhVWde2fCzgdyVUArwxspynfKvJmyGDJHRWjqgx27hoFSwexkwuSYjbjv5ZxVxGdB6/rm2ujDSVZ1aHtotR6AtUbQi9KzJk7O69gBhlHZIWMroNV7l25RY8Wjs5tVuGfF+H+FqYKPRUxag8yNBIwW4b2pS/Mu5TFzZvuO73AVFZTlJwKCT2L77eI6FyV4MvzUHaWI2/E0Jp5r2x+LyGiirCeV0259F23NwFi13bcuoMZfCtKHlL+yDAQCvrvYshakn6jKwRT/b1d18qD0XJ5fjzCuVWl69J21T6lqHs33FTd2nThtLh2r1YgM9pcSpZD63ur0nGtzik1pYid0W0otZ2sgt+F0BQx5nvN+WySSWYpVsKlJD8r6FPcv1d+ZWx/l1HnQLUcBhkqq5tccD0T/8jEymI7eYWvjEeZXA6vzXC3HL4JtrfXcuieLNVW3Ar6DVUqg56KoiBUB3UlYa7syDAy6BK7g8dSXbjJZMoHQ1/AfngXzsk29rCZM7JuNQB9EJFY8yq11FNF5yOnLr8K/ksZ9fkSKuWT953O5b2iz2nFVo70cqH27bnA3+ycS2lkFbOU2fbmjUOdgu5zdF2MiywV4cwaun1a0d6qI4NRFvfLHdLktXndVItT/0T2NVNX/r3KWS7z2oxJk5JT0Wk7PWdZGK5n+LyZ7zvUK1kSbGoNN4ihDDZuUmpQK9DQX3l81VqvvAmL2E3k5ebmWu3uzna1vlvVBM31oCMYlBpfQ86dHMrffXsJve/NlX0cWJWsxq0V2upGTp1vVFFYlaMayv41GOq9mkPRUu22v5U1CQO3rlBzEqHFWir6+MSee3Hn3nkvq2qjTvN7iDHNSZPm8P2Mm9OY+e2RR/b8nEhEs9s49sMlebcn5xEUJqooL9WwU1/P+Z+qN95rfmUUzVvPPtbtXvlfXK4aunqUpX61K4JT7ozMk5EX4j0oRcWdd2x/eEeodVGwzO38vP+FsJSph75+blam8pE2OD3tVkEbwhN6xoJZh9gSDZve0If8k5ttZ0qMXNKKmVvpS8BYaBfMu+LHu7/0SZO+IheoWmz6sqXOSe0PnfAONtLKZc3OpY6ZNNOL6DOI293IHBuwZ3G9dSW6NtRFUh6KYuyiXH5T1YcLzlY9ZUamyP2iBLyJED/haHOzmwuffRmrzGtIuRdABnRlCZoo3i3hFMrjO6tUoJqMV6posnjaWg3UoI1+UfsoVFGML8c14yIZZLYaL1qAlbdsq3gl+obOf7HL/A3qBHb+/igDLfU0777SuYzbd2mRo64KOe+2dTO46uiVYf9pOQrbdQsTAn6DvmFSSSr7aAvo0oFZqisH12g0lOqvdtb3ynBkwg5ecTlD7rwHWx1WZ5NN4Qha6JkUE18CP85tlykkQpVj1gSROEvkfpm563audCWcpXqJgrEBRqp7UxqfLNltsE8nT5F88gNv524wBt0oBZodbtPbdB2k2Ew7kRWY4qZg0hVfd7zyC0LITSVqdjFplpif9bwybq3ySRtyXEDr0N179kUXfXTSy/jBOL6qmzvdjbSd6jQVv0ZukhHVY0/yL+WNFm6mh5UF9fLaOTR8Iw9ha2eregE43wSbLNK2CqEtCLGpXMl792a7rRWaIUaXfE6g7qmKYgvx08IcgmpVys7bGfI0AxCh2lzYwQA26rocmf0FMa5cUSvv4AiSkVCPPVUSwpEIxAp3z9QN6h2zak54e86fD7suLRPahEQZYtGWaY1l1wewcrV6OS3NTtpnCcfZgidbZ9EAb25CMVd+TxoIARUji5mZ9ek0+jNcsU11FyZxegeWXadw0Qzegw424crhmD25jCtfo7yx1UDnzdjHx119//InuirSMr7cNBgsGKGz1pI86kWbUKLZzZZsbb51zIQolAvZavPPOOE6LrRmdnknK03q8NxXkVtmJvK4E/0zst/zVlJz5/Wa2qw3+3HrKwUA5LY1Ine5pApBKUB9leQ2wLavZAeiPgC5GUngzgCg5sVl6NxZShlFnaEuF4Qedi5aFTPtz0CgLtQ0Bk3TBymVn/BhWr3C3lbaJecexYCVlYQQCH08LcIP8qgbt4M8ekEmvRsW0u8H0AUINtaRRegW/kB72En6UcQkuVfrKbgsyoUzs8qgnzuOCnRECtor+wbRPxkewj2RWDAug7OUcgtAy6w7urLkA+sUuzC3SYJc92DpAjPyV9TCIEVdYPlL61KtadfROZqx20CatSSvYn83zNs6xq1VV7uEhAwboGydg5w3bTSl6xao0w+Yi7qHH8pqQr9k8RiDLKvssHSlxqn9qCJWycotowItEOL1BScRr92A1R5VZxhF2tw6xd7IomSoJ5nqeK9uqFBdnaDpsx33WFWR2e4UV6zIeOiAR9WtJ+gLlR7UXo4/cGyFB8Ed4sVVhmUy8PvylCZl1MVCZEuqUunFUWfSXps7Itw1sqoKtTcXwXaZx9VFMQbnLAHfPEiIPZuiYiyMycP9Uomf82dQOdj02mx54MrqJ3wyWTQSxJoxUbVR7hXm5S909EB6YBDwmBnbFEvg6OenFDOU2D6OA9gu43OWA+ghgo/rNLVZzCKX6A6U2cDMovvN9agkyTs6VQ8OuHdtJZKICmA67JVFGtBrH4COhRuGmZ+R9XB2qbP9lEO1ocwDZvxRWaqSbV+OWZmnWdr3Vy+ojh9gZtnygV1zDFlzEiqLOAVtuaFhQ7Di/rqKkeF/Zlw5wiiaGuP3LpJ6p+mdNxgKWKkmFbZ8J/YxrBO4UI6EDn2F0ZamTlifD0u9tu+rCg8Vf3Xmgv1IltNtwQcIi6JoZtjcSCVesSFxpBrZ3fSjVtVl2BzINbqh88iNnntFzFerhbl/EJ+2QeTyS40cZBOtf6FJGZWX9FfalfYdjOqC0HGYbg0XHJfq6yW2XZRaC+f6CcJFgkcNIXyUjv5W5XhDO0bG9pjOL0tLJTEhVUnq6CJLPGOPy6WRAttHj0RGr/NBXNnwStUAf09jMb1fM78Nd0Ri4DdKk65XrdwV3rfNDYkL0yweDR9m/Sw0CyRggq803+A5oPdhzY8qr047pp4pP4csJYZDeOLIVhvESvl2Drh0F6E76/JjrI2U3RNuV/iM+ODTUOmgFKdCVZHw/sJ7hqBjjjPPqV6GnAEOr1809yFOCSQK8ixuAOBwaxHGAqQ0m6q3zoYeUnOhzpsmkVtHzo9JdjgCctnBgvaO067kCw3S7Gz3BAKBl5LN7qZJw2gT2XW7uKclzmW+pytARZrvOtAC5UXl4/syWN2AM2fB3pN6LMLbrnQtev3UxaNC260yTxvwmHvWssldJG4LoRytqHbjDnARVWLqeQKqLP9mUvFUbD1FllxUysF6oA7vSi6RNy6Ba/GAu5Y8++ympplUr1pkHdXKHmweJ4/WTffQe4IgqMbyKp2TPjhhFq2Mk1dUMD6FsuVDXzsl2aHFO6hrcq/zm+5ruC26OoYOeokbi6xCmaSiXe2z9U0dwdb05Qpj9xdymshrrSg7B5gEnV4W+NlaSVKiFuLQP5EdL+OTBf4qHEVGjvHvgZiHd0QPc5OhYpGKs1/OI+cYdRC7t9T7neB/IzgDYcwGyLvS5qYv0U0cP/I7JFeSbgm2W74ePpDC7fdtniBX/JwlKpIQQrlSOqoIoy7TtED/oeHYWBRRw+j9Nt3r9j5gjqrNNZTXoxocpWKgiiY6oZGxCMzehkLMtd9W0FrEDao/jndggCCZx5/fSgtC2QjH+p8imjphSKsnMdeByY+fRnLfaNhKphEugHK7D6fz/KQM42MXh9wnRQU1iOO7kMdmhNBy2ObmSoUuekz9Bh3louyY2R/v5dRo0UCv0nnNDyVUc7NPXaTdXR/N66N0chePU6WJ36PjUB8crvP/EYlMRS4V/YIjza98MqaE2oSzzZLxLDqzbJAdRM6n8yKQoq1Zyh3aPnNa/atTX5XuBEabaO5/Ji9gTwrNaxQKAjqLiNeaatktbX3DC0ss33nxJSoQjlU8Xlfcbt+LLAGWPzx7qZCqD01Flmz0ICOvvmkaX2ElXXSHyEKyFp+ld0ZrtCxYSoRA/eWu3iCbnWNNHRII4D/1So5todPK387LIGh0AMuhrbURyM4NNACpY/YiXBWI97T2sq8f9lDYMgoEyaMseBpJMxTaQlhEe7JbIQfJEg+XSSohtqg7RDnhmBUJtqC+hf/qX73Wo1RFG522RRM0xxW6Tvyo7oeDZVDrwEXrfpCqWpFd4YOCUN4mfpFC0UWEoGBKhevPlIQvxzrQi0L6tA7gUisYTbUUWb3FtD55H5/z/oqyrRopo2G0itgo4T6pjgDY8aEun5B4OZaFW6XmsvAE0JvTLhy1NDKhSsIHI9K7o+uKIv2dggWng0oZzvKwRGpGTHxbv29IW630USEo6nMKlRi7uAkUPSpFT6YTN8aB/uvT12zVZ1dHPibRma6w5PpSZX5k4zHDGQIsWI6THmPviubc9W00VzLjndVHOM2WMt6CXIeaCSnfHbij19gF6v0E+OftrB/Es4WkMDfvdGNAwLgQfdcJqYg7x8SRCs5lzYd5iatqxprKkI4dClOJDW4XktYNP/KmQvFCK06lakyWYXKeUjus434c1JOoKt3dmtbUSyGRL8gLgW5Buq6xK/zAoic06o2glc9sTx+eJih56CowpH30eN+qk7hlnc5CcAm0heTbrA440OmCYhcsxIb/hLK5JyAWVcKAauglCVrd1WKI/f3EpfHVBB/agnR7nY8lWKh2B8W0yd64PcbjQCAlyiRYjOKZvx7BOd517LZUuUNeay3t8GCRJUywLP1jC3Lp0g1czWMiyqQTNlVfw6hBG4YNND1xtnX7Cv0xqobrPkezDZLbxtevm3TIek0gTkzLuISnbrqs0vUu66hMSEo3tVRRxF1C7fER1Tu/Bk2OMIuAhbP0MtGU7cScO4plgKxEStddak3KP0mU4Xik6ty5kmn4lLAndRp1oPeZcEJEXaHLRrCfN4NNb/SQCmje5sTyujXHmpkntS8X3OK8DwttQgzDYGd8XtZjWKBBU65WdB+HGXeGHY0AJBysCPpPEWViGTQJtPn2DjIiBsfdZg9rAWATNKCVtZCkNJA5wtVQLHUd4kRapGWv+H2BEcNG7MtBjLIiV5FGx8I86DDfJnhQs4H7mEbt9Bk733sOi8KqaoMYiiOh2lbkjYqq7hZPQUIi3qN6trT8iBYkiQRDvImMY7ubF+ln6LUZNtwWgc7MOTXPAQH95YNvraJvHMqUPwRlfFhvHqU2Cl3D4pJJsiY0z1pPFZNr1Qmtg8xvfTVo1Tv+oI+XEfmUV+JidNFDFCUOZtBMwpsMOUgcgGt2HWVlnObJDsJS+HStveruu3yYF8AC1Oh0b6ED7hA5VVJqyzDNkIe4HKPBkEOxfPk4GhM6K2PAnOg9pP1Xx72Zl7prjq/VAsrN25jFOlkah5I0iB246AS9ZZebte+NqVQtilpOuxmYZWpMsMeEEUVBBsB3QJKnbsUk4CMsNG1rcUThthqO6Kyc48y9WfVUs6aGgC/nRF3CrNEOgbjCuRtZRojWzoPRFdE7wqly/8oXmL/qlCvZzptcV5/dqOvO+aa8miPeQU/Tkx2dN6MV86ZbUS9ong+R7qkJGYoQlUj7X6XYohksXE2kfUyQC0o1txdaXrt5NlZdD1OnRTRK+NgFh48aXtBYUBhuU5oBakTZIXROgQFwGeB4NyM2ubiP10ZUItvbVe1tJWjvztqxmZP1pBkk5Pi2lQLzEsZElIEDpwENq3yAaQgpUyVGmGafcL3LCXepsUdsNhF3gWEToiC1jJ5sU8FuTvtPxIMEI6LGgSo54r60NGnGG9WEtMDmHXsza8tUyOVfIQ8S1au+RRpvQfg/U+vDc+qfbu53nB09ieiGwh8Zh63YVFwOnGHRCFbU6ypaZ6NdsYeDklU4kbgfJYJJze7JRcC/7xzp33TIK4jT0uUftPur2OG+SqkvoH+BKJwvmd0eeldWpN7QuGo0CgvByCwVS4yVScf+odEFbq6oarMPFxhKxyXFL8HFDtCgUSEcXkXhQZzP+AoZSXt1HFJXzuHro8lyVle+Mv75Su12EKQFQ8VGgNDxC/bPfnd1DyuxggZ5UK32ZvGJGnFhj1mEVPiMynccDHUQ+ghr8Rc7YNeg0QGq9eguiKwu7nC9Nm4HcDkXkGAQfgwBQP/2ROq+xu0hBougWQwSlwOPW0FkPnOZ0Ss8RGHjnG+qRyxy83XApAHky3FLoiwSx7ezv2y8DeFVETSIoLAnENtD0Xicvw8NUoXUrCby9sQjQNuSDOKBjIvcv/2he6Kb1A6Tlt64p7JdkJpCYg2tdCEd8+IQrPQRUx7zE7GNIk+7ECCrVyY6aPQ2FgA0zxGJVhDOsb5qVHtyOKMdKooLfCRgDToULa4BkirnUS6GE7RcxheAfp0rEHdRoqo1OUjkupN+VB03hyGW3b2LDXzlwpg0rWL4qFHn8rZzvalpAMV0hGEWBV1owJgwAU6LT7M1ak1+6PrlLA5AL7QO0B6weVNBqlMLl2i5mePjGYWeTvQPimycyjbcRBwtkNm1aqMiQl+ikRPJYsKU08DDQQvLGRBe1ti9CiimBNRYa1bhq2TtlxFmpJgE1EvZKtYI7hp1XV4snq9UFtedpyRle9PoMXTMehISpL8xzWklAf0nAhQsNZonjt1D6Yh+uMdjj5yrW8g+L3dD7ZvCub2rqIyq4XBeniAnntCGfkd/2Tk3IbpxPAti6IgiTAML23tiMgUjh4btQbrtSc2oG7cS5MLohtDnEq3PSlD3N+HQYDkmIBEDqZ3f7dqB+yqBbM1og8ljrjPNY0SVF9qUQxjeqBHyjNvNqsyk35SONAoRNaxfN81xh7MgS+cLjBpIXGblXjfeKXk3EKzu1u5/HjODJaAuVGfB7VX9MY6LwWiMWBEeGMmZ08of880/yMN1MXICFqS51pMpLvKOze7jPZlkRfxuSp3F8cAZSHUT8icpOJTLj8lI/6EcLg9XhHq23FwaGAtx0BstK1LivciggnDUhjLzPbjCCmBD1KPxUE1ZzmWkYybbR2DBYkODttKnbArPyWIVeGS9She+vhjb2C7tQZVYmeF5utNqklOsw+6e9yWY5h8q2KjdicHSyHjqfzE0rlENIClZBE30RiSYlSe7hK5rYihKYNSE3kxjEFRAzAZrEgJQhxkRSb9sj1FDRVoC9LjE7qvVlD6yvOZha92NZeGvUJoVyLT8jfc3938ZeIfPTADJ8L34fOGazIJqEIuu09ZSbXyhrdyisl08NchqCoVQWAO4lvVoHumyjoFz3aqzbN5Dx6ZuXEzwRmhG+Y8uRf4P9l8a5vIpdhEWoi/WOla3ttF6LAM6qg4lv1qzZp+IYKSPiWUBE4jWbWsviFgTgynFu6KXhQdRsiZha7dVr8eaag0ZRfPspGoRRktK5CaK7GyiwLw8Xe5R7mlSR0M16HIDka+GDQbeTbMSWXzl5TYPel0w6m7ItHOKzfrCoiaRdNgUSDAOGj8PewwspC+Q2KpdzHNo/QKeiKW1zPyA6zJ+Om+XC2rhtcchB1ohJ6IgPCjefpamZAI/zgjbKlTFcuFool24b9aV2NjHxbraaAY/OWcmYqkoQSc9C6JpQEUQ01/KIhnbGqweCo9o6JG0bGUbUBD1RqF4+LKSKGr8PiS6BVmeLB53DhrOlLeHhmpCo1iIzG7Lw4QfTR17jIp+QQiNbYGENmhz3QVlgj8JDMQ6XoMZz6RfH4FOWNCzB7BwWGoXMCQGbg7vAvqEbXne40Zh64k1lTNRvSLL6mpG15HSbhORqzCwETbnYv8JtjznY/9VKjKOnVWbRFsYS0yXehYsrdpI1t3Q/F4d6UsMD4OIMbJSgRGiHyXKDZPjlj5I6auE9UIJsS3SEdK/MZs5S+yOakktffmZuU8+1mdw4nPV5EIHDM5dtJCBqUrf7fPHutwzryjNFvKJq+BDpTxJXOxNR6+463MibIJVDDljMp/KbqPDE90e4gBla0INjUwGE5xpiZycgOAHJT6EJVMTtLJJVmBQ/Q/HBHtqjJUQDtrQmVDfHze/S3XhgmZzk77h6x8qtpdvyvWDEB9bpciUixl29DsTbl+9Fc4VnSH94apM8dVFnMYwNPui8gXVxHCJsxsnMBwzsEoIst1yvs7rTWOketuDEGaqkBmg1qNyRg8Loh/umE75zonCMdCyHG97CSO4uEBzUoFJWRydlWurQnTC0mjsDd9R/lKNMYR/JwtEVgLAUlGipwVbYFgKI709XG2AEpcvgL4HF0dP115Mq1u5u8s4qBFMMVnV9gSW7cPXjM5toQ8NuJK5P7R5YVuhxL2PlQPifsDwLPHzMvxysawmRnxDaZthRwlqwNGPdQMAdSe+NEFMZPjwuNuK+8Oe4YFYDiqpmjWiyHvMzC8vyO/X+0vuHie9mvut3ux0YVhlN+ZTZhmR3R7hvx0Sp3VMzSwygpOk5ReoD+5o4Ha3lySGNGFqmTK6f45YLC4iivpJp5gyDzraWXC/E3Bg3xb4o7gIu/baake9IxSS60mWtiovheMVZmwZDqyG/Kbdkg4P/NYgjhsDdGRdO21bkd35i/bKxZjp3lX5bqqAKu+1aTR7sAXitXJj2pZNhEEBl/myzBUrBVAn7ZR4O3F9YdPJiMIdREFND+Dqs6N0KWrHpRM8P+d8/9k50T2SB+1L4KNQt7Ue5LK1zUXs5jtgPQFc2f4m7NXN46ByddfmX709l7WrTKqKDFMkPm6btnX8crlRwP/hNQ3UXZjRSM9Bt0TOwopJpYYWszSc9e68ZkyA1FAZtKJ41OXNhgHv+pbNDvT2n69n67VTZR4bKAFRRNvZWKFdk5DzLv4PtEaIQBAqG3HGPr9BlSxPYWHS3yDxlBp9Y3Uhcm+B2LZpXgLFluAEwAPPcZiw0UAcwrvoHxSdJUf5KDVPkbrBxn/L/keoKuftivBsxFAHbBPsShrwjmZWgkf7aSLXuvDVhmJXLm1urKAG5SUhfxv1c556KSxzeipRUj6XV91bXh46APh49cIKYMAWCA/DQ3vlK3P9tH7muImVBpCbRSv0UHaC1nzWTDB1uXFdliWAYxSR2v8gOrFe3NfXcZTPnLRNe1ixCPeKfw/GudJelz5JlQ5NcjvYEmA+sRb8M0YIaipF59kuQBOt9h+pWQ8RRQTj6/NGGt+YTtt/RffzrulhAkuavZiXwxOqEqnA7cR9FVSrUIaUY5Zd3P78nNTrjvAuFIO+wiScIP2oC4vTwmZ4MraldMzC1dCRTTgwW4s/m4/ovl2G848iynBrScEQd3UD+5twVQmxByWcTLIoO9zHai7EU+W5YAd6WNngqx6X1Z1U05+sLC/7tvWj/IpGoNJIhee2dE9238IYS2p1o/6Ny+P3thfvNYcmBAOvOiHCNYQ4aNKgMJeL1eh4SURzOEEoe1H/eK6PMk6ALI4y3aqPCz2eU+3+Ge7WAlQKUWe+t5nI7MIbFqLiSRGp6dLN/QMvQDg11GsZJpunwYF+QesMA1kkOGq2bwufOeW5MmtdaRL6RIlVs9nHQFOuQ9gM6XTuqqcafZMW04VXGVM5A5X6YXXvknAwhnCVB6BnMC1G+fUrsKt3Q4mittZIFPAOVzQYZthePrpa+8ajIKqKTNDoLm8NgRCokzG7OTVl0o3CW2gtB53LSTqCG2ZdgFUp2rRlONKKuCAguRsLoEE2HrZqcJkLvJwxDxpzAu5dfq7tFNDfgGFOlWlFWWNMuF2lI7youXias3ZRooIri6q3KYlNDzGn2McDveIMjIlA/GU+Y2i1T//WCDUdrC3itFhxgPukTl8jYFujq57+YdGKpaB3hXB7r/dmJQkrXBqzOPbG38NO13uhEuBaau5SUwmqWzRGqhHaEmjn7qCXVMvJ4FfVyP1zbejljqEMZadcpAUZgKXV2mYRRJUfQoTapF2ei2FlQDf3Y0h2rV+lZhO0IDxre1DonC/tfbO/pp2QEiiv8ggE7i5iFZc3LtduPI4JaKgDos586a7AymOpCjnnrKO7JZ0+QL6G/V06+TJcxhDPrpLabQwuODUOgkW/JFzUx82Ur8FPJYgof7pue13N5O4NqOqx3V7EvpQQVrNpbaoTUPDbAygl7PrhEKD6c1r5wCSISYJmo28ILRVWSnByU9ooTDd1jepdbnw4EZvOX5gH2NqkKZu6fPawPsi8W/0bMkiUCQbjtptBF7qWq2/7vqyvpbJXkWM6s2348NnQ5kfcQwHq5/H0b0vdxiqqeXKTL9Fg1BpWL/GNAdMqb7MoHLgyS9gPGBAC/4CfppyOcbuqoOqy01ff9OwScYSKYPv55X2yBX1r9t9HerJLSysQ3QYPt4tjG5QO/Jaj/VkkrqnXqePk6SZteVmQjlE5ooT7kcV/5i/HyG55a7G5wEn9oJVZs7cV0kH7qLncrlgBBfDkEzt5CS2wUYPU3MyeZuYNz1BzlndNxI6K8mIngb/KUGfN7zk9/zw/4tQRbmWyAetcAtCsYpZHu9e0J/EBkLquD0apKkNxH+eAXrLiy9DAbcUMKbweyoCSoPOwH0oo69rl+Y0Sf5isd0QB1AvHah9oeN0AVa2iXSBUgEqQwSnya3gFgGIhaT2ln+eBPPLxlHp5WFKCHGCEn5PAg09KEEs/pJpD6p5lELocdvBSU0NdN/i45xMdFJvx9PCyhCK7TPP2Di0pRuR2iPhsRoBDFAr13RgoIQIwU4lmF0myn/sVNvEbhQmhaBRnMo5fU05X2CWI8sbxwt6+9iGmoz7/LzpU2qbXK+PuXRUlzznrf6bCaW8VRTQEtn7N0sqV3jMVfkqZbgGmZ0I42BSi9d1yhlOTlKG7UL59zKN7EG9ReMo8Y0+vF42141mDu2j5GlzoGTwdHP3PhjJ+ipfYcj/XBEfx8NOxrHK96WnInSrZ4STiAjYwfeLH4FiCWSbjplnhNlXRyvuQB2vkDpRFhW3ylaXkkjvnn111Ss2+8JE8MMPbqat09lAs8IFMN6/yhdp+tENXAN/dMkZ70kGt7c3WpMT3Y1yo3RZ5FAPE7rFSya92eUKucDsyvFN3hwsQQCcSl8cKDU/MnwCNhwBHmOm2UpirBl3Yqpgyx+WYy+o7WIepmSRx7/jzMAs1tf2DZg0W4E2OztAaRix0PDa6j5PW2WgWqv6WJRjtlokcP4NL7cja9hC0zaP+NQ76y6lmCFzMMIx6A8UMyQs8Zeo+rFcy3x6JNEq6/aw/gT4ox8SGjuNHA32oPQjfxNvugg75dSpF2WQ7dPdeE/swliECDR1RMWn70/NcVr2MIDbTZyuHW+Nm4nJ64ERZYxTKsc53uS/61nXM8AycdhChS2mItzzUHeRElNW9fVJl2IlhHeYvkmxpRGDV3JjOnD7ReUuuPnpR6Fg1FQb0g2anbx4G8k0GQl3oOScaqsYkfHpki2ooCp0YZLltj2+sm/f0M0I8IyEvpfFvIcziizKIn1TkIlw1bj+5LdPaBkCtYLwcuh9qEdfVy6SsoLRx6EdsfzJcvNsHXktoFd7NFSo/FqXW/clMXJh5/xbZg7Ee1JL20Z5WdvviO53v75kK005xqNILiP+ee/bbYJlBxMv1uqxltTfALC9d4z8FnQ57up0yyuYJSmqt92VlAhWjF9rxmIlUAQL3xdgxzWsjRzouafB2Feprm4vdHnTe2kRM2LQSRVgi3OyFAsjYlUWF3IcfoVrh8jKv5T7l+IGMZocEWXA+8gAQW8PjHILd5oelfOUxDMfcLlVlwyNlI49iAPYYVYyheyf8hu+ghZIGI7bBiYs7z0Y/QNhlk3X/FcXdBwb1TBriszMRaYjCOGpCSbEKfBq8soLzZj5bBkU012OroLIG2YUetdrVCgSm3JUGaRf5Y9C3W+CsITBBkiXHWPh425pWaJOYYUart0OOHHrksDgJ5YWRSGgu9XDcNiP65tCnH9IAh9z293gbp5OBOxyGBDHw7InKINA3QJt7f1h5OUvG557tEtnA8O94RysViqeyJREQ1PHjffz5PNbDqE418eahNA20tgMMWCUY3aGJVz0OotksRjJawmxAEhYniJBgmPYSui4f2AiP9DPvJs8zP5x0ecyBAcXYlKafPxYIbiG+QqKIgNjeqSuQdH0jZJyfkV0N8xnL3E7Nurxo9y0Aw9d327joNIeSUbcAczF0QrsqABQl928PCEPAhEiJRlV8LD98rLxC77qjekoAUn53SFI90Kvueuiy6iQBJDrs7U48Pu39XYFR9Iwf7ANV5e/YIGUeG70uNBfiANqfMZdxzISEXcP0aBk0s2jf1Lqceq6GBEMe3KfHzrtwV0A4ThDWIdn6REJ/paljIH0tZ1Js7+C8thRT+3O6BFQpKYzWv/295WO5vjkHne83GD2nSx+0EufXB0gdDwtGqolteTxOpfv2wdrJ1T3QCfdKJEP85iY9sPzlJMiftzdUqQ7dTlqZJ2TRr1KdXU4c4xh23J6zi26mBwcvzCa2TXKYbdj25Cnx+u2iBZnq7amG48k9BQNOEBHtsAtzR56vkOyBsFEttp/YLUctbPE8bFqP21l+dBZWIwelstmAXY9SUDcSukSjVAvFClny8OOtSdmna+3ehqK1uwjLy8sRqyutAf1lhvUzz5D2Z9nSxd7zVw23+StsxIzxRVi363lEpUQ10IjEGx3Hz9FpBpDnxa0qqTsfU07eGrBWPJK7rHwB5DJHE7kXo0l+0IxwGhucF3i4K7sNcOBMishd2bDzdoqAs0I8yQCSzgPxHRpDD/asn1mxH78WpVrUSB3CY16m7uIb7UcMg3P/KbudTuXJYEuvsXmslWriVBoblrTNkzdN+A4LAbQN6Hkyfi07B9YsuLgJJfg6pnAFtKm+IBRPuKdTPWAOf5bJ8K7cw/5kgQ4zq2KWuBf419qXLMrNY3svMEasMhObv/4p0K9vwAq6vrBrvACbzYhte9A8L31jlsL4YauoNe0qM1R/YceAXXPzGJS1jpM5LwEKww1fIIzFBXZOT4XxoJR60lfzgXqsL1CFzXp+aSkbx65y2pbdbkDvgrJECgCulgzQjttXDXZpS/lxfnepRcNSxahHrsZyvpz1hEc7zF82ZxlOLNef7ek/t/VVS9bqbj3DoJd71ad8tYwN05pPdHMxK60JP+w1bYZXbuIRZoxxvzuNJyor7jO0lS3BvMs17rJD+aqUMXlS8y4LzIh6dlf/fA8bkRFQJVoduwZh5o1fVajyXnbqnkor/7Tq4IzF5Nus5baeipp3LdtTWS8RLD+bbGNmtIj3dNw4cNrXTqOoeC/IyTeT3/4k0ci5ZQkY2xwcWrDQwWEkrugaP4qIZoWRRCJ2QzHV5Lbxk//ghqz7ggBKkA1m4OWs0D2bLpNs/BXm98S+/cMnTVMS22xp9+O99u8THVy2a6shP6HZlzkgdj+5nrfx7W+apP/ZpY+BXnasVrSx7WUrLMmOVG8TRk+4HhigJANj+R+zVB53kp/UPIOIM133c1MoI8PH13lGwF5WIHLvGB3363R3pCtSHxDdDvrM9MyvorZyadaTyuDG941P//Facg5iUAFrQZVZIkSv8p4ryHbelRm0NlaQ0wQo8mzN4yypIplVrrrDhD+XzyGwpHPBfdjT4jAJQVcha821oEftwivToIMUd5nxxleT2Ab79oxFDYB84coEUDOzZ4aezkcjdNueFAgLgJBQ5PRPjWQxF2LobvvHoEMbdWVK7bpvE+2NFY8IssFueiRU5XiJVY5rsIn7OMAUpDF+1zzs73uoJS07CoFRJfrnnV2PXwjIi+QGw7rS1mrOXGYkcsuc3+AYnRo22tJSfqkhHNSmLYIDlIBy4kLqVZOq9kevSd/ivWvgjscKjoJvlTFwtYETHj+aXHnHLVTi2Df/sJdZ5Ag6lVYA1XS1XNjo+2k23VHajfcouLhgFQmG/pHxqHBU+vjU+ZYXbWJerGrtLqa3/FCaprTMemxlw9waPsDFGOPN2745SiMa8FYLavATytL90GkGsgjXTMfwQ3XgsvR3tdHOl2h0NhY5gqvsciBjbMgPHRA+I6G1QW5VSmJI1SWr85aYhMHfY2p7LuNjBGV5hU6DdafOxq4DOCbOy05bssmh72nhUpVBJ1xuynRO5iqMOC8/WgDGBFv0hZw8L92scSXzLDUkb3WgH4SmBDQKV9OtQ2G68a9gqojSd9Dha04VrUalbufJzjNLjoloKR81XrmWPbLkdjxVkGhyrKLAZ9w6rUk0m3AMUtOcbWv7pX5WHT3rGSZSkGLRBnjekHjblsrAllHKqxWfdQEBCzjQ2nBvpOMankyS8TaSP5AtTGwX8xQkrRrFhnCzh5x6fG3D5Ud1bK9UxzA1Q6jf9UgXydXpOUmrGiTex94RaxcvVJpLCyRtt1lA8l0JvqzVFXrXRCd/SnS9g2C8f6RwktGYXLK4j+RCNmuuNGC9cJcAM++qmU0hR1n4lCBuX8V8nM+HNUOfglcIQfNjxhQ01NxqTEgoAlpqFToaARVUoadKULTSwNS8nYAqzpkJnOn5D4KqcwnQiRMUszwlO7xdeMwb7x9SsiaCMejvDvLy6RXTuz0k+2HU1uzYx51JgavmclpNA8u0+LYJmW1zbmRQzOON23OlcRspFeasvsolIlPPZ39G+Z043YEuJe0Mh3WecNI+9aIrYmVz6SuYnAQQcKJXA7LNYLUayVHttclKy4a9QAyALNu+qswX82DRqLPgEQsyKJqCpKSOZCrC85ly+mluuD1F4Nx1Id6NCzhs3Aav1fjWkzrwwt+mHU/dRh6AhoSMhMP8RLglsssQHiSOdHbtGT8Ix21y/xgSYdCcWQCkDgNCvsYDLnLgrAdIoXgZiKfEqzIxNmt03so3JaJxf6/ew74klNQYPn2KxmDg3vmsfdw2pasIs1kPXMD1Bj353LYd95cs8rt0OlJGebK4Zv/NSn/aN8BEPUQhdMUpFHIPqobwd4ka3C6Okeav8tu4ffdvtCE/kjj7jov1OuHno/gRAbcrSg3A+5Ej2geA9NvPUPrh/1U6WvqllGIj0s3oq3bfXRVUm0z0yMta4mB55XjyGpoOeYHpGq/cBiST33LBu2UzjpLsKiNlqzCGa2Jl287YrXWhaPwx1Z9KFZ4LuG0IdQ6PmMIohOlKqaEM+3t7GIcV7qWxb0XdTWPQ7IcFgwXt6UBn1uTqJQCQUA/1NUQj7XOpAXbp9y0AVaySz/zUvVwH6ETGGHEbvBjKhFKsjfCDE05ZEahNqmEaAVw2TrtshBCXC0aobIZnpIqaaoAxS9HMHyoF6N1hy8V1Pt/UjWejthdyOpIlY27QZIQR2jiPKfA8dDAyT4peho+4QE5bqmG/Z3FqdhmLTjQgfhYhdTfPnvpmHIqVEVtMgydOCcBrGjT2pK9S3CgDrWmTAynQz65HG3VZM4HT8eQyDetpjgYIwOSt5DlrW4LoONTQbCri4QER9jb/HlnRDQRGSelYuUKZ4DfLo/vyc3m29V9F2R7AFPXmjTljzX3W8LZENxm1tpsrI1y6o2C1WAZMQ0NRjo29YqCEeMzn05HySGkabQZueCqLHlM0qgIYmETLa+PHyrk70Sk6MOD1aZTyNsHP7KLT7USIL08vK/zyPCwc57o8AS5TKWMzs3aVLQVU/x3zYaLv1JHbXFyc1So+XHXRjppB5LlGfKTJYDUPxLGGUGVbVIhvMEN2XPhpGr2qV1gJ9T8a+ZQFi2qnwQynAf27xtl1EXL9DEwerTJBH2BHo24xGqHJUx0kVs9z4vXcbZTaSOWcOE2aLa/4OvmbSLjiGHO7BZdif7kmL4ALmxOZf1GNzQ9VF8crtSTPTFXWCLlwTNecMGvDzIcfYhT3Nzu5/iw9kF3qNnY9uwH4U/ZTMs9mApI5XXrWuGin1e5K6LHVIq71yQ4nm75wWyJBrwd8oKiHMI6rDpSxUjxsZNOB1MzjqrflnbukKfZts0RMMNR0nBXe3DgrBeb5kW3fI4nzzSvwMhXuyBNGxA5sCwlF1s1voLCZYLFbAXa/AVoewzjr+ATr7VQX0AI9e+ULFVphIzFrd213fBVzu+vZOTy9CYHhqWdnrVlPUelVtqElnQhj0e98xr36fjuYbkvlysrr+rufxaY4MdZ//cf/AZw+q6E= _r. uncommand _b,_r
#@gui Vector Painting : fx_vector_painting, fx_vector_painting_preview(1)
#@gui : Details = float(9,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.\nLatest Update: <i>2015/25/08</i>.</small>")
fx_vector_painting :
repeat $! l[$>]
+luminance b. {10-$1}%,1,1
f. "dmax = -1; nmax = 0;
for (n = 0, ++n<=8,
p = arg(n,-1,0,1,-1,1,-1,0,1);
q = arg(n,-1,-1,-1,0,0,1,1,1);
d = (j(p,q,0,0,0,1) - i)^2;
if (d>dmax,dmax = d; nmax = n,nmax)
)"
blend shapeaverage
endl done
fx_vector_painting_preview :
gui_split_preview "fx_vector_painting $*",${-3--1}
#@gui Warhol : warhol, warhol(1)
#@gui : X-Tiles = int(3,1,10)
#@gui : Y-Tiles = int(3,1,10)
#@gui : Smoothness = float(2,0,10)
#@gui : Color = float(40,0,60)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Watercolor : fx_watercolor, fx_watercolor_preview(1)
#@gui : sep = separator(), note = note("General settings:")
#@gui : Color Intensity = float(1.8,0,4)
#@gui : Light Colors = float(0.1,0,1)
#@gui : Dark Colors = float(1,0,10)
#@gui : sep = separator(), note = note("Line art settings:")
#@gui : Line Art Details = float (80,50,100)
#@gui : Line Art Smoothness = float(0,0,10)
#@gui : Line Art Strength = float(0.5,0,1)
#@gui : Line Art Style = choice("pencil","ink","comic style")
#@gui : Line Art Fade = float(0,0,100)
#@gui : sep = separator(), note = note("Color brushes settings:")
#@gui : Brush Style = choice("modern","classic","abstract","line","smooth")
#@gui : Cyan Brush Size = float(2,0,50)
#@gui : Cyan Stroke Strength = float(0,-5,5)
#@gui : Cyan Edge Distance = float(2,0,10)
#@gui : Cyan Abstraction = float(4,0,10)
#@gui : Magenta Brush Size = float(2,0,50)
#@gui : Magenta Stroke Strength = float(0,-5,5)
#@gui : Magenta Edge Distance = float(3,0,10)
#@gui : Magenta Abstraction = float(3,0,10)
#@gui : Yellow Brush Size = float(2,0,50)
#@gui : Yellow Stroke Strength = float(0,-5,5)
#@gui : Yellow Edge Distance = float(4,0,10)
#@gui : Yellow Abstraction = float(2,0,10)
#@gui : sep = separator(), note = note("Paper and ambience settings:")
#@gui : Paper Color Black = bool(0)
#@gui : Add Paper Texture = bool(0)
#@gui : Invert Colors = bool(0)
#@gui : Ambient Light = float(0,-50,50)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors : <i>Tom Keil and Arto Huotari </i>       Latest update: <i>2011/19/02</i>.</small>")
#@gui : note = link("Tutorial download","http://www.slideshare.net/ArtoHuotari/gmig-water-color-filter-tutorial")
#@gui : note = link("Video demonstration here","http://vimeo.com/19713850")
fx_watercolor :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$7==0} --fx_gradient_norm $5,0.5,{99.99-$4},$4,1,0
-elif {$7==1} --fx_edges {$5/3.5},{95-$4},0,0
-elif {$7==2} --fx_edges {$5/3.5},{95-$4},0,0
--fx_mix_hsv[0] 1,0,0,1,-1,0,1,0,0,0,2,0
-tk_fx_channel_processing[2] 1,1,0,{$5/10},4,{{$4-50}*2},100,256,0,0,0,2,7,0
-reverse[1,2] -fx_compose_multiply[1,2] {0.5+{$6/2}}
-endif -fx_frame_round[1] 5,$8,15,0,255,255,255,255,0,0.1,3
-fx_smooth_anisotropic[0]
60,0.16,{{20/50}+0.6},{{20/9}+0.6},2.35,0.8,30,2,0,1,1,0,1
[0] --negate[0] -move[1] 4
-fx_gaussian_blur[2] {{w+h}/100},0,0,1,0,0,0
-fx_compose_dodge[1,2] 1
-fx_mix_lab[0] 1,0,0,$1,0,0,$1,0,0,0,2,0
-reverse[0,1]
-fx_compose_colorburn[0,1] $2
--luminance[0] -reverse[1,2]
-tk_fx_channel_processing[1] 1,1,0,0,4,{$3*5},100,256,0,0,0,2,0,0
-fx_gaussian_blur[1] $3,0,0,1,0,0,0
-tk_fx_channel_processing[1] 1,1,0,0,4,0,99,256,0,1,0,2,0,0
-tk_fx_replace_color[1] 1,0,255,255,255,255,0,0,0,0
-fx_spread[1] {$3*2},{$3*2},0,0
-fx_gaussian_blur[1] {{w+h}/1000},0,0,1,0,0,0
-reverse[0,1] -fx_compose_multiply[0,1] 1
-split[0] c
-if {$9==0} --negate[0] --negate[1] --negate[2]
-elif {$9==1} --fill_color[0] 255,255,255 --fill_color[0] 255,255,255
--fill_color[0] 255,255,255
-elif {$9==2} --fill_color[0] 255,255,255 --fill_color[0] 255,255,255
--fill_color[0] 255,255,255
-elif {$9==3} --fx_edges[0] {$10/5},{$13*5},1,0
--fx_edges[1] {$14/5},{$17*5},1,0 --fx_edges[2] {$18/5},{$21*5},1,0
-elif {$9==4} --negate[0] --negate[1] --negate[2] -endif
-tk_fx_channel_processing[0] 1,{{$11/5}+1},{$11/50},0,0,0,100,256,0,0,0,2,0,0
-if {$9!=2}
-fx_gaussian_blur[0] $10,0,0,1,0,0,0
-else -cubism[0] 300,{$13*5},{$13*36},1,{$10/50} -endif
-if {$9==0}
-tk_fx_channel_processing[-3] 1,{{$11/5}+1},{$11/50},0,0,0,100,256,0,0,0,2,0,0
-cubism[-3] 300,{$13*5},{$13*36},1,{$10/50} -endif
-if {$9==4}
-tk_fx_channel_processing[-3] 1,{{$11/5}+1},{$11/50},0,0,0,100,256,0,0,0,2,0,0
-fx_painting[-3] $13,1.5,2 -endif
-fx_frame_fuzzy[-3] {$12*5},{$12*5},{$13*20},{$10/2},0,0,0,255
-tk_fx_channel_processing[1] 1,{{$15/5}+1},{$15/50},0,0,0,100,256,0,0,0,2,0,0
-if {$9!=2}
-fx_gaussian_blur[1] $14,0,0,1,0,0,0
-else -cubism[1] 300,{$17*5},{$17*36},1,{$14/50} -endif
-if {$9==0}
-tk_fx_channel_processing[-2] 1,{{$15/5}+1},{$15/50},0,0,0,100,256,0,0,0,2,0,0
-cubism[-2] 300,{$17*5},{$17*36},1,{$14/50} -endif
-if {$9==4}
-tk_fx_channel_processing[-2] 1,{{$15/5}+1},{$15/50},0,0,0,100,256,0,0,0,2,0,0
-fx_painting[-2] $17,1.5,2 -endif
-fx_frame_fuzzy[-2] {$16*5},{$16*5},{$17*20},{$14/2},0,0,0,255
-tk_fx_channel_processing[2] 1,{{$19/5}+1},{$19/50},0,0,0,100,256,0,0,0,2,0,0
-if {$9!=2}
-fx_gaussian_blur[2] $18,0,0,1,0,0,0
-else -cubism[2] 300,{$21*5},{$21*36},1,{$18/50} -endif
-if {$9==0}
-tk_fx_channel_processing[-1] 1,{{$19/5}+1},{$19/50},0,0,0,100,256,0,0,0,2,0,0
-cubism[-1] 300,{$21*5},{$21*36},1,{$18/50} -endif
-if {$9==4}
-tk_fx_channel_processing[-1] 1,{{$19/5}+1},{$19/50},0,0,0,100,256,0,0,0,2,0,0
-fx_painting[-1] $21,1.5,2  -endif
-fx_frame_fuzzy[-1] {$20*5},{$20*5},{$21*20},{$18/2},0,0,0,255
-to_gray[-1] -to_gray[-2] -to_gray[-3] -to_rgba[0] -to_rgba[1] -to_rgba[2]
-split[0] c -reverse[3,-3] -compose_multiply[3,-3] -append[0,1,2,3] c
-split[1] c -reverse[4,-2] -compose_multiply[4,-2] -append[1,2,3,4] c
-split[2] c -reverse[5,-1] -compose_multiply[5,-1] -append[2,3,4,5] c
-if {$22==0} --fill_color[0] 255,255,255 -else --fill_color[0] 0 -endif
-reverse[0,-1]  -compose_rgba[0,-1]
-if {$22==0} --fill_color[1] 255,255,255 -else --fill_color[1] 0 -endif
-reverse[1,-1] -compose_rgba[1,-1]
-if {$22==0} --fill_color[2] 255,255,255 -else --fill_color[2] 0 -endif
-reverse[2,-1] -compose_rgba[2,-1]
-to_gray[0] -to_gray[1] -to_gray[2] -append[0,1,2] c
-if {$23==1} -fx_paper 0,0 -endif
-if {$24==1} -negate[0] -endif
-fx_mix_lab 1,$25,0,1,0,0,1,0,0,0,2,0
-reverse[0,1] -fx_compose_multiply[0,1] $6
-endl -a c -endl -done
fx_watercolor_preview :
-gui_split_preview "-fx_watercolor ${1--2}",$-1
#@gui Whirl Drawing : fx_draw_whirl, fx_draw_whirl_preview(0)
#@gui : Amplitude = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_draw_whirl :
repeat $! l[$>] split_opacity draw_whirl[0] $* a c endl done
fx_draw_whirl_preview :
gui_split_preview "fx_draw_whirl $*",${-3--1}
#@gui _
#@gui <b>Black &amp; White</b>
#@gui B&amp;W Stencil : fx_stencilbw, fx_stencilbw_preview(0)
#@gui : Threshold = float(10,0,30)
#@gui : Smoothness = float(10,0,30)
#@gui : Hue = float(0,0,360)
#@gui : Saturation = float(0,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_stencilbw :
stencilbw $1,$2
if {$3||$4} repeat $! l[$>] split_opacity
/[0] 255 i[0] 100%,100%,1,1,$4 i[0] 100%,100%,1,1,$3 a[0-2] c hsv2rgb[0]
a c endl done fi
fx_stencilbw_preview :
gui_split_preview "fx_stencilbw $*",${-3--1}
#@gui Black &amp; White : fx_blackandwhite, fx_blackandwhite_preview(1)+
#@gui : Red Level = float(0.299,0,1)
#@gui : Red Smoothness = float(0,0,10)
#@gui : Green Level = float(0.587,0,1)
#@gui : Green Smoothness = float(0,0,10)
#@gui : Blue Level = float(0.114,0,1)
#@gui : Blue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator()
#@gui : Grain (Shadows) = float(0,0,200)
#@gui : Grain (Midtones) = float(0,0,200)
#@gui : Grain (Highlights) = float(0,0,200)
#@gui : Grain Tone Fading = float(2,0,10)
#@gui : Grain Scale = float(0,0,3)
#@gui : Grain Type = choice("Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui : sep = separator()
#@gui : Local Contrast = float(0,0,60)
#@gui : Radius = int(16,1,512)
#@gui : Contrast Smoothness = float(4,0,10)
#@gui : sep = separator()
#@gui : Pseudo-Gray Dithering = int(0,0,5)
#@gui : Use Maximum Tones = bool(false)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/20/02</i>.</small>")
fx_blackandwhite :
repeat $!
l. split_opacity rv to_rgb. s. c
*... $1 b... $2%
*.. $3 b.. $4%
*. $5 b. $6%
+[-3--1] /. {$1+$3+$5} c. 0,255
adjust_colors ${7-11},0,255
if {$12||$13||$14}
100%,100% [-1]x2
noise... 100,$17 b... $16% n... -$12,$12
noise.. 100,$17 b.. $16% n.. -$13,$13
noise. 100,$17 b. $16% n. -$14,$14
+tones[-4] 3 b[-3--1] $15%
*[-6,-3] *[-4,-2] *[-2,-1]
+[-4--1] c. 0,255
fi
rv a c endl mv. 0 done
if $18 normalize_local $18,$19,$20,2%,1,0,255 fi
if $22 n 0,255 fi
if $21 to_pseudogray $21,1 fi
fx_blackandwhite_preview :
gui_split_preview "fx_blackandwhite $*",${-3--1}
#@gui Charcoal : fx_charcoal, fx_charcoal_preview(0)
#@gui : Granularity = int(65,0,800)
#@gui : Lowlights Crossover Point = int(70,0,255)
#@gui : Highlights Crossover Point = int(170,0,255)
#@gui : Boost Contrast = bool(0)
#@gui : Resize Image for Optimum Effect = bool(1)
#@gui : Add Chalk Highlights = bool(0)
#@gui : Minimal Highlights = int(50,0,255)
#@gui : Maximal Highlights = int(70,0,255)
#@gui : Background Color = color(255,255,255)
#@gui : Foreground Color = color(0,0,0)
#@gui : Invert Background / Foreground = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/17/03</i>.</small>")
#@gui : note = note("<small>Inspired from the Charcoal script by <i>micomicon</i> :</small>")
#@gui : url = link("http://registry.gimp.org/node/25078")
fx_charcoal :
repeat $! l[$>] split_opacity l[0]
compose_channels max
w={w} h={h}
if $5 r. 150%,150%,1,1,6 fi
if $4 equalize. n. 0,255 fi
sharpen {$1*3} cut 0,255
if $6 +ir $7,$8 fi
ir[0] $2,$3
if {!$15} ==[0] 0 fi
-|
+*[0] $10 +*[0] $11 *[0] $9
a[-3--1] c replace_color 0,0,0,0,0,$12,$13,$14
r $w,$h,1,100%,2
endl a c endl done
fx_charcoal_preview :
gui_split_preview "fx_charcoal $*",${-3--1}
#@gui Colorize [Interactive] : fx_colorize_interactive, fx_colorize_interactive_preview
#@gui : Input Type = _choice("B&amp;W Photograph","Lineart")
#@gui : Output Type = _choice{"Colorized Image (1 Layer)","Colors Only (1 Layer)","Image + Colors (2 Layers)","Image + Colors (Multi-Layers)"}
#@gui : View Resolution = _choice{1,"Small (Faster)","Medium","High (Slower)","Very High (Even Slower)"}
#@gui : 1st Additional Palette (.gpl) = _filein()
#@gui : 2nd Additional Palette (.gpl) = _filein()
#@gui : Image to Grab Color from (.png) = _filein()
#@gui : sep = separator()
#@gui : note = note{"<small><b>Description:</b>\n
#@gui : This filter allows to quickly colorize a B&amp;W image or lineart.
#@gui : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the G'MIC interactive window and start adding color control points.
#@gui : When you're done, exit the interactive window: your colored result will be transferred back to the host software.\n\n
#@gui : If you are not satisfied with the result, <i>Undo it (CTRL+Z)</i>, and click on <i>Apply</i> once again to modify your control points defined previously.
#@gui : To clear all control points, click on the <i>Reset</i> button above.
#@gui : </small>"}
#@gui : Clear Control Points = button(0.5)
#@gui : Last Image Size = value(0,0)
#@gui : Control Points = value(-1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive window to manage your colorization :\n\n
#@gui : - <b>Left mouse button</b> creates a new color control point (or move an existing one).\n
#@gui : - <b>Right mouse button</b> or key <b>X</b> over a control point deletes it.\n
#@gui : - <b>Right mouse button</b> or key <b>P</b> anywhere else picks a color from the image.\n
#@gui : - <b>Mouse wheel</b>, or keys <b>CTRL+arrows up/down</b> zoom view in/out.\n
#@gui : - <b>CTRL+mouse wheel</b>, <b>SHIFT+wheel</b> or arrow keys move image in zoomed view.\n
#@gui : - Key <b>SPACE</b> updates the extrapolated color field.\n
#@gui : - Key <b>TAB</b> toggles markers view modes.\n
#@gui : - Key <b>BACKSPACE</b> deletes the last control point added.\n
#@gui : - Key <b>PAGE UP</b> increases image contrast.\n
#@gui : - Key <b>PAGE DOWN</b> decreases image contrast.\n
#@gui : - Key <b>R</b> enters/exits color replace mode.\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> resets window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>You can find more information on how to use this filter here :</small>")
#@gui : url = link("David Revoy's G'MIC Colorization Page","http://www.davidrevoy.com/article240/gmic-line-art-colorization")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/12/07</i>.</small>")
fx_colorize_interactive : skip "${4=},${5=},${6=}"
N=$! nm={n}
resolution={arg(1+$3,512,1024,2048,0)}
nm "[G"{`39`}"MIC] Colorize"
if {$9==-1" || "$8!=w" || "$9!=h} _gui_control_points= else _gui_control_points=${10--1} fi
N=$!
arg_palette1=0 l[] 0 nm. "$4" ext={x} rm if {same(['$ext'],'gpl',-1,0)} input_gpl "$4" arg_palette1=1 fi onfail rm endl if $arg_palette1 arg_palette1=[{$!-1}] fi
arg_palette2=0 l[] 0 nm. "$5" ext={x} rm if {same(['$ext'],'gpl',-1,0)} input_gpl "$5" arg_palette2=1 fi onfail rm endl if $arg_palette2 arg_palette2=[{$!-1}] fi
arg_grabber=0 l[] 0 nm. "$6" ext={x} rm i "$6" to_rgb arg_grabber=1 onfail rm endl if $arg_grabber arg_grabber=[{$!-1}] fi
repeat $N
status=${x_colorize[$>]\ $1,$resolution,$2,$arg_palette1,$arg_palette2,$arg_grabber}
done
k[0-{$N-1}]
if {$2==1} repeat $! l[$<]
channels {s-3},{s-1}
endl done
elif {$2>=2} repeat $! l[$<]
+channels {s-3},{s-1} channels.. 0,{0,s-4}
endl done
if {$2>=3} split_colors[1] 0,256,8 fi
fi
nm $nm
if {!narg($status)} status=-1 fi
u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{"$6"\}\{0\}\{{w},{h}\}\{$status\}
fx_colorize_interactive_preview : skip "${4=},${5=},${6=}"
if $7
gui_print_preview "No preview\n  available",,"(Control points cleared)"
u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{"$6"\}\{0\}\{{w},{h}\}\{-1\}
else gui_no_preview ,
fi
#@gui Colorize [Photographs] : fx_recolorize, fx_recolorize_preview(1)
#@gui : Smoothness = int(2,0,6)
#@gui : Anisotropy = float(0.2,0,1)
#@gui : Output Mode = choice("Merge Brightness / Colors","Split Brightness / Colors")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter needs two layers to work properly. The bottom layer must be a B&amp;W image, while the
#@gui : top layer contains color patches that will be extrapolated in a smart way (edge-directed) to fill the entire image. At the end,
#@gui : you get a completely recolored image.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/16/01</i>.</small>")
fx_recolorize :
repeat {int($!/2)}
if $3 s=$>,{$>+1} else s={2*$>},{2*$>+1} fi
l[$s] rv[0,1]
channels[0] 0 to_rgb..
to_rgba. split_opacity. !=. 0
srgb2rgb[-3,-2] rgb2lab8[-3,-2] channels... 0 channels.. 1,2
+.. 1 *.. . +gradient_norm... *. -1 watershed... . rm. -.. 1
+diffusiontensors... $2,1,0.5,0.5 ==.. 0 *. .. rm..
smooth.. .,{$1*80},0.8,60 rm.
a[-2,-1] c lab82rgb. rgb2srgb.
if $3 rgb2hsv. s. c i[2] 100%,100%,1,1,1 i[3] 100%,100%,1,2,0 a[0-2] c a[^0] c hsv2rgb rv fi
endl
done
fx_recolorize_preview :
fx_recolorize $* a x
#@gui Colorize [with Colormap] : fx_bwrecolorize, fx_bwrecolorize_preview
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Normalize Input = bool(0)
#@gui : sep = separator()
#@gui : Gradient Preset = choice("User-Defined","Black to White","White to Black","Sepia","Solarize")
#@gui : Interpolation Type = choice(1,"Nearest","Linear","Cubic","Lanczos")
#@gui : Preserve Initial Brightness = bool(0)
#@gui : sep = separator(), note = note("<small><u>User-defined gradient :</u></small>")
#@gui : Number of Tones = int(5,2,8)
#@gui : 1st Tone = color(0,0,0,255)
#@gui : 2nd Tone = color(43,25,55,255)
#@gui : 3rd Tone = color(158,137,189,255)
#@gui : 4th Tone = color(224,191,228,255)
#@gui : 5th Tone = color(255,255,255,255)
#@gui : 6th Tone = color(255,255,255,255)
#@gui : 7th Tone = color(255,255,255,255)
#@gui : 8th Tone = color(255,255,255,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_bwrecolorize :
remove_opacity
if $4 n 0,255 fi
if {$5==0}
(${9--2}) r. 4,$8,1,1,-1 permute. yzcx
elif {$5==1}
(0,255^0,255^0,255^255,255)
elif {$5==2}
(255,0^255,0^255,0^255,255)
elif {$5==3}
(0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200^255,255,255,255,255,255)
else
(0,359^1,1^1,1^255,255) r. 256,1,1,4,3 sh. 0,2 hsv2rgb. rm.
fi
if {$6==0} r. 256,1,1,4,1
elif {$6==1} r. 256,1,1,4,3
elif {$6==2} r. 256,1,1,4,5 c. 0,255
else r. 256,1,1,4,6
fi
if {$7==1} sh. 0,2 rgb2hsv. sh. 2 f. x/w hsv2rgb.. rm[-2,-1] fi
l[^-1] luminance adjust_colors ${1-3} endl map[^-1] . rm.
fx_bwrecolorize_preview :
gui_split_preview "fx_bwrecolorize ${^0}",${-3--1}
#@gui Colorize Lineart [Auto-Fill] : fx_autofill_lineart, fx_autofill_lineart_preview(0)
#@gui : Contour Threshold (%) = float(90,0,100)
#@gui : Contour Normalization = bool(1)
#@gui : Minimal Region Area = int(8,0,256)
#@gui : Tolerance to Gaps = int(0,0,10)
#@gui : Preview Type = choice("Lineart + Colors","Colors Only")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/12/11</i>.</small>")
fx_autofill_lineart :
repeat $! l[$>] nm=${-gui_layer_name}
is_alpha={s==2||s==4}
if $is_alpha sh 100% is_alpha={im<128&&iM>128} rm. fi
if $is_alpha +channels 100% negate.
else +norm fi
n. 0,255
l.
repeat {1+$4}
fact={2^-$<}
nw={0,max(1,round(w*$fact))}
nh={0,max(1,round(h*$fact))}
+r[0] $nw,$nh,1,1,2 if $2 normalize_local. , fi +>=. {min(99.5,$1)}%
if $colors
scale2x[colors] r[colors] .,1 *[colors,-1] rv[-2,-1]
fi
label_fg. 0,1 b.. 0.8 watershed. .. rm.. nm. colors
done
+area. 0,1 label_maxarea={"P=[xM,yM];i(#-2,P)-1"}
if {$3>1}
>. {$3*sqrt($3)} *[-2,-1]
b.. 0.8 watershed. ..
else
rm.
fi
rm..
N={iM}
if $N
-. 1
srand 0 {iM+1},1,1,3,">[j(-1) + u(135,225),u(0,0.7),u(0.4,0.9)]"
hsv2rgb. round. point. $label_maxarea,0,0,1,255
map.. . rm.
fi
endl
if {!$is_alpha} gui_set_layer_mode.. multiply fi
gui_set_layer_name. $nm" [colors]"
endl done
fx_autofill_lineart_preview :
repeat $! l[$>]
fx_autofill_lineart ${1-4}
if $5 k. else rv blend multiply fi
endl done
#@gui Colorize Lineart [Propagation] : fx_colorize_lineart, fx_colorize_lineart_preview(1)
#@gui : note = note("<b>Layers ordering:</b>")
#@gui : Input Layers = choice{0,"Color Spots + Lineart","Lineart + Color Spots","Color Spots + Extrapolated Colors + Lineart","Lineart + Color Spots + Extrapolated Colors"}
#@gui : Output Layers = _choice{1,"Single (Merged)","Extrapolated Colors + Lineart","Lineart + Extrapolated Colors","Color Spots + Extrapolated Colors + Lineart","Lineart + Color Spots + Extrapolated Colors"}
#@gui : Extrapolate Colors As = choice("One Layer","Two Layers","Three Layers","Four Layers","Five Layers","Six Layers","Seven Layers","Eight Layers","Nine Layers","Ten Layers","One Layer per Single Color","One Layer per Single Region")
#@gui : sep = separator()
#@gui : Smoothness = float(0.05,0,1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> You probably need to select <i>All</i> for the <i>Input layers</i> option on the left.\n
#@gui : <i>Color Spots</i> = your layer with color indications.\n
#@gui : <i>Lineart</i> = your layer with line-art (b&amp;w or transparent).\n
#@gui : <i>Extrapolated Colors</i> = the G'MIC generated layer with flat colors.\n\n
#@gui : <b>Warnings:</b>
#@gui : \n  - Do not rely too much on the preview, it is probably not accurate !
#@gui : \n  - Activate option <i>Extrapolate color as one layer per single color/region</i> only if you have <i>a lot</i> of available memory !
#@gui : </small>"}
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=7567")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>, <i>Timoth&#233;e Giet</i> and <i>David Revoy</i>.      Latest Update: <i>2013/19/06</i>.</small>")
fx_colorize_lineart :
if {$!<2} return fi
if {$1<2} selection=0,1 else selection=0,1,2 fi
l[$selection]
if {$1==0}
elif {$1==1} rv
elif {$1==2} rm[1]
elif {$1==3} rm[2] rv
fi
+to_rgba[0] split_opacity. +.. 1 !=. 0 *[-2,-1]
+norm[1] n. 0,1 +histogram. 2,0,1
if {i(0)>i(1)} *.. -1 +.. 1 fi rm.
b. $4% watershed.. . rm.
-. 1
if {$2==0} rm[0] rv blend[0,1] multiply ind=-1
elif {$2==1} rm[0] rv ind=0
elif {$2==2} rm[0] ind=1
elif {$2==3} rv[1,2] ind=1
elif {$2==4} rv[0,1] ind=2
fi
if {$3&&$ind>=0} l[$ind]
+mix_channels (65536,256,1)
if {$3==10} do
iM={1,iM}
if {$iM>=0}
+==[1] $iM area={is} replace[1] $iM,-1
+r. 100%,100%,1,3 *. [0]
rv[-2,-1] *. 255 a[-2,-1] c nm. $area
fi
while {$iM>=0} else
label.
if {$3<10} %. {$3+1} fi
repeat {iM+1} +==[1] $< area={is} +r. 100%,100%,1,[0] *. [0] rv[-2,-1] *. 255 a[-2,-1] c nm. $area done
fi
rm[0,1]
sort_list +,n
endl fi
endl
fx_colorize_lineart_preview :
fx_colorize_lineart $1,0,$3,$4
#@gui Colorize Lineart [Smart Coloring] : fx_colorize_lineart_smartcoloring, fx_colorize_lineart_smartcoloring_preview(0)
#@gui : Colorize Mode = choice("Generate Random-Colors Layer","Extrapolate Color Spots on Transparent Top Layer","Auto-Clean Bottom Color Layer")
#@gui : sep = separator(), note = note{"<small><b>Global geometry parameters:</b></small>"}
#@gui : Contour Detection (%) = float(95,0,100)
#@gui : Discard Contour Guides = bool(0)
#@gui : note = note{"<small>Add strokes with a saturated color having value 255 (e.g. pure red) on your lineart allows to guide the colorization algorithm with virtual contours.</small>"}
#@gui : Output Region Delimiters = _bool(0)
#@gui : sep = separator(), note = note{"<small><b>For <i>Random colors</i> mode only:</b></small>"}
#@gui : Make Hue Depends on Region Size = float(1,0,1)
#@gui : Maximal Color Saturation = int(24,0,255)
#@gui : Minimal Color Intensity = int(200,0,255)
#@gui : sep = separator(), note = note{"<small><b>For <i>color spots</i> mode only:</b></small>"}
#@gui : Color Shading (%) = int(0,0,100)
#@gui : sep = separator(), note = note{"<small><b>Connection parameters:</b></small>"}
#@gui : End Point Rate (%) = float(75,0,100)
#@gui : End Point Connectivity = int(2,1,5)
#@gui : Spline Max Length (px) = float(60,0,256)
#@gui : Segment Max Length (px) = float(20,0,256)
#@gui : Spline Max Angle (deg) = float(90,0,180)
#@gui : Spline Roundness = float(1,0,2)
#@gui : Minimal Region Area = float(10,0,100)
#@gui : Allow Self Intersections = bool(1)
#@gui : sep = separator(), Preview Type = choice(0,"Colored geometry","Colored regions","Colored lineart")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>, <i>S&#233;bastien Fourey</i> and <i>David Revoy</i>.      Latest Update: <i>2018/11/09</i>.</small>")
fx_colorize_lineart_smartcoloring :
_fx_colorize_lineart_smartcoloring $*,-1 round
fx_colorize_lineart_smartcoloring_preview :
if {$1==1" && "$!<2} gui_warning_preview "A top layer with color spots is missing, for this colorization mode." return
elif {$1==2" && "$!<2} gui_warning_preview "A bottom color layer is missing, for this colorization mode." return
fi
_fx_colorize_lineart_smartcoloring ${1-3},0,${5--1}
_fx_colorize_lineart_smartcoloring :
if {$1==1" && "$!<2} error "A top layer with color strokes is missing, for this colorization mode."
elif {$1==2" && "$!<2} error "A bottom color layer is missing, for this colorization mode."
fi
min_color_area={$15^2}
repeat {$1?1:$!} inds=${arg\ 1+!!$1,$<,0--1} l[$inds]
ind_lineart={$1==1?1:0}
nm=${gui_layer_name[$ind_lineart]} nm[$ind_lineart] lineart
if {$!>1} ind_colors={$1==1?0:1} nmc={$ind_colors,n} nm[$ind_colors] colors fi
if {$!>=3} rm[2--1] fi
[lineart]
is_alpha={s==2||s==4}
if $is_alpha sh. 100% is_alpha={iM-im>64} rm. fi
if $is_alpha channels. 100%
else luminance. negate. fi
>. {255*(1-$2%)}
nm. strokes
_keep_keycoords={$-1==0}
[strokes] close_binary. ${9-14},$min_color_area,$16 nm. new_strokes
if {$-1==0}
+negate[strokes] *. 255 to_rgb.
+-[new_strokes] [strokes] dilate. 2
100%,100%,1,3,[0,128,255] j... .,0,0,0,0,1,.. rm[-2,-1]
if {narg($keycoords)} f[keycoords] "ellipse(#-1,(I)[0,2],3,3,0,1,[255,0,0]);I" rm[keycoords] fi
nm. geometry
fi
if {$1==1}
to_rgba[$colors] [colors],[colors]
f[colors] "i(#-1) = A<255?0:norm(R,G+0.3,B+0.6);I"
label_fg. 0 {1+iM},1,1,{colors,s+1}
f.. ">I[#-1,i]+=[ I(#"$colors"),1 ];I"
s. c,{-s+1} /[-2,-1]
+l[new_strokes] * -1 + 1 +b 1% b.. 1 min endl
watershed... .,0 rm. map.. . rm.
if {!$8} rm[strokes]
else
j[strokes] [new_strokes] distance[strokes] 0 *[strokes] -1
eq[new_strokes] 0 label_fg[new_strokes] 0,0
if $min_color_area +area_fg[new_strokes] 0,0 >. $min_color_area *[new_strokes,-1] fi
watershed[new_strokes] [strokes],0 rm[strokes]
srgb2rgb. guided. [new_strokes],{1+$8/5},0 rgb2srgb.
fi
rm[new_strokes]
nm. new_colors
elif {$1==2}
j[strokes] [new_strokes] distance[strokes] 0 *[strokes] -1
eq[new_strokes] 0 label_fg[new_strokes] 0,0
if $min_color_area +area_fg[new_strokes] 0,0 xy_bg={[xM,yM]} >. $min_color_area *[new_strokes,-1] fi
watershed[new_strokes] [strokes],0 rm[strokes]
to_color[colors] sh[colors] 0,2 rgb2hsv8. rm. blend[colors,new_strokes] shapemedian sh[colors] 0,2 hsv82rgb. rm.
nm[colors] new_colors
else
j[strokes] [new_strokes] distance[strokes] 0 *[strokes] -1
eq[new_strokes] 0 label_fg[new_strokes] 0,0
if $min_color_area +area_fg[new_strokes] 0,0 xy_bg={[xM,yM]} >. $min_color_area *[new_strokes,-1] fi
watershed[new_strokes] [strokes],0 rm[strokes]
label[new_strokes] 0,0
+histogram[new_strokes] {new_strokes,[iM+1,0,iM]} equalize. 1024 n. 0,240
ind_bg={xM}
channels. 0,2 srand 0
f. "[i,u(1,max(3,$6))/255,u(min(252,$7),255)/255]"
. sh. 0 rand. 0,360 rm.
hsi2rgb[-2,-1] *.. $5 *. {1-$5} +[-2,-1] round.
point. $ind_bg,0,0,1,255 point. 0,0,0,1,255
map[new_strokes] . rm.
nm[new_strokes] new_colors
fi
ind_lineart=$lineart
ind_colors=$new_colors
if $4
100%,100%,1,1,"const boundary = 1; J(#"$new_colors",1)!=I(#"$new_colors") || J(#"$new_colors",0,1)!=I(#"$new_colors")"
*. 255 channels. -3,0 sh. 0,2 fc. 255,0,0 rm.
gui_set_layer_name. $nm" [region delimiters]"
mv. {$lineart+1}
fi
if {!narg($nmc)} gui_set_layer_name[$ind_colors] $nm" [colors]" fi
gui_set_layer_name[$ind_lineart] $nm
if {$-1==-1}
if {!$is_alpha} gui_set_layer_mode[$ind_lineart] multiply fi
if $3 l[0]
if $is_alpha
100%,100%,1,3,255 blend. [0],alpha,1 rgb2hsv. channels. 2 *. 255 negate.
channels.. 0,{0,s-2} s={0,s} luminance[0] to_colormode[0] $s a c
else
s={s} to_rgb rgb2hsv channels 2 * 255 to_colormode $s
fi
endl fi
elif {$-1==0}
if {$is_alpha} channels[$ind_lineart] 100% negate[$ind_lineart] fi to_rgb[$ind_lineart]
n[$ind_lineart] 180,255
blend[$ind_lineart,$ind_colors] multiply
+select_color[geometry] 0,255,255,255 ==. 0 j[$ind_lineart] [geometry],0,0,0,0,1,. k[$ind_lineart]
elif {$-1==1}
k[$ind_colors]
else
if {$is_alpha} channels[$ind_lineart] 100% negate[$ind_lineart] fi to_rgb[$ind_lineart]
if $3 l[$ind_lineart] s={s} to_rgb rgb2hsv channels 2 * 255 to_colormode $s endl fi
blend[$ind_lineart,$ind_colors] multiply k[$ind_lineart]
fi
endl done
#@gui Desaturate Norm : fx_gcd_norm_eq, fx_gcd_norm_eq_preview(0)
#@gui : note = note("<i>Desaturate sRGB using equalized norm</i>"), sep = separator()
#@gui : Red = float(0.5,0,1)
#@gui : Blue = float(0.5,0,1)
#@gui : Exp = float(2,1,3)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/12/27</i>.</small>")
fx_gcd_norm_eq : -skip ${1=0.5},${2=0.5},${3=2}
-repeat $! -l[$>]
-split_opacity
-l[0]
-to_rgb -srgb2rgb -gcd_gamma $3
-sh 0 -sh.. 2 -*.. $1 -*. $2 -k[0]
-norm -/ {sqrt(1+$1^2+$2^2)}
-gcd_gamma {1/$3} -rgb2srgb
-endl -a c
-endl -done
fx_gcd_norm_eq_preview :
-gui_split_preview "-fx_gcd_norm_eq ${1--2}",$-1
#@gui Dithering : fx_ditheredbw, fx_ditheredbw_preview(0)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue = float(0,0,360)
#@gui : Saturation (%) = float(0,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_ditheredbw :
repeat $! l[$>] split_opacity l[0]
luminance  adjust_colors ${1-3} b $6
ditheredbw
if {$4" || "$5} / 255 i[0] 100%,100%,1,2 fc[0] $4,{$5%} a c hsv2rgb fi
endl a c endl done
fx_ditheredbw_preview :
gui_split_preview "fx_ditheredbw $*",${-3--1}
#@gui Emboss : gcd_emboss, gcd_emboss_preview(1)
#@gui : note = note("<i>Make an image look embossed</i>"), sep = separator()
#@gui : Midpoint = int(128,0,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/11/11</i>.</small>")
gcd_emboss : -skip ${1=128}
-repeat $! -l[$>]
--norm --bilateral[0] 2%,30 -norm[-1] --[-2,-1]
--n[0] 0,255 -median[-1] 3 -bilateral[-1] 2%,30
-gcd_srgb2luma[-1] --[-1] $1
--abs[-1] -negate[-1]
--max[-2] 0 -min[-3] 0 -abs[-3]
-pde_flow[1] 20,7,iee
--n[-3] 0,2 -*[-1] [1] -+[0,-1]
--n[-1] 0,2 -*[-1] [1] -+[0,-1]
--n[-2] 0,2 -*[-1] [1] -+[0,-1]
-+[0,2] --[0,3] -k[0]
-gcd_srgb2luminance -c 0,255
-endl -done
gcd_emboss_preview :
-gui_split_preview "-gcd_emboss ${1--2}",$-1
#@gui Engrave : fx_engrave, fx_engrave_preview(0)
#@gui : note = note("<small><b>Black &amp; White foreground:</b></small>")
#@gui : Radius = float(0.5,0,2)
#@gui : Density = float(50,0,200)
#@gui : Edges = float(0,0,10)
#@gui : Coherence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal Area = int(0,-256,256)
#@gui : Flat Regions Removal = float(0,0,10)
#@gui : sep = separator(), note = note("<small><b>Color background:</b></small>")
#@gui : Add Color Background = bool()
#@gui : Quantization = float(10,0,40)
#@gui : Shading = int(1,0,5)
#@gui : Hue = float(0,-180,180)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Lightness (%) = float(0,-100,100)
#@gui : sep = separator()
#@gui : Anti-Aliasing = choice(1,"Disabled","x1.5","x2","x3")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>03/13/2015</i>.</small>")
fx_engrave :
f={arg(1+$14,1,1.5,2,3)}
r={$f*(0.2+$1)}
repeat $! l[$<]
nm=${-gui_layer_name} pos=${-gui_layer_pos}
if $8 [0] fi
l[0] split_opacity l[0]
wh={w},{h}
norm
if $14 r {100*$f}%,{100*$f}%,1,1,3 fi
if {$7>0} [0] fi
l[0]
amount={(0.5+$2)^2}
repeat 5 b $r unsharp $r,{1+$2} c 0,255 done
smooth 100,0.1,1,{$f*$3},{$f*$4}
>= {100-$5}%
endl
if {$7>0}
gradient_norm[1] b[1] $3 <[1] $7 max[0,1]
fi
if {$6<0} area_fg 0,0 > {$f*$6*$6}
elif {$6>0} == 0 area_fg 0,0 > {$f*$6*$6} == 0
fi
* 255
if $14 r $wh,1,1,2 fi
endl a c endl
if {$!>1}
l[1] split_opacity l[0]
f={arg(1+$14,1,1.5,2,3)}
if $14 r {100*$f}%,{100*$f}%,1,100%,3 fi
b {$f*$9} segment_watershed 5
if $14 r $wh,1,100%,2 fi
repeat $10 guided 10,{$10*80} done
rgb2hsv s c +... $11 +.. {$12%} +. $13% a c hsv2rgb
endl a c endl
nm[0] mode(darken),name($nm),pos($pos)
nm[1] name($nm" [colors]"),pos($pos)
fi
endl done
fx_engrave_preview :
repeat $! l[$<]
gui_split_preview "nm foo fx_engrave $* gui_merge_layers",${-3--1}
endl done
#@gui Freaky B&amp;W : fx_freaky_bw, fx_freaky_bw_preview
#@gui : Strength (%) = float(90,0,100)
#@gui : Oddness (%) = float(20,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/30/09</i>.</small>")
fx_freaky_bw :
repeat $! l[$>] split_opacity l[0]
to_rgb
+expand_xy 1,0 channels. 0,4
f. ">if (c!=4,i,
Rx = i(x+1,y,0,0) - i(x,y,0,0);
Ry = i(x,y+1,0,0) - i(x,y,0,0);
Rn = Rx^2 + Ry^2;
Gx = i(x+1,y,0,1) - i(x,y,0,1);
Gy = i(x,y+1,0,1) - i(x,y,0,1);
Gn = Gx^2 + Gy^2;
Bx = i(x+1,y,0,2) - i(x,y,0,2);
By = i(x,y+1,0,2) - i(x,y,0,2);
Bn = Bx^2 + By^2;
n = 1e-5 + max(Rn,Gn,Bn)^"{$2%}";
val = 0;
if (Rn>=Gn && Rn>=Bn,
i(x,y,0,3) = Rx/n; val=Ry/n,
if (Gn>=Rn && Gn>=Bn,
i(x,y,0,3) = Gx/n; val=Gy/n,
i(x,y,0,3) = Bx/n; val=By/n));
val
)"
channels. 3,4
luminance[0] ia={0,ia}
s. c
f.. "i - i(x-1,y,0,0)"
f. "i - i(x,y-1,0,0)"
+[-2,-1]
ilaplacian. 0
shrink_xy. 1 +. $ia n. 0,255
j[0] [1],0,0,0,0,{$1%} rm.
adjust_colors ${3-5}
endl a c endl done
fx_freaky_bw_preview :
gui_split_preview "fx_freaky_bw $*",${-3--1}
#@gui Ink Wash : fx_ink_wash, fx_ink_wash(0)
#@gui : note = note("Ink wash controls")
#@gui : Size = float(0.14,0,4)
#@gui : Amplitude = float(23,0,200)
#@gui : sep = separator()
#@gui : note = note("Check if you wish visual control on this step")
#@gui : Skip All Other Steps = bool(false)
#@gui : note = note ("UNcheck to reactivate the other controls")
#@gui : sep = separator()
#@gui : Smoother Sharpness = float(0.5,0,2)
#@gui : Smoother Edge Protection = float(0.54,0,1)
#@gui : Smoother Softness = float(2.25,0,10)
#@gui : sep = separator()
#@gui : Stretch Contrast = choice("None","Automatic","Automatic &amp; Contrast Mask","Manual Controls")
#@gui : note = note ("To activate the sliders below chose 'Manual Controls'")
#@gui : sep = separator()
#@gui : LN Amplitude = float(2,0,60)
#@gui : LN Size = float(6,0,64)
#@gui : LN Neightborhood-Smoothness = float(5,0,40)
#@gui : LN Average-Smoothness = float(20,0,40)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest Update: <i>2011/05/04</i>.</small>")
#@gui : url = link(0,"Forum thread about the filter discussion","http://gimpchat.com/viewtopic.php?f=10&t=914")
fx_ink_wash :
repeat $! l[$>] split_opacity l[0]
fx_pencilbw. $1,$2,0,0,0
if {$3==1} continue
elif {$3==0} fx_smooth_anisotropic. 60,$4,$5,$6,1.1,0.8,30,2,0,1,1,0,1,16
fi
if {$7==1} normalize_local. 2,6,5,24,1,0,255
elif {$7==2} normalize_local. 2,6,5,24,1,0,255 fx_contrast_swm 2,0,0.512
elif {$7==3} fx_normalize_local. $8,$9,$10,$11,1,3,0
fi
endl a c endl done
#@gui Multi-Layer Etch : fx_gcd_layeretch, fx_gcd_layeretch(2)
#@gui : note = note("<u>Etch with selectable number of layers</u>")
#@gui : note = note("<b>Warning: With high number of layers this can be VERY slow!</b>")
#@gui : sep = separator()
#@gui : Total Layers = int(11,2,16)
#@gui : White Layers = int(4,1,15)
#@gui : Etch Tones = int(12,2,32)
#@gui : Tone Blur = float(0.12,0,1)
#@gui : Noise Level = int(100,5,200)
#@gui : Dark Length = float(8.5,0,20)
#@gui : Bright Length = float(5,0,20)
#@gui : Start Angle = int(0,0,180)
#@gui : Random Angle = int(0,0,45)
#@gui : Max Curve = int(3,0,20)
#@gui : Gamma = float(1,0.01,2)
#@gui : Spread Angles = bool(1)
#@gui : Fast Resize = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2012/12/21</i>.</small>")
fx_gcd_layeretch : -skip ${1=16},${2=7},${3=14},${4=0.12},${5=100},${6=5},${7=4.65},${8=0},${9=0},${10=3},${11=1},${12=1},${13=0}
-repeat $! -l[$>]
w={w} h={h} sc=800 ml=$1 wl={min($2,$ml-1)}
nwl={$ml-$wl} nwl={$nwl+($nwl%2==0)}
-if {!$13} nw=$w nh=$h
-elif {w>h} nw={min($sc,w)} nh={$nw/w*h}
-else nh={min($sc,h)} nw={$nh/h*w} -endif
-to_rgb[0] [0] -r[1] $nw,$nh
-norm[1] -n[1] 0,255 --tones[1] $ml
-repeat {$ml-1} -+[{-$<-1}] [{-$<-2}] -done
-b[-$ml--1] $4%
-repeat $ml
pc={($>+1)/$ml} msk={2+$>} {w},{h},1,1,0
-if $12 ang={$>/$nwl} -else ang=$pc -endif
-if {$<>=$wl}
-noise[-1] {(1-$pc)*$5},2 ==. 1
-blur_linear[-1] {$6+$pc*($7-$6)}%,0,{$ang*360+u(-$9,$9)+$8}
-quantize[-1] $3,0 -deform[-1] {u*$10+1}
-endif
-r[-1] $nw,$nh -n[-1] 0,255
-mul[$msk,-1] -progress {$pc*100}
-done
-add[-$ml--1] -c[-1] 0,255
-n[-1] 0,255 -negate[-1] -apply_gamma[-1] $11
-if $13 -r[-1] $w,$h,1,3,5 -c[-1] 0,255 -endif
-keep[-1]
-endl -done
#@gui Pencil : fx_pencilbw, fx_pencilbw_preview(0)
#@gui : Size = float(0.3,0,5)
#@gui : Amplitude = float(60,0,200)
#@gui : Hue = float(0,0,360)
#@gui : Saturation = float(0,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/05/03</i>.</small>")
fx_pencilbw :
pencilbw $1,$2
if {$3||$4} repeat $! l[$>] split_opacity
/[0] 255 i[0] 100%,100%,1,1,$4 i[0] 100%,100%,1,1,$3 a[0-2] c hsv2rgb[0]
a c endl done fi
fx_pencilbw_preview :
gui_split_preview "fx_pencilbw $*",${-3--1}
#@gui Pencil Portrait : fx_pencil_portraitbw, fx_pencil_portraitbw_preview(0)
#@gui : Stroke Length = float(30,0,500)
#@gui : Stroke Angle = float(120,0,180)
#@gui : Contour Threshold = float(1,0,10)
#@gui : Opacity = float(0.5,0,1)
#@gui : Color = color(144,79,21)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Jamac4k</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_pencil_portraitbw :
repeat $! l[$>] split_opacity l[0]
+b 2%
+blend divide rm.. luminance.
fx_ink_wash.. 0,167,0,0.5,0.54,2.25,0,2,6,5,20
+fx_hardsketchbw. 80,32,1.89,0.21,31.46,0,0
+fx_sketchbw.. 1,$2,180,$1,$3,0.03,0,0.6,0.1,0.6,0.25,1,0,1,0
blend[0,1] darken
blend[0,1] multiply,0.5
blend[0,1] lighten,$4
normalize_local ,
to_rgb +fc ${5-7} blend softlight
endl a c endl done
fx_pencil_portraitbw_preview :
gui_split_preview "fx_pencil_portraitbw $*",${-3--1}
#@gui Stamp : fx_stamp, fx_stamp_preview(0)
#@gui : Auto-Threshold = bool(1)
#@gui : Threshold = int(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Sharpening = float(0,0,30)
#@gui : Grain = float(0,0,100)
#@gui : Negative = bool()
#@gui : Anti-Aliasing = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Antaron</i>, <i>Mahvin</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.             Latest Update: <i>2015/16/03</i>.</small>")
fx_stamp :
repeat $! l[$>] split_opacity l[0]
wh={w},{h}
norm
if $7 r 150%,150%,1,1,3 fi
noise $5
if $1 otsu 256 else >= $2% fi
b {if($7,1.5,1)*$3},0 sharpen $4 n 0,255
apply_curve 1,0,0,101,33,170,229,255,255
if $7 r $wh,1,1,2 fi
if $6 negate fi
endl a c endl done
fx_stamp_preview :
gui_split_preview "fx_stamp $*",${-3--1}
#@gui Threshold Etch : fx_gcd_etch, fx_gcd_etch_preview(1)
#@gui : note = note("<u>Replace tones with noise generated lines</u>")
#@gui : note = note("\n<i>Input Image Settings</i>"), sep = separator()
#@gui : Threshold Low = int(125,10,255)
#@gui : Threshold Mid = int(153,10,255)
#@gui : Threshold High = int(171,10,255)
#@gui : Threshold Max = int(185,10,255)
#@gui : Blur Amount = float(0.1,0,2)
#@gui : note = note("\n<i>Output Etch Settings</i>"), sep = separator()
#@gui : Horizontal Amount = int(50,0,100)
#@gui : Cross-Hatch Amount = int(80,0,100)
#@gui : Vertical 1 Amount = int(50,0,100)
#@gui : Vertical 2 Amount = int(10,0,100)
#@gui : sep = separator()
#@gui : Horizontal Length = int(15,0,50)
#@gui : Vertical 1 Length = int(12,0,50)
#@gui : Vertical 2 Length = int(20,0,50)
#@gui : Flip Cross-Hatch = bool(0)
#@gui : sep = separator()
#@gui : Curve Amount = int(1,0,20)
#@gui : Gamma = float(0.3,0.01,1)
#@gui : Fast Resize = bool(1)
#@gui : Color Image = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
fx_gcd_etch :
-skip ${1=125},${2=153},${3=171},${4=185},${5=0.1} -skip ${6=50},${7=80},${8=50},${9=10}
-skip ${10=15},${11=12},${12=20},${13=0} -skip ${14=1},${15=0.3},${16=1},${17=0}
-repeat $! -l[$>]
w={w} h={h} sc=800 ml=4
-if {w>h} nw={min($sc,w)} nh={$nw/w*h} -else nh={min($sc,h)} nw={$nh/h*w} -endif
-to_rgb[0] [0] -if $16 -r[1] $nw,$nh -endif
-b[1] $5% -norm[1] -negate[1] -n[1] 0,255
--c[1] 0,{255-$4} --c[1] {255-$3},128 --c[1] {255-$2},192 --c[1] {255-$1},255 -n[-3--1] 0,255
{w},{h},1,1,0 -noise[-1] $6,2 ==. 1 -deriche[-1] $10,0,x,0
{w},{h},1,1,0 -noise[-1] $7,2 ==. 1 {w},{h},1,3,0 -fc[-1] 0,-1,0 -smooth[-2] [-1],30,30,0 -rm[-1]
-if $13 -mirror[-1] x -endif
{w},{h},1,1,0 -noise[-1] $8,2 ==. 1 -deriche[-1] $11,0,y,0
{w},{h},1,1,0 -noise[-1] $9,2 ==. 1 -deriche[-1] $12,0,y,0
-quantize[-$ml--1] 2,0 -deform[-$ml--1] $14
-repeat $ml -mul[{2+$>},-1] -done
-add[-$ml--1] -n[-1] 0,255 -rm[1]
-negate[-1] -apply_gamma[-1] $15
-if $16 -r[-1] $w,$h,1,3,5 -c[-1] 0,255 -endif
-if $17 -blend[0,1] shapeaverage -else -keep[-1] -endif
-endl -done
fx_gcd_etch_preview :
-gui_split_preview "-fx_gcd_etch ${1--2}",$-1
#@gui _
#@gui <b>Colors</b>
#@gui Abstraction : fx_color_abstraction, fx_color_abstraction_preview(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Levels = int(10,2,100)
#@gui : Contrast = float(0.2,0.01,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/19/10</i>.</small>")
fx_color_abstraction :
repeat $! l[$>] split_opacity l[0] to_rgb
b $1 s c quantize $2,1,0 area 0 ^ $3 n 0,255
endl a c endl done
fx_color_abstraction_preview :
gui_split_preview "fx_color_abstraction $*",${-3--1}
#@gui Auto Balance : gcd_auto_balance, gcd_auto_balance(1)
#@gui : note = note("<i>Map based tone and color balance</i>"), sep = separator()
#@gui : Area = float(30,0,200)
#@gui : Smooth = float(0,0,2)
#@gui : Channels = choice(0,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Balance sRGB = bool(1)
#@gui : Reduce RAM = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/08</i>.</small>")
gcd_auto_balance : -skip ${1=30},${2=0},${3=0},${4=1},${5=0}
mode=${-arg\ 1+$3,hsi_i,hsv_v,lab_l,lrgb,rgb,ycbcr_y}
-if {$2>0} -bilateral 1%,$2 -c 0,255 -endif
-if {$4!=0} -ac "-gcd_rgb_balance",rgb -endif
if $5 ac "-gcd_tonemap_inplace $1",$mode,2
else -ac "-gcd_tonemap $1",$mode,2 fi
gcd_tonemap : -skip ${1=100},${2=255}
-repeat $! -l[$>]
-/ $2 --boxfilter $1%
---. 0.5 -sign. -*. -1
--*.. -2 -+. 1 -/[1] .
--eq. 0 -+[-2,-1] -/[0,-1]
--sqr.. -+[0,-1] -max[0] 0
-sqrt[0] -*[0,-1] -- -* $2
-endl -done
gcd_tonemap_inplace : skip ${1=100},${2=255}
repeat $! l[$>]
div $2 +boxfilter $1%
f[0] "*A=i(#-1,x,y,z,c);B=1-2*A;Bx=A/B;-sign(A-0.5)*sqrt(i/B+Bx^2)-Bx;"
rm. mul $2
endl done
gcd_rgb_balance :
-repeat $! -l[$>]
m={iM} -s c -n 0,$m -a c [0] --r. 1,1,1,100%,2
-repeat {s#1} -sh[1] $> --. {2,i[$>]+$m/2} -rm. -done
-rm. -n. 0,$m --/[0] $m --^. 3 -compose_channels. + -/. -3 -+. 1
-compose_channels.. max -*[-2,-1] -j[0] ..,0,0,0,0,1,. -k[0]
-endl -done
#@gui Basic Adjustments : fx_adjust_colors, fx_adjust_colors_preview
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/16/06</i>.</small>")
fx_adjust_colors :
adjust_colors ${1-5},0,255
fx_adjust_colors_preview :
gui_split_preview "fx_adjust_colors $*",${-3--1}
#@gui Boost-Fade : fx_boost_fade, fx_boost_fade_preview
#@gui : Amplitude = float(5,0,10)
#@gui : Chromaticity From = choice("YCbCr","Lab")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/11/26</i>.</small>")
fx_boost_fade :
repeat $! l[$>]
100%,100%,1,3 rand. 0,1 b. {10-10*($1/10)^0.5} n. 0,255
to_colormode 0 a z
ac "s z transfer_histogram.. . rm.",${"arg 1+$2,ycbcr_cbcr,lab_ab"}
endl done
fx_boost_fade_preview :
gui_split_preview "fx_boost_fade $1,$2",${-3--1}
#@gui Boost Chromaticity : fx_boost_chroma, fx_boost_chroma_preview(1)
#@gui : Amplitude (%) = float(50,0,100)
#@gui : Color Space = choice{"YCbCr (Distinct)","YCbCr (Mixed)","Lab (Distinct)","Lab (Mixed)"}
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/19/07</i>.</small>")
fx_boost_chroma :
repeat $! l[$>] split_opacity l[0]
+to_rgb
if {$2>=2}
srgb2rgb rgb2lab.
if {$2==2} sh. 1 sh.. 2 equalize[-2,-1] rm[-2,-1]
else sh. 1,2 equalize. rm.
fi
lab2rgb. rgb2srgb
else
rgb2ycbcr.
if {$2==0} sh. 1 sh.. 2 equalize[-2,-1] rm[-2,-1]
else sh. 1,2 equalize. rm.
fi
ycbcr2rgb.
fi
j.. .,0,0,0,0,{$1%} rm.
endl a c endl done
fx_boost_chroma_preview :
gui_split_preview "fx_boost_chroma $*",${-3--1}
#@gui Channels to Layers : fx_channels2layers, fx_channels2layers_preview
#@gui : Colorspace = choice("RGB","CMY","HSV")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/15/07</i>.</small>")
fx_channels2layers :
repeat $! l[$<] nm=${-gui_layer_name} to_rgb
if {$1==0}
s[0] c
r[0] 100%,100%,1,3,0,0,0,0,0,0 nm[0] name($nm" "[red]),mode(add)
r[1] 100%,100%,1,3,0,0,0,0,0,0.5 nm[1] name($nm" "[green]),mode(add)
r[2] 100%,100%,1,3,0,0,0,0,0,1 nm[2] name($nm" "[blue]),mode(add)
elif {$1==1}
rgb2cmy[0] -[0] 255 s[0] c
r[0] 100%,100%,1,3,0,0,0,0,0,0 nm[0] name($nm" "[cyan]),mode(difference)
r[1] 100%,100%,1,3,0,0,0,0,0,0.5 nm[1] name($nm" "[magenta]),mode(difference)
r[2] 100%,100%,1,3,0,0,0,0,0,1 nm[2] name($nm" "[yellow]),mode(difference)
+[0-2] 255
i[0] 100%,100%,1,3,255 nm[0] name($nm" "[base]),mode(difference)
else
rgb2hsv[0] s[0] c,-2
r[0] 100%,100%,1,3,0,0 sh[0] 2 f. 1 rm. nm[0] name($nm" "[color]),mode(normal)
r[1] 100%,100%,1,3,0,0,0,0,0,1 nm[1] name($nm" "[value]),mode(value)
hsv2rgb[0,1] rv[0,1]
fi
endl done
fx_channels2layers_preview :
repeat $! l[$>]
fx_channels2layers $*
repeat $! l[$>] to "#"{1+$>},1,1,43,7,1,255 endl done
frame 1,1,0 frame 3,3,255 append_tiles ,
endl done
#@gui Channel Processing : fx_channel_processing, fx_channel_processing_preview(1)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Value Action = choice("None","Cut","Cut &amp; Normalize","Normalize","Threshold")
#@gui : Low Value = float(0,0,100)
#@gui : High Value = float(100,0,100)
#@gui : Quantization = int(256,1,256)
#@gui : Equalization = bool(0)
#@gui : Negation = bool(0)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator()
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_channel_processing :
adjust_colors ${1-3} b. $4%
if {$5==1} c. $6%,$7%
elif {$5==2} c. $6%,$7% n. 0,255
elif {$5==3} n. $6%,$7%
elif {$5==4} ir. $6%,$7% *. 255
fi
if {$8!=256} quantize. $8,1,0 fi
if $9 equalize. fi
if $10 negate. fi
fx_channel_processing :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $11,$12
ac. "_fx_channel_processing $1,$2,$3,$4,$5,$6,$7,$8,$9,$10",$13,1
fx_end_mix $11
if {$!!=3} rv a c fi endl mv. 0 done
fx_channel_processing_preview :
gui_split_preview "fx_channel_processing $*",${-3--1}
#@gui CLUT from After - Before Layers : fx_clut_from_ab, fx_clut_from_ab_preview
#@gui : Output CLUT Resolution = _choice("512 x 512","4096 x 4096")
#@gui : Influence of Color Samples (%) = float(50,0,100)
#@gui : sep = separator()
#@gui : note = note{"<b>What is this filter for?</b>\n\n
#@gui : This filter requires at least two input layers to work properly.\n
#@gui : It assumes you have an input top layer <b>A</b> and a base layer <b>B</b> such that <b>A</b> and <b>B</b> both represent the same image but with only color variations
#@gui : (typically <b>A</b> has been obtained from <b>B</b> using the color curves tool).\n\n
#@gui : This filter is then able to estimate and outputs a color HaldCLUT <b>H</b> so that applying <b>H</b> on the base layer <b>B</b> gives back <b>A</b>.\n\n
#@gui : This is useful when you have a color transformation between two images, that you want to recover and re-apply on a bunch of other images.
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/07/25</i>.</small>")
fx_clut_from_ab :
if {$!<2} error "At least two input layers are needed to run this filter." fi
repeat {$!-1} l[$<,-1] nm=${gui_layer_name..}
64,64,64,4 f[0] ">I(#2,round(I(#1)*(w#2-1)/255))+=[R,G,B,1]; I" rm[0]
s. c,-3 +max. 1 /[-3,-1] ==. 0
inpaint_diffusion.. .,75%,1
distance. 0 *. {-1/(1+$2)} exp.
f.. "f = i(#-1); f*I + (1-f)*[x,y,z]*255/(w-1)"
rm.
if $1 r. 256,256,256,3,3 fi
r. {s=whd^0.5;[s,s]},1,3,-1
rv nm[0] "name(CLUT to '"$nm"')"
endl done
if $_output_mode rm. fi
fx_clut_from_ab_preview :
if {$!<2} gui_warning_preview "At least two input layers are needed to run this filter." return fi
fx_clut_from_ab 0,$2
#@gui CMYK Tone : iain_cmyk_tone_p, iain_cmyk_tone_p
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"Strength of effect for Saturation level:"}
#@gui : None = int(255,0,255)
#@gui : Little = int(255,0,255)
#@gui : Some = int(255,0,255)
#@gui : Much = int(255,0,255)
#@gui : Most = int(255,0,255)
#@gui : sep = separator()
#@gui : Output = choice(0,"Perserve Luminance","Clip CMYK","Clip RGB","Scale CMYK","Scale RGB")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
iain_cmyk_tone_p:
-apply_parallel_overlap "-iain_cmyk_tone ${1--2}",0,${-1}
iain_cmyk_tone:
-repeat $! -l[$>] -split_opacity -l[0]
-rgb2cmyk
--split c
--apply_curve[1] 0,0,$1,128,$2,255,$3
--apply_curve[2] 0,0,$4,128,$5,255,$6
--apply_curve[3] 0,0,$7,128,$8,255,$9
--apply_curve[4] 0,0,$10,128,$11,255,$12
-add[-1,-2,-3,-4]
--apply_curve[1] 0,0,$13,128,$14,255,$15
--apply_curve[2] 0,0,$16,128,$17,255,$18
--apply_curve[3] 0,0,$19,128,$20,255,$21
--apply_curve[4] 0,0,$22,128,$23,255,$24
-add[-1,-2,-3,-4]
--apply_curve[1] 0,0,$25,128,$26,255,$27
--apply_curve[2] 0,0,$28,128,$29,255,$30
--apply_curve[3] 0,0,$31,128,$32,255,$33
--apply_curve[4] 0,0,$34,128,$35,255,$36
-add[-1,-2,-3,-4]
--apply_curve[1] 0,0,$37,128,$38,255,$39
--apply_curve[2] 0,0,$40,128,$41,255,$42
--apply_curve[3] 0,0,$43,128,$44,255,$45
--apply_curve[4] 0,0,$46,128,$47,255,$48
-add[-1,-2,-3,-4]
-add[1,5]
-add[2,5]
-add[3,5]
-add[4,5]
-a[-1,-2,-3,-4] c
--sub[0,1]
--cmyk2rgb[0] -rgb2hsv[-1] -split[-1] c -remove[-1,-3] -mul[-1] 255
-apply_curve[-1] 0,0,$49,64,$50,128,$51,192,$52,255,$53
-compose_multiply[-1,-2]
--sub[0,-1]
-if {$54==0}
-cmyk2rgb
-luminance[0]
--luminance[-1]
-compose_grainextract[-1,-2]
-compose_grainmerge[0,-1]
-keep[0]
-endif
-if {$54==1}
-keep[-1]
-c 0,255
-cmyk2rgb
-endif
-if {$54==2}
-keep[-1]
-cmyk2rgb
-c 0,255
-endif
-if {$54==3}
-keep[-1]
-n 0,255
-cmyk2rgb
-endif
-if {$54==4}
-keep[-1]
-cmyk2rgb
-n 0,255
-endif
-endl -a c -endl -done
#@gui Colorful Blobs : fx_colorful_blobs, fx_colorful_blobs_preview
#@gui : Colorspace = choice(1,"sRGB","Linear RGB","Lab")
#@gui : Background Color = color(200,200,200,0)
#@gui : Display Blob Controls = bool(1)
#@gui : sep = separator()
#@gui : Blob 1 = point(25,25,1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 1 Color = color(255,0,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob2 = point(75,25,1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 2 Color = color(0,255,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 3 = point(50,75,1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 3 Color = color(0,0,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 4 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 4 Color = color(255,255,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 5 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 5 Color = color(255,0,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 6 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 6 Color = color(0,255,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 7 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 7 Color = color(255,255,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 8 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 8 Color = color(0,0,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 9 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 9 Color = color(255,128,64)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 10 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 10 Color = color(255,64,128)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 11 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 11 Color = color(128,64,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 12 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 12 Color = color(64,128,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : note = note("This filter can be used to create custom palettes with given color shades. It has been inspired by <a href="https://research.adobe.com/project/playful-palette-an-interactive-parametric-color-mixer-for-artists/">Adobe's Playful Palette</a>.")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/08/26</i>.</small>")
fx_colorful_blobs :
N=12
colorspace,bgR,bgG,bgB,bgA,display_controls,\
x0,y0,rx0,ry0,R0,G0,B0,p_x0,p_y0,p_rx0,p_ry0,\
x1,y1,rx1,ry1,R1,G1,B1,p_x1,p_y1,p_rx1,p_ry1,\
x2,y2,rx2,ry2,R2,G2,B2,p_x2,p_y2,p_rx2,p_ry2,\
x3,y3,rx3,ry3,R3,G3,B3,p_x3,p_y3,p_rx3,p_ry3,\
x4,y4,rx4,ry4,R4,G4,B4,p_x4,p_y4,p_rx4,p_ry4,\
x5,y5,rx5,ry5,R5,G5,B5,p_x5,p_y5,p_rx5,p_ry5,\
x6,y6,rx6,ry6,R6,G6,B6,p_x6,p_y6,p_rx6,p_ry6,\
x7,y7,rx7,ry7,R7,G7,B7,p_x7,p_y7,p_rx7,p_ry7,\
x8,y8,rx8,ry8,R8,G8,B8,p_x8,p_y8,p_rx8,p_ry8,\
x9,y9,rx9,ry9,R9,G9,B9,p_x9,p_y9,p_rx9,p_ry9,\
x10,y10,rx10,ry10,R10,G10,B10,p_x10,p_y10,p_rx10,p_ry10,\
x11,y11,rx11,ry11,R11,G11,B11,p_x11,p_y11,p_rx11,p_ry11,\
=$"*"
if {!0$_is_preview} display_controls=0 fi
if {$1==1} srgb2cs=srgb2rgb cs2srgb=rgb2srgb
elif {$1==2} srgb2cs=srgb2lab cs2srgb=lab2srgb
fi
{0,s=min(w,h);[s,s]},1,4 k. 100%,100%,1,1,1e-8
repeat $N
rx$>,ry$>={"P = ["${x$>},${y$>}"]; R = ["${rx$>},${ry$>}"]; oP = ["${p_x$>},${p_y$>}"]; oP==[-1,-1]?P + [10,0]:P!=oP?R + P - oP:R"}
if {!isnan(${x$>})}
x,y,rx,ry,R,G,B={"const w1 = (w - 1)%; const h1 = (h -1)%; "round([${x$>}*w1,${y$>}*h1,${rx$>}*w1,${ry$>}*h1,${R$>},${G$>},${B$>}])}
r={max(1,round(norm($x-$rx,$y-$ry)))}
if $1 ($R^$G^$B) $srgb2cs. R,G,B={^} rm. fi
f. "*
pexp(x) = x<2?(res = 1; px = x^2; res+=-1.17282*px; px*=x; res+=0.683221*px; px*=x; res+=-0.110353*px):0;
const r = 1.2*"($r)";
dist = norm(x-"$x",y-"$y")/r;
w = pexp(dist);
j(#0,0,0,0) += w*"$R";
j(#0,0,0,0,1) += w*"$G";
j(#0,0,0,0,2) += w*"$B";
i + w;
"
fi
done
sh[0] 0,2 /. [1] if $1 $cs2srgb. fi
f[0] "*begin(bg = [ "$bgR,$bgG,$bgB,$bgA" ]); i(#1)<0.5?bg:[R,G,B,255]" k[0]
repeat $N
if {!isnan(${x$>})" && "$display_controls}
x,y,rx,ry,R,G,B={"const w1 = (w - 1)%; const h1 = (h -1)%; "round([${x$>}*w1,${y$>}*h1,${rx$>}*w1,${ry$>}*h1,${R$>},${G$>},${B$>}])}
circle $x,$y,3,0.85,0xFFFFFFFF,{v=avg(crop($x-3,$y-3,7,7))>128?0:255;[v,v,v,255]}
rectangle {"const x = "$rx"; const y = "$ry"; [x-2,y-2,x+2,y+2]"},0.85,0xFFFFFFFF,{v=avg(crop($rx-3,$ry-3,7,7))>128?0:255;[v,v,v,255]}
line $x,$y,$rx,$ry,0.5,0xF0F0F0F0,255 line $x,$y,$rx,$ry,0.5,0x0F0F0F0F,0,0,0,255
fi
done
if 0$_is_preview
u \{$colorspace\}\{$bgR,$bgG,$bgB,$bgA\}\{$display_controls\}\
\{$x0,$y0\}\{$rx0,$ry0\}\{$R0,$G0,$B0\}\{$x0,$y0,$rx0,$ry0\}\
\{$x1,$y1\}\{$rx1,$ry1\}\{$R1,$G1,$B1\}\{$x1,$y1,$rx1,$ry1\}\
\{$x2,$y2\}\{$rx2,$ry2\}\{$R2,$G2,$B2\}\{$x2,$y2,$rx2,$ry2\}\
\{$x3,$y3\}\{$rx3,$ry3\}\{$R3,$G3,$B3\}\{$x3,$y3,$rx3,$ry3\}\
\{$x4,$y4\}\{$rx4,$ry4\}\{$R4,$G4,$B4\}\{$x4,$y4,$rx4,$ry4\}\
\{$x5,$y5\}\{$rx5,$ry5\}\{$R5,$G5,$B5\}\{$x5,$y5,$rx5,$ry5\}\
\{$x6,$y6\}\{$rx6,$ry6\}\{$R6,$G6,$B6\}\{$x6,$y6,$rx6,$ry6\}\
\{$x7,$y7\}\{$rx7,$ry7\}\{$R7,$G7,$B7\}\{$x7,$y7,$rx7,$ry7\}\
\{$x8,$y8\}\{$rx8,$ry8\}\{$R8,$G8,$B8\}\{$x8,$y8,$rx8,$ry8\}\
\{$x9,$y9\}\{$rx9,$ry9\}\{$R9,$G9,$B9\}\{$x9,$y9,$rx9,$ry9\}\
\{$x10,$y10\}\{$rx10,$ry10\}\{$R10,$G10,$B10\}\{$x10,$y10,$rx10,$ry10\}\
\{$x11,$y11\}\{$rx11,$ry11\}\{$R11,$G11,$B11\}\{$x11,$y11,$rx11,$ry11\}
fi
fx_colorful_blobs_preview :
_is_preview=1
rm {s=min($_preview_width,$_preview_height)/2;[s,s]},1,1
fx_colorful_blobs $*
#@gui Colormap : fx_colormap,fx_colormap_preview
#@gui : Colormap = choice[1,"Adaptive","Custom","Standard (256)","HSV (256)","Lines (256)","Hot (256)","Cool (256)","Jet (256)","Flag (256)","Cube (256)"]
#@gui : Dithering = float(1,0,1)
#@gui : sep = separator(), note = note("<small><i>For adaptive and custom colormaps only :</i></small>")
#@gui : Number of Tones = int(32,2,256)
#@gui : sep = separator(), note = note("<small><i>For custom colormaps only :</i></small>")
#@gui : Number of Colors = int(8,2,8)
#@gui : 1st Color = color(0,0,0)
#@gui : 2nd Color = color(255,255,255)
#@gui : 3rd Color = color(255,0,0)
#@gui : 4th Color = color(0,255,0)
#@gui : 5th Color = color(0,0,255)
#@gui : 6th Color = color(255,255,0)
#@gui : 7th Color = color(255,0,255)
#@gui : 8th Color = color(0,255,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/27/12</i>.</small>")
fx_colormap :
repeat $! l[$>] split_opacity to_rgb[0]
if {$1>=2}
index[0] {$1-2},$2,1
elif {$1==1}
(${5-28}) z. 0,{3*$4-1}
r. 3,{w/3},1,1,-1 permute. yzcx r. $3,1,1,3,3
index[0] .,$2,1 rm.
else
autoindex[0] $3,$2,{if($3<=32,1,0)}
fi
a c
endl done
fx_colormap_preview :
gui_split_preview "fx_colormap $*",${-3--1}
#@gui Color Balance : fx_balance_gamma, fx_balance_gamma_preview
#@gui : Neutral Color = color(128,128,128)
#@gui : Stretch Colors = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/01/07</i>.</small>")
fx_balance_gamma :
repeat $! l[$>] split_opacity
if {$!>1} +!=. 0 *[0,-1] fi
l[0]
balance_gamma ${1-3}
if $4 n 0,255 fi
endl
a c endl
done
fx_balance_gamma_preview :
gui_split_preview "fx_balance_gamma $*",${-3--1}
#@gui Color Blindness : colorblind, fx_colorblind_preview
#@gui : Blindness Type = choice("Protanopia","Protanomaly","Deuteranopia","Deuteranomaly","Tritanopia","Tritanomaly","Achromatopsia","Achromatomaly")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter simulates different types of colorblindness vision.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/04</i>.</small>")
fx_colorblind_preview :
gui_split_preview "colorblind $*",${-3--1}
#@gui Color Grading : jl_colorgrading, jl_colorgrading_preview(1)
#@gui : note = note("A filter for basic photo editing and color grading.")
#@gui : note = note("<small><b>Note:</b> Saturation channel gamma affects more the less saturated areas. S-curve contrast, affects shadows and highlights equally. When using noise reduction or sharpening tools, zoom in for more accurate view.</small>")
#@gui : sep = separator()
#@gui : HDR Effect (Tone Map) = float(0.,0.0,1)
#@gui : Cool / Warm = int(0,-50,50)
#@gui : Saturation = float(1,0,2)
#@gui : Saturation Channel Gamma = float(1,0.1,3)
#@gui : note = note("<small><b>Note:</b> Saturation channel gamma may introduce artifacts depending on the image.</small>")
#@gui : sep = separator()
#@gui : S-Curve Contrast = int(0,-30,30)
#@gui : Shadows = int(0,-50,50)
#@gui : Highlights = int(0,-50,50)
#@gui : Blacks = int(0,0,50)
#@gui : Brightness = int(0,-50,50)
#@gui : Contrast = int(0,-50,50)
#@gui : Gamma = float(1,0.1,3)
#@gui : sep = separator()
#@gui : Clarity = float(0,0.0,2.0)
#@gui : Local Contrast Enhance = float(0,0,3)
#@gui : sep = separator()
#@gui : Color Grading = bool(0)
#@gui : Highlights Color Intensity = int(70,0,130)
#@gui : Highlights Hue = int(0,0,360)
#@gui : Highlights Brightness = int(0,-100,100)
#@gui : Midtones Color Intensity = int(0,0,130)
#@gui : Midtones Hue = int(0,0,360)
#@gui : Midtones Brightness = int(0,-100,100)
#@gui : Shadows Color Intensity = int(70,0,130)
#@gui : Shadows Hue Shift = int(180,0,360)
#@gui : Shadows Brightness = int(0,-100,100)
#@gui : note = note("<small><b>Color grading subsection usage:</b> Use intensity sliders to control the amount of color being applied in the highlights/midtones/shadows, use brightness sliders for bringing up or down highlights/midtones/shadows. Hues here follow rotation axis in color wheel ie: 0 or 360 deg is red, 180 is blue it's complimentary. Shadows hue shift in default position uses always the complimentary color of highlights in the shadows. Default sliders for grading apply red highlights and blue shadows effect.</small>")
#@gui : sep = separator()
#@gui : Output Saturation = float(1,0,2)
#@gui : Output Sharpening = float(0,0,10)
#@gui : Output Chroma Nr = float(0,0,20)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>John Lakkas</i>.      Latest update: <i>17/03/2015</i>.</small>")
jl_colorgrading :
if {$1>0.01}
map_tones_fast 5%,$1
fi
_ystr=""
if {$2>0}
_mymin={$2}
_mymax={255-$2}
apply_channels "-apply_curve 0,0,$_mymin,255,255",ycbcr_cr,0
apply_channels "-apply_curve 0,0,0,255,$_mymax",ycbcr_cb,0
fi
if {$2<0}
_mymin={-$2}
_mymax={255+$2}
apply_channels "-apply_curve 0,0,$_mymin,255,255",ycbcr_cb,0
apply_channels "-apply_curve 0,0,0,255,$_mymax",ycbcr_cr,0
fi
if {$3!=1.0}
fx_equalize_s $3,0
fi
if {$4!=1.0}
apply_channels "-apply_gamma $4",hsv_s,0
fi
if {$5!=0}
_p1={64-$5}
_p2={192+$5}
_ystr=$_ystr" apply_curve 1,0,0,64,$_p1,192,$_p2,255,255"
fi
if {$6!=0}
_p3={64-$6}
_ystr=$_ystr" apply_curve 1,0,0,64,$_p3,128,128,192,192,255,255"
fi
if {$7!=0}
_p4={192+$7}
_ystr=$_ystr" apply_curve 1,0,0,64,64,128,128,192,$_p4,255,255"
fi
if {$8>0}
_ystr=$_ystr" apply_curve 1,$8,0,64,64,255,255"
fi
if {$9>0}
_p5=0
_ystr=$_ystr" apply_curve 0,0,$9,255,255"
fi
if {$9<0}
_p5={255+$9}
_ystr=$_ystr" apply_curve 0,0,0,255,$_p5"
fi
if {$10>0}
_p6=$10
_p7={255-$10}
_ystr=$_ystr" apply_curve 0,0,0,$_p6,0,$_p7,255,255,255"
fi
if {$10<0}
_p6={-$10}
_p7={255+$10}
_ystr=$_ystr" apply_curve 0,0,$_p6,255,$_p7"
fi
if {$11!=1.0}
_ystr=$_ystr" apply_gamma $11"
fi
if {'$_ystr'!=0}
apply_channels $_ystr,hsv_v,0
fi
if {$12>0}
to_rgb +rgb2hsl s. c rm.. rm.. *. 255 apply_curve. 1,0,0,63,0,127,255,192,0,255,0 +unsharp[0] 5%,$12,0 c. 0,255 c.. 0,255 rv[-1,-2] a[-1,-2] c blend alpha
fi
if {$13>0}
unsharp 1%,$13,0
c. 0,255
fi
if {$14}
if {$16+$22>360}
_shh={($16+$22-360)/360}
else
_shh={($16+$22)/360}
fi
_shs={$21/100}
_shlev={$23}
_midh={$19/360}
_mids={$18/100}
_midlev={$20}
_highh={$16/360}
_highs={$15/100}
_highlev={$17}
_satlev={$24}
color_grade $_shh,$_shs,$_shlev,$_midh,$_mids,$_midlev,$_highh,$_highs,$_highlev,$_satlev
fi
if {$24!=1.0}
fx_equalize_s $24,0
fi
if {$25>0}
unsharp 0.5,$25
c 0,255
fi
if {$26>0}
apply_channels "-denoise_haar $26",ycbcr_cb,0
apply_channels "-denoise_haar $26",ycbcr_cr,0
fi
color_grade :
_shadownrgb=${-jl_hsv_to_rgb" "$1,1.0,{$2*0.40}}
_midtonesrgb=${-jl_hsv_to_rgb" "$4,1.0,{$5*0.40}}
_highlightsrgb=${-jl_hsv_to_rgb" "$7,1.0,{$8*0.40}}
_crsh=${-arg" 1,"$_shadownrgb}
_mgsh=${-arg" 2,"$_shadownrgb}
_ybsh=${-arg" 3,"$_shadownrgb}
_shlev=$3
_crmid=${-arg" 1,"$_midtonesrgb}
_mgmid=${-arg" 2,"$_midtonesrgb}
_ybmid=${-arg" 3,"$_midtonesrgb}
_midlev=$6
_crhigh=${-arg" 1,"$_highlightsrgb}
_mghigh=${-arg" 2,"$_highlightsrgb}
_ybhigh=${-arg" 3,"$_highlightsrgb}
_highlev=$9
_satlev=$10
_lowinred=0
_hiinred=255
_lowingreen=0
_hiingreen=255
_lowinblue=0
_hiinblue=255
_gammared=0.
_gammagreen=0.
_gammablue=0.
_lowoutred=0
_hioutred=255
_lowoutgreen=0
_hioutgreen=255
_lowoutblue=0
_hioutblue=255
if {$_crmid>0.}
_gammared={$_gammared+0.4*$_crmid/100.}
_gammagreen={$_gammagreen-0.3*$_crmid/100.}
_gammablue={$_gammablue-0.3*$_crmid/100.}
fi
if {$_crmid<0.}
_gammared={$_gammared+0.3*$_crmid/100.}
_gammagreen={$_gammagreen-0.4*$_crmid/100.}
_gammablue={$_gammablue-0.4*$_crmid/100.}
fi
if {$_mgmid>0.}
_gammared={$_gammared-0.3*$_mgmid/100.}
_gammagreen={$_gammagreen+0.4*$_mgmid/100.}
_gammablue={$_gammablue-0.3*$_mgmid/100.}
fi
if {$_mgmid<0.}
_gammared={$_gammared-0.4*$_mgmid/100.}
_gammagreen={$_gammagreen+0.3*$_mgmid/100.}
_gammablue={$_gammablue-0.4*$_mgmid/100.}
fi
if {$_ybmid>0.}
_gammared={$_gammared-0.3*$_ybmid/100.}
_gammagreen={$_gammagreen-0.3*$_ybmid/100.}
_gammablue={$_gammablue+0.4*$_ybmid/100.}
fi
if {$_ybmid<0.}
_gammared={$_gammared-0.4*$_ybmid/100.}
_gammagreen={$_gammagreen-0.4*$_ybmid/100.}
_gammablue={$_gammablue+0.3*$_ybmid/100.}
fi
_gammared={$_gammared+1.}
_gammagreen={$_gammagreen+1.}
_gammablue={$_gammablue+1.}
if {$_midlev>0.}
_gammared={$_gammared+0.4*$_midlev/100.}
_gammagreen={$_gammagreen+0.4*$_midlev/100.}
_gammablue={$_gammablue+0.4*$_midlev/100.}
fi
if {$_midlev<0.}
_gammared={$_gammared+0.3*$_midlev/100.}
_gammagreen={$_gammagreen+0.3*$_midlev/100.}
_gammablue={$_gammablue+0.3*$_midlev/100.}
fi
_crsh={$_crsh*0.3}
_mgsh={$_mgsh*0.3}
_ybsh={$_ybsh*0.3}
if {$_crsh>0}
_lowingreen={$_lowingreen+$_crsh}
_lowinblue={$_lowinblue+$_crsh}
_lowoutred={$_lowoutred+$_crsh}
else
_lowinred={$_lowinred-$_crsh}
_lowoutgreen={$_lowoutgreen-$_crsh}
_lowoutblue={$_lowoutblue-$_crsh}
fi
if {$_mgsh>0}
_lowinred={$_lowinred+$_mgsh}
_lowinblue={$_lowinblue+$_mgsh}
_lowoutgreen={$_lowoutgreen+$_mgsh}
else
_lowingreen={$_lowingreen-$_mgsh}
_lowoutred={$_lowoutred-$_mgsh}
_lowoutblue={$_lowoutblue-$_mgsh}
fi
if {$_ybsh>0}
_lowinred={$_lowinred+$_ybsh}
_lowingreen={$_lowingreen+$_ybsh}
_lowoutblue={$_lowoutblue+$_ybsh}
else
_lowinblue={$_lowinblue-$_ybsh}
_lowoutred={$_lowoutred-$_ybsh}
_lowoutgreen={$_lowoutgreen-$_ybsh}
fi
if {$_shlev>0}
_lowoutred={$_lowoutred+$_shlev}
_lowoutgreen={$_lowoutgreen+$_shlev}
_lowoutblue={$_lowoutblue+$_shlev}
fi
if {$_shlev<0}
_lowinred={$_lowinred-$_shlev}
_lowingreen={$_lowingreen-$_shlev}
_lowinblue={$_lowinblue-$_shlev}
fi
_crhigh={$_crhigh*0.3}
_mghigh={$_mghigh*0.3}
_ybhigh={$_ybhigh*0.3}
if {$_crhigh>0}
_hiinred={$_hiinred-$_crhigh}
_hioutgreen={$_hioutgreen-$_crhigh}
_hioutblue={$_hioutgreen-$_crhigh}
else
_hiingreen={$_hiingreen+$_crhigh}
_hiinblue={$_hiinblue+$_crhigh}
_hioutred={$_hioutred+$_crhigh}
fi
if {$_mghigh>0}
_hiingreen={$_hiingreen-$_mghigh}
_hioutred={$_hioutred-$_mghigh}
_hioutblue={$_hioutblue-$_mghigh}
else
_hiinred={$_hiinred+$_mghigh}
_hiinblue={$_hiinblue+$_mghigh}
_hioutgreen={$_hioutgreen+$_mghigh}
fi
if {$_ybhigh>0}
_hiinblue={$_hiinblue-$_ybhigh}
_hioutred={$_hioutred-$_ybhigh}
_hioutgreen={$_hioutgreen-$_ybhigh}
else
_hiinred={$_hiinred+$_ybhigh}
_hiingreen={$_hiingreen+$_ybhigh}
_hioutblue={$_hioutblue+$_ybhigh}
fi
if {$_highlev>0}
_hiinred={$_hiinred-$_highlev}
_hiingreen={$_hiingreen-$_highlev}
_hiinblue={$_hiinblue-$_highlev}
fi
if {$_highlev<0}
_hioutred={$_hioutred+$_highlev}
_hioutgreen={$_hioutgreen+$_highlev}
_hioutblue={$_hioutblue+$_highlev}
fi
levels $_lowinred,$_hiinred,$_gammared,$_lowoutred,$_hioutred,19
levels $_lowingreen,$_hiingreen,$_gammagreen,$_lowoutgreen,$_hioutgreen,20
levels $_lowinblue,$_hiinblue,$_gammablue,$_lowoutblue,$_hioutblue,21
jl_colorgrading_preview :
gui_split_preview "-jl_colorgrading $*",$-1
#@gui Color Mask [Interactive] : fx_mask_color, gui_no_preview
#@gui : Color Metric = _choice(13,"RGB [all]","RGB [red]","RGB [green]","RGB [blue]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [all]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [all]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [all]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [all]","HSI [intensity]","HSL [all]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Spatial Tolerance = _float(10,0,100)
#@gui : Color Tolerance = _float(5,0,100)
#@gui : sep = separator()
#@gui : Output Mode = _choice(0,"Masked image","Color mask")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter is CPU consuming, so use it at least with 4+ cores (or reduce the size of the interactive window to speed up computation).</small>"}
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive window to build your color mask :\n\n
#@gui : - <b>Left mouse button</b> make the color pointed by the mouse wanted for the mask.\n
#@gui : - <b>Right mouse button</b> make the color pointed by the mouse unwanted for the mask.\n
#@gui : - <b>Middle mouse button</b> or key <b>R</b> resets color mask.\n
#@gui : - Key <b>SPACE</b> or <b>TAB</b> toggles view modes (half/full-masked RGB or color mask).\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> resets window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>01/20/2017</i>.</small>")
fx_mask_color :
cs=rgb,rgb_r,rgb_g,rgb_b,lrgb,lrgb_r,lrgb_g,lrgb_b,ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,lab,lab_l,lab_ab,lab_a,lab_b,lch,lch_c,lch_h,\
hsv,hsv_h,hsv_s,hsv_v,hsi,hsi_i,hsl,hsl_l,cmyk_c,cmyk_m,cmyk_y,cmyk_k,yiq_y,yiq_iq
repeat $! l[$<] to_rgb nm={n} nm ${-gui_layer_name}
+x_mask_color ${arg\ 1+$1,$cs},$2,$3
if {$4==1} channels. 100% fi
nm $nm rv
endl done
#@gui Color Temperature : fx_tk_colortemp, fx_tk_colortemp_preview
#@gui : Color Temperature = float(0,-20,20)
#@gui : Automatic Color Balance = bool(0)
#@gui : sep = separator()
#@gui : Preview Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2012/04/05</i>.</small>")
fx_tk_colortemp :
-repeat $! -l[$>] -if {$2==1} --luminance[-1] -to_rgb[-2]
-s[-2] c  avb={-2,127.5-ia} avg={-3,127.5-ia} avr={-4,127.5-ia}
-+[-4] $avr -+[-3] $avg -+[-2] $avb -a[-4,-3,-2] c -rv -compose_luminance -endif
-fx_mix_lab 1,0,0,1,{if({$1>=0},{$1/4},{$1*0.75})},0,1,$1,0,0,2,0 -endl -done
fx_tk_colortemp_preview :
-gui_split_preview "-fx_tk_colortemp ${1--2}",$-1
#@gui Curves : fx_curves_interactive, fx_curves_interactive_preview
#@gui : Colorspace = choice{"RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr"}
#@gui : Output Preset as a HaldCLUT Layer = _choice("Disable","Lowres CLUT","Highres CLUT")
#@gui : Apply Transformation From = _choice("New Curves [Interactive]","Curves Previously Defined")
#@gui : Colorspace = value(0)
#@gui : Keypoints = value(0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Description:</b>\n
#@gui : This filter allows to apply color curves on your images, in many different colorspaces.
#@gui : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the G'MIC interactive windows and start building your color curves.
#@gui : When you're done, exit the main image window: your modified result will be transferred back to the host software.\n\n
#@gui : Once you've set curves, you can save them by pressing the <b>Add to faves</b> button below the filter tree.
#@gui : To clear control points for your curves, click on the <i>Reset</i> button above.
#@gui : </small>"}
#@gui : sep = separator()
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive windows to manage your colorization :\n\n
#@gui : - <b>Left mouse button</b> on a curve creates a new color control point (or move an existing one).\n
#@gui : - <b>Right mouse button</b> on a control point deletes it.\n
#@gui : - <b>Left mouse button</b> on the main image window shows the initial image until button is released.\n
#@gui : - <b>Right mouse button</b> on the main image window adds a keypoint to all curves from picked color.\n
#@gui : - Key <b>R</b> on a curve resets it.\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> resets window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> close the current window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>09/28/2014</i>.</small>")
fx_curves_interactive :
nm "Color curves"
repeat 4 __xcc_C$>=0,0,100,100 done
if {$4==$1} l[] (${5--1}) s -,-1 repeat $! __xcc_C$>={$>,^} done rm endl fi
if $3 _xcc_colorbase=${arg\ {$4+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr} x_color_curves last
else
x_color_curves ${arg\ {$1+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr}
u "{$1}{$2}{$3}{$1}{"$__xcc_C0,-1,$__xcc_C1,-1,$__xcc_C2,-1,$__xcc_C3,-1,$__xcc_C4"}"
fi
if $2
(0,255) (0;255) (0/255) r[-3--1] 2,2,2 a[-3--1] c
if {$2==2} r. 256,256,256,3,3 r. 4096,4096,1,3,-1
else r. 64,64,64,3,3 r. 512,512,1,3,-1
fi
x_color_curves. last
fi
fx_curves_interactive_preview :
fx_curves_interactive $1,0,1,${4--1}
#@gui Customize CLUT : fx_customize_clut,fx_customize_clut_preview(1)+
#@gui : Keypoint Influence (%) = float(100,0,100)
#@gui : Lock Uniform Sampling = choice{0,"None","8 Keypoints (RGB Corners)","27 Keypoints","64 Keypoints","125 Keypoints","216 Keypoints","343 Keypoints"},
#@gui : Spatial Regularization = int(10,0,30)
#@gui : sep = separator()
#@gui : note = note("<small><b>Global correction:</b></small>")
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Post-Normalize = bool(0)
#@gui : sep = separator()
#@gui : Output Corresponding CLUT = _choice("Disable","512x512 Layer","4096x4096 Layer")
#@gui : Preview Type = choice{8,"Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Horizontal","Duplicate Vertical","HaldCLUT","3D CLUT (Fast)","3D CLUT (Precise)"}
#@gui : CLUT Opacity = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Color correspondences:</b></small>")
#@gui : Action #1 = choice(1,"Ignore","Lock Source","Replace Source by Target"), Source Color #1 = color(0,0,0), Target Color #1 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #2 = choice(1,"Ignore","Lock Source","Replace Source by Target"), Source Color #2 = color(255,255,255), Target Color #2 = color(255,196,128)
#@gui : sep = separator()
#@gui : Action #3 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #3 = color(0,0,0), Target Color #3 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #4 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #4 = color(0,0,0), Target Color #4 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #5 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #5 = color(0,0,0), Target Color #5 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #6 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #6 = color(0,0,0), Target Color #6 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #7 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #7 = color(0,0,0), Target Color #7 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #8 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #8 = color(0,0,0), Target Color #8 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #9 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #9 = color(0,0,0), Target Color #9 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #10 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #10 = color(0,0,0), Target Color #10 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #11 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #11 = color(0,0,0), Target Color #11 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #12 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #12 = color(0,0,0), Target Color #12 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #13 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #13 = color(0,0,0), Target Color #13 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #14 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #14 = color(0,0,0), Target Color #14 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #15 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #15 = color(0,0,0), Target Color #15 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #16 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #16 = color(0,0,0), Target Color #16 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #17 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #17 = color(0,0,0), Target Color #17 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #18 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #18 = color(0,0,0), Target Color #18 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #19 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #19 = color(0,0,0), Target Color #19 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #20 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #20 = color(0,0,0), Target Color #20 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #21 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #21 = color(0,0,0), Target Color #21 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #22 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #22 = color(0,0,0), Target Color #22 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #23 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #23 = color(0,0,0), Target Color #23 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #24 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #24 = color(0,0,0), Target Color #24 = color(0,0,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/14/06</i>.</small>")
fx_customize_clut :
if {!narg($_N)} N=64 else N=$_N fi N1={$N-1}
$N,$N,$N,4
if $2
uniform_distribution {(1+$2)^3},3
repeat {w} point.. {round($N1*I[$>])},1,{255*I[$>]},1 done rm.
fi
$=arg
repeat 24
mode=${arg{13+7*$<}}
if $mode
sr=${arg{14+7*$<}} sg=${arg{15+7*$<}} sb=${arg{16+7*$<}}
tr=${arg{17+7*$<}} tg=${arg{18+7*$<}} tb=${arg{19+7*$<}}
xyz={round(($N1/255)*[$sr,$sg,$sb])}
point. $xyz,1,{$mode==2?[$tr,$tg,$tb]:[$sr,$sg,$sb]},1
fi
done
s c,-3
if {$1<100}
+distance. 1
if $1 ^. {1/(0.05+4*$1%)} else f. 0 fi
n. 0,1 nm. influence mv. -3
fi
==. 0 inpaint_diffusion.. .,100%,1,20 rm. c. 0,255
if $influence
100%,100%,100%,3,[x,y,z] n. 0,255
j. ..,0,0,0,0,1,...
rm[-3,-2]
fi
if {!$3} map_clut[^-1] .
else repeat {$!-1}
+luminance[$>] +map_clut[$>] .. -. [$>]
repeat $3 guided. ..,2,50 done +[$>,-1] rm.
done fi
adjust_colors ${4-8},0,255
if $9 repeat $! l[$>] split_opacity n[0] 0,255 a c endl done fi
if $10
if {$10==2} r. 256,256,256,3,5 c. 0,255 fi
siz={w^1.5} r. $siz,$siz,1,3,-1
mv. 0
else rm.
fi
fx_customize_clut_preview :
if {$11<7} gui_split_preview "fx_customize_clut ${1-9},0,0,${12--1}",$11
elif {$11==7}
rm fx_customize_clut ${1-9},1,0,${12--1}
elif {$11>=8}
_N={$11>=9?64:32}
k[0] to_rgb w={w} h={h}
+fx_customize_clut ${1-9},1,0,${12--1} mv. 1
r. $_N,$_N,$_N,3,-1 pointcloud3d. o3d. $12
l[]
if $2
uniform_distribution {(1+$2)^3},3
repeat {w} circle3d {0,round($_N*I[$>])},0.75 col3d. {0,255*I[$>]} done rm[0]
fi
$=arg
repeat 24
mode=${arg{13+7*$<}}
if $mode
sr=${arg{14+7*$<}} sg=${arg{15+7*$<}} sb=${arg{16+7*$<}}
tr=${arg{17+7*$<}} tg=${arg{18+7*$<}} tb=${arg{19+7*$<}}
xy={round(($_N/255)*[$sr,$sg])}
z={round(($_N/255)*$sb)-0.1}
circle3d $xy,$z,0.75 col3d. {$mode==2?[$tr,$tg,$tb]:[$sr,$sg,$sb]}
fi
done
colorcube3d *3d. {$_N/255} o3d. 0.5 col3d. 0 p3d. 1
endl
+3d[2--1]
pose3d. 5.10656,2.04904,2.723,-316.115,-0.0815767,4.97762,-3.59262,-41.7094,-3.40685,2.95212,4.16756,-118.811,0,0,203,1
if {$w>$h}
r2dx[0,1] {0,round(w/2)}
to[0] "Before",2,0,13,1,0.75
to[1] "After",2,0,13,1,0.75
a[0,1] y r[0] 100%,$h,1,3,0
else
r2dy[0,1] {0,round(h/2)}
to[0] "Before",2,0,13,1,0.75
to[1] "After",2,0,13,1,0.75
a[0,1] x r[0] $w,100%,1,3,0
fi
snapshot3d. {0,1.1*min(w,h)},1.2,64,64,64 autocrop. -. 64 r. {0,max(w,$w-w)},{0,max(h,$h-h)},1,3,0,0,0.5,0.5 +. 64
to. "RGB CLUT",2,0,13,1,0.75
a {`$w>$h?_'x':_'y'`}
fi
#@gui Darken Sky : fx_darken_sky, fx_darken_sky_preview(1)
#@gui : Strength = float(.75,0,1)
#@gui : Contrast = float(5,0,5)
#@gui : Blend Mode = choice(0,"Overlay","Softlight")
#@gui : sep = separator(), Normalize = bool(1)
#@gui : Brighten = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("Based on <a href="https://discuss.pixls.us/t/deep-blue-sky-effect/4506"><i>Carmelo_DrRaw</i>'s tutorial</a>")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="https://discuss.pixls.us/u/afre">Afre/pixls.us</a></i>.      Latest update: <i>2017/01/07</i>.</small>")
fx_darken_sky :
mode=${-arg\ 1+$3,overlay,softlight}
-repeat $! -l[$>] -split_opacity -l[0]
-if {iM>255} -/ 257 bit=1 -endif
--l
-s c -rm.. -remove_hotpixels.. 5 -guided.. .,1,{.01*255^2}
-- -- {im} -min 128 -- 128 -* {(5+$2)/10} -+ 128
-endl
-blend $mode,$1
-if $4 -n 0,255 -endif
-apply_curve 1,0,0,{ia},{ia+(sqrt(iv)*$5/2)},255,255
-if $bit -* 257 -endif
-endl -a c -endl -done
fx_darken_sky_preview :
-gui_split_preview "-fx_darken_sky $*",$-1
#@gui Decompose Channels : fx_decompose_channels, fx_decompose_channels_preview
#@gui : Color Basis = choice(7,"RGB","HSV","HSL","HSI","YUV","YCbCr","XYZ","Lab","Lch","CMY","CMYK","YIQ")
#@gui : Action = choice("Decompose","Recompose")
#@gui : Output Multiple Layers = _bool(0)
#@gui : Include Opacity Layer = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/19/07</i>.</small>")
fx_decompose_channels :
if {!$2}
if $4 to_rgba else to_rgb fi
repeat $! l[$<] nm={0,n}
split_opacity
_s3=A _s4=A
_fx_decompose_channels$1[0]
s[0] c
if {!$3} a x nm $nm
else nm=${-gui_layer_name} repeat $! gui_set_layer_name[$>] {``$nm}" ["${_s$>}"]" done
fi
endl done
else
channels 0 nbc={3+($1==10)} nb={$nbc+$4}
if $3 repeat {int($!/$nb)} l[0-{$nb-1}]
a[0-{$nbc-1}] c _fx_recompose_channels$1[0] a c
endl mv. 0 done
else repeat $! l[$>]
s x,$nb a[0-{$nbc-1}] c _fx_recompose_channels$1[0] a c
endl mv. 0 done fi
fi
fx_decompose_channels_preview :
repeat $! l[$<]
_s3=A _s4=A
fx_decompose_channels $1,$2,1,$4
if {!$2}
fs={round(min(w,h)*15%)}
repeat $! to[$>] ${_s$>},5,3,$fs,{max(2,round($fs/15))} done
to_rgba
fi
endl done
append_tiles ,
_fx_decompose_channels0 : _s0=R _s1=G _s2=B
_fx_decompose_channels1 : rgb2hsv8 _s0=H _s1=S _s2=V
_fx_decompose_channels2 : rgb2hsl8 _s0=H _s1=S _s2=L
_fx_decompose_channels3 : rgb2hsi8 _s0=H _s1=S _s2=I
_fx_decompose_channels4 : rgb2yuv8 _s0=Y _s1=U _s2=V
_fx_decompose_channels5 : rgb2ycbcr _s0=Y _s1=Cb _s2=Cr
_fx_decompose_channels6 : rgb2xyz8 _s0=X _s1=Y _s2=Z
_fx_decompose_channels7 : rgb2lab8 _s0=L _s1=a _s2=b
_fx_decompose_channels8 : rgb2lch8 _s0=L _s1=c _s2=h
_fx_decompose_channels9 : rgb2cmy _s0=C _s1=M _s2=Y
_fx_decompose_channels10 : rgb2cmyk _s0=C _s1=M _s2=Y _s3=K
_fx_decompose_channels11 : rgb2yiq8 _s0=Y _s1=I _s2=Q
_fx_recompose_channels0 :
_fx_recompose_channels1 : hsv82rgb
_fx_recompose_channels2 : hsl82rgb
_fx_recompose_channels3 : hsi82rgb
_fx_recompose_channels4 : yuv82rgb
_fx_recompose_channels5 : ycbcr2rgb
_fx_recompose_channels6 : xyz82rgb
_fx_recompose_channels7 : lab82rgb
_fx_recompose_channels8 : lch82rgb
_fx_recompose_channels9 : cmy2rgb
_fx_recompose_channels10 : cmyk2rgb
_fx_recompose_channels11 : yiq82rgb
#@gui Detect Skin : fx_detect_skin, fx_detect_skin_preview(1)
#@gui : Skin Estimation = choice(1,"Manual","Automatic")
#@gui : sep = separator()
#@gui : Tolerance = float(0.5,0,1)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Threshold = float(1,0,10)
#@gui : Pre-Normalize Image = bool(1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Manual estimation:</b>\n
#@gui : Use the sliders below to target as much skin pixels as you can.</small>")
#@gui : X-Coordinate = float(50,0,100)
#@gui : Y-Coordinate = float(50,0,100)
#@gui : Radius = float(5,0,25)
#@gui : sep = separator()
#@gui : Output Mode = choice(1,"Probability Map","Opaque Skin","Transparent Skin")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/03/01</i>.</small>")
fx_detect_skin :
to_rgb
m "_fx_detect_skin :
if $5 balance_gamma 128,128,128 fi
if $1 detect_skin $2 else detect_skin $2,$6%,$7%,$8% fi
M={iM} b $3% * {255*$M/iM} * $4 c 0,255"
repeat $! l[$>]
if $9
+_fx_detect_skin a c
if {$9>1} sh 100% *. -1 +. 255 rm. fi
else _fx_detect_skin
fi
endl done
uncommand _fx_detect_skin
fx_detect_skin_preview :
gui_split_preview "fx_detect_skin $*",${-3--1}
to_rgba
if {!$1}
circle $6%,$7%,$8%,0.3,0,255,0,255
circle $6%,$7%,$8%,1,0xFFFFFFFF,0,255,0,255
line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
fi
#@gui Equalize HSI-HSL-HSV : fx_equalize_hsv, fx_equalize_hsv_preview(0)+
#@gui : Colorspace = choice(1,"HSI","HSL","HSV")
#@gui : Opacity (%) = float(100,0,100)
#@gui : Value Blending = float(0,0,64)
#@gui : Color Blending = float(0,0,64)
#@gui : sep = separator()
#@gui : Preview Mapping = choice("None","Grey","Color")
#@gui : sep = separator(), note = note("<small><b>Black:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Near black:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Dark grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Mi-dark grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Middle grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Mid-light grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Light grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Highlights:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>White:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>David Revoy</i>.      Latest Update: <i>2018/01/19</i>.</small>")
fx_equalize_hsv :
cs=${"arg 1+$1,hsi,hsl,hsv"}
repeat $! l[$>] split_opacity l[0]
to_rgb
9,1,1,4,\
{"V = [${6-30:3}]*pi/180; [cos(V),sin(V)]"},${7-31:3},\
{"V = [${8-32:3}];
const sV = size(V);
for (k = 0, k<sV, ++k,
v0 = k/sV;
v1 = (k+1)/sV;
V[k]*=(V[k]>0?(1 - v0):v1);
); V"}
r. 256,1,1,4,1
sh. 3 b. $3 rm.
f. "[ atan2(G,R)*180/pi,B,A,0 ]" channels. 0,2
+rgb2$cs.. +channels. 100% *. 256 round. map. ...
+[-2,-1] rm.. +channels. 100% ${cs}2rgb..
if $4
*. 255 bilateral.. .,$4,{2+$4}
rgb2$cs.. /. 255 j.. .,0,0,0,2 ${cs}2rgb..
fi
rm.
blend alpha,{$2%}
endl a c endl done
fx_equalize_hsv_preview :
if $5
cs=${"arg 1+$1,hsi,hsl,hsv"}
rm {0.8*[${-gui_preview_wh}]},1,3,\
"$5==1?
(H = S = 0; V = y/(h-1)):
(H = x*360/(w-1); S = y/(h-1); V = y/(h-1));
[H,S,V]"
${cs}2rgb.
fi
gui_split_preview "fx_equalize_hsv $*",${-3--1}
if $5 r. ${-gui_preview_wh},1,3,0,0,0.5,0.5 fi
#@gui Equalize HSV : fx_hsv_equalizer, fx_hsv_equalizer_preview
#@gui : Preview Bands = bool(false)
#@gui : sep = separator()
#@gui : Hue Band = float(180,0,360)
#@gui : Band Width = float(40,1,360)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Saturation Correction = float(0,-0.99,0.99)
#@gui : Value Correction = float(0,-0.99,0.99)
#@gui : sep = separator()
#@gui : Hue Band = float(180,0,360)
#@gui : Band Width = float(40,1,360)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Saturation Correction = float(0,-0.99,0.99)
#@gui : Value Correction = float(0,-0.99,0.99)
#@gui : sep = separator()
#@gui : Hue Band = float(180,0,360)
#@gui : Band Width = float(40,1,360)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Saturation Correction = float(0,-0.99,0.99)
#@gui : Value Correction = float(0,-0.99,0.99)
#@gui : sep = separator()
#@gui : note = note("<small>Author: <i>J&#233;rome Ferrari</i>.      Latest Update: <i>01/14/2011</i>.</small>")
#@gui : url = link("Filter explained here","http://www.flickr.com/groups/gmic/discuss/72157625798533482")
fx_hsv_equalizer :
repeat $! l[$>]
to_rgb rgb2hsv s c
+f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
+f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
+f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0)
+threshold[1,2] 0.01 *[-1,-2] [-1]x2 *[-1,3] *[-1,4] *[-1,5]
+*[3] $4 +*[4] $9 +*[5] $14 +[-1,-2,-3]
+[-1,0] %[0] 360
if {$5>=0} +*[3] -$5 else +*[3] {1/(1+$5)-1} fi +. 1
if {$10>=0} +*[4] -$10 else +*[4] {1/(1+$10)-1} fi +. 1
if {$15>=0} +*[5] -$15 else +*[5] {1/(1+$15)-1} fi +. 1
*[-1,-2,-3] ^[1,-1]
if {$6>=0} +*[3] -$6 else +*[3] {1/(1+$6)-1} fi +. 1
if {$11>=0} +*[4] -$11 else +*[4] {1/(1+$11)-1} fi +. 1
if {$16>=0} +*[5] -$16 else +*[5] {1/(1+$16)-1} fi +. 1
*[-1,-2,-3] ^[2,-1]
rm[3,4,5] a[0,1,2] c hsv2rgb
endl done
fx_hsv_equalizer_preview :
l.
if {$1==0} fx_hsv_equalizer $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
else
to_rgb rgb2hsv s c
(0,359) r. ..,{{0,h}/10},1,1,3 . f. 1
j[0] [3],0,91% j[1] [4],0,91% j[2] [4],0,91% rm[-1,-2]
+f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
+f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
+f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0)
-|[-3--1] +. 0.33 /. 1.33
*[2,-1] a c hsv2rgb
fi endl
#@gui HSL Adjustment : gcd_hsl, gcd_hsl_preview(1)
#@gui : note = note("\n<i>Input Saturation Settings</i>"), sep = separator()
#@gui : Contrast = float(1,0,2)
#@gui : Level = float(0,-1,1)
#@gui : Auto Reduce Level (Level Slider Is Disabled) = bool(0)
#@gui : note = note("\n<i>Output Hue Settings</i>"), sep = separator()
#@gui : Hue = float(180,0,360)
#@gui : Amount = float(0.2,0,1)
#@gui : Auto Set Hue Inverse (Hue Slider Is Disabled) = bool(0)
#@gui : note = note("\n<i>Output Luminance Settings</i>"), sep = separator()
#@gui : Gamma = float(1,0,2)
#@gui : Contrast = float(1,0,2)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/05/15</i>.</small>")
gcd_hsl : -skip ${1=1},${2=0},${3=0},${4=180},${5=0.2},${6=0},${7=1},${8=1}
-repeat $! -l[$>]
-split_opacity -to_rgb[0] -rgb2hsv[0]
-if $6
--channels[0] 0
-histogram[-1] 360,0,360
hue={(xM+180)%360} -rm[-1]
-else hue=$4 -endif
-sh[0] 1,1
-if $3 sat={-max(0,ia-0.5)} -else sat=$2 -endif
--[-1] 0.5 -*[-1] $1 -+[-1] $sat
-+[-1] 0.5 -c[-1] 0,1 -rm[-1]
-hsv2rgb[0]
--channels[0] 0 -*[-1] 66
--channels[0] 1 -*[-1] 129 -+[-2,-1]
--channels[0] 2 -*[-1] 25 -+[-2,-1]
-+[-1] 128 -/[-1] 256 -+[-1] 16
-apply_gamma[-1] {max(0.001,$7)}
-if {$8!=1} --[-1] 128 -*[-1] $8 -+[-1] 128 -endif
-c[-1] 0,255
-sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
($hue^1^1) -hsv2rgb[-1] -n[-1] {1-$5},1
-*[-4] {@0} -*[-3] {@1} -*[-2] {@2}
-rm[-4--1] -rgb2ycbcr[0] -j[0] [-1] -rm[-1]
-ycbcr2rgb[0] -a c
-endl -done
gcd_hsl_preview :
-gui_split_preview "-gcd_hsl ${1--2}",$-1
#@gui HSV Select : gcd_hsv_select, gcd_hsv_select(2)
#@gui : note = note("<i>Color Selection</i>"), sep = separator()
#@gui : Hue = int(0,0,360)
#@gui : Saturation = float(0.5,0,1)
#@gui : Value = float(1,0,1)
#@gui : note = note("\n<i>Color Range</i>"), sep = separator()
#@gui : Hue Range = int(180,0,180)
#@gui : Sat Range = float(0.5,0,0.5)
#@gui : Val Range = float(0.5,0,0.5)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Grow Alpha = int(2,-20,20)
#@gui : Blur Alpha = int(2,0,20)
#@gui : note = note("\n<i>Advanced Options</i>"), sep = separator()
#@gui : Patch Size = int(18,3,100)
#@gui : Fill Holes % = int(0,0,50)
#@gui : Min Area % = int(0,0,50)
#@gui : Show Watershed = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/11</i>.</small>")
gcd_hsv_select :
-skip ${1=0},${2=0.5},${3=1} -skip ${4=180},${5=0.5},${6=0.5}
-skip ${7=2},${8=2} -skip ${9=18},${10=0},${11=0},${12=0}
-repeat $! -l[$>]
-to_rgba[0] -remove_opacity[0]
-if {!$12} [0] -endif
-l[-1]
-gcd_shrink
--rgb2hsv[0] -s[-1] c
bh={$1-$4} th={$1+$4}
--ge[1] {360+$bh} --le[1] {$th-360}
-ir[1] {max($bh,0)},{min($th,360)}
-or[-2,-1] -or[1,-1]
-ir[2] {$2-$5},{$2+$5}
-ir[3] {$3-$6},{$3+$6}
-and[-2,-1] -and[-2,-1]
-meancurvature_flow[0] 3 -median[0] 3
-+[0] 1 --gradient_norm[0] --b[-1] 2,1,1 -min_patch[-1] $9
-*[0,-1] -*[-1] -1
--*[0] [1] -gt[0] 0 -negate[1] -*[0,1] -*[0] 0.5 -max[0,-1]
--watershed[0] [-1] -k[-1] --[-1] 1
-gcd_unshrink
-endl
-if {!$12}
-channels[-1] 0 -ge[-1] 0
--area[-1] 0 --le[-1] {($10%*max(w,h))^2}
--negate[-3] -*[-2,-1] -inpaint[-3] [-1] -rm[-1]
-le[-1] {($11%*max(w,h))^2} -*[-1] [-2]
-inpaint[-2] [-1] -rm[-1] -*[-1] 255
-if {$7>0} -dilate[-1] $7
-elif {$7<0} -erode[-1] {abs($7)} -endif
-if $8 -b[-1] $8,1,1 -endif
-a[-2,-1] c
-endif
-c[-1] 0,255
-endl -done
#@gui Hue Lighten-Darken : iain_hue_light_dark_p, iain_hue_light_dark_p
#@gui : Red = float(0,-255,255)
#@gui : 2 = float(0,-255,255)
#@gui : 3 = float(0,-255,255)
#@gui : Yellow = float(0,-255,255)
#@gui : 5 = float(0,-255,255)
#@gui : 6 = float(0,-255,255)
#@gui : Green = float(0,-255,255)
#@gui : 8 = float(0,-255,255)
#@gui : Cyan = float(0,-255,255)
#@gui : 10 = float(0,-255,255)
#@gui : 11 = float(0,-255,255)
#@gui : Blue = float(0,-255,255)
#@gui : 13 = float(0,-255,255)
#@gui : 14 = float(0,-255,255)
#@gui : Magenta = float(0,-255,255)
#@gui : 16 = float(0,-255,255)
#@gui : 17 = float(0,-255,255)
#@gui : 18 = float(0,-255,255)
#@gui : sep = separator()
#@gui : Global = float(0,-255,255)
#@gui : HSL = bool (0)
#@gui : sep = separator()
#@gui : Sat Top = float(255,0,255)
#@gui : Sat Bottom = float(100,0,255)
#@gui : Value Top = float(255,0,255)
#@gui : Value Bottom = float(0,0,255)
#@gui : sep = separator()
#@gui : B&W = bool (0)
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
iain_hue_light_dark_p:
-repeat $! -l[$>]
-apply_parallel_overlap "-iain_hue_light_dark ${1--2}",0,${-1}
-endl -done
iain_hue_light_dark:
-repeat $! -l[$>] -split_opacity -l[0]
--l[0]
-to_rgb
-if {$20==0}
-rgb2hsv8
-else
-rgb2hsl8
-endif
-s c
--apply_curve[0] 0,0,{128+$1},16,{128+$2},30,{128+$3},42,{128+$4},60,{128+$5},75,{128+$6},85,{128+$7},105,{128+$8},127,{128+$9},135,{128+$10},150,{128+$11},170,{128+$12},180,{128+$13},195,{128+$14},213,{128+$15},225,{128+$16},240,{128+$17},255,{128+$18}
-sub[-1] 128
-add[-1] $19
-add[-1,-2]
-a c
-if {$20==0}
-hsv82rgb
-else
-hsl82rgb
-endif
-endl
--rgb2hsv[0]
-s[-1] c
-keep[0,1,-1,-2]
-mul[-1,-2] 255
-apply_curve[-2] 0,0,0,$22,0,$21,255,255,255
-apply_curve[-1] 0,0,0,$24,0,$23,255,255,255
-mul[-1] [-2]
-div[-1] 255
-remove[-2]
-c[-1] 0,255
-a[1,2] c
-blend[0,1] alpha
-if {$25==1}
-to_gray
-endif
-endl -a c -endl -done
#@gui Metallic Look : fx_tk_metallic, fx_tk_metallic_preview(1)
#@gui : Strength = float(1,0,1)
#@gui : Smoothness = float(0,0,20)
#@gui : Metal = choice("Silver","Gold","Copper","Bronze","Blue steel")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Tom Keil</i>.      Latest update: <i>2011/12/04</i>.</small>")
fx_tk_metallic :
-repeat $! -l[$>]
-fx_gaussian_blur $2,0,0,1,1,0,0
-luminance --luminance
-fx_apply_curve[1] 0,31,111,64,17,110,176,148,75,177,235,186,1,0,0,0,0
-fx_apply_curve[1] 0,31,111,64,17,110,176,148,75,177,235,186,1,0,0,0,0
-rv[0,1] -fx_compose_value[0,1] $1,0
-if {$3==1} -fx_mix_rgb 1,50,0,1,50,0,1,-50,0,0,2,0
-elif {$3==2} -fx_mix_rgb 1,75,0,1,5,0,1,-25,0,0,2,0
-elif {$3==3} -fx_mix_rgb 1,70,0,1,40,0,1,-20,0,0,2,0
-elif {$3==4} -fx_mix_rgb 1,-5,0,1,0,0,1.1,12,0,0,2,0
-endif -endl -done
fx_tk_metallic_preview :
-gui_split_preview "-fx_tk_metallic ${1--2}",$-1
#@gui Mixer [CMYK] : fx_mix_cmyk, fx_mix_cmyk_preview(1)+
#@gui : Cyan Factor = float(1,0,4)
#@gui : Cyan Shift = float(0,-255,255)
#@gui : Cyan Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Magenta Factor = float(1,0,4)
#@gui : Magenta Shift = float(0,-255,255)
#@gui : Magenta Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Yellow Factor = float(1,0,4)
#@gui : Yellow Shift = float(0,-255,255)
#@gui : Yellow Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Key Factor = float(1,0,4)
#@gui : Key Shift = float(0,-255,255)
#@gui : Key Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_cmyk :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $13,$14
rgb2cmyk. s. c
*[-4] $1 +[-4] $2 b[-4] $3%
*... $4 +... $5 b... $6%
*.. $7 +.. $8 b.. $9%
*. $10 +. $11 b. $12%
a[-4--1] c cmyk2rgb.
fx_end_mix $13
if {$!!=3} rv a c fi endl mv. 0 done
fx_mix_cmyk_preview :
gui_split_preview "fx_mix_cmyk $*",${-3--1}
#@gui Mixer [HSV] : fx_mix_hsv, fx_mix_hsv_preview(1)+
#@gui : Hue Factor = float(1,0,4)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Hue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Saturation Factor = float(1,0,4)
#@gui : Saturation Shift = float(0,-1,1)
#@gui : Saturation Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Value Factor = float(1,0,4)
#@gui : Value Shift = float(0,-1,1)
#@gui : Value Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_hsv :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $10,$11
rgb2hsv. s. c -[-2,-1] 0.5
*... $1 +... $2 b... $3%
*.. $4 +.. $5 b.. $6%
*. $7 +. $8 b. $9%
%... 360 +[-2,-1] 0.5 c[-2,-1] 0,1 a[-3--1] c hsv2rgb.
fx_end_mix $10
if {$!!=3} rv a c fi endl mv. 0 done
fx_mix_hsv_preview :
gui_split_preview "fx_mix_hsv $*",${-3--1}
#@gui Mixer [Lab] : fx_mix_lab, fx_mix_lab_preview(1)+
#@gui : Lightness Factor = float(1,0.5,1.5)
#@gui : Lightness Shift = float(0,-50,50)
#@gui : Lightness Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : A-Color Factor = float(1,0,4)
#@gui : A-Color Shift = float(0,-20,20)
#@gui : A-Color Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : B-Color Factor = float(1,0,4)
#@gui : B-Color Shift = float(0,-20,20)
#@gui : B-Color Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_lab :
repeat $! l[$>] split_opacity to_rgb[0]
gui_parallel_overlap[0] "_fx_mix_lab $*",0,{3*max($3,$6,$9)}
a c
endl mv[$>] 0 done
_fx_mix_lab :
fx_start_mix $10,$11
rgb2lab. s. c
*... $1 +... $2 b... $3%
*.. $4 +.. $5 b.. $6%
*. $7 +. $8 b. $9%
a[-3--1] c lab2rgb.
fx_end_mix $10
fx_mix_lab_preview :
gui_split_preview "fx_mix_lab $*",${-3--1}
#@gui Mixer [PCA] : fx_mix_pca, fx_mix_pca_preview(1)+
#@gui : Primary Factor = float(0,-1.5,1.5)
#@gui : Primary Shift = float(0,-255,255)
#@gui : Primary Twist = float(0,-180,180)
#@gui : sep = separator()
#@gui : Secondary Factor = float(0,-1.5,1.5)
#@gui : Secondary Shift = float(0,-255,255)
#@gui : Secondary Twist = float(0,-180,180)
#@gui : sep = separator()
#@gui : Tertiary Factor = float(0,-1.5,1.5)
#@gui : Tertiary Shift = float(0,-255,255)
#@gui : Tertiary Twist = float(0,-180,180)
#@gui : sep = separator()
#@gui : Display Color Axes = bool(1)
#@gui : Stats = value(-1,-1,-1,-1)
#@gui : Avg Covariance = value(0,0,0,0,0,0,0,0,0,0,0,0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/07/18</i>.</small>")
fx_mix_pca :
repeat $! l[$>] split_opacity l[0] to_rgb
if {[${11-14}]==round(stats()[0,4],0.1)} _avg=${15-17} C=${18-26} status=
else
+rr2d 256,256,0,2 C=${"covariance_colors. _avg"} rm.
__status="{$1}{$2}{$3}{$4}{$5}{$6}{$7}{$8}{$9}{$10}{"{round(stats()[0,4],0.1)}"}{"$_avg,$C"}{$27}{${28,29}}"
fi
f "begin(
avg = ["$_avg"];
eig = eig(["$C"]);
for (k = 3, k<12, k+=3, eig[k]<0?copy(eig[k],eig[k,3]*=-1,3));
Pt = eig[3,9];
P = transp(Pt,3);
T = mul(P,mul(diag(10^[$1,$4,$7]),Pt,3),3);
R1 = rot(eig[3,3],$3);
R2 = rot(eig[6,3],$6);
R3 = rot(eig[9,3],$9);
T = mul(R1,mul(R2,mul(R3,T,3),3),3);
avg_shift = avg + $2*eig[3,3] + $5*eig[6,3] + $8*eig[9,3];
if ("0$_is_preview",
L = [ 2,5,10]*sqrt(1e-5 + eig[0,3]);
ext('__cols=',vtos(round([
avg - L[0]*eig[3,3],
avg + L[0]*eig[3,3],
avg - L[1]*eig[6,3],
avg + L[1]*eig[6,3],
avg - L[2]*eig[9,3],
avg + L[2]*eig[9,3] ])));
);
);
avg_shift + T*(I - avg)"
c 0,255
endl a c endl done u $__status
fx_mix_pca_preview :
_is_preview=1
__status=
repeat $! l[$>]
gui_split_preview "fx_mix_pca $*",${-3--1}
if $10
rr2d ${-gui_preview_wh},0,1
($__cols) r. 3,6,1,1,-1 permute. yzcx s. x,3
r[-3--1] {w#0/2},13,1,3,3 c[-3--1] 0,255
frame[-3--1] 1,1,0
to[0] Primary,4,2,13,1 j[0] ...,64,4
to[0] Secondary,4,17,13,1 j[0] ..,64,19
to[0] Tertiary,4,32,13,1 j[0] .,64,34
k[0]
fi
endl done
u $__status
#@gui Mixer [RGB] : fx_mix_rgb, fx_mix_rgb_preview(1)+
#@gui : Red Factor = float(1,0,4)
#@gui : Red Shift = float(0,-255,255)
#@gui : Red Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Green Factor = float(1,0,4)
#@gui : Green Shift = float(0,-255,255)
#@gui : Green Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Blue Factor = float(1,0,4)
#@gui : Blue Shift = float(0,-255,255)
#@gui : Blue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
fx_mix_rgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $10,$11
-. 128 s. c
*... $1 +... $2 b... $3%
*.. $4 +.. $5 b.. $6%
*. $7 +. $8 b. $9%
a[-3--1] c +. 128 c. 0,255
fx_end_mix $10
if {$!!=3} rv a c fi endl mv. 0 done
fx_mix_rgb_preview :
gui_split_preview "fx_mix_rgb $*",${-3--1}
#@gui Mixer [YCbCr] : fx_mix_ycbcr, fx_mix_ycbcr_preview(1)+
#@gui : Luminance Factor = float(1,0,4)
#@gui : Luminance Shift = float(0,-255,255)
#@gui : Luminance Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Blue Chroma Factor = float(1,0,4)
#@gui : Blue Chroma Shift = float(0,-255,255)
#@gui : Blue Chroma Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Red Chroma Factor = float(1,0,4)
#@gui : Red Chroma Shift = float(0,-255,255)
#@gui : Red Chroma Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_ycbcr :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $10,$11
rgb2ycbcr. -. 128 s. c
*... $1 +... $2 b... $3%
*.. $4 +.. $5 b.. $6%
*. $7 +. $8 b. $9%
a[-3--1] c +. 128 c. 0,255 ycbcr2rgb.
fx_end_mix $10
if {$!!=3} rv a c fi endl mv. 0 done
fx_mix_ycbcr_preview :
gui_split_preview "fx_mix_ycbcr $*",${-3--1}
#@gui Normalize Brightness : gcd_normalize_brightness, gcd_normalize_brightness(1)
#@gui : note = note("<i>Normalize brightness across the image</i>"), sep = separator()
#@gui : Bright = float(0,-2,2)
#@gui : Area = float(10,0,100)
#@gui : Smooth = float(0,0,4)
#@gui : Channels = choice(3,"HSI","HSV","Lab","YCbCr","sRGB")
#@gui : Mask = choice("Normal","Darken","Lighten")
#@gui : Absolute Brightness = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/05/27</i>.</small>")
#@gui : note = note("<small>\n<u>Tips:</u>\n\nDefault settings for de-haze.</small>")
#@gui : note = note("<small>Large area and Lab for very bright images.</small>")
#@gui : note = note("<small>Small area and HSV for very dark images.</small>")
#@gui : note = note("<small>Medium area and HSV for high contrast images.</small>")
#@gui : note = note("<small>Smooth to reduce artifacts, however some detail may be lost.</small>")
gcd_normalize_brightness : -skip ${1=0},${2=10},${3=0},${4=3},${5=0},${6=0}
mode=${-arg\ 1+$4,hsi_i,hsv_v,lab_l,ycbcr_y,rgb}
-if {$3>0} -bilateral 1%,$3 -c 0,255 -endif
-if {$5==0} -ac "-gcd_tonemap_area $2,$1,$6",$mode,2
-else --ac "-gcd_tonemap_area $2,$1,$6",$mode,2 -blend ${-arg\ $5,darken,lighten} -endif
gcd_tonemap_area : -skip ${1=100},${2=0},${3=0}
-repeat $! -l[$>]
-+ 0.5 m={iM+1} -/ $m
-if $3 a={$2/4.001+0.5} -else --^. $2 a={is} -rm. --^. {$2-1} a={$a/is} -rm. -endif
H={1/$a-1} --oneminus -/. .. -b. $1% -^. -1 -*. $H
--oneminus. -*. [0] -+[-2,-1] -/ -* $m -- 0.5
-endl -done
#@gui Retinex : fx_retinex, fx_retinex_preview(0)+
#@gui : Strength (%) = float(75,0,100)
#@gui : Value Offset = float(16,1,256)
#@gui : Colorspace = choice(1,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Min Cut (%) = float(1,0,100)
#@gui : Max Cut (%) = float(1,0,100)
#@gui : Regularization = float(5,0,32)
#@gui : sep = separator()
#@gui : Low Scale = float(15,1,512)
#@gui : Middle Scale = float(80,1,512)
#@gui : High Scale = float(250,1,512)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> This filter implements the <i>Multiscale Color Retinex</i> algorithm, as described in:</small>")
#@gui : url = link{"http://www.ipol.im/pub/art/2014/107/"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/13/09</i>.</small>")
fx_retinex :
repeat $! l[$>]
+retinex $2,${"arg 1+$3,hsi,hsv,lab,lrgb,rgb,ycbcr"},$4,$5,${7--1}
if $6 guided. ..,$6,$6 fi
j[0] .,0,0,0,0,{$1%} rm.
c 0,255
endl done
fx_retinex_preview :
gui_split_preview "fx_retinex $*",${-3--1}
#@gui Retro Fade : fx_retrofade, fx_retrofade_preview
#@gui : Iterations = int(20,1,64)
#@gui : Colors = int(6,2,32)
#@gui : Grain = float(40,1,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/25/10</i>.</small>")
fx_retrofade :
repeat $! l[$>] split_opacity l[0]
+f 0
repeat $1
+noise[0] $3 c. 0,255 autoindex. $2,0,0
+[-2,-1]
progress {$>*100/$1}
done
k. n 0,255
progress 100
endl a c endl done
fx_retrofade_preview :
gui_split_preview "fx_retrofade $*",${-3--1}
#@gui RGB Tone : iain_rgb_tone, iain_rgb_tone
#@gui : note = note{"<b>Adjust Reds</b> for pixels that have:"}
#@gui : Little Red = float(0,-255,255)
#@gui : Some Red = float(0,-255,255)
#@gui : Much Red = float(0,-255,255)
#@gui : note = note{"<b>Adjust Reds</b> for pixels that have:"}
#@gui : Little Green = float(0,-255,255)
#@gui : Some Green = float(0,-255,255)
#@gui : Much Green = float(0,-255,255)
#@gui : note = note{"<b>Adjust Reds</b> for pixels that have:"}
#@gui : Little Blue = float(0,-255,255)
#@gui : Some Blue = float(0,-255,255)
#@gui : Much Blue = float(0,-255,255)
#@gui : sep = separator(xx)
#@gui : note = note{"<b>Adjust Greens</b> for pixels that have:"}
#@gui : Little Red = float(0,-255,255)
#@gui : Some Red = float(0,-255,255)
#@gui : Much Red = float(0,-255,255)
#@gui : note = note{"<b>Adjust Greens</b> for pixels that have:"}
#@gui : Little Green = float(0,-255,255)
#@gui : Some Green = float(0,-255,255)
#@gui : Much Green = float(0,-255,255)
#@gui : note = note{"<b>Adjust Greens</b> for pixels that have:"}
#@gui : Little Blue = float(0,-255,255)
#@gui : Some Blue = float(0,-255,255)
#@gui : Much Blue = float(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Blues</b> for pixels that have:"}
#@gui : Little Red = float(0,-255,255)
#@gui : Some Red = float(0,-255,255)
#@gui : Much Red = float(0,-255,255)
#@gui : note = note{"<b>Adjust Blues</b> for pixels that have:"}
#@gui : Little Green = float(0,-255,255)
#@gui : Some Green = float(0,-255,255)
#@gui : Much Green = float(0,-255,255)
#@gui : note = note{"<b>Adjust Blues</b> for pixels that have:"}
#@gui : Little Blue = float(0,-255,255)
#@gui : Some Blue = float(0,-255,255)
#@gui : Much Blue = float(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"Strength of effect for Saturation level:"}
#@gui : None = float(255,0,255)
#@gui : Little = float(255,0,255)
#@gui : Some = float(255,0,255)
#@gui : Much = float(255,0,255)
#@gui : Most = float(255,0,255)
#@gui : sep = separator()
#@gui : Output = choice(0,"Perserve Luminance","Clip","Scale")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
iain_rgb_tone:
-repeat $! -l[$>] -split_opacity -l[0]
-to_rgb
--split c
--apply_curve[1] 0,0,$1,128,$2,255,$3
--apply_curve[2] 0,0,$4,128,$5,255,$6
--apply_curve[3] 0,0,$7,128,$8,255,$9
-add[-1,-2,-3]
--apply_curve[1] 0,0,$10,128,$11,255,$12
--apply_curve[2] 0,0,$13,128,$14,255,$15
--apply_curve[3] 0,0,$16,128,$17,255,$18
-add[-1,-2,-3]
--apply_curve[1] 0,0,$19,128,$20,255,$21
--apply_curve[2] 0,0,$22,128,$23,255,$24
--apply_curve[3] 0,0,$25,128,$26,255,$27
-add[-1,-2,-3]
-add[1,4]
-add[2,4]
-add[3,4]
-a[-1,-2,-3] c
--sub[0,1]
--rgb2hsv[0] -split[-1] c -remove[-1,-3] -mul[-1] 255
-apply_curve[-1] 0,0,$28,64,$29,128,$30,192,$31,255,$32
-compose_multiply[-1,-2]
--sub[0,-1]
-if {$33==0}
-luminance[0]
--luminance[-1]
-compose_grainextract[-1,-2]
-compose_grainmerge[0,-1]
-keep[0]
-endif
-if {$33==1}
-keep[-1]
-c 0,255
-endif
-if {$33==2}
-keep[-1]
-n 0,255
-endif
-endl -a c -endl -done
#
####################################
#@gui Saturation EQ : Saturation_EQ_p, Saturation_EQ_p
#@gui : note = note{"<b>Lightness</b>"}
#@gui : Black = float(0,-128,128)
#@gui : Near Black = float(0,-128,128)
#@gui : Dark Grey = float(0,-128,128)
#@gui : Mid-Dark Grey = float(0,-128,128)
#@gui : Middle Grey = float(0,-128,128)
#@gui : Mid-Light Grey = float(0,-128,128)
#@gui : Light Grey = float(0,-128,128)
#@gui : Highlights = float(0,-128,128)
#@gui : White = float(0,-128,128)
#@gui : sep = separator()
#@gui : note = note{"<b>Hue</b>"}
#@gui : 0 = float(0,-128,128)
#@gui : 45 = float(0,-128,128)
#@gui : 90 = float(0,-128,128)
#@gui : 135 = float(0,-128,128)
#@gui : 180 = float(0,-128,128)
#@gui : 225 = float(0,-128,128)
#@gui : 270 = float(0,-128,128)
#@gui : 315 = float(0,-128,128)
#@gui : 360 = float(0,-128,128)
#@gui : Rotate Hue Bands = float (0,-45,45)
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note{"This filter allows you to adjust the Saturation based on the Lightness or Hue of the pixel. The <i>Rotate Hue Bands</i> control allows you shift the hue that each band controls by 45 degrees."}
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
variance_noise :
-u {${-std_noise}^2}
Saturation_EQ_p:
-repeat $! -l[$>]
-apply_parallel_overlap "-Saturation_EQ ${1-19}",
-endl -done
Saturation_EQ:
-repeat $! -l[$>] -split_opacity -l[0]
-to_rgb -rgb2hsl8
-split[-1] c
--apply_curve[2] .5,0,{128+$1},31,{128+$2},63,{128+$3},95,{128+$4},128,{128+$5},160,{128+$6},192,{128+$7},224,{128+$8},255,{128+$9}
--+[0] {((($19/360)*255))*-1}
-mod[-1] 255
-apply_curve[-1] .5,0,{128+$10},31,{128+$11},63,{128+$12},95,{128+$13},128,{128+$14},160,{128+$15},192,{128+$16},224,{128+$17},255,{128+$18}
-sub[-1,-2] 128
-add[-1,-2]
-mul[-1] 2
-add[1,3]
-c[1] 0,255
-append c
-hsl82rgb
-endl -a c -endl -done
#@gui Select-Replace Color : fx_select_color, fx_select_color_preview(0)
#@gui : Similarity Space = choice(0,"RGB[A]","RGB","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue &amp; Red Chrominances","Hue","Saturation")
#@gui : Tolerance = float(20,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Fill Holes = int(0,0,256)
#@gui : Selected Color = color(255,255,255,255)
#@gui : Output As = choice(0,"Selected Colors","Selected Mask","Rejected Colors","Rejected Mask","Replaced Color")
#@gui : Replacement Color = color(255,0,0,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_select_color :
if {$1==1} to_rgb
elif {$1==2} to_rgb rgb2ycbcr
elif {$1==3} channels 0
elif {$1==4} channels 1
elif {$1==5} channels 2
elif {$1==6} to_rgba channels 3
elif {$1==7} to_rgb rgb2ycbcr channels 0
elif {$1==8} to_rgb rgb2ycbcr channels 1,2
elif {$1==9} to_rgb rgb2hsv channels 0
elif {$1==10} to_rgb rgb2hsv channels 1
fi
fx_select_color :
($5^$6^$7^$8) _fx_select_color. $1 color={^} rm.
repeat $! l[$>] to_rgba
+_fx_select_color $1
select_color[1] $2%,$color
if $4 +area. 0,0 <=. {round($4^1.5)} inpaint.. .,0,3 rm. fi
b[1] $3 n[1] 0,255
if {$9==0} sh[0] 100% &. [1]
elif {$9==1} rm[0]
elif {$9==2} -[1] 255 *[1] -1 sh[0] 100% &. [1]
elif {$9==3} rm[0] - 255 * -1
else
/[1] 255 +*[0,1] +*[1] $11 +*[1] $12 +*[1] $13 *[1] $10 a[1,-3--1] c -[1,2] +
fi
k[0]
endl done
fx_select_color_preview :
gui_split_preview "fx_select_color $*",${-3--1}
#@gui Selective Desaturation : fx_selective_desaturation, fx_selective_desaturation_preview(1)
#@gui : Reference Color = color(255,255,255)
#@gui : Desaturate = choice("Reference Color","All but Reference Color")
#@gui : Strength = float(3,0,10)
#@gui : Regularization = int(0,0,20)
#@gui : Maximum Saturation = choice("From Input","From Reference Color","Maximum Value")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/15/07</i>.</small>")
fx_selective_desaturation :
repeat $! l[$>] to_color split_opacity l[0]
+fc $1,$2,$3
-[1] [0] norm[1] /[1] {1e-6+iM}
if $4 *[1] -{max(0.01,$5)} +[1] 1
else >=[1] {5*$5}%
fi
c[1] 0,1
rgb2hsl[0] s[0] c
mM={[im,iM]} repeat $6 guided. [2],1,0.1 done n. $mM
if {$7==0} *[1,-1]
elif {$7==1} ($1^$2^$3) rgb2hsl. *[1] {i[1]} rm[-2,-1]
else rv[1,-1] rm.
fi
a c hsl2rgb
endl a c endl done
fx_selective_desaturation_preview :
gui_split_preview "fx_selective_desaturation $*",${-3--1}
#@gui Sepia : fx_sepia, fx_sepia_preview(1)+
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sepia :
sepia adjust_colors ${1-3},0,0,0,255
fx_sepia_preview :
gui_split_preview "fx_sepia $*",${-3--1}
#@gui Specific Saturation : gcd_hio_levels, gcd_hio_levels_preview(1)
#@gui : note = note("\n<i>Hue Levels</i>"), sep = separator()
#@gui : Input = float(1,0,2)
#@gui : Opposing = float(1,0,2)
#@gui : Hue = int(39,0,360)
#@gui : Level = float(0,-0.5,0.5)
#@gui : note = note("\n<i>Luma Levels</i>"), sep = separator()
#@gui : Gamma = float(1,0.2,1.8)
#@gui : Contrast = float(1,0.2,1.8)
#@gui : sRGB Conversion = bool(0)
#@gui : Process Top Layer Only = bool(0)
#@gui : sep = separator(), Preview = choice("Full","Forward horizontal","Forward vertical","Backward horizontal",
#@gui : "Backward vertical","Duplicate horizontal","Duplicate vertical","Blend all layers")
#@gui : Is Preview = value(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/01/22</i>.</small>")
gcd_hio_levels : -skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0},${8=0},${9=0},${10=0}
-if {$8} -_gcd_hio_levels[0] ${1--4} -else -_gcd_hio_levels ${1--4} -endif
-if {$10" && "$!>1} -rv -blend alpha -endif
_gcd_hio_levels : -skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0}
-repeat $! -l[$>]
-split_opacity -to_rgb[0] --gcd_srgb2luma[0]
-if {$4!=0}
-sh[0] 0 -sh[0] 1 -sh[0] 2,2
({$3%360}^1^1) -hsv2rgb. -max. 0 -*. $4 --. {ia}
-+[-4] {@0} -+[-3] {@1} -+[-2] {@2} -rm[-4--1] -max[0] 0
-endif
-gcd_hue_chroma[0] $3,$1,$2
-gcd_srgb2jpeg[0] -j[0] [-1] -rm.
-max[0] 0 -sh[0] 0 srgb={($5!=1" || "$6!=1)" && "$7}
-if $srgb -srgb2rgb. -endif
-gcd_gamma. $5
-if {$6!=1}
m={iM/2} --. $m --sign. -abs..
-gcd_gamma.. $6,1,$m -*[-2,-1] -+. $m
-endif
-if $srgb -rgb2srgb. -endif
-rm. -gcd_jpeg2srgb[0] -a c -c 0,255
-endl -done
gcd_hio_levels_preview :
-if {$-2==7} -gcd_hio_levels ${1--2},1
-else -gui_split_preview "-gcd_hio_levels $*",$-2 -endif
gcd_hue_chroma : -skip ${1=0},${2=1},${3=1}
-if {$2==1" && "$3==1} -return -endif
-repeat $! -l[$>]
h={($1%360)/60} x={1-abs($h%2-1)} y={if($x>0,1/$x,0)} h={int($h)+1}
p={arg($h,0,1,1,2,2,0)} s={arg($h,1,0,2,1,0,2)} z={arg($h,2,2,0,0,1,1)}
[0] -sh. $p -sh.. $s --*.. $x
--le. [-2] -j[-3] [-2],0,0,0,0,1,[-1] -rm..
-eq. 0 --*.. $y -j[-4] [-1],0,0,0,0,1,[-2]
-rm[-4--1] -sh. $z -f. 0 -rm.
-sh. $p --compose_channels[0] min --eq.. 0 -+. [-3]
-if {$3!=1}
--/[-2,-1] --. 1 -r. 100%,100%,1,3 -*. [-5] -+[0] [-1]
--compose_channels[0] min --[0] [-1] -*[0] $3 -+[0,-1] --[0,-1]
-endif
-if {$2!=1} ---[-3,-2] -*. $2 -+[-3,-1] -/[-2,-1] --. 1 -*[-3,-1] -rm. -+
-else -k[0] -endif
-endl -done
#@gui Temperature Balance : gcd_temp_balance, gcd_temp_balance(1)
#@gui : note = note("<i>Auto-detect lighting and adjust color temperature</i>"), sep = separator()
#@gui : Saturation = float(0,-1,1)
#@gui : Level = float(0,-1,1)
#@gui : Color = float(1,0,2)
#@gui : Lighting = choice("Automatic","Automatic [Scan All Hues]","Standard [No Scan]")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/08/30</i>.</small>")
gcd_temp_balance : -skip ${1=0},${2=0},${3=1},${4=0}
-repeat $! -l[$>]
-split_opacity -to_rgb[0] --gcd_srgb2luma[0]
-if {$4<2}
m={if($4,360,90)} $m,1,1,1 --r[0] 32,32,100%,100%,2
-repeat $m --gcd_hue_level. $> -=... {ia},$> -rm. -done
-rm. h={xM} -rm.
-else h=39 -endif
-if {$2!=0}
--l[0] -sh[0] 0 -sh[0] 1 -sh[0] 2
({$h%360}^1^1) -hsv2rgb. -max. 0 -*. $2 --. {ia}
-+[-4] {@0} -+[-3] {@1} -+[-2] {@2} -rm[-4--1] -max[0] 0
-endl
--compose_channels[0] max -n. 0,1
-j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
-endif
-gcd_hue_chroma[0] $h,{($1+1)*$3},$3
-gcd_srgb2jpeg[0] -j[0] [-1] -rm.
-gcd_jpeg2srgb[0] -round 1 -a c -c 0,255
-endl -done
gcd_hue_level : -skip ${1=0}
-repeat $! -l[$>]
h={($1%360)/60} x={1-abs($h%2-1)} y={if($x>0,1/$x,0)} h={int($h)+1}
p={arg($h,0,1,1,2,2,0)} s={arg($h,1,0,2,1,0,2)} z={arg($h,2,2,0,0,1,1)}
-sh. $p -sh.. $s --*.. $x
--le. [-2] -j[-3] [-2],0,0,0,0,1,[-1] -rm..
-eq. 0 --*.. $y -j[-4] [-1],0,0,0,0,1,[-2]
-rm[-4--1] -sh. $z -f. 0 -rm.
-endl -done
#@gui Tone Presets : iain_tone_presets_p, iain_tone_presets_p
#@gui : Preset = choice("Whiter Whites","Warm Vintage","Magenta-Yellow","Velvetia","Seventies Magazine","Faded Print","Expired 69","Modern Film")
#@gui : Strength = float (100,-200,200)
#@gui : Scale Output = bool (0)
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
iain_tone_presets_p:
-repeat $! -l[$>]
-apply_parallel_overlap "-iain_tone_presets ${1--2}",0,${-1}
-endl -done
iain_tone_presets:
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0}
--iain_rgb_tone 00,10,00,00,00,00,00,00,00,00,00,00,00,10,00,00,00,00,00,20,00,00,20,00,00,00,00,255,0,0,0,0,0
-endif
-if {$1==1}
--iain_cmyk_tone 00,00,00,00,00,00,-8,-20,00,00,00,-49,00,00,00,00,00,00,00,-25,00,00,17,0,00,00,00,00,00,00,35,-25,17,8,26,31,00,00,00,00,17,00,-9,-31,29,00,00,-9,188,255,181,133,72,1
-endif
-if {$1==2}
--iain_cmyk_tone 00,-38,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,-164,88,255,00,00,00,00,00,00,00,00,00,65,33,-15,00,00,00,00,00,00,00,00,00,00,00,-25,128,92,62,45,38,1
-endif
-if {$1==3}
--iain_cmyk_tone -25,50,00,25,00,00,25,00,00,00,00,00,025,25,00,-50,00,00,25,00,00,00,00,00,025,00,00,25,00,00,-50,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,36,178,255,169,94,2
-endif
-if {$1==4}
--iain_cmyk_tone 25,-50,00,-25,00,00,-25,00,00,00,00,00,-025,-25,00,50,00,00,-25,00,00,00,00,00,-025,00,00,-25,00,00,50,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,17,120,240,255,255,4
-endif
-if {$1==5}
--iain_cmyk_tone 000,00,00,00,00,00,00,00,00,00,00,-60,000,00,00,00,00,00,00,00,00,-22,40,161,000,00,00,0,00,00,00,00,28,33,33,16,00,00,00,00,00,00,00,00,00,77,-8,-80,255,255,255,255,255,0
-endif
-if {$1==6}
--iain_cmyk_tone 000,00,00,00,00,00,00,00,00,00,00,00,000,00,00,00,00,00,00,00,00,07,-20,-33,000,00,00,00,00,00,00,00,00,48,-65,-77,000,00,00,00,00,00,00,00,00,45,45,00,255,255,255,255,255,0,0
-endif
-if {$1==7}
--iain_cmyk_tone 000,20,00,00,08,00,00,00,00,00,-23,00,000,-13,00,0,17,00,00,00,00,-1,29,00,000,00,00,00,00,-12,00,00,00,19,68,18,000,00,00,00,00,00,00,00,00,-5,55,-15,128,255,255,255,255,0,0
-endif
--sub[0,1]
-mul[-1] {{$2/100}*-1}
-+[0,-1]
-keep[0]
-if {$3==0}
-c 0,255
-else
-n 0,255
-endif
-endl -a c -endl -done
#
#######################################
#@gui Transfer Colors [Histogram] : fx_transfer_histogram, fx_transfer_histogram_preview(1)+
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note: </b>
#@gui : The bottom layer contains the reference colors.\n
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/11/26</i>.</small>")
fx_transfer_histogram :
to_colormode 0
repeat {$!-1} l[$>,-1]
nm0={0,n} nm1={1,n}
m "_split : s z r.. "{[w#0,h#0,1,s#0,0]}" r. "{[w#1,h#1,1,s#1,0]}
a z
ac "_split transfer_histogram.. . a z",$1
_split uncommand _split
nm[0] $nm0 nm[1] $nm1
endl done
fx_transfer_histogram_preview :
to_colormode 0
repeat {$!-1} l[$>,-1]
i[0] [0] fx_transfer_histogram[-2,-1] $1 rm.
a z gui_split_preview "s z k.",${-3--1}
endl done
#@gui Transfer Colors [Patch-Based] : fx_gcd_transfer_colors_patch, fx_gcd_transfer_colors_patch_preview(1)
#@gui : note = note("<i>Generate a CLUT and apply it to other images.</i>")
#@gui : note = note("\n<i>Input Options</i>"), sep = separator()
#@gui : Resolution = int(6,2,8)
#@gui : Smooth = float(3,0,10)
#@gui : Iters = int(5,0,20)
#@gui : Random = int(5,0,20)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Reference = choice("Top layer","Bottom layer")
#@gui : Output CLUT = _choice("Disable","512x512 layer","4096x4096 layer")
#@gui : note = note("\n"), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/08/17</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set the <i>Input layers</i> option to transfer colors to other layers.</small>")
#@gui : note = note("<small>If only one input layer is selected a CLUT is always output.</small>")
#@gui : note = note("<small>Higher resolution, iters, or random generally produce better results - at the cost of processing time.</small>")
#@gui : note = note("<small>Results are not necessarily the same every time due to the random based algorithm.</small>")
fx_gcd_transfer_colors_patch : -skip ${1=6},${2=3},${3=5},${4=5},${5=0},${6=0}
ref={if($5,$!-1,0)} n=$!
--gcd_extract_clut[$ref] ${1-4}
-map_clut[^-1,$ref] .
-if {$6>0" || "$n==1}
r,s={arg(max($6,1),64,256)},{arg(max($6,1),512,4096)}
-r. $r,$r,$r,3,3 -r. $s,$s,1,3,-1
-else -rm. -endif
fx_gcd_transfer_colors_patch_preview :
-fx_gcd_transfer_colors_patch $*
-if {!$5} -rm[0] -endif
#@gui Transfer Colors [Variationnal] : fx_transfer_rgb, fx_transfer_rgb_preview(1)+
#@gui : Regularization = int(8,0,32)
#@gui : Preserve Luminance = float(0.2,0,1)
#@gui : Precision = _choice(1,"Low","Normal","High","Very High")
#@gui : Reference Colors = choice("Bottom Layer","Top Layer")
#@gui : Add User-Defined Constraints (Interactive) = _bool(0)
#@gui : sep = separator()
#@gui : Preview Reference = choice(1,"None","Up-Left","Up-Right","Bottom-Left","Bottom-Right")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Instructions:</b>\n
#@gui : - This filter transfers the colors of one layer to all the others.\n
#@gui : - This is a <b>highly</b> experimental filter, it may be unstable or particularly long to render.\n
#@gui : - Don't forget to set the <i>Input layers...</i> option on the left to manage your input layers.\n
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/04/04</i>.</small>")
fx_transfer_rgb :
to_rgb
ref={if($4,0,-1)}
transfer_rgb[^$ref] [$ref],0.25,$1,$2,{2^(4+$3)},$5,0
fx_transfer_rgb_preview :
if {$!<2} gui_print_preview "Warning:",,"This filter requires at least two input layers to work properly." return fi
ref={if($4,0,-1)}
pf=${-path_tmp}gmic_tmp o[$ref] $pf
gui_split_preview[^$ref] "i "$pf" fx_transfer_rgb $1,$2,0,0,0 rm.",${-3--1}
if $4 mv[0] $! fi
if $6 repeat {$!-1} l[$>,-1]
+r2dy. {0,h/3} to. Reference,2,2,13,1,1,255 frame. 2,2,255 frame. 1,1,0
if {$6==1} j[0] .,5,5
elif {$6==2} j[0] .,{{0,w}-w-6},6
elif {$6==3} j[0] .,5,{{0,h}-h-6}
else j[0] .,{{0,w}-w-6},{{0,h}-h-6}
fi
rm.
endl done fi
#@gui User-Defined : fx_custom_transform, fx_custom_transform
#@gui : Red - Green - Blue - Alpha = text{"i"}
#@gui : Red - Green - Blue = text{"i + 90*(x/w)*cos(i/10)"}
#@gui : Red = text{"i"}
#@gui : Green = text{"i"}
#@gui : Blue = text{"i"}
#@gui : Alpha = text{"i"}
#@gui : Value Normalization = choice("None","RGB","RGBA")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_custom_transform :
to_rgba repeat $!
f. "$1"
s. c a[-4--2] c f.. "$2"
s.. c f[-4] "$3" f... "$4" f.. "$5" f. "$6"
if {$7==0} a[-4--1] c c. 0,255
elif {$7==1} a[-4--2] c n.. 0,255 c. 0,255 a[-2,-1] c
else a[-4--1] c n. 0,255
fi
mv. 0 done
#@gui Vintage Style : fx_tk_vintage, fx_tk_vintage_preview(1)
#@gui : Exposure = float(2,-5,5)
#@gui : Contrast = float(0.85,0.5,1.5)
#@gui : Saturation = float(0.7,0,4)
#@gui : Shadows Threshold = float(80,0,128)
#@gui : Highlights Threshold = float(200,128,255)
#@gui : Transition Smoothness = float(5,0,50)
#@gui : sep = separator()
#@gui : Color Shadows = color(147,26,161)
#@gui : Strength Shadows = float(0.3,0,1)
#@gui : Color Midtones = color(235,220,176)
#@gui : Strength Midtones = float(0.4,0,1)
#@gui : Color Highlights = color(190,181,108)
#@gui : Strength Highlights = float(0.2,0,1)
#@gui : Color Overall Effect = color(0,0,100)
#@gui : Color Effect Mode = choice("exclusion","overlay","soft  Light","multiply","screen")
#@gui : Strength Effect = float(0.3,0,1)
#@gui : sep = separator()
#@gui : Vignette Size = float(25,0,100)
#@gui : Vignette Strenth = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward  horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gui : sep = separator(), note = note("<small>Author : <i>Tom Keil</i>.       Latest update: <i>2011/04/06</i>.</small>")
fx_tk_vintage :
-repeat $! -l[$>]
-to_rgb[0] --luminance[0] --luminance[0] --luminance[0]
-fx_mix_lab[0] $2,{$1*10},0,$3,0,0,$3,0,0,0,2,0
-tk_fx_channel_processing[-1] 1,1,0,0,4,{$4/2.55},100,256,0,1,0,2,0,0
-tk_fx_channel_processing[-2] 1,1,0,0,4,{$4/2.55},{$5/2.55},256,0,0,0,2,0,0
-tk_fx_channel_processing[-3] 1,1,0,0,4,0,{$5/2.55},256,0,1,0,2,0,0
-to_gray[-1,-2,-3] -fx_gaussian_blur[-1,-2,-3] $6,0,0,1,0,0,0
--fc[0] $7,$8,$9 --fc[0] $11,$12,$13 --fc[0] $15,$16,$17 -to_rgba[-1,-2,-3]
-s[-1] c -rv[-1,-9] -compose_multiply[-1,-9] -mv[-8] 9 -a[-4,-3,-2,-1] c
-s[-2] c -rv[-2,-8] -compose_multiply[-2,-8] -mv[-7] 7 -a[-5,-4,-3,-2] c
-s[-3] c -rv[-3,-7] -compose_multiply[-3,-7] -mv[-6] 5 -a[-6,-5,-4,-3] c
--fc[0] $19,$20,$21 -rv[-1,-5]
-if {$22==0} -fx_compose_exclusion[-1,-5] $23
-elif {$22==1} -fx_compose_overlay[-1,-5] $23
-elif {$22==2} -fx_compose_softlight[-1,-5] $23
-elif {$22==3} -fx_compose_multiply[-1,-5] $23
-elif {$22==4} -fx_compose_screen[-1,-5] $23
-endif
-rv[-3,-4] -fx_compose_lighten[-3,-4] $10
-rv[-2,-3] -fx_compose_overlay[-2,-3] $14
-rv[-1,-2] -fx_compose_darken[-1,-2] $18
-if {$25!=0}
--fc[0] 255,255,255 -fx_frame_round[-1] 2,$24,0,0,0,0,0,255,100,0.1,3
-fx_gaussian_blur[-1] {$6*5},0,0,1,0,0,0
-rv[-1,-2] -fx_compose_multiply[-1,-2] $25 -endif
-endl -done
fx_tk_vintage_preview :
-gui_split_preview "-fx_tk_vintage ${1--2}",$-1
#@gui Zone System : fx_zonesystem, fx_zonesystem_preview(1)
#@gui : Shadows Zone = int(1,1,5)
#@gui : Highlights Zone = int(10,6,10)
#@gui : Gamma = float(1,0,5)
#@gui : Contrast = float(1,0,4)
#@gui : Black Point = int(0,0,255)
#@gui : White Point = int(255,0,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Tom Keil</i>.      Latest update: <i>2011/13/02</i>.</small>")
fx_zonesystem :
-repeat $! -l[$>] -to_rgb -rgb2lab -s c -n[0] {{$1-1}*10}%,{$2*10}%
-a c -lab2rgb -tk_fx_channel_processing $3,$4,0,0,0,0,100,256,0,0,0,2,7,0
-fx_apply_curve 0,$5,0,$6,255,-1,128,-1,128,-1,128,255,1,7,0,0,0
-endl -done
fx_zonesystem_preview :
-gui_split_preview "-fx_zonesystem ${1--2}",$-1
#@gui _
#@gui <b>Contours</b>
#@gui Convolve : fx_convolve, fx_convolve_preview(0)
#@gui : Kernel = choice("Custom","Average 3x3","Average 5x5","Average 7x7","Average 9x9","Prewitt-X","Prewitt-Y","Sobel-X","Sobel-Y","Rotinv-X","Rotinv-Y","Laplacian","Robert Cross 1","Robert Cross 2","Impulses 5x5","Impulses 7x7","Impulses 9x9")
#@gui : Boundary = choice(1,"Dirichlet","Neumann")
#@gui : sep = separator(), note = note("<small><b>Note:</b> If parameter <i>Kernel</i> is set to <i>Custom</i>, it uses the custom convolution kernel defined below. Use commas and semicolons as separators for res. matrix columns and rows.</small>")
#@gui : Custom Kernel = text("0,1,0;1,-4,1;0,1,0")
#@gui : sep = separator(), note = note("<small><b>Note:</b> Kernel multiplier is useful only when parameter <i>Value range</i> is set to <i>Cut</i>.</small>")
#@gui : Value Range = choice(1,"Cut","Normalize")
#@gui : Kernel Multiplier = float(1,0,50)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/06/06</i>.</small>")
fx_convolve : skip "${3=1}"
ac "_fx_convolve $1,$2,\"$3\",${4--5}",$-4
_fx_convolve :
if $1 _fx_convolve$1[] else ($3) fi
if {!$4} *. $5 fi
convolve[0--2] .,$2
if $4 n 0,255 else c 0,255 fi
rm.
_fx_convolve1 : 3,3 f 1 normalize_sum
_fx_convolve2 : 5,5 f 1 normalize_sum
_fx_convolve3 : 7,7 f 1 normalize_sum
_fx_convolve4 : 9,9 f 1 normalize_sum
_fx_convolve5 : (1,0,-1;1,0,-1;1,0,-1)
_fx_convolve6 : (1,1,1;0,0,0;-1,-1,-1)
_fx_convolve7 : (1,0,-1;2,0,-2;1,0,-1)
_fx_convolve8 : (1,2,1;0,0,0;-1,-2,-1)
_fx_convolve9 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,0,-$a;$b,0,-$b;$a,0,-$a)
_fx_convolve10 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,$b,$a;0,0,0;-$a,-$b,-$a)
_fx_convolve11 : (0,1,0;1,-4,1;0,1,0)
_fx_convolve12 : (1,0;0,-1)
_fx_convolve13 : (0,1;-1,0)
_fx_convolve14 : 3,3 f 1 r 7,7,1,1,4,0,0.5,0.5 autocrop normalize_sum
_fx_convolve15 : 3,3 f 1 r 9,9,1,1,4,0,0.5,0.5 autocrop normalize_sum
_fx_convolve16 : 3,3 f 1 r 11,11,1,1,4,0,0.5,0.5 autocrop normalize_sum
fx_convolve_preview : skip "${3=1}"
gui_split_preview "fx_convolve $1,$2,\"$3\",${4--1}",${-3--1}
#@gui Curvature : fx_curvature, fx_curvature_preview(0)
#@gui : Smoothness = float(2,0,10)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Absolute Value = bool(0)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_curvature :
repeat $! l[$>] split_opacity l[0]
b $1 iee
if $4 abs fi
c $2%,$3%
if $5 negate fi
n 0,255
endl a c endl done
fx_curvature_preview :
gui_split_preview "fx_curvature ${^0}",${-3--1}
#@gui Difference of Gaussians : fx_dog, fx_dog_preview(1)
#@gui : 1st Variance = float(1.4,0,5)
#@gui : 2nd Variance = float(1.5,0,5)
#@gui : Threshold = float(0,0,49)
#@gui : Negative Colors = bool(0)
#@gui : Monochrome = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_dog :
dog $1%,$2%
if $5 norm fi
c $3%,{100-$3}%
if $4 negate fi
n 0,255
fx_dog_preview :
gui_split_preview "fx_dog ${^0}",${-3--1}
#@gui Distance Transform : fx_distance, fx_distance_preview(0)
#@gui : Value = int(128,0,255)
#@gui : Metric = choice(2,"Chebyshev","Manhattan","Euclidean","Squared-Euclidean")
#@gui : Normalization = choice(2,"Cut","Normalize","Modulo")
#@gui : Modulo Value = int(32,1,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/07/04</i>.</small>")
fx_distance :
repeat $! l[$>] split_opacity l[0]
distance $1,$2
if {$3==0} c 0,255
elif {$3==1} n 0,255
else % $4 n 0,255
fi
endl a c endl done
fx_distance_preview :
gui_split_preview "fx_distance ${^0}",${-3--1}
#@gui Edges : fx_edges, fx_edges_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_edges :
to_rgb b $1% edges $2%
if $3 negate fi
n 0,255
fx_edges_preview :
gui_split_preview "fx_edges ${^0}",${-3--1}
#@gui Edges Offsets : fx_edge_offsets, fx_edge_offsets_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Scale = int(4,0,32)
#@gui : Thickness = int(1,0,16)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_edge_offsets :
repeat $!
os={s}
b. $1% gradient_norm. >=. $2% skeleton. 0 distance. 1 round. 1 %. $3 >=. {max(1,$3-$4)}
if {!$5} negate. fi
n. 0,255 to_colormode. $os
mv. 0 done
fx_edge_offsets_preview :
gui_split_preview "fx_edge_offsets ${^0}",${-3--1}
#@gui Extract Foreground [Interactive] : fx_extract_foreground, gui_no_preview
#@gui : Feathering = _float(0,0,4)
#@gui : Dilation = int(0,-32,32)
#@gui : Output Mode = choice{3,"RGBA Image (Full-Transparency / 1 Layer)","RGBA Image (Updatable / 1 Layer)","RGB Image + Binary Mask (2 Layers)","RGBA Foreground + Background (2 Layers)"}
#@gui : View Resolution = _choice{1,"Small (Faster)","Medium","High (Slower)","Very High (Even Slower)"}
#@gui : sep = separator()
#@gui : note = note{"<small><b>Description:</b>\n
#@gui : This filter allows to quickly extract foreground objects from background in opaque RGB images.
#@gui : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the interactive window and start adding foreground and background control points.
#@gui : When you're done, exit the interactive window: your extracted foreground will be transferred back to the host software.\n\n
#@gui : If you are not satisfied with the result, click on <i>Apply</i> once again to modify your control points defined previously.
#@gui : To remove all control points, click on the <i>Reset</i> button above.
#@gui : </small>"}
#@gui : Last Image Size = value(0,0)
#@gui : Control Points = value(-1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive window to build your extraction mask :\n\n
#@gui : - <b>Left mouse button</b> or key <b>F</b> create a new <b>foreground</b> control point (or move an existing one).\n
#@gui : - <b>Right mouse button</b> or key <b>B</b> create a new <b>background</b> control point (or move an existing one).\n
#@gui : - <b>Mouse wheel</b>, or keys <b>CTRL+arrows UP/DOWN</b> zoom view in/out.\n
#@gui : - Key <b>SPACE</b> updates the extraction mask.\n
#@gui : - Key <b>TAB</b> toggles background view modes.\n
#@gui : - Key <b>M</b> toggles marker view modes.\n
#@gui : - Key <b>BACKSPACE</b> deletes the last control point added.\n
#@gui : - Key <b>PAGE UP</b> increases background opacity.\n
#@gui : - Key <b>PAGE DOWN</b> decreases background opacity.\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> reset window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/29/09</i>.</small>")
fx_extract_foreground :
if {!$!} return fi
resolution={arg(1+$3,512,1024,2048,0)}
repeat $! l[$<]
nm=${-gui_layer_name}
nm "[G"{`39`}"MIC] Interactive Foreground Extraction"
if {$7==-1||$5!=w||$6!=h} _gui_control_points= else _gui_control_points=${7--1} fi
status=${x_segment\ $resolution}
sh 3 b. $1% if {$2>0} dilate. {1+2*$2} elif {$2<0} erode. {1-2*$2} fi
rm.
if {$3==1} sh 3 max. 1 rm.
elif {$3==2} s c,-3 r. 100%,100%,1,4 rv nm[0] name(Mask) nm[1] name($nm)
elif {$3==3}
.
sh.. 0,2 +channels... 3,3 >=. 3 *[-2,-1] rm.
sh. 0,2 +channels.. 3,3 <=. {255-3} *[-2,-1] rm.
sh. 3 *. -1 +. 255 rm.
gui_autocrop_layers[0]
pos0=${gui_layer_pos[0]} pos1=${gui_layer_pos[1]}
nm[0] name($nm" [foreground]"),pos($pos0)
nm[1] name($nm" [background]"),pos($pos1)
fi
endl done
if {narg($status)>=4} u \{$1\}\{$2\}\{$3\}\{$4\}\{{w},{h}\}\{$status\} else u "" fi
#@gui Gradient Norm : fx_gradient_norm, fx_gradient_norm_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_gradient_norm :
b $1 gradient_norm ^ $2
c $3%,$4%
if $5 negate fi
n 0,255
fx_gradient_norm_preview :
gui_split_preview "fx_gradient_norm ${^0}",${-3--1}
#@gui Gradient RGB : fx_gradient2rgb, fx_gradient2rgb_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Orientation Only = bool(0)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_gradient2rgb :
b $1 gradient2rgb $4
c $2%,$3%
if $5 negate fi
n 0,255
fx_gradient2rgb_preview :
gui_split_preview "fx_gradient2rgb ${^0}",${-3--1}
#@gui Isophotes : fx_isophotes, fx_isophotes_preview(0)
#@gui : Levels = int(8,1,256)
#@gui : Smoothness = float(0,0,5)
#@gui : Filling = choice(1,"Transparent","Colors")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_isophotes :
if $3
topographic_map $1,$2
else
b $2 isophotes $1
fi
fx_isophotes_preview :
gui_split_preview "fx_isophotes ${^0}",${-3--1}
#@gui Laplacian : fx_laplacian, fx_laplacian_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Absolute Value = bool(0)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_laplacian :
b $1 laplacian
if $4 abs fi
c $2%,$3%
if $5 negate fi
n 0,255
fx_laplacian_preview :
gui_split_preview "fx_laplacian ${^0}",${-3--1}
#@gui Local Orientation : fx_local_orientation, fx_local_orientation_preview(1)
#@gui : Smoothness = float(0,0,5)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_local_orientation :
repeat $! l[$>] split_opacity l[0]
b $1% gradient_orientation 2 complex2polar rm[0--1:2]
c $2%,$3%
if $4 negate fi
n 0,255
endl a c endl done
fx_local_orientation :
ac "_fx_local_orientation $1,$2,$3,$4",$5,2
fx_local_orientation_preview :
gui_split_preview "fx_local_orientation ${^0}",${-3--1}
#@gui Morphological Filter : fx_morpho_v2, fx_morpho_v2_preview(0)
#@gui : Action = choice{"Erosion","Dilation","Opening","Closing","Original - Erosion","Dilation - Original","Original - Opening","Closing - Original","Original - (Opening + Closing)/2","Closing - Opening"}
#@gui : Kernel = choice(0,"Square","Octagonal","Circular","Custom")
#@gui : Size = int(5,2,60)
#@gui : note = note("<small>Parameter <i>Size</i> is inactive for <i>Custom</i> kernel.</small>")
#@gui : Custom Kernel = text("1,0,1; 0,1,0; 1,0,1")
#@gui : Negative = bool()
#@gui : Process Transparency = bool(0)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Stretch")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/22/06</i>.</small>")
fx_morpho_v2 :
ac "_fx_morpho_v2 ${1-3},\"$4\",${5-6}",$7,$8
fx_morpho_v2_preview :
gui_split_preview "fx_morpho_v2 ${1-3},\"$4\",${5--1}",${-3--1}
if {$2==3}
({'"$4"'}) f. "(i>=_'0' && i<=_'9') || i==_',' || i==_';'?i:-1" discard. -1 ({t}) rr2d. {0,max(24,w/6)},{0,max(24,h/6)},0,1 >. 0 *. 255
to_rgba. frame. 1,1,0,0,0,0,255 frame. 1,1,255 frame. 1,1,0,0,0,0,255
j[^-1] .,2,2,0,0,0.75 rm.
else
fi
_fx_morpho_v2 :
({'"$4"'}) f. "(i>=_'0' && i<=_'9') || i==_',' || i==_';'?i:-1" discard. -1 ckernel={t} rm.
if {$2==0} m "my_erode: erode $""1" m "my_dilate: dilate $""1"
elif {$2==1} m "my_erode: erode_oct $""1" m "my_dilate: dilate_oct $""1"
elif {$2==2} m "my_erode: erode_circ $""1" m "my_dilate: dilate_circ $""1"
else
m "my_erode : ("$ckernel") erode[^-1] . rm."
m "my_dilate : ("$ckernel") dilate[^-1] . rm."
fi
if {$1==0} m "my_action : my_erode $3"
elif {$1==1} m "my_action : my_dilate $3"
elif {$1==2} m "my_action : my_erode $3 my_dilate $3"
elif {$1==3} m "my_action : my_dilate $3 my_erode $3"
elif {$1==4} m "my_action : +my_erode $3 -"
elif {$1==5} m "my_action : +my_dilate $3 rv -"
elif {$1==6} m "my_action : +my_erode $3 my_dilate. $3 -"
elif {$1==7} m "my_action : +my_dilate $3 my_erode. $3 rv -"
elif {$1==8} m "my_action : +my_erode $3 my_dilate. $3 +my_dilate.. $3 my_erode. $3 +[-2,-1] /. 2 -"
else m "my_action : +my_erode $3 my_dilate. $3 my_dilate.. $3 my_erode.. $3 -"
fi
repeat $! l[$>]
if {!$6} split_opacity fi
my_action[0]
a c
endl done
if $5 repeat $! l[$>] split_opacity negate[0] a c endl done fi
uncommand my_erode,my_dilate,my_action
#@gui Segmentation : fx_segment_watershed, fx_segment_watershed_preview(0)
#@gui : Edge Threshold = float(2,0,15)
#@gui : Smoothness = float(1,0,5)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_segment_watershed : skip ${4=1}
ac "b $2 segment_watershed $1",$3,$4
fx_segment_watershed_preview :
gui_split_preview "fx_segment_watershed ${^0}",${-3--1}
#@gui Skeleton : fx_skeleton, fx_skeleton_preview(1)
#@gui : Method = choice{"Distance (Fast)","Thinning (Slow)"}
#@gui : Smoothness = float(0,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/07/04</i>.</small>")
fx_skeleton :
remove_opacity
b $2% >= 50%
if $1 thinning 1
else
distance 0 sharpen 1e10 >= 100%
repeat $! +erode[$>] 2 -[$>,-1] done
fi
* 255
fx_skeleton_preview :
gui_split_preview "fx_skeleton ${^0}",${-3--1}
#@gui Super-Pixels : fx_superpixels, fx_superpixels_preview(0)
#@gui : Size = int(16,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border Opacity = float(1,0,1)
#@gui : Border Color = color(0,0,0,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/11/16</i>.</small>")
fx_superpixels :
repeat $! l[$>]
+srgb2lab slic. ${1-3}
if $4 +blend shapeaverage else +map. 2,2 fi
if $5 f[1] "i!=j(1,0) || i!=j(0,1)" [0],[0],1,4 fc. ${6-9} to_rgba.. j.. .,0,0,0,0,$5,... k..
else k.
fi
endl done
fx_superpixels_preview :
gui_split_preview "fx_superpixels ${^0}",${-3--1}
#@gui Thin Edges : fx_thin_edges, fx_thin_edges_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_thin_edges :
b $1% gradient_norm >= $2% thinning 1
if {!$3} negate fi
n 0,255
fx_thin_edges_preview :
gui_split_preview "fx_thin_edges ${^0}",${-3--1}
#@gui _
#@gui <b>Deformations</b>
#@gui Cartesian Transform : fx_custom_deformation, fx_custom_deformation(1)
#@gui : X-Warping = text{"(w+h)/20 * cos(y*20/h)"}
#@gui : Y-Warping = text{"(w+h)/20 * sin(x*20/w)"}
#@gui : Relative Warping = bool(1)
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_custom_deformation :
if {!$5} to_a fi
repeat $!
+norm. . f.. "$1" f. "$2"
a[-2,-1] c warp.. .,$3,$4,$5,1 rm.
mv. 0 done
#@gui Circle Transform : fx_circle_transform, fx_circle_transform_preview(1)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Radius = point(75,50,0,1)
#@gui : X-Scale = float(-2,-16,16)
#@gui : Y-Scale = float(-2,-16,16)
#@gui : Symmetry = choice("None","Inside","Outside")
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Preview Reference Circle = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/08/01</i>.</small>")
fx_circle_transform :
repeat $! l[$>] to_rgba
r={dx=($3-$1)*(w-1)%;dy=($4-$2)*(h-1)%;norm(dx,dy)}
if {$7==0} cond="i(X,Y,z,c,$8,$9)"
elif {$7==1} cond="if(N<"$r",i(X,Y,z,c,$8,$9),i)"
else cond="if(N>"$r",i(X,Y,z,c,$8,$9),i)"
fi
f "U = x - w*$1%;
V = y - h*$2%;
N = sqrt(U*U + V*V);
Nr = N - "$r";
X = x + $5*Nr*U/N;
Y = y + $6*Nr*V/N;
"$cond
endl done
fx_circle_transform_preview :
fx_circle_transform $*
if $10
rr2d ${-gui_preview_wh},0,1
repeat $! l[$>]
x0,y0={[$1,$2]*([w,h]-1)%}
r={dx=($3-$1)*(w-1)%;dy=($4-$2)*(h-1)%;norm(dx,dy)}
circle $x0,$y0,{$r-1},1,0xFFFFFFFF,0,0,0,255
circle $x0,$y0,{$r+1},1,0xFFFFFFFF,0,0,0,255
circle $x0,$y0,$r,1,0xFFFFFFFF,0,255,0,255
endl done
fi
#@gui Conformal Maps : fx_conformal_maps, fx_conformal_maps_preview(1)
#@gui : Mapping = choice{8,"Custom Formula","z","(z-1)/(z+1)","cos(z)","sin(z)","tan(z)","exp(z)","log(z)","Dipole: 1/(4*z^2-1)","Star: -5*(z^3/3-z/4)/2"}
#@gui : Exponent (Real) = float(1,-16,16)
#@gui : Exponent (Imaginary) = float(0,-16,16)
#@gui : Custom Formula = text{1,"((1.1 + i*z/6)/(1.04 - i*z/6))^6.2"}
#@gui : sep = separator()
#@gui : Zoom = float(0,-4,4)
#@gui : Angle = float(0,-180,180)
#@gui : Aspect Ratio = float(0,-1,1)
#@gui : X-Shift = float(0,-5,5)
#@gui : Y-Shift = float(0,-5,5)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Anti-Aliasing = int(0,0,3)
#@gui : sep = separator()
#@gui : Specify Different Output Size = _bool(0)
#@gui : Output Width = _text("1024")
#@gui : Output Height = _text("1024")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/15/02</i>.</small>")
fx_conformal_maps :
to_a
expr0="$4"
expr1="z"
expr2="(z+1)/(z-1)"
expr3="cos(z)"
expr4="sin(z)"
expr5="tan(z)"
expr6="exp(z)"
expr7="log(z)"
expr8="1/(4*z^2-1)"
expr9="-5*(z^3/3-z/4)/2"
({'${expr$1}'})
replace_str. "*","**"
replace_str. "/","//"
replace_str. "^","^^"
replace_str. "exp(","cexp("
replace_str. "log(","clog("
replace_str. "cos(","ccos("
replace_str. "sin(","csin("
replace_str. "tan(","ctan("
expr={t}
rm.
repeat $! l[$>]
wh={$12?[$13,$14]:[w,h]}
{(1+$11)*[$wh]},1,100%
f. "begin(
ccos(z) = (iz = [ -z[1],z[0] ]; (cexp(iz) + cexp(-iz)/2));
csin(z) = (iz = [ -z[1],z[0] ]; (cexp(iz) - cexp(-iz)/2));
ctan(z) = csin(z)//ccos(z);
boundary = $10;
interpolation = 1;
const f = max(w,h);
const f0 = max(w#0,h#0);
i = [0,1];
);
z = (2*[ x,y ] - [ w,h ])/f;
z = rot(-$6)*z;
z-= [ $8, $9 ];
z/=[ 10^($5 + $7), 10^$5 ];
z = ("$expr");
if ($1, z = z^^[$2,$3]);
z = rot($6)*z;
z = 0.5*(f0*z + [w#0,h#0]);
I(#0,z)"
r. $wh,1,100%,2
rm..
endl done
fx_conformal_maps_preview :
fx_conformal_maps ${1-3},"$4",${5-11},0,0,0
#@gui Continuous Droste : souphead_droste10, souphead_droste10_preview(1)
#@gui : Inner Radius = float(40,1,100)
#@gui : Outer Radius = float(100,1,100)
#@gui : Periodicity = float(1,-6,6)
#@gui : Strands = int(1,-6,6)
#@gui : Zoom = int(1,1,100)
#@gui : Rotate = int(0,-360,360)
#@gui : X-Shift = int(0,-100,100)
#@gui : Y-Shift = int(0,-100,100)
#@gui : Center X-Shift = int(0,-100,100)
#@gui : Center Y-Shift = int(0,-100,100)
#@gui : Starting Level = int(1,1,20)
#@gui : Number of Levels = int(10,1,20)
#@gui : Level Frequency = int(1,1,10)
#@gui : sep = separator()
#@gui : Show Both Poles = bool(0)
#@gui : Pole Rotation = int(90,-180,180)
#@gui : Pole Long = int(0,-100,100)
#@gui : Pole Lat = int(0,-100,100)
#@gui : sep = separator()
#@gui : Tile Poles = bool(0)
#@gui : Hyper Droste = bool(0)
#@gui : Fractal Points = int(1,1,10)
#@gui : sep = separator()
#@gui : Auto-Set Periodicity = bool(0)
#@gui : No Transparency = bool(0)
#@gui : External Transparency = bool(1)
#@gui : Mirror Effect = bool(0)
#@gui : Untwist = bool(0)
#@gui : Do Not Flatten Transparency = bool(0)
#@gui : sep = separator()
#@gui : Show Grid = bool(0)
#@gui : Show Frame = bool(0)
#@gui : sep = separator()
#@gui : Antialiasing = bool(1)
#@gui : Edge Behavior X = choice("Blank","Wrap","Reflect","Rotate")
#@gui : Edge Behavior Y = choice("Blank","Wrap","Reflect","Rotate")
#@gui : sep = separator(), note = note("<small>This filter is a conversion of the Mathmap script originally proposed here:</small>")
#@gui : url = link("Droste effect for Mathmap.","https://www.flickr.com/groups/88221799@N00/discuss/72157601071820707/")
#@gui : Note2 =note("<small>Original design by <b>Breic</b> and coding by <b>Josh Sommers</b>.</small>")
#@gui : sep = separator(), note = note("<small>Author : <i>Souphead</i>.      Latest update : <i>2016/19/01</i>.</small>")
souphead_droste10 :
-_souphead_droste10 ${1-26},0,${28-31}
souphead_droste10_preview :
-_souphead_droste10 ${1--1}
_souphead_droste10 :
-repeat $! -l[$>]
-to_a
--f. 0
-sh. 0
-f. "*
begin(InnerRadius = $1;
OuterRadius = $2;
Periodicity = $3;
Strands = $4;
Zoom = $5;
Rotate = $6;
XShift = $7;
YShift = $8;
XCenterShift = $9;
YCenterShift = $10;
StartingLevel = $11;
NumberOfLevels = $12;
LevelFrequency = $13;
ShowBothPoles = $14;
PoleRotation = $15;
PoleLong = $16;
PoleLat = $17;
TilePoles = $18;
HyperDroste = $19;
FractalPoints = $20;
AutoSetPeriodicity = $21;
NoTransparency = $22;
ExternalTransparency = $23;
MirrorEffect = $24;
Untwist = $25;
DoNotFlattenTransparency = $26;
ShowGrid = $27;
ShowFrame = $28;
Antialias = $29;
XEdgeType = $30;
YEdgeType = $31;
r1 = InnerRadius/100;
r2 = OuterRadius/100;
p1 = Periodicity;
p2 = Strands;
xCenterShift = XCenterShift/100;
yCenterShift = YCenterShift/100;
W = (w-1)/2;
H = (h-1)/2;
xShift = (XShift*w/W)/100;
yShift = (YShift*h/H)/100;
tileBasedOnTransparency=!(NoTransparency);
transparentPointsIn=!(ExternalTransparency);
levelsToLookOut=StartingLevel;
levelToShow=LevelFrequency;
retwist=!(Untwist);
if (AutoSetPeriodicity,p1=p2/2*(1+sqrt(1-(log(r2/r1)/pi)^2)));
if (p1>0,rotate=-(pi/180)*Rotate,rotate=(pi/180)*Rotate);
zoom=(Zoom+InnerRadius-1)/100;
epsilon=0.01;
if(retwist,xbounds0=-r2;xbounds1=r2;ybounds0=-r2;ybounds1=r2,ybounds0=0;ybounds1=2.1*pi;xbounds0=-log(r2/r1);xbounds1=-xbounds0);
minDimension=min(w,h);
xymiddle=0.5*(xbounds0+xbounds1);
xymiddlei=0.5*(ybounds0+ybounds1);
xyrangex=xbounds1-xbounds0;
xyrangey=ybounds1-ybounds0;
aspectRatio=w/h;
xyrangex=xyrangey*aspectRatio;
xbounds0=xymiddle-0.5*xyrangex;
xbounds1=xymiddle+0.5*xyrangex;
pLat = (PoleLat*w/W)/100;
pLon = (PoleLong*w/W)/100;
alpha=atan(p2/p1*log(r2/r1)/(2*pi));
f=cos(alpha);
beta=f*cos(alpha);
betai=f*sin(alpha);
if(p2>0,angle=2*pi*p1,angle=-2*pi*p1);
if(MirrorEffect,angle=angle/Strands);
);
X=x-((w-1)/2);
Y=((h-1)/2)-y;
z=xbounds0+(xbounds1-xbounds0)*(X+w/2)/w;
zi=ybounds0+(ybounds1-ybounds0)*(Y+h/2)/h;
if(retwist,
zinitial=z;
zinitiali=zi;
z=z-xShift;
zi=zi-yShift;
expo=cos(rotate);
expoi=sin(rotate);
zmid=(z-xymiddle)/zoom;
zmidi=(zi-xymiddlei)/zoom;
zx=(zmid*expo+zmidi*expoi);
zy=(zmidi*expo-zmid*expoi);
z=xymiddle+zx;
zi=xymiddlei+zy,
zinitial=r1*exp(z)*cos(zi);
zinitiali=r1*exp(z)*sin(zi);
expo=cos(rotate)*zoom;
expoi=sin(rotate)*zoom;
zx=zinitial*expo-zinitiali*expoi;
zy=zinitial*expoi+zinitiali*expo;
zinitial=zx;
zinitiali=zy
);
if(ShowBothPoles,
theta=(pi/180)*PoleRotation;
xx=z;
yy=zi;
div=0.5*(1+xx^2+yy^2+((1-xx^2-yy^2)*cos(theta))-(2*xx*sin(theta)));
xx=xx*cos(theta)+(0.5*(1-xx^2-yy^2)*sin(theta));
z=xx/div;
zi=yy/div,
if(HyperDroste,
zx=sin(z)*cosh(zi);
zy=cos(z)*sinh(zi);
z=zx;
zi=zy
);
if(TilePoles,
p=sqrt(z*z + zi*zi)^FractalPoints;
frac=FractalPoints*atan2(zi,z);
z=p*cos(frac);
zi=p*sin(frac);
z=2*z;
zi=2*zi;
p=cos(2*z)+cosh(2*zi);
zx=sin(2*z)/p;
zy=sinh(2*zi)/p;
z=zx;
zi=zy
);
);
z=z+pLat;
zi=zi+pLon;
if(retwist,
za=z/r1;
zb=zi/r1;
zx=0.5*log(za*za+zb*zb);
zy=atan2(zb,za);
z2=zx;
z2i=zy,
z2=z;
z2i=zi
);
p=beta*beta+betai*betai;
z=p1*(z2*beta+z2i*betai)/p;
zi=p1*(z2i*beta-z2*betai)/p;
rotatedscaledlogz=z;
rotatedscaledlogzi=zi;
logz=z2;
logzi=z2i;
zx=r1*exp(z)*cos(zi);
zy=r1*exp(z)*sin(zi);
z=zx;
zi=zy;
if(tileBasedOnTransparency && levelsToLookOut>0,
if(!transparentPointsIn,
ratio=r2/r1*cos(angle);
ratioi=r2/r1*sin(angle),
ratio=r1/r2*cos(angle);
ratioi=-r1/r2*sin(angle)
);
p=sqrt(ratio*ratio+ratioi*ratioi)^levelsToLookOut;
q=atan(ratioi/ratio);
rp=p*cos(levelsToLookOut*q);
rpi=p*sin(levelsToLookOut*q);
zx=z*rp-zi*rpi;
zy=z*rpi+zi*rp;
z=zx;
zi=zy;
);
colorSoFarR=0;
colorSoFarG=0;
colorSoFarB=0;
colorSoFarA=0;
alphaRemaining=1;
ix=minDimension/2*(z+xCenterShift);
iy=minDimension/2*(zi+yCenterShift);
realx=ix+((w-1)/2);
realy=((h-1)/2)-iy;
if(realx<0 || realx>=w,
if(XEdgeType==1,
realx=realx%w;
if(realx<0,realx=w+realx)
);
if(XEdgeType==2,
realx=abs(realx%w);
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
if(XEdgeType==3,
realx=abs(realx%w);
realy=h-realy;
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
);
if(realy<0 || realy>=h,
if(YEdgeType==1,
realy=realy%h;
if(realy<0,realy=h+realy)
);
if(YEdgeType==2,
realy=abs(realy%h);
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
if(YEdgeType==3,
realy=abs(realy%h);
realx=w-realx;
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
);
ColorOutR=i(#0,realx,realy,0,0,Antialias,0)/255;
ColorOutG=i(#0,realx,realy,0,1,Antialias,0)/255;
ColorOutB=i(#0,realx,realy,0,2,Antialias,0)/255;
ColorOutA=i(#0,realx,realy,0,3,Antialias,0)/255;
colorSoFarR=colorSoFarR+(ColorOutR*ColorOutA*alphaRemaining);
colorSoFarG=colorSoFarG+(ColorOutG*ColorOutA*alphaRemaining);
colorSoFarB=colorSoFarB+(ColorOutB*ColorOutA*alphaRemaining);
colorSoFarA=colorSoFarA+(ColorOutA*ColorOutA*alphaRemaining);
alphaRemaining=alphaRemaining*(1-ColorOutA);
sign=0;
if(tileBasedOnTransparency,
if(transparentPointsIn && alphaRemaining>epsilon,sign=-1);
if(!transparentPointsIn && alphaRemaining>epsilon,sign=1),
radius=sqrt(z*z+zi*zi);
if(radius<r1,sign=-1);
if(radius>r2,sign=1)
);
if(sign<0,
ratio=r2/r1*cos(angle);
ratioi=r2/r1*sin(angle)
);
if(sign>0,
ratio=r1/r2*cos(angle);
ratioi=-r1/r2*sin(angle)
);
if(levelToShow>1,
lograt=levelToShow*0.5*log(ratio*ratio+ratioi*ratioi);
lograti=levelToShow*atan2(ratioi,ratio);
ratio=exp(lograt)*cos(lograti);
ratioi=exp(lograt)*sin(lograti)
);
iteration=StartingLevel;
maxiteration=NumberOfLevels+StartingLevel-1;
while(sign!=0 && iteration<maxiteration,
zx=z*ratio-zi*ratioi;
zy=z*ratioi+zi*ratio;
z2=zx;
z2i=zy;
z=z2;
zi=z2i;
rotatedscaledlogzi=rotatedscaledlogzi-sign*angle;
ix=minDimension/2*(z+xCenterShift);
iy=minDimension/2*(zi+yCenterShift);
realx=ix+((w-1)/2);
realy=((h-1)/2)-iy;
if(realx<0 || realx>=w,
if(XEdgeType==1,
realx=realx%w;
if(realx<0,realx=w+realx)
);
if(XEdgeType==2,
realx=abs(realx%w);
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
if(XEdgeType==3,
realx=abs(realx%w);
realy=h-realy;
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
);
if(realy<0 || realy>=h,
if(YEdgeType==1,
realy=realy%h;
if(realy<0,realy=h+realy)
);
if(YEdgeType==2,
realy=abs(realy%h);
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
if(YEdgeType==3,
realy=abs(realy%h);
realx=w-realx;
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
);
sign=0;
ColorOutR=i(#0,realx,realy,0,0,Antialias)/255;
ColorOutG=i(#0,realx,realy,0,1,Antialias)/255;
ColorOutB=i(#0,realx,realy,0,2,Antialias)/255;
ColorOutA=i(#0,realx,realy,0,3,Antialias)/255;
if(tileBasedOnTransparency,
colorSoFarR=colorSoFarR+(ColorOutR*ColorOutA*alphaRemaining);
colorSoFarG=colorSoFarG+(ColorOutG*ColorOutA*alphaRemaining);
colorSoFarB=colorSoFarB+(ColorOutB*ColorOutA*alphaRemaining);
colorSoFarA=colorSoFarA+(ColorOutA*ColorOutA*alphaRemaining);
alphaRemaining=alphaRemaining*(1-ColorOutA);
if(transparentPointsIn && alphaRemaining>epsilon,sign=-1);
if(!transparentPointsIn && alphaRemaining>epsilon,sign=1),
radius=sqrt(z*z+zi*zi);
colorSoFarR=ColorOutR;
colorSoFarG=ColorOutG;
colorSoFarB=ColorOutB;
colorSoFarA=ColorOutA;
if(radius<r1,sign=-1);
if(radius>r2,sign=1)
);
iteration=iteration+1;
);
ColorOutR=colorSoFarR;
ColorOutG=colorSoFarG;
ColorOutB=colorSoFarB;
ColorOutA=colorSoFarA;
if(ShowGrid,
gridzx=(logz+10*log(r2/r1))%log(r2/r1);
gridzy=(logzi+10*2*pi)%(2*pi);
if(gridzx<epsilon || gridzx>(log(r2/r1)-epsilon) || gridzy<epsilon || gridzy>(2*pi-epsilon),
ColorOutR=0;
ColorOutG=1;
ColorOutB=0;
ColorOutA=1;
);
gridzx=(rotatedscaledlogz+10*log(r2/r1))%log(r2/r1);
gridzy=(rotatedscaledlogzi+10*2*pi)%(2*pi);
if(gridzx<epsilon || gridzx>(log(r2/r1)-epsilon) || gridzy<epsilon || gridzy>(2*pi-epsilon),
ColorOutR=0;
ColorOutG=0;
ColorOutB=1;
ColorOutA=1;
);
);
if(ShowFrame,
gridzx=zinitial;
gridzy=zinitiali;
if(gridzx<(aspectRatio*r2) && gridzx>-(aspectRatio*r2) && gridzy<r2 && gridzy>-r2,
dx=min((aspectRatio*r2)-gridzx,gridzx+(aspectRatio*r2));
dy=min(r2-gridzy,gridzy+r2);
if(dx<(4*epsilon) || dy<(4*epsilon),
ColorOutR=1;
ColorOutG=1;
ColorOutB=1;
ColorOutA=1
);
if(dx<(2*epsilon) || dy<(2*epsilon),
ColorOutR=0;
ColorOutG=0;
ColorOutB=0;
ColorOutA=1
),
ColorOutR=0.75*ColorOutR;
ColorOutG=0.75*ColorOutG;
ColorOutB=0.75*ColorOutB;
ColorOutA=1
);
);
if(!DoNotFlattenTransparency,ColorOutA=1);
i(#1,x,y,0,1)=ColorOutG*255;
i(#1,x,y,0,2)=ColorOutB*255;
i(#1,x,y,0,3)=ColorOutA*255;
ColorOutR*255"
-k..
-endl -done
#@gui Crease : fx_crease,fx_crease(0)
#@gui : Amplitude = float(30,0,300)
#@gui : Frequency (%) = float(10,0,100)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/01/22</i>.</small>")
fx_crease :
repeat $! l[$>]
if {!$3} to_a fi
2,2,1,2,{"const w1 = w#-1-1; const h1 = h#-1 - 1; [ 0,w1,0,w1,0,0,h1,h1 ];"}
r. {0,D=$2*[w,h]%;[max(D[0],1),max(D[1],1)]},1,2,3 noise. $1,1
r. ..,..,1,2,3 warp.. .,0,1,$3 rm.
endl done
#@gui Distort Lens : fx_distort_lens, fx_distort_lens(1)
#@gui : Amplitude = float(0.1,-1,1)
#@gui : Aspect Ratio = float(0,-2,2)
#@gui : Zoom = float(0,-4,4)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/18/02</i>.</small>")
fx_distort_lens :
if {!$6} to_a fi
undistort ${1-3},$4%,$5%,$6
#@gui Drop Water : fx_drop_water, fx_drop_water_preview(1)
#@gui : note = note("<small><b>Shape geometry:</b></small>")
#@gui : Shapes = choice("Procedural","Opaque Regions on Top Layer")
#@gui : Density = float(20,0,100)
#@gui : Radius = float(2,0,5)
#@gui : Variability = float(80,0,100)
#@gui : Random Seed = int(0,0,16384)
#@gui : note = note("<small>Parameters <i>Density</i>, <i>Radius</i>, <i>Variability</i> and <i>Random seed</i> are used only in <i>Procedural shapes</i> mode.</small>")
#@gui : sep = separator(), note = note("<small><b>Light parameters:</b></small>")
#@gui : Refraction = float(3,0,20)
#@gui : Light Angle = float(35,0,360)
#@gui : Specular Size = float(10,0,100)
#@gui : Specular Intensity = float(1,0,1)
#@gui : Specular Centering = float(0.5,0,1)
#@gui : sep = separator(), note = note("<small><b>Shadow parameters:</b></small>")
#@gui : Shadow Size = float(0.25,0,3)
#@gui : Shadow Intensity = float(0.5,0,1)
#@gui : Shadow Smoothness = float(0.75,0,3)
#@gui : Diffuse Shadow = float(0.05,0,3)
#@gui : sep = separator()
#@gui : Smoothness = float(0.15,0,3)
#@gui : Output as Separate Layers = _bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/21/07</i>.</small>")
fx_drop_water :
N={$!-$1}
if {$N<=0} error "At least two layers are required in this mode." fi
repeat $N l[{$!-$>-1}] nm0={n} nm=${-gui_layer_name}
nm img
srand $5
if $1
pass[0] 0 to_a. channels. 100% >=. 50%
r. [0],[0],1,1,0,0,0.5,0.5
else
100%,100%
rmin={max(0.1,$3*(1-$4%))} rmax={max(0.1,$3)}
repeat 10
100%,100%
random3d {max(1,$2)} *3d. {-2,w},{-2,h},0
j3d.. .,0,0,0,1,1,0,0 rm.
b. {$rmin+($rmax-$rmin)*$>/9}%,0,1
j.. .,0,0,0,0,0.5 rm.
done
>=. 10%
fi
nm. shape
+b[shape] 1% n. 0,30
nm. elevation
g[elevation] xy a[-2,-1] c nm. grad
+*[grad] {grad,$6*max(w,h)/100} *. [shape] b. $15%
+warp[img] .,1,1,1 rm.. nm. refraction
+*[grad] -1 100%,100%,1,1,1 a[-2,-1] c orientation.
a={$7*pi/180} ca={-cos($a)} sa={-sin($a)}
mix_channels. ({(1-$10)*$ca},{(1-$10)*$sa},1) c. {100-$8}%,100% n. 0,1
*. [shape] nm. spots
mix_channels[grad] ($ca,$sa)
n[grad] 0,1 *[grad] [shape]
+shift[shape] {-$11*$ca}%,{-$11*$sa}%,0,0,1
-. [shape] >=. 1 b. $13% n. 0,1
nm. shadow
b[shape] $14% n. 0,1
nm[img] name($nm)
*[shadow] 255 channels[shadow] -1,0 mv[shadow] 1
nm[shadow] name($nm" [shadow]"),mode(alpha),opacity({$12*100})
to_a[refraction] sh[refraction] 100% +b[shape] $15% *[-2,-1] rm.
mv[refraction] 2
nm[refraction] name($nm" [refraction]"),mode(alpha)
channels[spots] -1,0 sh[spots] 0 f. 1 rm. *[spots] 255
nm[spots] name($nm" [specular spots]"),mode(alpha),opacity({$9*100})
rv[shape,grad] a[grad,shape] c *[grad] 255 b[grad] $15%
nm[grad] name($nm" [gradient]"),mode(grainmerge)
rv
if {!$16} gui_merge_layers nm $nm0 fi
endl done
if $1 rm[0] fi
fx_drop_water_preview :
N={$!-$1}
if {$N<=0} gui_warning_preview "At least two layers are required in this mode." return fi
if $1
repeat $N l[{$!-$>-1}]
pass[0] 0 mv. 0
fx_drop_water $* gui_merge_layers
endl done
rm[0]
else
repeat $! l[$>]
fx_drop_water $* gui_merge_layers
endl done
fi
#@gui Equirectangular to Nadir-Zenith : fx_equirectangular2nadirzenith, fx_equirectangular2nadirzenith(1)
#@gui : Mode = choice{"to Nadir / Zenith","to Equirectangular"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/29/12</i>.</small>")
fx_equirectangular2nadirzenith :
if $1 nadirzenith2equirectangular else equirectangular2nadirzenith fi
#@gui Euclidean - Polar : fx_euclidean2polar, fx_euclidean2polar(1)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Stretch Factor = float(1,0.1,10)
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui : Inverse Transform = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_euclidean2polar :
if {!$4} to_a fi
if $5 polar2euclidean $1%,$2%,$3,$4 else euclidean2polar $1%,$2%,$3,$4 fi
#@gui Fish-Eye : fisheye, fisheye(1)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : Radius = float(70,0,100)
#@gui : Amplitude = float(1,0,2)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Flower : fx_flower, fx_flower_preview(1)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Amplitude / Angle = point(75,50,0,1)
#@gui : Petals = int(6,2,20)
#@gui : Offset (%) = float(0,0,100)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_flower :
if {!$7} to_a fi
amplitude,angle={dx=$3-$1;dy=$4-$2;[norm(dx,dy),-atan2(dy,dx)*180/pi]}
flower $amplitude,$5,$6%,$angle,$1%,$2%,$7
fx_flower_preview :
fx_flower $*
line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,0
line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,255
#@gui Kaleidoscope [Blended] : fx_rotoidoscope, fx_rotoidoscope(1)
#@gui : Center (%) = point(50,50)
#@gui : Angular Tiles = int(10,1,72)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_rotoidoscope :
if {!$5} to_a fi
rotoidoscope $1%,$2%,$3,$4%,$5
#@gui Kaleidoscope [Polar] : fx_kaleidoscope, fx_kaleidoscope(1)
#@gui : Center (%) = point(50,50)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Radius Cut = float(100,0,100)
#@gui : Angle Cut = float(10,0,100)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_kaleidoscope :
if {!$7} to_a fi
shift $3%,$4%,0,0,2 kaleidoscope $1%,$2%,$5,$6,$7
#@gui Kaleidoscope [Symmetry] : fx_symmetrizoscope, fx_symmetrizoscope(1)
#@gui : Iterations = int(4,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Symmetry Sides = choice("Backward","Forward","Swap")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/07/01</i>.</small>")
fx_symmetrizoscope :
if {!$3} to_a fi
repeat $1
ang={$2+180*$>/max(1,$1-1)}
symmetrize 50%,50%,$ang,$3,0,{if($4!=2,$4,$>%2)}
done
#@gui Moon2panorama : moon2panorama, moon2panorama_preview(1)
#@gui : Center Help = bool(0)
#@gui : Center X = float(0,-20,20)
#@gui : Center Y = float(0,-20,20)
#@gui : Span = float(360,0,1450)
#@gui : Shift X = float(0,-200,200)
#@gui : Shift Y = float(0,-200,200)
#@gui : sep = separator()
#@gui : Antialiasing = bool(1)
#@gui : Edge Behavior X = choice("Blank","Wrap","Reflect","Rotate")
#@gui : Edge Behavior Y = choice("Blank","Wrap","Reflect","Rotate")
#@gui : sep = separator()
#@gui : note = note("<small>This filter is a conversion of the Mathmap script originally written by Edgar Bonet</small>")
#@gui : url = link("Edgar Bonet.","http://edgar-bonet.org/")
#@gui : note = note("<small>Converts partial cylindrical layout to panorama layout</small>")
moon2panorama_preview :
-moon2panorama ${1--1}
moon2panorama :
-repeat $! -l[$>]
--f. 0
-sh. 0
-f. "
begin(
center_help=$1;
center_x=$2;
center_y=$3;
span=$4;
shift_x=$5;
shift_y=$6;
Antialias = $7;
XEdgeType = $8;
YEdgeType = $9;
AR=w/h;
if (AR>1, W=2;H=2/AR,H=2;W=2/AR);
minXY=min(W/2,H/2);
);
if (AR>1,
X=(2*x/(w-1))-1;
Y=(1-(2*y/(h-1)))/AR,
X=((2*x/(w-1))-1)/AR;
Y=1-(2*y/(h-1))
);
scaled=X/W*span;
scaledi=(Y/(1+9*center_help))/W*span;
shifted=(scaled-shift_x)*pi/180;
shiftedi=(scaledi-shift_y)*pi/180;
reshifted=shiftedi;
reshiftedi=-shifted;
remapped=-exp(reshifted)*sin(reshiftedi);
remappedi=exp(reshifted)*cos(reshiftedi);
centered=(remapped*0.8+center_x/100)*minXY;
centeredi=(remappedi*0.8+center_y/100)*minXY;
if (center_help && abs(2*Y/H)<0.01,
outR=255;
outG=255;
outB=0;
outA=255,
if (AR>1,
realx=(centered+1)*(w-1)/2;
realy=(1-AR*centeredi)*(h-1)/2,
realx=(AR*centered+1)*(w-1)/2;
realy=(1-centeredi)*(h-1)/2
);
if(realx<0 || realx>=w,
if(XEdgeType==1,
realx=realx%w;
if(realx<0,realx=w+realx)
);
if(XEdgeType==2,
realx=abs(realx%w);
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
if(XEdgeType==3,
realx=abs(realx%w);
realy=h-realy;
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
);
if(realy<0 || realy>=h,
if(YEdgeType==1,
realy=realy%h;
if(realy<0,realy=h+realy)
);
if(YEdgeType==2,
realy=abs(realy%h);
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
if(YEdgeType==3,
realy=abs(realy%h);
realx=w-realx;
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
);
outR=i(#0,realx,realy,0,0,Antialias);
outG=i(#0,realx,realy,0,1,Antialias);
outB=i(#0,realx,realy,0,2,Antialias);
outA=i(#0,realx,realy,0,3,Antialias);
);
i(#1,x,y,0,1)=outG;
i(#1,x,y,0,2)=outB;
i(#1,x,y,0,3)=outA;
outR"
-k..
-endl -done
#@gui Perspective : fx_warp_perspective, fx_warp_perspective(1)
#@gui : X-Angle = float(1.73,-4,4)
#@gui : Y-Angle = float(0,-4,4)
#@gui : Zoom = float(1,0.1,4)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : X-Offset = float(0,0,100)
#@gui : Y-Offset = float(0,0,100)
#@gui : Boundary = choice(2,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_warp_perspective :
if {!$8} to_a fi
shift $6%,$7%,0,0,2 warp_perspective $1,$2,$3,$4,$5,$8
#@gui Polar Transform : fx_transform_polar, fx_transform_polar(1)
#@gui : Preset = choice("Custom Transform","Inverse Radius","Swap Radius / Angle")
#@gui : Center (%) = point(50,50,0,1)
#@gui : Radius = text{"r + R/10*cos(a*5)"}
#@gui : Angle = text{"a"}
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_transform_polar :
if {!$6} to_a fi
if {$1==0}
transform_polar "$4","$5",$2%,$3%,$6
elif {$1==1}
transform_polar R-r,a,$2%,$3%,$6
else
transform_polar a*R/(2*pi),r*2*pi/R,$2%,$3%,$6
fi
#@gui Quadrangle : fx_quadrangle, fx_quadrangle_preview(1)
#@gui : Top-Left Vertex (%) = point(5,5,0,1,255,0,0)
#@gui : Top-Right Vertex (%) = point(95,25,0,1,0,255,0)
#@gui : Bottom-Right Vertex (%) = point(60,95,0,1,64,128,255)
#@gui : Bottom-Left Vertex (%) = point(40,95,0,1,255,255,0)
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Preview Type = choice(1,"Input","Output","Both")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/10/11</i>.</small>")
fx_quadrangle :
at_quadrangle $1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,${9-10}
fx_quadrangle_preview :
repeat $! l[$>]
if {!$10} to_a fi
if $11 +fx_quadrangle $* rr2d. {0,[w,h]},2,3 fi
polygon[{$11==1?1:0}] 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,0.25,255
if {$11>=2}
circle[0] $1%,$2%,4,1,0 circle[0] $1%,$2%,3,1,255,0,0
circle[0] $3%,$4%,4,1,0 circle[0] $3%,$4%,3,1,0,255,0
circle[0] $5%,$6%,4,1,0 circle[0] $5%,$6%,3,1,64,128,255
circle[0] $7%,$8%,4,1,0 circle[0] $7%,$8%,3,1,255,255,0
elif {$11>0}
rm[0]
fi
if {$!==2}
drgba to[0] Quadrangle to[1] Result frame 1,1,0
+a x a[0,1] y rr2d ${-gui_preview_wh},0,3
k[{max(w#0,h#0)>max(w#1,h#1)?0:1}]
fi
endl done
#@gui Raindrops : raindrops, raindrops(0)
#@gui : Amplitude = float(80,0,300)
#@gui : Density = float(0.1,0,1)
#@gui : Wavelength = float(1,0,2)
#@gui : Merging Steps = int(0,0,20)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/28/11</i>.</small>")
#@gui Random : deform, deform(0)
#@gui : Amplitude = float(10,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Reflection : fx_reflect, fx_reflect(1)
#@gui : Height = float(50,0,100)
#@gui : Attenuation = float(1,0.1,4)
#@gui : Color = color(110,160,190,64)
#@gui : Waves Amplitude = float(0,0,100)
#@gui : Waves Smoothness = float(1.5,0,4)
#@gui : X-Angle = float(0,-10,10)
#@gui : Y-Angle = float(-3.30,-10,10)
#@gui : Focale = float(7,0,10)
#@gui : Zoom = float(1.5,1,5)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_reflect :
repeat $!
to_rgba. +rows. {100-$1}%,100% mirror. y water. $7,$8
s. c
f[-4] "(i*(255-$6) + $6*$3)/255"
f... "(i*(255-$6) + $6*$4)/255"
f.. "(i*(255-$6) + $6*$5)/255" a[-4--1] c
*. '(h^$2-y^$2)/h^$2' a[-2,-1] y
100%,100%,100%,1,$11*$12*(x/w-0.5)
100%,100%,100%,1,$11*$12*(y/h-0.5)
100%,100%,100%,1,"$10*(x/w-0.5) + $9*(y/h-0.5) + $11"
/... . +... 0.5 *... {-3,w}
/[-2,-1] +. 0.5 *. {h}
a[-2,-1] c warp.. .,0,1,0 rm.
mv. 0 done
autocrop 0,0,0,0
#@gui Ripple : ripple, ripple(0)
#@gui : Amplitude = float(10,0,100)
#@gui : Bandwidth = float(20,1,300)
#@gui : Shape = choice(2,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,0,360)
#@gui : Offset = float(0,0,500)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/23/08</i>.</small>")
#@gui Seamcarve : fx_seamcarve, fx_seamcarve_preview(1)
#@gui : Width (%) = float(85,0,200)
#@gui : Height (%) = float(100,0,200)
#@gui : Maximal Seams per Iteration (%) = float(15,0,100)
#@gui : Use Top Layer as a Priority Mask = bool(0)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : You can define a transparent top layer that will help the seam-carving algorithm to preserve or force removing image structures:\n
#@gui : \n  - Draw areas in <i>red</i> to force removing them.
#@gui : \n  - Draw areas in <i>green</i> to preserve them.
#@gui : \n  - Don't forget also to set the <i>Input layers...</i> parameter to input both layers to the filter.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Garagecoder</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/02/06</i>.</small>")
fx_seamcarve :
if $4
if {$!<2} error "Priority mask (top layer) is missing!" fi
_fx_seamcarve
fi
seamcarve $1%,$2%,$4,$5,$3%
if $4 repeat $! channels[$>] 0,{$>,s-2} done fi
c 0,255
fx_seamcarve_preview :
if $4
if {$!<2} to_rgb to "Priority mask (top layer) is missing!",5,5,18,2 return fi
_fx_seamcarve
fi
repeat $! l[$>]
w={w} h={h}
seamcarve $1%,$2%,$4,$5,{max($3,10)}%
if $4 channels 0,{s-2} fi
to_rgba r $w,$h,1,100%,0,0,0.5,0.5
endl done
c 0,255
_fx_seamcarve :
mv[0] $!
l.
s c k[0,1]
>[1] [0] !=[0] 0 -[0] [1] *[0] -1 + * 256
endl
repeat {$!-1} a[$>] .,c done rm.
#@gui Sphere : fx_map_sphere, fx_map_sphere_preview(1)
#@gui : Width = _int(512,1,4096)
#@gui : Height = _int(512,1,4096)
#@gui : Radius = float(90,0,400)
#@gui : Dilation = float(0.5,0,1)
#@gui : Angle = float(0,-50,50)
#@gui : Border Smoothness = float(0,0,200)
#@gui : Border Width = float(20,0,100)
#@gui : Orientation = choice("0 deg.","90 deg.","180 deg.","270 deg.")
#@gui : Background = choice("Transparent","Mean Color")
#@gui : Fading = float(0,0,100)
#@gui : Fading Shape = float(0.5,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/07/11</i>.</small>")
fx_map_sphere :
rotate {$8*90}
if $6
repeat $!
shift. {round(w/2)},0,0,0,2 +columns. {(1-$7/100)*w/2},{(1+$7/100)*w/2}
100% gaussian. {0.1*w},{h},0 100% 100% a[-3--1] c r. ..,..,1,3
smooth.. .,$6,5,0 rm.
j.. .,{(1-$7/100)*{-2,w}/2} rm. shift. -{round(w/2)},0,0,0,2
mv. 0 done
fi
shift $5%,0,0,0,2 to_rgba
if $9
repeat $!
+rows[$>] 0 r. 1,1,1,4,2 RGBA$>={^}
r. [$>],[$>],1,4 -[$>,-1]
done
fi
map_sphere $1,$2,$3,$4,$10,$11
if $9
repeat $!
(${RGBA$>}) y. c r. [$>],[$>],1,4 +[$>,-1]
done
fi
fx_map_sphere_preview :
fx_map_sphere {w},{h},${3--1}
#@gui Spherize : fx_spherize, fx_spherize_preview(1)
#@gui : Radius (%) = float(50,0,300)
#@gui : Strength = float(1,-10,10)
#@gui : Smoothness (%) = float(0,0,4)
#@gui : Center (%) = point(50,50,0,1,255,255,255,170,10)
#@gui : Ratio = float(0,-2,2)
#@gui : Angle = float(0,-90,90)
#@gui : Interpolation = choice(2,"Nearest Neighbor","Linear","Cubic")
#@gui : Preview Grid = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/10/03</i>.</small>")
fx_spherize :
ratio={10^$6}
spherize $1%,$2,$3%,$4%,$5%,$ratio,$7,$8
cut 0,255
fx_spherize_preview :
cx,cy=${4,5}
if $9 grid 5%,5%,50%,50%,0.6,255 fi
fx_spherize ${1-3},$cx,$cy,${6--1}
#@gui Square to Circle : fx_square_circle, fx_square_circle
#@gui : Mode = choice(0,"Square to Circle","Circle to Square")
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator()
#@gui : X-Factor (%) = float(0,-100,100)
#@gui : Y-Factor (%) = float(0,-100,100)
#@gui : X-Offset (%) = float(0,-300,300)
#@gui : Y-Offset (%) = float(0,-300,300)
#@gui : sep = separator(), note = note("<small>This filter implements the mapping functions described in this page, by <i>C. Fong</i>:</small>")
#@gui : url = link("http://squircular.blogspot.com/2015/09/mapping-circle-to-square.html")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/10/30</i>.</small>")
fx_square_circle :
mode,interp,boundary,factx,facty,offx,offy=${1-7}
if {!$boundary} to_a fi
base="const interpolation = "$interp";
const boundary = "$boundary";
const offx = "$offx"%;
const offy = "$offy"%;
const factx = 10^-("$factx"%);
const facty = 10^-("$facty"%);
const w2 = int(w/2);
const h2 = int(h/2);"
if {!$mode}
f $base"
const tst = 2*sqrt(2);
U = (2*x/(w-1) - 1)*factx + offx;
V = (2*y/(h-1) - 1)*facty + offy;
U2 = U^2;
V2 = V^2;
U2mV2 = U2 - V2;
X = 0.5*(sqrt(max(0,2 + tst*U + U2mV2)) - sqrt(max(0,2 - tst*U + U2mV2)));
Y = 0.5*(sqrt(max(0,2 + tst*V - U2mV2)) - sqrt(max(0,2 - tst*V - U2mV2)));
(X+=1)*=w2 - 0.5;
(Y+=1)*=h2 - 0.5;
I(X,Y)"
else
f $base"
X = (2*x/(w-1) - 1)*factx + offx;
Y = (2*y/(h-1) - 1)*facty + offy;
U = X*sqrt(abs(1 - 0.5*Y^2));
V = Y*sqrt(abs(1 - 0.5*X^2));
(U+=1)*=w2 - 0.5;
(V+=1)*=h2 - 0.5;
I(U,V)"
fi
#@gui Stereographic Projection : fx_project_stereographic, fx_project_stereographic_preview(1)
#@gui : Transform = choice("Direct","Inverse")
#@gui : Center (%) = point(50,50,0,1,255,255,255,170)
#@gui : Radius / Angle = point(50,75,0,1,255,0,255,170)
#@gui : Horizon Leveling (deg) = float(0,-10,10)
#@gui : Left / Right Blur (%) = float(0,0,20)
#@gui : Dilation = float(0,-2,2)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axis")
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : Last Center = value(50,50)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/07/04</i>.</small>")
fx_project_stereographic :
is_inverse,centerx,centery,radangx,radangy,rechor,lrblur,dilation,mirror,boundary,ocenterx,ocentery=${1-12}
if {$centerx!=$ocenterx" || "$centery!=$ocentery}
deltax,deltay={[$radangx,$radangy]-[$ocenterx,$ocentery]}
radangx,radangy={[$centerx,$centery]+[$deltax,$deltay]}
fi
status=\{$is_inverse\}\{$centerx,$centery\}\{$radangx,$radangy\}\{$rechor\}\{$lrblur\}\{$dilation\}\{$mirror\}\{$boundary\}\{$centerx,$centery\}
nradangx,nradangy={[$centerx,$centery]+rot(-90)*([$radangx,$radangy]-[$centerx,$centery])}
init="const boundary = "$is_inverse?$boundary:2";
const interpolation = 1;
const dilation = 2^"$dilation";
const centerx = "$centerx"%*(W-1);
const centery = "$centery"%*(H-1);
const radangx = "$nradangx"%*(W-1) - centerx;
const radangy = "$nradangy"%*(H-1) - centery;
const R = sqrt(radangx^2 + radangy^2);
const theta0 = atan2(radangy,radangx);
const pi2 = 2*pi;"
m "_fx_project_stereographic_mirror : if {!$""1} mirror y elif {$""1==1} mirror xy elif {$""1==3} mirror x fi"
repeat $! l[$>]
if {!$boundary} to_a fi
if $rechor rotate $rechor,1,3 fi
if $lrblur
100%,1,1,1,!x||x==w-1 shift {round(w/2)},0,0,0,2 b. x,$lrblur% n. 0,1 +b.. x,$lrblur%
r.. .,.,1,1 j... .,0,0,0,0,1,.. k[0] shift {-round(w/2)},0,0,0,2
fi
if $is_inverse
100%,50%,1,100%,"*
const W = w#0;
const H = h#0;
"$init"
theta = theta0 + x*pi2/w;
phi = (y/h - 0.5)*pi;
z = R*sin(phi);
rho = ((R + z)/(R - z))^(0.5/dilation)*R;
X = centerx + rho*cos(theta);
Y = centery + rho*sin(theta);
I(#0,X,Y)"
_fx_project_stereographic_mirror $mirror
else
_fx_project_stereographic_mirror $mirror
{u=0$_is_preview?min(w,h):max(w,h);[u,u,1,s]},"*
const W = w;
const H = h;
"$init"
X = x - centerx;
Y = y - centery;
theta = atan2(Y,X);
beta = ((X^2 + Y^2)/R^2)^dilation;
z = R*(beta - 1)/(beta + 1);
phi = asin(z/R);
theta = ((theta - theta0)*w#0/pi2)%w#0;
phi = (h#0*(phi/pi + 0.5))%h#0;
I(#0,theta,phi)"
fi
k. endl done uncommand _fx_project_stereographic
if $_is_preview
line $centerx%,$centery%,$radangx%,$radangy%,0.75,0xF0F0F0F0,255,255,255,255
line $centerx%,$centery%,$radangx%,$radangy%,0.75,0x0F0F0F0F,0,0,0,255
fi
u $status
fx_project_stereographic_preview :
_is_preview=1
fx_project_stereographic $*
#@gui Symmetrize : fx_symmetrize, fx_symmetrize_preview(1)
#@gui : Point 1 = point(50,50,0,1,0,255,0,170,10)
#@gui : Point 2 = point(50,75,-1,1,255,255,0,170,10)
#@gui : Angle = float(0,-180,180)
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : Type = choice("Symmetry","Antisymmetry")
#@gui : Swap Sides = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/06/11</i>.</small>")
fx_symmetrize :
if {!$6} to_a fi
angle={isnan($3)?$5:atan2($4-$2,$3-$1)*180/pi}
symmetrize $1%,$2%,$angle,${6-8}
fx_symmetrize_preview :
fx_symmetrize $*
rr2d ${-gui_preview_wh},0,1
u,v={angle=isnan($3)?$5*pi/180:atan2($4-$2,$3-$1);[cos(angle),sin(angle)]}
repeat $! l[$>]
x0,y0,x1,y1={V=[$u,$v];([${1,2},${1,2}]+10000*[V,-V])*([w,h,w,h]-1)%}
line $x0,$y0,$x1,$y1,1,0x0F0F0F0F,0,0,0,255
line $x0,$y0,$x1,$y1,1,0xF0F0F0F0,255
endl done
#@gui Textured Glass : fx_textured_glass, fx_textured_glass_preview(0)
#@gui : X-Amplitude = float(40,0,400)
#@gui : Y-Amplitude = float(40,0,400)
#@gui : X-Smoothness = float(1,0,5)
#@gui : Y-Smoothness = float(1,0,5)
#@gui : Edge Attenuation = float(0,0,1)
#@gui : Edge Influence = float(2,0,10)
#@gui : Noise Scale = int(0,0,16)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/21/11</i>.</small>")
fx_textured_glass :
repeat $! l[$>]
100%,100%,1,1
if $7 plasma. 1,1,$7 else rand. 0,1 fi
g. xy
if $5
+gradient_norm... +. 1 b. $6 ^. -$5
*... . *[-2,-1]
fi
blur_xy[-2,-1] $3,$4
*.. {-2,$1/max(abs(im),abs(iM))}
*. {$2/max(abs(im),abs(iM))}
a[-2,-1] c
warp.. .,1,1 rm.
endl done
fx_textured_glass_preview :
gui_split_preview "fx_textured_glass $*",${-3--1}
#@gui Twirl : fx_twirl, fx_twirl(1)
#@gui : Amplitude = float(1,-5,5)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_twirl :
if {!$4} to_a fi
twirl $1,$2%,$3%,$4
#@gui Water : water, water(0)
#@gui : Amplitude = float(30,0,300)
#@gui : Smoothness = float(1.5,0,4)
#@gui : Angle = float(45,0,180)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/07/10</i>.</small>")
#@gui Wave : wave, wave(1)
#@gui : Amplitude = float(10,0,30)
#@gui : Frequency = float(0.4,0,2)
#@gui : Center (%) = point(50,50,0,1,255,255,255,170,10)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Wind : fx_wind, fx_wind_preview(0)
#@gui : Amplitude = int(20,0,500)
#@gui : Angle = float(0,0,360)
#@gui : Attenuation = float(0.7,0,1)
#@gui : Threshold = float(20,0,100)
#@gui : Mode = choice(1,"Darker","Brighter")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/13/07</i>.</small>")
fx_wind :
if {!$5} negate fi
ac "wind ${1-4}",$6,$7
if {!$5} negate fi
fx_wind_preview :
gui_split_preview "fx_wind $*",${-3--1}
#@gui Zoom : fx_zoom, fx_zoom(1)
#@gui : Factor = float(2,0.01,10)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_zoom :
if {!$4" && "$1<1} to_a fi
zoom $1,{$2%},{$3%},0,$4
#@gui _
#@gui <b>Degradations</b>
#@gui Blur [Angular] : fx_blur_angular, fx_blur_angular_preview(1)
#@gui : Amplitude (%) = float(2,0,20)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Sharpness = float(0,0,500)
#@gui : Preview Guides = bool(1)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/16/01</i>.</small>")
fx_blur_angular :
ac "blur_angular $1%,$2%,$3% sharpen $4",$6,$7
fx_blur_angular_preview :
fx_blur_angular $*
if $5
line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
fi
#@gui Blur [Bloom] : fx_blur_bloom, fx_blur_bloom_preview(0)
#@gui : Amplitude = float(1,0,10)
#@gui : Ratio = float(2,0,5)
#@gui : Iterations = int(5,0,100)
#@gui : Operator = choice("Add","Max","Min")
#@gui : Kernel = choice("Quasi-Gaussian","Gaussian","Box","Triangle","Quadratic")
#@gui : Normalize Scales = bool(0)
#@gui : Anisotropy = float(0,0,1)
#@gui : Angle = float(0,-180,180)
#@gui : note = note("Parameter <i>Angle</i> is only active when <i>Anisotropy</i>&gt;0")
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/03/02</i>.</small>")
fx_blur_bloom :
op=${"arg 1+$4,+,max,min"}
if {!$7} ac "blur_bloom ${1-3},"$op",${5-6},xy",$9
else
wh={[w,h]}
rotate $8,2,1
ac "blur_bloom ${1-3},"$op",${5-6},x blur_bloom {$1*(1-$7)},${2-3},"$op",${5-6},y",$9
rotate {-$8},2,1
r $wh,1,100%,0,0,0.5,0.5 c 0,255
fi
fx_blur_bloom_preview :
gui_split_preview "fx_blur_bloom $*",${-3--1}
#@gui Blur [Depth-of-Field] : fx_blur_dof, fx_blur_dof_preview(1)
#@gui : Blur Amplitude = float(3,0,20)
#@gui : Blur Precision = int(16,2,64)
#@gui : Depth-of-Field Type = choice{"Gaussian","User-Defined (Bottom Layer)"}
#@gui : Invert Blur = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small><b>Gaussian depth-of-field:</b></small>")
#@gui : Center (%) = point(50,50,0,0,255)
#@gui : First Radius = float(30,0,200)
#@gui : Second Radius = float(30,0,200)
#@gui : Angle = float(0,0,180)
#@gui : Sharpness = float(1,0,8)
#@gui : Preview Guides = bool(1)
#@gui : sep = separator()
#@gui : note = note("<small><b>User-defined depth-of-field:</b></small>")
#@gui : Gamma = float(0,-2,2)
#@gui : note = note("<small>You can specify your own depth-of-field image, as a <b>bottom layer</b> image whose luminance encodes the depth for each pixel.
#@gui : Don't forget to modify the <b>Input layers</b> combo-box to make this layer active for the filter.</small>")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/25/02</i>.</small>")
fx_blur_dof :
_$0 ${1-10},0,$12
fx_blur_dof_preview :
_fx_blur_dof $*
_fx_blur_dof :
if {!$3}
repeat $! l[$>] if $11 drgba fi split_opacity l[0]
rmax={(w*w+h*h)^0.5} R={$7*$rmax/100} r={$8*$rmax/100}
t={$9*pi/180} u={cos($t)} v={sin($t)}
l1={($rmax/(1e-8+$R))^2} l2={($rmax/(1e-8+$r))^2}
a={$l1*($u)^2+$l2*($v)^2} b={$u*$v*($l1-$l2)} c={$l1*($v)^2+$l2*($u)^2}
100%,100%,1,1,'X=(x-$5*w/100)/max(w,h);Y=(y-$6*h/100)/max(w,h);f=$a*X*X+2*$b*X*Y+$c*Y*Y;exp(-f^$10/2.5)'
-[1] 1 *[1] -$1 ms={im} Ms={iM}
if $11
+isoline3d[1] {0.1*$1} col3d. 255,255,0
+isoline3d[1] {0.5*$1} col3d. 255,128,0
+3d[-2--1]
__fx_dof_blur[0,1] $2,$ms,$Ms,$4
[0],[0],1,3 j3d. ..,0,0,0,1,1,0,0 rm..
circle. $5%,$6%,3,1,255,255,255
+compose_channels. + !=. 0 dilate. 3
j[0] ..,0,0,0,0,0.5,.,1 rm[-2,-1]
else __fx_dof_blur[0,1] $2,$ms,$Ms,$4
fi
endl if $11 k[0] fi a c endl done
elif {$!>1}
luminance. n. 0,1 ^. {10^$12}
repeat {$!-1} +r. {$>,w},{$>,h},1,1,3 l[$>,-1] split_opacity[0]
__fx_dof_blur[0,-1] $2,0,$1,$4
a c endl done rm.
else drgba to "Depth-of-field (bottom layer) is missing !",2,2,13,2,1,255
fi
__fx_dof_blur :
n[1] 0,{$1-1} round[1]
[0],[0],1,{0,s+1}
s=0
repeat $1
+==[1] {if($4,$<,$>)} b. 2%
j.. [0],0,0,0,0,-1,.,1
j.. .,0,0,0,100%,-1
rm.
ns={$2+($3-$2)*($>+1)/($1-1)}
b[0] {sqrt($ns^2-$s^2)}%
s=$ns
done
s. c,{-s+1} /[-2,-1] rm[0,1]
#@gui Blur [Gaussian] : fx_gaussian_blur, fx_gaussian_blur_preview(0)
#@gui : XY-Amplitude = float(3,0,20)
#@gui : X-Amplitude = float(0,0,20)
#@gui : Y-Amplitude = float(0,0,20)
#@gui : Boundary = choice(1,"Black","Nearest")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_gaussian_blur :
b $1,$4
if {$2>0} repeat $! l. s y b $2,$4 a y endl mv. 0 done fi
if {$3>0} repeat $! l. s x b $3,$4 a x endl mv. 0 done fi
fx_gaussian_blur :
ac "_fx_gaussian_blur $1,$2,$3,$4",$5,$6
fx_gaussian_blur_preview :
gui_split_preview "fx_gaussian_blur $*",${-3--1}
#@gui Blur [Glow] : fx_glow, fx_glow_preview(0)
#@gui : Amplitude = float(6,0,20)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_glow :
ac "glow $1",$2,$3
fx_glow_preview :
gui_split_preview "fx_glow $*",${-3--1}
#@gui Blur [Linear] : fx_blur_linear, fx_blur_linear_preview(1)
#@gui : Tangent Radius = float(10,0,100)
#@gui : Orthogonal Radius = float(0.5,0,100)
#@gui : Angle = float(0,0,180)
#@gui : Sharpness = float(0,0,500)
#@gui : Boundary = choice(1,"Black","Nearest")
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_blur_linear :
ac "blur_linear $1,{$2*$1/100},$3,$5 sharpen $4",$6,$7
fx_blur_linear_preview :
gui_split_preview "fx_blur_linear $*",${-3--1}
#@gui Blur [Radial] : fx_blur_radial, fx_blur_radial_preview(1)
#@gui : Amplitude = float(3,0,20)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Sharpness = float(0,0,500)
#@gui : Preview Guides = bool(1)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/16/01</i>.</small>")
fx_blur_radial :
ac "blur_radial $1%,$2%,$3% sharpen $4",$6,$7
fx_blur_radial_preview :
fx_blur_radial $*
if $5
line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
fi
#@gui Chromatic Aberrations : fx_chromatic_aberrations, fx_chromatic_aberrations_preview(0)
#@gui : Primary Color = color(255,0,0)
#@gui : X-Shift = float(2,-16,16)
#@gui : Y-Shift = float(2,-16,16)
#@gui : sep = separator()
#@gui : Secondary Color = color(0,255,0)
#@gui : X-Shift (px) = float(0,-16,16)
#@gui : Y-Shift (px) = float(0,-16,16)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/05/07</i>.</small>")
fx_chromatic_aberrations :
l[]
(${1-3}) (${6-8}) y c orientation[0]
+*[0,1] +*[0] {is} -[1,3] rm[2] orientation[1]
_cross3d {0,^},{^} y x a y
M={^} transpose Minv={^} rm
endl
repeat $! l[$>] to_color split_opacity l[0]
mix_rgb $M
s c
100%,100%,1,2 fc. {($9-$4)/2},{($10-$5)/2} warp[0] .,1,2,1 rm.
100%,100%,1,2 fc. {($4-$9)/2},{($5-$10)/2} warp[1] .,1,2,1 rm.
100%,100%,1,2 fc. {(-$4-$9)/2},{(-$5-$10)/2} warp[2] .,1,2,1 rm.
a c
mix_rgb $Minv
endl a c endl done
c 0,255
fx_chromatic_aberrations_preview :
gui_split_preview "fx_chromatic_aberrations $*",${-3--1}
#@gui CRT Sub-Pixels : fx_gcd_crt, fx_gcd_crt(2)
#@gui : note = note("<i>Cathode ray tube sub-pixel rendering filter</i>"), sep = separator()
#@gui : Horizontal Blur = float(1.8,0,5)
#@gui : Vertical Blur = float(1.8,0,5)
#@gui : Screen Border = bool(0)
#@gui : Equalize = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/12/11</i>.</small>")
fx_gcd_crt : -skip ${1=1.8},${2=1.8},${3=0},${4=0}
-repeat $! -l[$>]
-to_rgb[0]
-expand_xy 12,0 24,14,1,3,0
-f[-1] "if((x-c*4)%12<4,255,0)"
-f[-1] "if(x%4==0,0,i)"
-f[-1] "if((y%14==0)&&(x%24<12),0,i)"
-f[-1] "if(((y-7)%14==0)&&((x+12)%24<12),0,i)"
-array[-1] {0,round(w/24)},{0,round(h/14)},2
-z[-1] 0,0,{0,w-1},{0,h-1}
-s c -repeat 3 -blend[-4,-1] shapeaverage0 -done -a c
-n[-1] 0,255 -meancurvature_flow[-1] 4
-if $3
{w},{h},1,1,0
-rectangle[-1] 5%,5%,95%,95%,1,1
-b[-1] 10% -*[0,1]
-endif
-deriche[-1] $1,0,x -deriche[-1] $2,0,y
-shrink_xy[-1] 12 -n[-1] 0,255
-if $4 -equalize[-1] 256 -endif
-endl -done
#@gui Dirty : fx_dirty, fx_dirty_preview(0)
#@gui : Amplitude = float(30,0,100)
#@gui : Monochrome = bool(1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/24/11</i>.</small>")
fx_dirty :
ac "_fx_dirty ${1-2}",$3,$4
fx_dirty_preview :
gui_split_preview "fx_dirty ${1--2}",${-3--1}
_fx_dirty :
repeat $! l[$>]
dct 100%,100%,1,{if($2,1,s)} noise. $1,2
==. 0 point. 0,0,0,1,1
* idct c 0,255
endl done
#@gui Flip &amp; Rotate Blocs : fx_flip_blocs,fx_flip_blocs_preview(0)
#@gui : X-Size (px) = int(4,1,128)
#@gui : Y-Size (px) = int(4,1,128)
#@gui : Flip = choice(3,"None","X-axis","Y-axis","XY-axes")
#@gui : Rotate = choice(1,"-90 deg.","0 deg.","90 deg.")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/01/09</i>.</small>")
fx_flip_blocs :
repeat $! l[$>]
if $5 ac "_fx_flip_blocs ${1-4}",$5
else _fx_flip_blocs ${1-4}
fi
endl done
_fx_flip_blocs :
if {($3%2)" && "$1>1} s x,-$1 mirror x a x fi
if {($3>1)" && "$2>1} s y,-$2 mirror y a y fi
if {$4!=1" && "$1>1" && "$2>1}
s y,-$2 N=$!
s x,-$1 M={$!/$N}
ap "rotate {($4-1)*90}"
append_tiles $M,$N
fi
fx_flip_blocs_preview :
gui_split_preview "fx_flip_blocs $*",${-3--1}
#@gui JPEG Artefacts : fx_jpeg_artefacts, fx_jpeg_artefacts_preview(0)
#@gui : note = note("<small>This filter simulates the JPEG compression artifacts, using DCT quantization on 8x8 blocs.</small>")
#@gui : Quality (%) = int(50,1,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/05/07</i>.</small>")
fx_jpeg_artefacts :
base642img "MSBmbG9hdCBsaXR0bGVfZW5kaWFuCjggOCA2NCAxICMyMjIyCnic5Vs9q51FEC60kKtWMYpaCirYKCoI767iR6UoSangtdM/EAM2Fgab2FhaWdgIUXOqVO8sXEHBVDFia6kgCBaCQSyu+5w8c3nv5p55Bg+3uSmGs19nP2Z2Zt752P39/bJ/G8PHF5+qD1y4v77+yNWyeulegPWy9bbW+9pJ7z9XH6s/f3KxdLBeRr2hjDb0nfR+4OZyxwlw8UbHS4f1nehtBTg66f3kAyOU261OfDTiA/ehEV91ga8T208+cDlg5JNKPiknvR8ykfKwLuRlo7y0k96PegS8MxsB80RAnROBRYC9R0AZtxF45o1w+cXz9fHvztTnP7y7nv7z5dLBern1NvTht37/75P17Qt/lOsPPQqwXrbeth6D/6Hv3F2fl2/++WXqMPfyegzmwZz439e9755fHwbMvTxjHqwFQBlt6MMYjMV/8F/MgbkwJ+bGGlgLa2Jt7AF7wRjMg/+hD3vG3nmGxr0Y5/S+euPGe/XVJ/ZKB+vlBkAZbeh77ctX6re/f1E6WC83AMpoQ9+Zd++oV6+8WTpYLzcAymhD30+fPlee/e2zqcPcywZAGW3oO6J+aPw437jeuJ9xv+N5xvMCD/d1vABPL3QcdVjjpbcV4rb+2PGK8jsdxx3QjrZCvJevOl2A3/c7jTqs8dvbJtKkgK7A/eU+rsMEGoDOpJehjDb0YQzG4j+kpWEuzIm5sQbWwpqkc8NesCfsDXvEXrFn3oGGs+BMOBvOiLPizPgP+fzgW3Gsu87wb4mxTj53fixjfeDxo+qb2suC/2+Z1+ub9uX1TefyOundSG/HlxFfjfRupHclvo34dno30tvpNZNeRnob6V1I75n0nknvQnr7fZl4XybSu5Lexvs28b45vSvp7fe18L4W0ruS3n7fC+97JV808oWRLyr5ppCvGvnKyFeVfFfIl418aeTLSr4t5GsjX8/ka+f76Yj6ofHjfON6437G/Y7nGc/rMtZlJfVBoz5weXrAS9QHjfrAKI+N8tj1gVEfuDyfKc+N+sCoD2bqg4n6oPia1AeuTwr1SaU+KNQHE/VRoT5yfVBd9lCfVeoz1wfVdZPbSJvAv6ECsAjc5vq/oOZX+1Pncx3nusp1zkJ3lL1+p37gXcad7GXb490CoIw212MYi//4XcNcmNPvNdbCmn4vo341v9qfOt8HH71V/7rzSulgvYx6Qxlt3vfg36cBxnZDGW3+v6F+aPw4n1pv7Ffzq/2p9YCb6x0nwMXZjpcOa7z3trUcAW6f6TgFLv07BDjvbRNwDEAZbf5dgrH4zx5lEebCnJgba2AtrOlyK+pX86v9qfO5LeQ20lgfeHzk+RK0L30ut8ybrav51f7UOsRHIz6cHkZ6NOLTiM9Cesykh5EehfQw0mMiPQrpWUnPRnoU0qOqfjW/2p86H/nA5YDzbCWfFPKR85mRz5zvyxH1Q+PH+dR6Y7+aX+1PrUd52yhvG+Vlo7w0ylujvDXKW6O8nSlvC+VtobwulNcT5W2lvHV5Xynvi+pX86v9qfMp+x6+ogiUfU0fVAQlAuWfgF8rAuUfUPb9Kdrnl/p32E7/VuswXaJ93vvKKrCvV7Qhdm/aCQf2H77bd29+m69tMpTR5vYfxuI/+O8q8E9g7VP0L2BP2Bv2eIn+hVP85o/8A9QxZW9h37ucQd+1fkee7veow9TLBYAy2q5Rr0T29dmF/U55d2C/uz4a6ofGK//EuJ9xv+N5xvMu7XvgfHew74Ez4BV4Bo6BW+B1h/a529erhX29WtjXmBPf9+g732ncYU1XfN9jLQDKaEMfxmAs/rNL2w5zrRb+idXCP4E9YC/YE/aGPWKvO/QvLP0DXO+Qf0DZ9+Rz5ycb68q+Hnh85HkL2m3B/xvt+E378rryD+wG9j1wRXqXnYV9zvuAvsl5dLSvSa9KelfS20jvifQupHcjvQvvy7z87+oI/4TLFtLbdhb+Bd4H3Nd5N/APYL29hb3s37P+nYA+8lUhX03kKyPfzcq+9m+Qswv7fcH3dkT90Hjlnxj3M+53PM94XmXfU55OlKeF+qBQH0xL+xo0WQ32NeV5oTx3fVDcN+Q+HuqDRn1g1Afz0j+BuVeDf4L6aKY+MuoDoz6YlX8gESO3LWHbGP2xrp+InzfGSw58kxjLeEpN9G8bvz/W9RPx823j7dvG7491/UT8fB07Zbx0rZsYT/VvZ9W/bfz+WNdPxMu3jbNvG68/1vUT8XMjvmxBr0J8lkT/tvH7Y10/ET/fNt6+bfz+WNdPxM+N8tS/Pz3uZQt5GvVvG78/1vUT9nccP9f2t8ohCO3zhP8h9A8o/0PC/g7t+4T9HfoXlH2e8D+E/gHlf0jY36F9n7C/Q/+Css8T/ofQP6D8Dwn7O7TvE/Z36F9Q9nnC/xD6B5T/IWF/h/Z9wv4O/QvKPk/4H0L/gPI/JOzv0L5P2N+hf0HZ5wn/Q+gfUP6HhP0d2vcJ+zv0Lyj7POF/CP0Dyv+QsL9D+z5hf4f+BWWfJ/wPoX9A+R8S8XMVo1f5Ayp+r/IHwvnV/tT5EvFzFb9X+QMqfq/yB8L5E/kD4fkS8XMVv1f5Ayp+r/IHVL6Ayh8I10vEz1X8XuUPqPi9yh8I50/kD4TnS8TPVbxe5Q+o+L3KH1B5Aip/IFwnET9X8XuVP6Di9yp/IJw/kT8Qni8RP1fxe5U/oOL3Kn9A5Quo/IFwvUT8XMXvVf6Ait+r/IFw/kT+QHg+lZ+fyL8P7XvlP1D2u/IPJN4fhO8LVH5+Iv8+tO9V/n3i/UHoH0i8PwjfF6j8/ET+ffg+QPkPEu8Pwvz+xPuD8H2Bys9P5N+H7wNU/n3i/UGY3594fxC+L1D5+Yn8+9C+V/4DZb8r/0Di/UH4vkDl5yfy78P3ASr/PvH+IMzvT7w/CN8XqPz8RP59+D5A+Q8S7w/C/P7E+4PwfYHKz0/k34f2vcq/T7w/CP0DifcH4fuC/wBiGjbi"
base642img "MSBmbG9hdCBsaXR0bGVfZW5kaWFuCjggOCA2NCAxICMyOTE3CnicjVsxjybFEV0JB4iDyHdYhhAJIznBAiSS6ZbBkb3YS4glHOI/4ENyQuDTOsAJIRGBEyP7di+6cKo5yZY4J95DmxKChIREYMln5ODo1/OqXd9KU1XZzX37Tc+rqqlX9aq+o6Ojevr+T+rvlh/VH9x6uh716189d79c/un9cue1pwo+O//pu/Xhw9/WF/5+Mv62vnet/vzHn5Qb37xe8D189vs//Lr+4i8/G/d5853H6r+/d7d89sGrBffE9/DZP/734jjjN7e+Lp989efy4Jnny6NHj4o9H9e/NOfj3zgP98T3cP3u4x+V+3ffKufffr7g7/AsOA/3xDU+++F/bpRXvvxwwT3wnHgWnIdrfA+fPfnFswvw4lx87/y1p6Rft/48rT9Pe+O5+4Jnw/PjjO9/8zquW7dH65hbee8a/m5gw/kPPnhV8D181u3RTt55rOHewI1n+9czz0u/bv1+rX+nvX3rawFePf+sn9+vxZ4PvMANTH/79vO1X0u3R+v2aDcf/0jwPdwbeF/68sO1X0t/VunPI5/efUuAF7iB99oXz679Wro9pNtDbvf7Af8bm73HucDf7VDUH8BfNn8LcONvuh2KxgP+7mTztwA3nrvboWg84B5vb/4W4Ab+boei8QD89nzgPzPnA//Nzd8DN/B3OywaD8D/6ebvgRv36XZYNB6A//bm7xW4gb/bYdF4AP4723mtx72YeBjPA/w3NrwN55t4GPbAc3624R0+MfEw7IF7Pdjwtv68YuJh2AP49XxgM/Ewzgf+8w1v63Fv42HYA/hf2fAK/s/Ew7AH7v3khlf6fVYTD8MexC/EX4i/8fxK/EL8lfgb8VfiF+KvxN+IvxK/EH8h/kb8lfiF+Avxz/OJfyX+QvxC/JX4V+IvxC/EX4h/Jf6F+IX4C+Nf9DzGvzD+GuN/4mX8C+O/Mf4nXsa/MP4b418UL+NfGP+N8T/PZ/zP8xn/Ey/jf2X8C+N/4mX8r4x/YfyvipfxvzL+xfgb+a8w/1Xmn2L8jfxXmP8q85/1N/JfYf6rzH/V+Bv5rzD/VeY/62/kv8L8N883/kb+W5j/KvOf9Tfy38L8V5j/ivE38t/C/FeY/0b+Z74ddiD/CflHyH9N/U3+a+Q/If819Tf5r5H/hPzX1N/kPyH/Cflvnk/+m+eT/5r6m/wn5L+V/Cfqb/KfkP9W8p+ov8l/K/lvPQr4X/n7+Ap/3yN/R/yLd+k6+eain4/rv/bzX+7PhvMt3xG/EP/I1X/sn93p9v9vtzHsiGvaX2j/ybe0f6P9x5m4F95fvKO0n8B+/+w2OiP/efyv+Rp4Lwx/H5O/I/7FPfE94H2ixx/eseusRz7u8Qe8mu8Y/7MeQvwDr+ZbfK9f126P2u1R+f41zbd8/2Y9hvcPeIEbeG9v70/B9/AZ3p+I/5W/7xn+7niKxkPEv8D/8ebvBc+Pez/BfHyxxb8w/xXmv8L8N84CfubfAtzAj3jSeMDfMf8W5t/K/DvsAvw3N38P3MCPfKjxEPG/8vfxFf5We0T8C/zkn9LjfjHxMOwB/OS/Sv7TeBj2AP4bG95Rd5t4GPbAc5N/K/lX42HYA/jPNryV/KnxMOwR8b/y9/EV/ib+kH+JfyH+lfgL8QvxF+IX4q/E34i/EH8j/kr8jfgL8Tfir8TfiH8hfiH+Qvwt4n/l73uGvy82eww7RPzL+F8UL+N/YfwXxn9RvIz/wvivjP+Jl/FfGP+V8T/xMv4L478y/idexv/C+C8R/xt/I/9N/mb+C/nX+Bv5b2X+E+a/1fhb2P9MPoRfjL8HjzD/NeY/629h/zX5GBiNv0e/w/zXmP8k4n/l7+Mr/E3+k4h/yX9F/U3+W8h/i6132P8K+9/xXpD/qvqb/FfJfwf1Fvvvxv572Jj8V9Xf5L9C/lsi/rd8YftvxNPZ1n9PviN+If5RY0f8HfG/5Uvar9B+o3/P6g979UvE/9pvAS/jZ9YT7L9F8x3jf9ZDiP+IvyP+B17Nl3x/Zj2F9yerP+zVLxH/a/+NeGH+EOYP7b+F+a8w/xXmv2GXiL8j/sezMH+uzJ/C/DnsktUf9uqXiP+Bn/xx0H+rPfB35L9C/tN4GPaI+Dvi/3PTv5M/NR6GPbL6w179EvE/8a8nV/pv4q/EvxC/vg+F+CXi74j/z03/zvqpaD19nfpjRn/Yq18i/tf+W/Ey/teT//ffwvq3sP4trH+HHSL+jvif8b8qXsb/yviXrP6wV79E/G/8Xdg/TD5h/63+FvY/kw+RFyL+jvjf+Hth/zT5FHkhqz/s1S8R/9t6wfbf5D/t94r6m/xXyH9LxN8R/9t6if1zYf88+ves/rBXv0T8H+nnmf5b9WrbfyNXnG/1n6v/R/ODqP6wej31m4P6I+L/SD/P9t94JupXc56B9yfS/6P5QVR/nJr6g/rdnOdo/+fxf6SfZ/tvvBPULwv1yxEPkf4fzQ+i+uPU1B/Ubyv122b4b5f/I/08039Tvz7ov9Uekf4fzQ+i+uOU9cdD1h8mHoY9Iv6P9PNM/835xUH/Tfw6/9jV/6P5QVR/EH8h/nZq6g/khYj/I/08238rXsb/wvgvkf4fzQ+i+uPU1B+c31XO75rWPx7/R/p5tv9m/lutno28EOn/0fwgqj+Mv4Xz26nnq/7j8X+kn2f6b51X2P6b/LdE+n80P4jqDzuv4fz+oP5I8P/kO+IX4l8Nfo//3fl9gv8n3xF/I34x+D3+d/cXEvwvmu8Y/7MeMvHv8b87v0/wf9N8x/if9ZCJf4//3f2FBP8L89/C/FeY/8TkP4//3fl9gv8b819h/qvMf83kP4//3f2FBP9P/Z78p/GwGP7z+N+d3yf4v5H/KvlP46EY/vP4391fSPD/1O9Z/4jWw6b+8fjfnd8n+L+x/qmsf5rWw6b+8fjf3V9I8L+w/l1Y/xbWv2LqX4//3fl9gv8b69/C+rey/m2m/vX4391fSPC/+ntl/zP50PQ/Hv+78/sE/6u/hf3P5EPT/3j87+4vJPh/1jvsf4X972r6X4//3fl9gv9nvcP+t7H/FdP/evzv7i8k9H93fp7Q/6feTf3jgH8T+r+7P5DQ/6febeuHe6wfEvq/Oz9P6P+Tf6l/zXmI0b88/d/dH0jo/031zgtTPxyzfkjo/+78PKH/T/6l/tmof1ajf3r6v7s/kND/G/XPWT9Q/2yqfwb6vzs/T+j/lfp3o/49+dfo357+7+4PJPT/Rv37oH5QeyT0f3d+ntD/K+cfjfOPyb9m/uHp/+7+QEL/b5x/HNQPxB/2/9H8PKH/T/7l/Ktx/lXN/MvT/939gYT+3zj/mvUD519N51+B/u/OzxP6/+Rfzj+nHm7mn57+7+4PJPR/9bdcmPqB+S+c/0fz84T+P+cdnH8f8G9C/3f3BxL6/5x32PqB/Bf2/xF/Wr7b2f9z5/eJ/T+3fsjoD97+QmL/z+XPy3j/z53fJ/b/3Pohqz/s7S8k9v9c/ryM9//c+X1i/8+tH7L6w97+QmL/z+XPy3j/z53fJ/b/3Pohoz94+wuJ/T+XPy/j/T93fp/Y/3Prh4z+4O0vJPb/XP68jPf/3Pl9Yv/PrR+y+sPe/kJi/8/lT+Pvvf0/d36f2P9z64es/rC3v5DY/3P509Y7O/t/7vw+sf/n1g8Z/cHbX4j4P5qfZ/vvPf0+0v+j/YGo/ojmF4nf/7nz82z/vaffR/p/tD8Q1R/R/CLx+z93fp7tv/f0+0j/j/YHovojml8kfv/nzs+z/feefh/p/9H+QFR/RPOLxO//3Pl5tv/e0+8j/T/aH4jqj2h+kfj9nzs/z/bfe/p9pP9H+wNR/RHNLxK//3Pn59n+e0+/j/T/aH8gqj+i+UXi93/u/Dzbf+/p95H+H+0PRPVHNL/4DgTd2gQ="
nm[-2,-1] dct,idct
i[Q] (16,11,10,16,24,40,51,61;12,12,14,19,26,58,60,55;14,13,16,24,40,57,69,56;14,17,22,29,51,87,80,62;18,22,37,56,68,109,103,77;24,35,55,64,81,104,113,92;49,64,78,87,103,121,120,101;72,92,95,98,112,100,103,99)
f. "const S = $1<50?5000/$1:200-2*$1; max(1,round((S*i+50)/100,1,-1))"
repeat {$!-3} l[$>,-3--1]
l[0] w,h={[w,h]} r {w+(-w%16)},{h+(-h%16)},1,100%,0,3 rgb2ycbcr s c r[-2,-1] 50%,50%,1,1,2 round. endl
repeat 3
[$>]
f[$>] "begin(boundary = 2; res = vector64());
if (!(x%8) && !(y%8),
src = crop(x,y,8,8);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = sum(src*crop(#"$dct",0,0,off,8,8,1))));
draw(#-1,res,x,y,0,0,8,8);
); i"
round.
+r[Q] {$>,w},100%,1,1,0,2 /.. . round.. *[-2,-1]
f. "begin(boundary = 2; res = vector64());
if (!(x%8) && !(y%8),
src = crop(x,y,8,8);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = sum(src*crop(#"$idct",0,0,off,8,8,1))));
draw(#"$>",res,x,y,0,0,8,8);
); i"
rm.
round[$>]
done
l[^3--1] r ${-max_wh},1,1,1 a c ycbcr2rgb round. r $w,$h,1,3,0 endl
endl done
rm[dct,idct,Q]
fx_jpeg_artefacts_preview :
gui_split_preview "fx_jpeg_artefacts $*",${-3--1}
#@gui Lomo : fx_lomo, fx_lomo_preview(1)
#@gui : Vignette Size = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>J&#233;rome Boulanger</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/06/06</i>.</small>")
fx_lomo :
remove_opacity repeat $! l[$>] to_rgb
+gaussian {100-$1}%,{100-$1}% n. 0,1 *
s c
f[0] '255*atan((i-128)/128)'
f[1] '255*tan((i-128)/128)'
f[2] '255*atan((i-128)/255)'
a c
sharpen 1
normalize 0,255
endl done
fx_lomo_preview :
gui_split_preview "fx_lomo $*",${-3--1}
#@gui Mess With Bits : fx_mess_with_bits, fx_mess_with_bits_preview
#@gui : note = note("<small><b>Input processing:</b></small>")
#@gui : Pre-Normalize = bool(1)
#@gui : Smoothness (%) = float(15,0,100)
#@gui : Multiplier = int(1,1,256)
#@gui : sep = separator(), note = note("<small><b>Output processing:</b></small>")
#@gui : Reversing = choice{1,"None","Reverse bits","Reverse bytes"}
#@gui : Bit Masking (Start) = int(0,0,15)
#@gui : Bit Masking (End) = int(15,0,15)
#@gui : Opacity (%) = float(100,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2019/01/16</i>.</small>")
fx_mess_with_bits :
ac "_fx_mess_with_bits ${1-7}",$8
_fx_mess_with_bits :
repeat $! +l[$>]
b {($2/100)^2*100}% if $1 n 0,255 fi * $3 round
if {$4==1} f "for (k = res = 0, k<15, ++k, res|=((i>>k)&1)<<(15-k))"
elif {$4==2} f "res = ((i>>8)&255) | ((i&255)<<8)"
fi
f "begin( mask = (65535>>(15-max($5,$6))) & (65535<<min($5,$6))); i & mask"
n 0,255
endl j[$>] .,0,0,0,0,{$7%} rm. done
fx_mess_with_bits_preview :
gui_split_preview "fx_mess_with_bits $*",${-3--1}
#@gui Noise [Additive] : fx_noise, fx_noise_preview(0)
#@gui : Amplitude = float(10,0,200)
#@gui : Noise Type = choice("Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_noise :
ac "_fx_noise $1,$2",$3,$4
_fx_noise :
repeat $! l[$>] split_opacity l[0] noise $1,$2 endl a c endl done
fx_noise_preview :
gui_split_preview "fx_noise $*",${-3--1}
#@gui Noise [Perlin] : fx_noise_perlin, fx_noise_perlin_preview(1)
#@gui : Random Seed = int(0,0,65536)
#@gui : sep = separator(), note = note("<small><b>1st scale:</b></small>")
#@gui : Amplitude = float(100,0,512)
#@gui : Scale (%) = float(8,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>2nd scale:</b></small>")
#@gui : Amplitude = float(0,0,512)
#@gui : Scale (%) = float(4,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>3rd scale:</b></small>")
#@gui : Amplitude = float(0,0,512)
#@gui : Scale (%) = float(2,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>4th scale:</b></small>")
#@gui : Amplitude = float(0,0,512)
#@gui : Scale (%) = float(1,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2019/01/24</i>.</small>")
_fx_noise_perlin :
seedx,seedy={[$1>>8,$1&255]}
repeat $! l[$>]
if $2 .,.,1,. noise_perlin. {r=2^$4;s=max(w,h)*$3%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $2 + fi
if $5 .,.,1,. noise_perlin. {r=2^$7;s=max(w,h)*$6%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $5 + fi
if $8 .,.,1,. noise_perlin. {r=2^$10;s=max(w,h)*$9%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $8 + fi
if $11 .,.,1,. noise_perlin. {r=2^$13;s=max(w,h)*$12%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $11 + fi
endl done
fx_noise_perlin :
ac "_fx_noise_perlin $*",$-4,1
fx_noise_perlin_preview :
gui_split_preview "fx_noise_perlin $*",${-3--1}
#@gui Noise [Spread] : fx_spread, fx_spread_preview(0)
#@gui : X-Variations = float(4,0,20)
#@gui : Y-Variations = float(4,0,20)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_spread :
ac "spread $1,$2",$3,$4
fx_spread_preview :
gui_split_preview "fx_spread $*",${-3--1}
#@gui Old-Movie Stripes : fx_stripes_y, fx_stripes_y_preview(1)
#@gui : Frequency = float(10,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_stripes_y :
ac "stripes_y $1",$2,$3
fx_stripes_y_preview :
gui_split_preview "fx_stripes_y $*",${-3--1}
#@gui Oldschool 8bits : fx_8bits, fx_8bits_preview(0)
#@gui : Scale = float(25,1,100)
#@gui : Dithering = float(800,0,10000)
#@gui : Levels = int(16,2,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/02/11</i>.</small>")
fx_8bits :
remove_opacity repeat $! l[$>]
w={w} h={h}
r $1%,$1%,1,100%,2
+luminance sharpen. $2 otsu. 256 blend[-2,-1] shapeaverage0
l. s c quantize $3,1,1 a c endl
r. $w,$h,1,100%,1
endl done
fx_8bits_preview :
gui_split_preview "fx_8bits $*",${-3--1}
#@gui Pixel Sort : fx_pixelsort, fx_pixelsort_preview(1)+
#@gui : note = note{"<small><b>Sorting parameters:</b></small>"}
#@gui : Order = choice(1,"Decreasing","Increasing")
#@gui : Axis = choice("X-axis","Y-axis","X-axis Then Y-axis","Y-axis Then X-axis")
#@gui : Sorting Criterion = choice("Red","Green","Blue","Intensity","Luminance","Lightness","Hue","Saturation","Minimum","Maximum","Random")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Masking parameters:</b></small>"}
#@gui : Mask By = choice(1,"Bottom Layer","Criterion","Contours","Random")
#@gui : Lower Mask Threshold (%) = float(0,0,100)
#@gui : Higher Mask Threshold (%) = float(100,0,100)
#@gui : Mask Smoothness (%) = float(0,0,5)
#@gui : Invert Mask = bool(0)
#@gui : Preview Mask = bool(0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter implements one version of the algorithm described here :
#@gui : </small>"}
#@gui : url = link("http://satyarth.me/articles/pixel-sorting/")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/05/09</i>.</small>")
fx_pixelsort :
_fx_pixelsort ${1-8},0
_fx_pixelsort :
repeat {$!-($4==0)} l[$>]
if {$3==0} +to_rgb channels. 0
elif {$3==1} +to_rgb channels. 1
elif {$3==2} +to_rgb channels. 2
elif {$3==3} +compose_channels +
elif {$3==4} +luminance
elif {$3==5} +to_rgb rgb2hsl. channels. 2
elif {$3==6} +to_rgb rgb2hsl. channels. 0
elif {$3==7} +to_rgb rgb2hsl. channels. 1
elif {$3==8} +compose_channels min
elif {$3==9} +compose_channels max
else 100%,100%,1,1 rand. 0,100
fi
if {$4==0} pass. 0 norm.
elif {$4==1} .
elif {$4==2} +gradient_norm[0]
else +rand. 0,100
fi
b. $7% ir. $5%,{$6+0.01}%
if $8 ==. 0 fi
if $9 k. * 255
else pixelsort[0] {`$1?_'+':_'-'`},{`$2==0?'x':$2==1?'y':$2==2?'xy':'yx'`},[1],[2] k[0]
fi
endl done
fx_pixelsort_preview :
_fx_pixelsort $*
#@gui Rain &amp; Snow : fx_rain, fx_rain_preview(0)
#@gui : Angle = float(65,-180,180)
#@gui : Speed = float(10,0,50)
#@gui : Density (%) = float(50,0,100)
#@gui : Radius = float(0.1,0,3)
#@gui : Gamma = float(1,0,2)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_rain :
repeat $! l[$<] nm=${-gui_layer_name}
100%,100% l.
noise 300 c 0,255 b 1,0
c {100-$3}%,100%
+>= 40% blend shapeaverage0
blur_linear $2,$4,$1
max n 0,255 apply_gamma $5
nm name($nm),mode(screen),opacity({$6*100})
endl
rv
endl done
fx_rain_preview :
gui_split_preview "repeat $! l[$>] fx_rain $* rv blend screen,$6 endl done",${-3--1}
#@gui Random Shade Stripes : fx_shade_stripes, fx_shade_stripes_preview(1)
#@gui : Frequency = float(30,1,100)
#@gui : Orientation = choice(1,"Horizontal","Vertical")
#@gui : Darkness = float(0.8,0,3)
#@gui : Lightness = float(1.3,0,3)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_shade_stripes :
ac "shade_stripes $1,$2,$3,$4",$5,$6
fx_shade_stripes_preview :
gui_split_preview "fx_shade_stripes $*",${-3--1}
#@gui Scanlines : fx_scanlines, fx_scanlines_preview(0)
#@gui : Amplitude = float(60,0,255)
#@gui : Bandwidth = float(2,1,300)
#@gui : Shape = choice(0,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,0,360)
#@gui : Offset = float(0,0,500)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/19/11</i>.</small>")
fx_scanlines :
ac "scanlines ${1-5}",$6,$7
fx_scanlines_preview :
gui_split_preview "fx_scanlines $*",${-3--1}
#@gui Self Glitching : fx_self_glitching, fx_self_glitching_preview(1)
#@gui : Multiplier = float(0,-5,5)
#@gui : Bias = float(0,-255,255)
#@gui : Negate = bool(0)
#@gui : Operator = choice("Add","Mul","And","Or","Xor","Pow","Reverse Pow","Mod","Reverse Mod")
#@gui : Shift Point = point(50,50,0,1)
#@gui : Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/08/19</i>.</small>")
fx_self_glitching :
ac "_fx_self_glitching ${1-7}",$8
_fx_self_glitching :
f "begin(
shift = ([w,h]-1)*(50-[$5,$6])%;
const sign = $3?-1:1;
const boundary = $7;
);
val = sign*((2^$1)*j(shift) + $2);
($4==0?(val + i):
$4==1?(val * i):
$4==2?(val & i):
$4==3?(val | i):
$4==4?xor(val,i):
$4==5?(val^i):
$4==6?(i^val):
$4==7?(val%i):
(i%val)
)%256;
"
fx_self_glitching_preview :
gui_split_preview "fx_self_glitching $*",${-3--1}
#@gui Streak : fx_streak,fx_streak(1)
#@gui : Mask Color = color(255,0,0,255)
#@gui : Step (%) = float(0,0,30)
#@gui : Angle = float(0,0,360)
#@gui : Propagation = choice(3,"Backward","Forward","Bidirectional [Sharp]","Bidirectional [Smooth]")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/12/22</i>.</small>")
fx_streak :
repeat $! l[$>]
to_rgba
if {!$4} R,G,B,A=0 else R,G,B,A=${1-4} fi +select_color 0,$R,$G,$B,$A
if {$7==3} srgb2rgb.. fi
f.. "
const step = max(1,$5%*min(w,h));
const angle = $6*pi/180;
const dx = step*cos(angle);
const dy = step*sin(angle);
if (!i(#-1),I,
ixf = xf = x; iyf = yf = y; lf = 0; if ($7>=1, while (i(#-1,ixf=round(xf),iyf=round(yf)), ++lf; xf-=dx; yf-=dy));
ixb = xb = x; iyb = yb = y; lb = 0; if ($7!=1, while (i(#-1,ixb=round(xb),iyb=round(yb)), ++lb; xb+=dx; yb+=dy));
$7==0?I(ixb,iyb):
$7==1?I(ixf,iyf):
$7==2?(lf<lb?I(ixf,iyf):I(ixb,iyb)):
(lb*lb*I(ixf,iyf) + lf*lf*I(ixb,iyb))/(lb^2+lf^2);
)"
if {$7==3} rgb2srgb.. fi
rm.
endl done
#@gui Visible Watermark : fx_watermark_visible, fx_watermark_visible(0)
#@gui : Text = text{"\\251 G'MIC"}
#@gui : Opacity = float(0.4,0.1,0.9)
#@gui : Size = int(50,13,128)
#@gui : Angle = float(25,0,360)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Lightness = choice(1,"Darker","Brighter")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_watermark_visible : skip "${1= }"
watermark_visible "$1",$2,$3,$4,$6,$5
#@gui Warp by Intensity : fx_warp_by_intensity, fx_warp_by_intensity_preview(0)
#@gui : X-Factor = float(0.04,-6,6)
#@gui : Y-Factor = float(0.04,-6,6)
#@gui : sep = separator()
#@gui : X-Offset = float(128,0,255)
#@gui : Y-Offset = float(128,0,255)
#@gui : sep = separator()
#@gui : Correlated Channels = bool(0)
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/09</i>.</small>")
fx_warp_by_intensity :
if {!$7} to_a fi
ac "_fx_warp_by_intensity ${1-7}",$8
_fx_warp_by_intensity :
if $5 f "ni = norm2(R,G,B); J((ni-$3)*$1,(ni-$4)*$2,0,$6,$7)"
else f "j((i-$3)*$1,(i-$4)*$2,0,0,$6,$7)"
fi
fx_warp_by_intensity_preview :
gui_split_preview "fx_warp_by_intensity $*",${-3--1}
#@gui _
#@gui <b>Details</b>
#@gui Constrained Sharpen : iain_constrained_sharpen, iain_constrained_sharpen(0)
#@gui : Sharpen Radius = float(.75,0,10)
#@gui : Amount = float(2,0,10)
#@gui : Threshold = float(1,0,50)
#@gui : Constraint Radius = int(5,0,10)
#@gui : Overshoot = float(0,0,50)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Value Action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator()
#@gui : note = note("Sharpens image but restricts pixels values to local minimum and maximum values to significantly reduce halos.")
#@gui : note = note("<b>Sharpen Radius</b>, <b>Amount</b> and <b>Threshold</b> are the normal unsharp controls.)
#@gui : note = note("A high <b>Amount</b> will produce aliasing")
#@gui : note = note("<b>Constraint Radius</b> sets the radius to find the local minimum and maximum.)
#@gui : note = note("<b>Overshoot</b> sets how far the sharpening is allowed to go past the local minimum and maximum values.)
#@gui : note = note("Author : <i>Iain Fergusson</i>. release: 2 August 2016 update: 25 August 2018")
iain_constrained_sharpen:
-repeat $! -l[$>]
nm=${-gui_layer_name}
sharp_radius=$1
amount=$2
threshold=$3
constrant_radius=$4
overshoot=$5
channels=$6
value_action=$7
-apply_channels "
sharp_radius=$1
amount=$2
threshold=$3
constrant_radius=$4
overshoot=$5
--dilate_oct[0] $constrant_radius
--erode_oct[0] $constrant_radius
-unsharp[0] $sharp_radius,$amount,$threshold
-add[1] $overshoot
-sub[2] $overshoot
-blend[0,1] darken,1,0
-blend[0,1] lighten,1,0
-blend alpha,1,0
",$channels,$value_action
nm name($nm)
-endl -done
#@gui DCP Dehaze : jeje_dehaze,jeje_dehaze_preview
#@gui : Scale = int(5,1,20)
#@gui : Strength = float(1,0,2)
#@gui : Min = float(.2,0,1)
#@gui : Max = float(1,0,1)
#@gui : Brighness = float(0,-100,100)
#@gui : Contrast = float(0,-100,100)
#@gui : Gamma = float(0,-100,100)
#@gui : Transmittance Map = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Dark Channel Prior dehazing.Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/08/09</i>.</small>")
jeje_dehaze:
-apply_channels "-dehaze {2*$1+1},$2,$3,$4,$5,$6,$7 -if $8 -k[1] -n 0,255 -to_rgb -else -k[0] -endif",rgb,1
jeje_dehaze_preview:
-gui_split_preview "-jeje_dehaze $1,$2,$3,$4,$5,$6,$7,$8",$9
#@gui Details Equalizer : fx_equalize_details, fx_equalize_details_preview(0)
#@gui : Base Scale = float(5,0,15)
#@gui : Detail Scale = float(0.5,0,5)
#@gui : note = note("<small><b>Coarse scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>Medium scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>Small scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>Fine scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(32,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/11/11</i>.</small>")
_fx_equalize_details :
repeat $! l[$>]
split_details 5,{max(0.1,$1)},{max(0.1,$2)}
__fx_equalize_details[1] ${3-6},8
__fx_equalize_details[2] ${7-10},4
__fx_equalize_details[3] ${11-14},2
__fx_equalize_details[4] ${15-18},1
+ c 0,255
endl done
__fx_equalize_details :
threshold $1,1
if {$3==0} b {$2*$5/2}
elif {$3==1}
if {$2>0}
m={im} M={iM} n. 0,255
repeat {int($2/5)} bilateral 15,{5*$5} done
bilateral 15,{($2%5)*$5}
*. {($M-$m)/255} +. $m
fi
else smooth {$2*50},0.2,0.8,$5,$5 fi
* {10^$4}
fx_equalize_details :
ac "gui_parallel_overlap \"_fx_equalize_details ${1-18}\",$21,$22",$19,$20
fx_equalize_details_preview :
gui_split_preview "fx_equalize_details $*",${-3--1}
#@gui Dynamic Range Increase : fx_tk_dri, fx_tk_dri_preview(1)
#@gui : Map Tones = float(0,0,1)
#@gui : Recover Shadows = float(0,0,1)
#@gui : Recover Highlights = float(0,0,1)
#@gui : Enhance Details = float (1,0,5)
#@gui : Detail Strength = float (0.5,0,1)
#@gui : Map Tones = bool(1)
#@gui : Enhance Details = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>      Latest update: <i>2011/12/04</i>.</small>")
fx_tk_dri :
-repeat $! -l[$>]
-if {$6==1}
--negate --to_rgba[0] --luminance[0] --to_rgba[0] --luminance[0]
-fx_gaussian_blur[1] {{{w+h}/20}*{1.1-$1}},0,0,1,0,0,0 -to_gray[1]
-rv[0,1] -fx_compose_softlight[0,1] $1
-fx_gaussian_blur[2] {{w+h}/200},0,0,1,1,0,0 -negate[2] -to_gray[2]
-s[1] c -rv[4,5] -compose_multiply[4,5] -a[1,2,3,4] c -rv[0,1]
-fx_compose_dodge[0,1] $2
-fx_gaussian_blur[2] {{w+h}/200},0,0,1,1,0,0 -to_gray[2] -s[1] c
-rv[4,5] -compose_multiply[4,5] -a[1,2,3,4] c -rv[0,1]
-fx_compose_colorburn[0,1] $3 -endif
-if {$7==1} --map_tones[0] 0.50,0.70,$4,50
--normalize_local[0] $4,6.00,5.00,1.00
-rv[0,1] -fx_compose_value[0,1] $5,0
-rv[0,1] -fx_compose_value[0,1] $5,0 -endif
-endl -done
fx_tk_dri_preview :
-gui_split_preview "-fx_tk_dri ${1--2}",$-1
#@gui Easy Skin Retouch : iain_easy_skin_retouch,iain_easy_skin_retouch_preview(0)
#@gui : note = note("<b>Base Smoothing</b>")
#@gui : Edge Sensitivity = float (7,0,25)
#@gui : Iterations = int (2,1,5)
#@gui : Low Bias = float(.7,0,1)
#@gui : sep = separator ()
#@gui : note = note("<b>Detail Intensity</b>")
#@gui : note = note("If preview appears dark, increase size of preview window.")
#@gui : On = bool(1)
#@gui : Very Fine = float (1,0,2)
#@gui : Fine 2 = float (.7,0,2)
#@gui : Medium 3 = float (.6,0,2)
#@gui : Course 4 = float (.5,0,2)
#@gui : Very Course 5 = float (.5,0,2)
#@gui : Reduce Redness = float (.5,0,1)
#@gui : sep = separator ()
#@gui : Split Base and Detail Output = bool(0)
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 12 May 2013 - now handles alpha channel and some internal changes")
iain_easy_skin_retouch:
-repeat $! -l[$>] -split_opacity -l[0]
str1=$1
str2={$str1*$3}
str3={$str2*$3}
str4={$str3*$3}
str5={$str4*$3}
str6={$str5*$3}
str7={$str6*$3}
str8={$str7*$3}
--l[0]
-repeat $2
cropwidth={w}
cropheight={h}
-resize[0] {w+(256-w%256)},{h+(256-h%256)},1,{s},0,1
width={w}
height={h}
-if {$str1!=0}
-denoise[0] 10,$str1,3,5,0,1
-endif
--resize[0] {$width/2},{$height/2},1,{s},2,1
--resize[-1] $width,$height,1,{s},3,1
-blur[-1] .5
-compose_grainextract[0,-1]
-if {$str2!=0}
-denoise[-1] 10,$str2,3,5,0,1
-endif
--resize[-1] {$width/4},{$height/4},1,{s},2,1
--resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainextract[1,-1]
-if {$str3!=0}
-denoise[-1] 10,$str3,3,5,0,1
-endif
--resize[-1] {$width/8},{$height/8},1,{s},2,1
--resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainextract[2,-1]
-if {$str4!=0}
-denoise[-1] 10,$str4,3,5,0,1
-endif
--resize[-1] {$width/16},{$height/16},1,{s},2,1
--resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainextract[3,-1]
-if {$str5!=0}
-denoise[-1] 10,$str5,3,5,0,1
-endif
--resize[-1] {$width/32},{$height/32},1,{s},2,1
--resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainextract[4,-1]
-if {$str6!=0}
-denoise[-1] 10,$str6,3,5,0,1
-endif
--resize[-1] {$width/64},{$height/64},1,{s},2,1
--resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainextract[5,-1]
-if {$str7!=0}
-denoise[-1] 10,$str7,3,5,0,1
-endif
--resize[-1] {$width/128},{$height/128},1,{s},2,1
--resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainextract[6,-1]
-if {$str8!=0}
-denoise[-1] 10,$str8,3,5,0,1
-endif
--resize[-1] {$width/256},{$height/256},1,{s},2,1
--resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainextract[7,-1]
-resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/1},{$height/1},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-done
-endl
-if {$4==1}
--compose_grainextract[0,-1]
--rgb2hsv8[-1]
-split[-1] c
-remove[-1,-2]
-add[-1] 30
-mod[-1] 255
-ge[-1]  40
-n[-1] 0,255
-negate[-1]
-blur[-1] 4
--split[-2] c
-remove[-1,-2]
-move[-1] -2
-append[-2,-1] c
--blend[-1,-2] alpha
-remove[-2]
-mul[-1] {$10}
-mul[-2] {1-$10}
-add[-1] [-2]
-remove[-2]
-l[-1]
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$5
-ellipse[-1] 50%,50%,25%,25%,0,1,$6
-ellipse[-1] 50%,50%,12%,12%,0,1,$7
-ellipse[-1] 50%,50%,6%,6%,0,1,$8
-ellipse[-1] 50%,50%,3%,3%,0,1,$9
-ellipse[-1] 50%,50%,0.1%,0.1%,0,1,1
-set[-1] 1,50%,50%
-mul[1] [-1]
-ifftpolar[1,2]
-keep[1]
-c 0,255
-endl
-remove[0]
-if {$11==0}
-compose_grainmerge[-1,-2]
-endif
-else
-keep[-1]
-endif
-endl -a c -endl -done
iain_easy_skin_retouch_preview:
-iain_easy_skin_retouch ${1--1}
#@gui Equalize Local Histograms : fx_equalize_local_histograms, fx_equalize_local_histograms_preview(0)
#@gui : Strength (%) = float(75,0,100)
#@gui : Mode = choice(2,"Raw","Hard","Soft")
#@gui : Radius = int(4,1,16)
#@gui : Sigma = float(100,0,256)
#@gui : Regularization = float(8,0,32)
#@gui : Reduce Halos = bool(1)
#@gui : sep = separator(), Channel(s) = choice(16,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/01/31</i>.</small>")
fx_equalize_local_histograms :
b0="normal" b1="overlay" b2="softlight"
repeat $! l[$>]
+ac "_fx_equalize_local_histograms ${1-6}",$7,1
blend ${b$2},{$1%}
endl done
_fx_equalize_local_histograms :
+n 0,511 round.
f. "
begin(
const boundary = 1;
const N = $3;
const sigma = ($6?1:-1)*(0.1+$4);
weights = vector512();
for (k = 0, k<size(weights), ++k,
weights[k] = sigma>=0?exp(-sqr(k/sigma)):1 - exp(-sqr(k/sigma))
);
);
bins = vector512(0);
for (c = 0, c<s, ++c,
V = crop(x - N,y - N,0,c,2*N+1,2*N+1,1,1);
for (k = 0, k<size(V), ++k,
val = V[k];
diff = abs(val - V[size(V)/2]);
bins[val]+=weights[diff];
);
);
sum = 0;
for (k = 0, k<size(bins), ++k,
sum+=bins[k];
bins[k] = sum;
);
bins/=max(1e-5,sum);
P = I;
size(P)==1?(P = bins[P[0]]; 0):
size(P)==2?(P = [ bins[P[0]], bins[P[1]] ]; 0):
size(P)==3?(P = [ bins[P[0]], bins[P[1]], bins[P[2]] ]; 0):
size(P)==4?(P = [ bins[P[0]], bins[P[1]], bins[P[2]], bins[P[3]] ]; 0);
P"
n. 0,255
if $5 norm.. bilateral. ..,$5,{2+$5} fi
k.
fx_equalize_local_histograms_preview :
gui_split_preview "fx_equalize_local_histograms $*",${-3--1}
#@gui Freaky Details : fx_freaky_details, fx_freaky_details_preview(0)
#@gui : Amplitude = int(2,1,5)
#@gui : Scale = float(10,0,100)
#@gui : Iterations = int(1,1,4)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(32,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>Patrick David</i>.      Latest Update: <i>2013/27/02</i>.</small>")
#@gui : sep = separator(), note = note("This effect has been done following:")
#@gui : url = link("This tutorial from Patrick David","http://blog.patdavid.net/2013/02/calvin-hollywood-freaky-details-in-gimp.html")
_fx_freaky_details :
repeat $! l[$>]
repeat $3
. +-. 255 *. -1
repeat $1 bilateral. $2,{1.5*$2} done
blend[-2,-1] vividlight blend overlay
done
endl done
fx_freaky_details :
ac "gui_parallel_overlap \"_fx_freaky_details ${1-3}\",$5,$6",$4
n 0,255
fx_freaky_details_preview :
gui_split_preview "fx_freaky_details $*",${-3--1}
#@gui High Pass : fx_highpass, fx_highpass_preview(0)
#@gui : Radius = float(5,0,100)
#@gui : Contrast = float(2,0,7)
#@gui : Inverse = bool(0)
#@gui : Greyscale = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Tom Keil</i>.      Latest update: <i>2011/05/01</i>.</small>")
fx_highpass :
-repeat $! -l[$>]
-to_rgb --negate
-if {$4==1} -to_gray -endif
-fx_gaussian_blur[1] $1,0,0,1,0,0,0
-compose_interpolation
-tk_fx_channel_processing 1,$2,0,0,0,0,100,256,0,0,0,2,0,0
-if {$2>=4} -tk_fx_channel_processing 1,{$2-3},0,0,0,0,100,256,0,0,0,2,0,0  -endif
-tk_fx_channel_processing 1,1,0,0,1,50,100,256,0,0,0,2,0,0
-if {$3==1} -negate -endif -endl -done
fx_highpass_preview :
-gui_split_preview "-fx_highpass ${1--2}",$-1
#@gui Local Contrast Enhancement : fx_LCE, fx_LCE_preview(0)
#@gui : note = note("Local contrast enhancement is <i>Unsharp Mask</i> with high radius. Apply filter to RGB channels for color and contrast enhancement.")
#@gui : Spatial Radius = float(80,30,200)
#@gui : Amount = float(0.5,0,5)
#@gui : Darkness Level = float(1,0,4)
#@gui : Lightness Level = float(1,0,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = note{"\n\n<small><b>Note : </b>
#@gui : Original USM code by <i>by David Tschumperl&#233;</i>.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors : <i>Arto Huotari, PhotoComiX</i>.      Latest update : <i>2013/03/23</i>.</small>")
_fx_LCE :
SpatialRadius=$1
Amount=$2
DarknessLevel=$3
LightnessLevel=$4
Threshold=0
--blur[-1] $SpatialRadius
--[-1] [-2] -*[-1] -$Amount
--norm[-1] -ge[-1] $Threshold% -r[-1] [-2] -*[-2,-1]
--c[-1] 0,100% -c[-2] -100%,0 -*[-2] $DarknessLevel -*[-1] $LightnessLevel -+[-2,-1]
-+[-2,-1] -c[-1] 0,255
fx_LCE :
-ac "-_fx_LCE $1,$2,$3,$4",$5,0
fx_LCE_preview :
-gui_split_preview "-fx_LCE ${1--2}",$-1
#@gui Local Normalization : fx_normalize_local, fx_normalize_local_preview(0)
#@gui : Amplitude = float(2,0,60)
#@gui : Radius = int(6,1,64)
#@gui : Neighborhood Smoothness = float(5,0,40)
#@gui : Average Smoothness = float(20,0,40)
#@gui : Constrain Values = bool(1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_normalize_local :
repeat $! l[$>]
ac "normalize_local $1,$2,$3,$4,$5,0,255",$6
endl done
fx_normalize_local_preview :
gui_split_preview "fx_normalize_local $*",${-3--1}
#@gui Local Processing : fx_local_processing, fx_local_processing_preview(1)
#@gui : Action = choice("Normalize","Equalize")
#@gui : Strength (%) = float(75,0,100)
#@gui : Neighborhood Size (%) = float(10,1,100)
#@gui : Overlap (%) = float(50,0,75)
#@gui : Regularization (%) = float(20,0,100)
#@gui : Process Channels Individually = bool(0)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/02/28</i>.</small>")
fx_local_processing :
com0="n 0,255"
com1="equalize 256,0,255 n 0,255"
com=${com$1}
if $6 com="s c "$com" a c" fi
repeat $! l[$>]
size={round(max(8,max(w,h)*$3%))}
+ac "at \""$com"\","$size","$size",1,$4%,$4%",$7
if $5 +norm[0] bilateral[1] .,{$5/20}%,{2+$5/4} rm. fi
blend alpha,{$2%}
endl done
fx_local_processing_preview :
gui_split_preview "fx_local_processing $*",${-3--1}
#@gui Local Variance Normalization : jeje_normalize_local_variance, jeje_normalize_local_variance_preview
#@gui : Amplitude = float(50,0,100)
#@gui : Smoothness = float(5,0,20)
#@gui : Threshold = float(5,0,100)
#@gui : Repeat = int (1,1,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/30</i>.</small>")
jeje_normalize_local_variance :
-apply_channels "-normalize_local_variance $1,$2,$3,$4",$5,0
-c 0,255
jeje_normalize_local_variance_preview:
-gui_split_preview "-jeje_normalize_local_variance $1,$2,$3,$4,$5",$-1
#@gui Magic Details : fx_magic_details,fx_magic_details_preview(0)
#@gui : Amplitude = float(6,0,30)
#@gui : Spatial Scale = float(3,0,10)
#@gui : Value Scale = float(15,0,20)
#@gui : Edges = float(-0.5,-3,3)
#@gui : Smoothness = float(2,0,20)
#@gui : sep = separator(), Channel(s) = choice(27,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/01/10</i>.</small>")
fx_magic_details :
ac "_fx_magic_details ${1-5}",$6,1
_fx_magic_details :
repeat $! l[$>]
+bilateral $2,$3
+gradient_norm.. +. 1
pow. {$4>=0?3.1-$4:-3.1-$4}
b. $5 n. 1,{1+$1}
-... .. *[-3,-1] + c 0,255
endl done
fx_magic_details_preview :
gui_split_preview "fx_magic_details $*",${-3--1}
#@gui Make Up : make_up, make_up_preview(0)
#@gui : Space = float(15,1,40)
#@gui : Value = float(4,0,30)
#@gui : Fast = bool(0)
#@gui : Limit Hue Range = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.  - Update: 1 March 2013: Fixed resizing issue, some memory useage improvements, and added more options.</small>")
makeup_full:
-to_rgb
-sub[-1] 128 -*[-1] .5 -+[-1] 128
-split c
-name[0] red
-name[1] green
-name[2] blue
-sub[green] [red]
-bilateral[green] $1,$2
-add[green] [red]
-sub[blue] [red]
-bilateral[blue] $1,$2
-add[blue] [red]
-append[0,1,2] c
--[-1] 128 -*[-1] 2 -+[-1] 128
-c 0,255
make_up:
cropwidth={w}
cropheight={h}
-resize[0] {w+(2-w%2)},{h+(2-h%2)},1,{s},0,1
width={w}
height={h}
-if {$3==1}
--resize 50%,50%,1,3,5
--makeup_full[1] {$1/2},$2
--resize[1] 200%,200%,1,3,5
--compose_grainextract[0,3]
-resize[2] {w},{h},1,3,5
--compose_grainmerge[2,4]
-keep[0,-1]
-else
-if {$4==1}
--makeup_full[0] $1,$2
-else
-makeup_full[0] $1,$2
-endif
-endif
-if {$4==1}
--rgb2hsl8[1]
-split[-1] c -remove[-1,-2]
-+[-1] 128
-mod[-1] 255
-apply_curve[-1] 0,0,0,130,0,136,255,155,255,160,0,255,0
-median[-1] 3
--edges[1] 10% -n[-1] 0,1
-mul[-1,-2]
-a[1,2] c
-blend[0,1] alpha
-else
-keep[-1]
-endif
-crop 0,0,{$cropwidth-1},{$cropheight-1}
make_up_preview:
-gui_split_preview "-make_up ${1--2}",$-1
#
#@gui Mask Creator : fx_tk_mask, fx_tk_mask_preview(1)
#@gui : sep = separator()
#@gui : Mask Type = choice("Luminance","Saturation","Hue","LAB-lightness")
#@gui : Color Channels = choice("All","Red","Green","Blue","Yellow","Magenta","Cyan","LAB-A","LAB-B")
#@gui : Shadows Threshold = float(0,0,255)
#@gui : Highlights Threshold = float(255,0,255)
#@gui : Tones Smoothness = float(0,0,20)
#@gui : Mask Contrast = float(1,0,10)
#@gui : Negative = bool(0)
#@gui : Apply Mask = bool(0)
#@gui : Transparency = float(1,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2011/11/04</i>.</small>")
fx_tk_mask :
-repeat $! -l[$>]
-if {$8==1} --to_rgba[-1] -rv[-1,-2] -endif -to_rgb[-1]
-if {$2==1} -channels[-1] 0
-elif {$2==2} -channels[-1] 1
-elif {$2==3} -channels[-1] 2
-elif {$2==4} -rgb2cmy -channels[-1] 2
-elif {$2==4} -rgb2cmy -channels[-1] 1
-elif {$2==4} -rgb2cmy -channels[-1] 0
-elif {$2==5} -rgb2lab -channels[-1] 1
-elif {$2==6} -rgb2lab -channels[-1] 2
-endif -to_rgb[-1]
-if {$1==0} -luminance[-1] --luminance[-1]
-elif {$1==1} -rgb2hsv[-1] -channels[-1] 1
-n[-1] 0,255 [-1]
-elif {$1==2} -rgb2hsv[-1] -channels[-1] 0
-n[-1] 0,255  [-1]
-elif {$1==3} -rgb2lab[-1] -channels[-1] 0
-n[-1] 0,255  [-1]
-endif
-c[-1] $3,255 -n[-1] 0,255
-f[-2] "if(i<$4,if(c==0,i,i),0)"
-fx_gaussian_blur[-1,-2] $5,0,0,1,0,0,0
-compose_darken
-if {$8==1} -rv[-1,-2] -endif
-tk_fx_channel_processing[-1] 1,$6,0,0,0,0,100,256,0,0,0,2,0,0
-if {$7==1} -negate[-1] -endif
-if {$8==1} -s[-2] c  -rv[-1,-2]
-fx_compose_multiply[-1,-2] $9
-a[-4,-3,-2,-1] c
-endif -endl -done
fx_tk_mask_preview :
-gui_split_preview "-fx_tk_mask ${1--2}",$-1
#@gui Mighty Details : fx_mighty_details, fx_mighty_details_preview(0)
#@gui : Amplitude = float(25,0,100)
#@gui : Details Amount = float(1,0,2)
#@gui : Details Scale = float(25,1,100)
#@gui : Details Smoothness = int(1,0,10)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/08/08</i>.</small>")
_fx_mighty_details :
+smooth $3,0,1,0.5,0.5 -[1] [0]
+abs. sign.. M={iM} ^. {2-$2} *. {$M/iM} *[-2,-1]
+diffusiontensors[0] 0,1,0.5,0.5
repeat $4 smooth[1] [2],20 done
*[1] {-$1/5} +
fx_mighty_details :
ac "_fx_mighty_details ${1-4}",$5,1
n 0,255
fx_mighty_details_preview :
gui_split_preview "fx_mighty_details $*",${-3--1}
#@gui Portrait Retouching : fx_tk_portrait, fx_tk_portrait_preview(0)
#@gui : sep = separator()
#@gui : Retouching Style = choice("Standard","Glamour glow","Masculine","High key","Low Key")
#@gui : Effect Strength = float(100,0,100)
#@gui : sep = separator()
#@gui : note = note("<b>Retouching settings:</b>")
#@gui : Fine Details Smoothness = float(1,0,10)
#@gui : Medium Details Smoothness = float(5,0,25)
#@gui : Areas Smoothness = float(20,0,100)
#@gui : Fine Details Threshold = float(3,0,10)
#@gui : Medium Details Threshold = float(20,0,100)
#@gui : Areas Light Adjustment = float(10,0,100)
#@gui : Smoothing Type = choice("Gaussian","Bilateral","Anisotropic","Median")
#@gui : Output Mode = choice("Retouched image","Composed layers","All layers and masks")
#@gui : sep = separator()
#@gui : note = note("<b>Skin tone mask settings:</b>")
#@gui : Apply Skin Tone Mask = bool(1)
#@gui : Similarity Space = choice(2,"RGB[A]","RGB","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue & Red chrominances","Hue","Saturation")
#@gui : Tolerance = float(25,0,100)
#@gui : Smoothness = float(2,0,25)
#@gui : Selected Color = color(250,180,150,255)
#@gui : Generic Skin Structure = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Enhancement settings:</b>")
#@gui : Apply Adjustments On = choice(0,"Final image","Retouched areas only","Sharpened areas only","Retouched and sharpened areas")
#@gui : Sharpening Radius = float(1,0,10)
#@gui : Sharpening Strength = float(1.5,0,5)
#@gui : Edge Threshold = float(10,0,50)
#@gui : Edge Smoothness = float(1,0,10)
#@gui : Color Temperature = float(0,-20,20)
#@gui : Lightness = float(0,-50,50)
#@gui : Contrast = float(1,0.5,1.5)
#@gui : Saturation = float(1,0,4)
#@gui : sep = separator()
#@gui : Preview Selection = choice("Retouched image final","Retouched image basic","Retouch layer","Sharpening layer","Skin tone mask","Skin tone colors","Edge mask","High frequency layer","Medium frequency layer","Low frequency layer")
#@gui : Preview Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2012/18/04</i>.</small>")
fx_tk_portrait :
-repeat $! -l[$>] -to_rgb
-if {narg($_previewflag)==0} _previewflag=0 -endif
-if {{$1==3}||{$1==4}} --luminance[0] -elif {$1==2} --channels[0] 2 -fx_unsharp[-1] 0,$21,30,$22,0.00,1.00,0.5,1,0,0,0 -endif
--fx_edges[0] $24,$23,0,0 -if {$23==0} -fc[-1] 0 -endif --fx_unsharp[0] 0,$21,30,$22,0.00,1.00,0.5,1,0,7,0
-if {{$_previewflag==4}&&{$29==5}} --tk_fx_select_color[0] ${12-18},0,0 -else --tk_fx_select_color[0] ${12-18},1,0 -endif
--fx_split_freq[0] $6 -if {$19==1} -fc[-1] 128,128,128 -noise[-1] {$6*2},0 -luminance[-1] -endif
--fx_split_freq[0] $7
-rm[-2,-4]
--fx_tk_dri[0] {$8/100},{$8/200},{$8/200},0,0,1,0,0
-if {$9==0} -blur[-1] $5 -rv[-1,-2] -blur[-1] $4 -blur[-3] $3
-elif {$9==1} -bilateral[-1] $7,$5 -rv[-1,-2] -bilateral[-1] $6,$4 -bilateral[-3] {$3/5},$3
-elif {$9==2} -smooth[-1] $5 -rv[-1,-2] -smooth[-1] $4 -smooth[-3] $3
-elif {$9==3} -median[-1] $5 -rv[-1,-2] -median[-1] $4 -median[-3] $3
-endif
-if {{{$_previewflag!=0}&&{$_previewflag<=3}}||{{$10<=1}&&{$_previewflag==0}}}
-fx_compose_freq[-1,-2] -rv[-1,-2] -fx_compose_freq[-1,-2]
-if {$11==1} -to_rgba[-1] -blur[-2] $14 -s[-1] c -negate[-1] -+[-1] [-5] -a[-1,-2,-3,-4] c -endif -rm[-2] -mv[-1] 1
-to_rgba[-1] -s[-1] c -negate[-1,-5] -+[-1] [-5] -a[-1,-2,-3,-4] c -rm[-2] -if {$23==50} -fc[-1] 0,0,0,0 -endif
-if {{{$_previewflag==1}||{$_previewflag==2}}||{{$10==0}&&{$_previewflag==0}}}
-if {{$1!=0}&&{$1!=1}} -mv[-2] 0 -endif
-if {$20==1} -fx_mix_lab[-2] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0
-elif {$20==2} -fx_mix_lab[-1] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0
-elif {$20==3} -fx_mix_lab[-1,-2] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0
-endif
-fx_compose_alpha[-2,-3] {if({$1==0},{$2/100},1)},0 -fx_compose_alpha[-1,-2] {if({$1==0},{$2/100},1)},0
-if {$23==50} -fx_unsharp[0] 0,$21,30,$22,0.00,1.00,0.5,1,0,0,0 -endif
-if {$_previewflag<=1}
-if {$1==1} -fx_glow[0] {$2/10},0,0
-elif {$1==2} -fx_compose_hardlight[0,1] {$2/100}
-elif {$1==3} -fx_compose_screen[0,1] {$2/100}
-elif {$1==4} -fx_compose_multiply[0,1] {$2/100}
-endif
-if {$20==0} -fx_mix_lab[0] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0  -endif
-endif -endif -endif -endl -done
fx_tk_portrait_preview :
_previewflag=1
-if {$29==1} _previewflag=2 -elif {{$29==2}||{$29==3}} _previewflag=3 -elif {$29>=4} _previewflag=4 -endif
-if {$29>=2} -gui_split_preview "-fx_tk_portrait ${1--2}",0
-else -gui_split_preview "-fx_tk_portrait ${1--2}",$-1 -endif
-if {$29==1} -k[0] -elif {$29==2} -k[2] -elif {$29==3} -k[0] -elif {$29==4} -k[-3] -elif {$29==5} -k[-3]
-elif {$29==6} -k[-5] -negate -elif {$29==7} -k[-2] -elif {$29==8} -k[0] -elif {$29==9} -k[-1] -endif
_previewflag=0
#@gui Sharpen [Deblur] : fx_deblur, fx_deblur_preview(0)
#@gui : Radius = float(2,0,20)
#@gui : Iterations = int(10,0,100)
#@gui : Time Step = float(20,0,50)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Regularization = choice(1,"Tikhonov","Mean Curvature","Total Variation")
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_deblur :
ac "gui_parallel_overlap \"deblur ${1-5} c 0,255\",$7,$8",$6,1
fx_deblur_preview :
gui_split_preview "fx_deblur $*",${-3--1}
#@gui Sharpen [Gold-Meinel] : fx_unsharp_goldmeinel, fx_unsharp_goldmeinel_preview(0)
#@gui : Sigma = float(1,0.5,10)
#@gui : Iterations = int(5,1,15)
#@gui : Acceleration = float(1,1,3)
#@gui : Blur = choice(1,"Exponential","Gaussian")
#@gui : Cut = bool(true)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;r&#244;me Boulanger</i>.      Latest Update: <i>2013/29/03</i>.</small>")
fx_unsharp_goldmeinel:
ac "gui_parallel_overlap \"_fx_unsharp_goldmeinel $*\",$7,$8",$6,1
_fx_unsharp_goldmeinel :
deblur_goldmeinel $*
if $5 c 0,255 else n 0,255 fi
fx_unsharp_goldmeinel_preview:
gui_split_preview "fx_unsharp_goldmeinel $*",${-3--1}
#@gui Sharpen [Gradient] : gcd_sharpen_gradient, gcd_sharpen_gradient_preview(1)
#@gui : note = note("<i>Sharpen areas with low detail</i>"), sep = separator()
#@gui : Amount = float(0.5,0,2)
#@gui : Scale = float(2,0.1,2)
#@gui : Values = choice("cut","normalize luma")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/09/28</i>.</small>")
gcd_sharpen_gradient : -skip ${1=0.5},${2=2},${3=0}
-repeat $! -l[$>]
-split_opacity
--norm[0] --bilateral[0] $2%,30 -norm[-1] --[-2,-1]
--gradient_norm[0] -negate[-1] -n[-1] 0,$1 -*[-2,-1] -+[0,-1]
-if {$3} -ac[0] "-n 0,255",ycbcr_y -else -c[0] 0,255 -endif
-a c
-endl -done
gcd_sharpen_gradient_preview :
-gui_split_preview "-gcd_sharpen_gradient ${1--2}",$-1
#@gui Sharpen [Inverse Diffusion] : fx_sharpen_inversediff, fx_sharpen_inversediff_preview(0)
#@gui : Amplitude = float(50,1,300)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sharpen_inversediff :
ac "gui_parallel_overlap \"repeat $2 sharpen $1 c 0,255 done\",$4,$5",$3,1
fx_sharpen_inversediff_preview :
gui_split_preview "fx_sharpen_inversediff $*",${-3--1}
#@gui Sharpen [Octave Sharpening] : fx_unsharp_octave, fx_unsharp_octave_preview(0)
#@gui : Scales = int(4,1,10)
#@gui : Maximal Radius = float(5,0,20)
#@gui : Amount = float(3,0,10)
#@gui : Threshold = float(0,0,255)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_unsharp_octave :
ac "gui_parallel_overlap \"unsharp_octave $1,$2,$3,$4\",$6,$7",$5,1
fx_unsharp_octave_preview :
gui_split_preview "fx_unsharp_octave $*",${-3--1}
#@gui Sharpen [Richardson-Lucy] : fx_unsharp_richardsonlucy, fx_unsharp_richardsonlucy_preview
#@gui : Sigma = float(1,0.5,10)
#@gui : Iterations = int(10,1,100)
#@gui : Blur = choice(1,"Exponential","Gaussian")
#@gui : Cut = bool(true)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;r&#244;me Boulanger</i>.      Latest Update: <i>2013/29/03</i>.</small>")
fx_unsharp_richardsonlucy :
deblur_richardsonlucy $*
if $4 c 0,255 else n 0,255 fi
fx_unsharp_richardsonlucy_preview :
gui_split_preview "fx_unsharp_richardsonlucy $*",${-3--1}
#@gui Sharpen [Shock Filters] : fx_sharpen_shock, fx_sharpen_shock_preview(0)
#@gui : Amplitude = float(150,1,400)
#@gui : Edge Threshold = float(0.1,0,0.7)
#@gui : Gradient Smoothness = float(0.8,0,10)
#@gui : Tensor Smoothness = float(1.1,0,10)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sharpen_shock :
ac "gui_parallel_overlap \"repeat $5 sharpen $1,$2,$3,$4 c 0,255 done\",$7,$8",$6,1
fx_sharpen_shock_preview :
gui_split_preview "fx_sharpen_shock $*",${-3--1}
#@gui Sharpen [Texture] : fx_sharpen_texture, fx_sharpen_texture_preview(0)
#@gui : Strength = float(1,0,4)
#@gui : Radius = float(4,0,32)
#@gui : sep = separator(), Channel(s) = choice(16,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/09</i>.</small>")
fx_sharpen_texture :
ac "_fx_sharpen_texture ${1-2}",$3,1
_fx_sharpen_texture :
repeat $! l[$>]
+rolling_guidance $2,5,0.5 -. [0] *. $1 - c 0,255
endl done
fx_sharpen_texture_preview :
gui_split_preview "fx_sharpen_texture $*",${-3--1}
#@gui Sharpen [Tones] : gcd_sharpen_tones, gcd_sharpen_tones_preview(1)
#@gui : note = note("<i>Sharpen shadows and highlights</i>"), sep = separator()
#@gui : Amount = float(1,0,4)
#@gui : Centre = int(128,0,255)
#@gui : Values = choice("cut","normalize luma")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/09/28</i>.</small>")
gcd_sharpen_tones : -skip ${1=1},${2=128},${3=0}
-repeat $! -l[$>]
-split_opacity
--norm[0] --bilateral[0] 2%,30 -norm[-1] --[-2,-1]
--gradient_norm[0] -n[-1] 0,1 -oneminus[-1] -*[-2,-1]
--n[0] 0,255 -median[-1] 3 -bilateral[-1] 2%,30
-gcd_srgb2luma[-1] --[-1] $2
--max[-1] 0 -min[-2] 0 -abs[-2]
-n[-2,-1] 0,$1 -*[-2,-1] [-3] -rm[-3] -+[0,-2,-1]
-if {$3} -ac[0] "-n 0,255",ycbcr_y -else -c[0] 0,255 -endif
-a c
-endl -done
gcd_sharpen_tones_preview :
-gui_split_preview "-gcd_sharpen_tones ${1--2}",$-1
#@gui Sharpen [Unsharp Mask] : fx_unsharp, fx_unsharp_preview(0)
#@gui : Sharpening Type = choice(1,"Gaussian","Bilateral")
#@gui : Spatial Radius = float(1.25,0,20)
#@gui : Bilateral Radius = float(10,0,60)
#@gui : Amount = float(2,0,10)
#@gui : Threshold = float(0,0,20)
#@gui : Darkness Level = float(1,0,4)
#@gui : Lightness Level = float(1,0,4)
#@gui : Iterations = int(1,1,10)
#@gui : Negative Effect = bool(0)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : note = note{"\n\n<small><b>Note: </b>
#@gui : This filter is inspired by the original GIMP <i>Unsharp Mask</i> filter, with additional parameters.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_unsharp :
repeat $! repeat $8
if {$1==0} +b. $2 else +bilateral. $2,$3 fi
-. .. *. -$4
+norm. >=. $5% r. .. *[-2,-1]
if $9 *. -1 fi
+c. 0,100% c.. -100%,0 *.. $6 *. $7 +[-2,-1]
+[-2,-1] c. 0,255
done mv. 0 done
fx_unsharp :
ac "_fx_unsharp $1,$2,$3,$4,$5,$6,$7,$8,$9",$10,1
fx_unsharp_preview :
gui_split_preview "fx_unsharp $*",${-3--1}
#@gui Sharpen [Whiten] : jeje_whiten_frequency, jeje_whiten_frequency_preview(0)
#@gui : Alpha = float(50,0,100)
#@gui : Cut = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter equalizes frequencies in the image.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/06/01</i>.</small>")
jeje_whiten_frequency :
-repeat $! -l[$>] -split_opacity -l[0]
-whiten_frequency {exp($1/100)-1}
-if $2 -c 0,255 -n 0,255 -else -n 0,255 -endif
-endl -a c -endl -done
jeje_whiten_frequency_preview :
-gui_split_preview "-jeje_whiten_frequency $1,$2",$-1
#@gui Simple Local Contrast : simplelocalcontrast_p,simplelocalcontrast_p(0)
#@gui : Edge Sensitivity = float (16,0,25)
#@gui : Iterations = int (2,1,5)
#@gui : Paint Effect = float (0,0,50)
#@gui : Channels = choice (1,"Colour","Luminance Only")
#@gui : Pre-Gamma = float (1,.1,5)
#@gui : Post-Gamma = float (1,.1,5)
#@gui : sep = separator ()
#@gui : note = note("<small><b>Luminance Mask</b></small>" )
#@gui : Blacks = float (1,0,1)
#@gui : Dark Grey = float (1,0,1)
#@gui : Mid Grey = float (1,0,1)
#@gui : Light Grey = float (1,0,1)
#@gui : Whites = float (1,0,1)
#@gui : sep = separator ()
#@gui : Parallel Processing = choice (0,"Auto","None")
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 18 April 2014 - added parallel processing and luminance mask")
simplelocalcontrast_p:
-to_rgb
[0]
-apply_parallel_overlap[1] "
-simplelocalcontrast[0] ${1-6}",{30+$3},$12
--luminance[-1]
-apply_curve[-1] 0,0,$7,64,$8,128,$9,196,$10,255,$11
-mul[-1] 255
-append[1,2] c
-blend alpha,1,0
simplelocalcontrast:
str1=$1
str2={$str1*0.7}
str3={$str2*0.7}
str4={$str3*0.7}
str5={$str4*0.7}
str6={$str5*0.7}
str7={$str6*0.7}
str8={$str7*0.7}
-apply_gamma $5
-conttest4 $4,$str1,$str2,$str3,$str4,$str5,$str6,$str7,$str8,$2,$3,$3,$3,$3,$3,$3,2,1
-apply_gamma $6
-n 0,255
conttest4:
-to_rgb
-if {$1==1}
--luminance
--smoothbase4[-1] $2,$3,$4,$5,$6,$7,$8,$9,$10
--compose_grainextract[-1,-2]
-ms_smooth[-1] $11,$12,$13,$14,$15,$16,$17,$18,1
-remove[1,2]
-sub[-1] 128 -mul[-1] 2 -add[-1] 128
--compose_grainmerge
-remove[0,1]
-else
--smoothbase4 $2,$3,$4,$5,$6,$7,$8,$9,$10
--compose_grainextract
-ms_smooth[-1] $11,$12,$13,$14,$15,$16,$17,$18,1
-remove[1]
-sub[-1] 128 -mul[-1] 2 -add[-1] 128
--compose_grainmerge
-remove[1]
-rgb2hsv
-split c
-remove[1,2,3]
-append c
-hsv2rgb
-endif
smoothbase4:
-repeat $9
cropwidth={w}
cropheight={h}
-resize[0] {w+(256-w%256)},{h+(256-h%256)},1,{s},0,1
width={w}
height={h}
-if {$1!=0}
-denoise[0] 10,$1,3,5,0,1
-endif
--resize[0] {$width/2},{$height/2},1,{s},2,1
--resize[-1] $width,$height,1,{s},3,1
-blur[-1] .5
-compose_grainextract[0,-1]
-if {$2!=0}
-denoise[-1] 10,$2,3,5,0,1
-endif
--resize[-1] {$width/4},{$height/4},1,{s},2,1
--resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainextract[1,-1]
-if {$3!=0}
-denoise[-1] 10,$3,3,5,0,1
-endif
--resize[-1] {$width/8},{$height/8},1,{s},2,1
--resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainextract[2,-1]
-if {$4!=0}
-denoise[-1] 10,$4,3,5,0,1
-endif
--resize[-1] {$width/16},{$height/16},1,{s},2,1
--resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainextract[3,-1]
-if {$5!=0}
-denoise[-1] 10,$5,3,5,0,1
-endif
--resize[-1] {$width/32},{$height/32},1,{s},2,1
--resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainextract[4,-1]
-if {$6!=0}
-denoise[-1] 10,$6,3,5,0,1
-endif
--resize[-1] {$width/64},{$height/64},1,{s},2,1
--resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainextract[5,-1]
-if {$7!=0}
-denoise[-1] 10,$7,3,5,0,1
-endif
--resize[-1] {$width/128},{$height/128},1,{s},2,1
--resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainextract[6,-1]
-if {$8!=0}
-denoise[-1] 10,$8,3,5,0,1
-endif
--resize[-1] {$width/256},{$height/256},1,{s},2,1
--resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainextract[7,-1]
-resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/1},{$height/1},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-done
#@gui Split Details [Alpha] : fx_split_details_alpha, fx_split_details_alpha_preview(0)
#@gui : Number of Levels = int(6,2,8)
#@gui : Base Scale = float(10,0,30)
#@gui : Details Scale = float(1,0,20)
#@gui : Opacity Gain = float(5,1,20)
#@gui : sep = separator()
#@gui : Preview Without Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/22/04</i>.</small>")
fx_split_details_alpha :
remove_opacity
repeat $! l[$<]
repeat {$1-1}
s={$3+($2-$3)*$>/if($1-2>0,$1-2,1)}
+_fx_split_details_alpha_blur. $s
sub_alpha.. .,$4
done
endl done
_fx_split_details_alpha_blur :
if {$1>=0.1} b. $1
else
if {$1>=0.05} (1,4,7,4,1;4,16,26,16,4;7,26,41,26,7;4,16,26,16,4;1,4,7,4,1)
else (1,2,1;2,4,2;1,2,1) fi
normalize_sum. convolve.. . rm.
fi
fx_split_details_alpha_preview :
repeat $! l[$>]
fx_split_details_alpha ${1-4}
if $5 remove_opacity[^-1] else to_rgba. fi
N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
repeat $! l[$>] 0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0] endl done
to_rgba frame 1,1,0 frame 3,3,255 append_tiles ,
endl done
#@gui Split Details [Gaussian] : fx_split_details_gaussian, fx_split_details_gaussian_preview(0)
#@gui : Number of Scales = int(6,3,12)
#@gui : Base Scale = float(10,0,200)
#@gui : Details Scale = float(1,0,20)
#@gui : sep = separator(), Sharpen details in preview = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/22/01</i>.</small>")
fx_split_details_gaussian :
remove_opacity repeat $! l[$>]
nm=${-gui_layer_name}
pos=${-gui_layer_pos}
split_details $1,$2,$3
+[^0] 128 c[^0] 0,255 round
repeat {$!-1} nm[{1+$>}] "mode(grainmerge), name"($nm" [scale ""#"{1+$>}"]), pos("$pos")" done
nm[0] "name"($nm" [residual]), pos("$pos")"
rv
endl done
fx_split_details_gaussian_preview :
repeat $! l[$>]
fx_split_details_gaussian $*
if $4 equalize[^-1] 256 fi n[^-1] 0,255
N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
repeat $! l[$>] 0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0] endl done
to_rgba frame 1,1,0 frame 3,3,255 append_tiles ,
endl done
#@gui Split Details [Wavelets] : fx_split_details_wavelets, fx_split_details_wavelets_preview(0)
#@gui : Number of Scales = int(6,2,12)
#@gui : Add Alpha Channels to Detail Scale Layers = _bool(0)
#@gui : sep = separator(), Sharpen Details in Preview = bool(0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter decomposes an image into several detail scales, using wavelet atrous.
#@gui : It should provide similar results to the
#@gui : <a href ="http://registry.gimp.org/node/11742">Wavelet Decompose Plug-in</a>
#@gui : (by Marco Rossini).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/23/03</i>.</small>")
fx_split_details_wavelets :
remove_opacity repeat $! l[$>]
nm=${-gui_layer_name}
pos=${-gui_layer_pos}
split_details $1,0,0 rv +[^-1] 128 c[^-1] 0,255 round
if $2 to_a[^-1] fi
repeat {$!-1} nm[$>] "mode(grainmerge), name"($nm" [scale ""#"{1+$>}"]), pos("$pos")" done
nm. "name"($nm" [residual]), pos("$pos")"
endl done
fx_split_details_wavelets_preview :
repeat $! l[$>]
fx_split_details_wavelets $1,0
if $3 equalize[^-1] 256 fi n[^-1] 0,255
N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
repeat $! l[$>] 0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0] endl done
to_rgba frame 1,1,0 frame 3,3,255 append_tiles ,
endl done
#@gui Spotify : jeje_spotify,jeje_spotify_preview
#@gui : Scale = float(1,0.75,10)
#@gui : Iteration = int(1,1,50)
#@gui : Gamma = float(1,0,10)
#@gui : Cut = bool(1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/16</i>.</small>")
jeje_spotify:
-apply_channels "-spotify $1,$2  -apply_gamma $3 -if $4 -c 0,255 -else -n 0,255 -endif",$5
jeje_spotify_preview:
-gui_split_preview "-jeje_spotify $1,$2,$3,$4,$5",$6
#@gui Texture Enhance : iain_texture_enhance_p, iain_texture_enhance_p_preview(0)
#@gui : Radius = int (2,2,11)
#@gui : Strength = float (2,0,10)
#@gui : Reduce Halos = float (30,0,255)
#@gui : Reduce Noise = float (0,0,255)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
#@gui : note = note("<small>Update: 4 March 2013 - Different halo protection method, added option to reduce noise, faster.</small>")
iain_texture_enhance_p:
-apply_parallel_overlap "-iain_texture_enhance ${1--2}",{$1*2},$-2
iain_texture_enhance_p_preview :
-gui_split_preview "-iain_texture_enhance_p ${1--2}",$-1
iain_texture_enhance:
-tic
-ac "
-if {$1%2!=0}
--erode_circ[0] $1  -dilate_circ[-1] $1
--dilate_circ[0] $1  -erode_circ[-1] $1
-else
--erode_oct[0] $1  -dilate_oct[-1] $1
--dilate_oct[0] $1  -erode_oct[-1] $1
-endif
-sub[1] [0]
-sub[2] [0]
-add[1] [2]
-remove[2]
-mul[1] $2
--abs[1]
pt1={min(0,($4-10))}
-apply_curve[-1] 0,0,0,$pt1,0,{$4+1},1,255,1
(0.0579710145,0.1304347826,0.0579710145;0.1304347826,0.2463768116,0.1304347826;0.0579710145,0.1304347826,0.0579710145)
-convolve[-2] [-1]
-remove[-1]
-mul[1] [2]
-c[1] {$3*-1},$3
-sub[0] [1]
-keep[0]
",$5
-c 0,255
-toc
iain_texture_enhance_preview :
-gui_split_preview "-iain_texture_enhance ${1--2}",$-1
#@gui Tone Enhance : gcd_tone_enhance, gcd_tone_enhance(1)
#@gui : note = note("<i>Sharpen or adjust shadows and highlights</i>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Shadows</i></small></span>")
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Highlights</i></small></span>")
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Mid Point</i></small></span>")
#@gui : Centre = int(128,0,255)
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Extra Shadow/Highlight recovery</i></small></span>")
#@gui : Boost = float(0.5,0,1)
#@gui : Smooth = float(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Detail Mask</i></small></span>")
#@gui : Smooth = int(0,0,20)
#@gui : sep = separator()
#@gui : Channels = choice(4,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Values = choice("cut","normalize")
#@gui : Color Median = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/01/03</i>.</small>")
gcd_tone_enhance :
-skip ${1=0},${2=1},${3=0},${4=1},${5=128},${6=0},${7=1}
-skip ${8=0.5},${9=0},${10=0},${11=4},${12=0},${13=0}
-if $13 -repeat $! -l[$>]
-gcd_srgb2jpeg -sh 1,2 -median. 5,20 -rm. -gcd_jpeg2srgb -c 0,255
-endl -done -endif
mode=${-arg\ 1+$11,hsi_i,hsv_v,lab_l,lrgb,rgb,ycbcr_y}
-ac "-_gcd_tone_enhance ${1-10}",$mode,{$12+1}
_gcd_tone_enhance :
-repeat $! -l[$>]
-if {$9>0} -bilateral 1%,$9 -c 0,255 -endif
--norm --bilateral.. 2%,30 -norm. --[-2,-1]
--gradient_norm.. -n. 0,1 -oneminus. -*[-2,-1]
-if $10 -b. {0.025*$10}% -endif
--n.. 0,255 -median. 3 -bilateral. 2%,30
-gcd_srgb2luma. --. $5 --abs. -negate.
--max.. 0 -min... 0 -abs...
-if {$8!=0.5}
--n[{$8>0.5?-3:-1}] 0,1 --gcd_ibezier[0] {1-$8}
-j[0] .,0,0,0,0,1,.. -rm[-2,-1]
-endif
--/... {if(iM#-3>0,iM#-3/(1/$2-1),1)} -+. 1
--/... {if(iM#-3>0,iM#-3/(1/$7-1),1)} -+. 1 -*[-2,-1]
--/.. {if(iM#-2>0,iM#-2/(1/$4-1),1)} -+. 1 -*[-2,-1]
m={0,iM} -/[0] $m -^[0,-1] -*[0] $m
-n... 0,$1 -n.. 0,$6 -n. 0,$3 -*[-3--1] [-4] -rm[-4] -+
-endl -done
#@gui Tone Mapping : fx_map_tones, fx_map_tones_preview(0)
#@gui : Threshold = float(0.5,0,1)
#@gui : Gamma = float(0.7,0,1)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Iterations = int(30,0,500)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_map_tones :
ac "map_tones ${1-4}",$5,1
n 0,255
fx_map_tones_preview :
gui_split_preview "fx_map_tones $*",${-3--1}
#@gui Tone Mapping [Fast] : fx_map_tones_fast, fx_map_tones_fast_preview(0)
#@gui : Radius = float(3,0,20)
#@gui : Power = float(0.5,0,1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Paul Nasca</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/10/06</i>.</small>")
fx_map_tones_fast :
ac "map_tones_fast $1,$2",$3,2
fx_map_tones_fast_preview :
gui_split_preview "fx_map_tones_fast ${^0}",${-3--1}
#@gui YAG Effect : fx_yag_soften, fx_yag_soften_preview(0)
#@gui : Darken = float(0,0,100)
#@gui : Soften = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6260257923/")
fx_yag_soften :
Darken=$1
Soften=$2
--fx_laplacian[0] 0,0,100,0,0,0
-if {$Soften>0}
-fx_gaussian_blur[1] {$Soften/10},0,0,1,0,0,0
-endif
--fx_mix_lab[0] 0.5,50,0.2,1,2,1,1,2,1,0,10,0
-if {$Darken>0}
--blend[0,2] softlight
-blend[0,3] multiply,{$Darken/100}
-endif
-blend[0,2] hardlight
-if {$Soften!=100}
-blend[0,1] grainextract
-elif {$Soften==100}
-remove[1]
-endif
fx_yag_soften_preview :
-gui_split_preview "-fx_yag_soften ${1--2}",$-1
#@gui _
#@gui <b>Film Emulation</b>
#@gui <i>[Collages]</i>
#@gui B&amp;W Films - Collage : fx_emulate_film_collage_bw, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>B&amp;W</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/28/10</i>.</small>")
fx_emulate_film_collage_bw :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_bw}
#@gui Instant - Collage [Consumer] : fx_emulate_film_collage_instant_consumer, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Instant [consumer]</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/28/10</i>.</small>")
fx_emulate_film_collage_instant_consumer :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_instant_consumer}
#@gui Instant - Collage [Pro] : fx_emulate_film_collage_instant_pro, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Instant [pro]</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/28/10</i>.</small>")
fx_emulate_film_collage_instant_pro :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_instant_pro}
#@gui Negative - Collage [Color] : fx_emulate_film_collage_negative_color, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [color]</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/28/10</i>.</small>")
fx_emulate_film_collage_negative_color :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_negative_color}
#@gui Negative - Collage [New] : fx_emulate_film_collage_negative_new, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [new]</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/28/10</i>.</small>")
fx_emulate_film_collage_negative_new :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_negative_new}
#@gui Negative - Collage [Old] : fx_emulate_film_collage_negative_old, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [old]</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/28/10</i>.</small>")
fx_emulate_film_collage_negative_old :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_negative_old}
#@gui PictureFX - Collage : fx_emulate_film_collage_picturefx, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Others</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/15/04</i>.</small>")
fx_emulate_film_collage_picturefx :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_picturefx}
#@gui Print Films - Collage : fx_emulate_film_collage_print, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Others</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/15/04</i>.</small>")
fx_emulate_film_collage_print :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_print}
#@gui Slide - Collage [Color] : fx_emulate_film_collage_colorslide, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Slide [color]</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/28/10</i>.</small>")
fx_emulate_film_collage_colorslide :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_colorslide}
_fx_emulate_film_collage :
$=arg progress 0
repeat $#
preset=${arg{$>+1}}
+l[0]
_fx_emulate_film[0] 1,$preset,100,0,0,0,0,0,0
({'$preset'}) replace. {'_'},32 f. if(x==0" && "i>=_'a'" && "i<=_'z',i+_'A'-_'a',i) title={t} rm.
to. $title,2,2,$_label_size,2,1,255
endl
progress {(1+$>)*100/$#}
done
to[0] "Original image",2,2,$_label_size,2,1,255
if {!$_output_type} frame 1,1,0 frame 5,5,255 - 255 append_tiles {min($_nbc,$!)} + 255 fi
#@gui Various - Collage : fx_emulate_film_collage_various, gui_no_preview
#@gui : Image Size = float(512,16,1024)
#@gui : Columns for Collage = int(4,1,8)
#@gui : Label Size = int(16,10,100)
#@gui : Output As = choice("Table","Multiple Layers")
#@gui : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Others</i> film emulation presets
#@gui : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gui : (this may take some time at the first run).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>Patrick David</i>.      Latest Update: <i>2014/29/07</i>.</small>")
fx_emulate_film_collage_various :
k[0] to_rgb if {max(w,h)>$1} if {w>h} r2dx $1 else r2dy $1 fi fi
_nbc=$2 _label_size=$3 _output_type=$4 _fx_emulate_film_collage ${-_fx_emulate_film_various}
#@gui _
#@gui Add Grain : fx_emulate_grain, fx_emulate_grain_preview(0)
#@gui : Preset = choice{"Orwo NP20-GDR","Kodak TMAX 400","Kodak TMAX 3200","Kodak TRI-X 1600","Unknown"}
#@gui : Blend Mode = choice(1,"Alpha","Grain Merge","Hard Light","Overlay","Soft Light","Grain Only")
#@gui : Opacity = float(0.2,0,1)
#@gui : Scale = float(100,30,200)
#@gui : Colored Grain = bool()
#@gui : sep = separator()
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : Preview Grain Alone = bool()
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_grain :
__fx_emulate_grain ${arg\ {1+$1},${-_fx_emulate_grain}},${2-10},0,0
_fx_emulate_grain :
u grain_orwo_np20,grain_kodak_tmax400,grain_kodak_tmax3200,grain_kodak_trix1600,grain_unknown
fx_emulate_grain_preview :
gui_split_preview "_fx_emulate_grain_preview $*",$-2
_fx_emulate_grain_preview :
__fx_emulate_grain ${arg\ {1+$1},${-_fx_emulate_grain}},${2-12}
__fx_emulate_grain :
bm0=alpha bm1=grainmerge bm2=hardlight bm3=overlay bm4=softlight bm5=alpha
if ${_path_rc}$1.cimgz i ${_path_rc}$1.cimgz
else i https://gmic.eu/data_film_presets/$1.cimgz o. ${_path_rc}$1.cimgz
fi
repeat {$!-1} l[$>,-1] split_opacity[0]
+syntexturize. {0,max(10,100*w/$4)},{0,max(10,100*h/$4)}
if $5 +syntexturize.. {w},{h} +syntexturize... {w},{h} a[-3--1] c fi
r. {0,w},{0,h},1,100%,5 c. 0,255
adjust_colors. ${6-10}
if $12 k[0,-1] rv
else blend[0,-1] ${bm$2},{if($2<=4,$3,1)}
fi
a[^-1] c endl done rm.
#@gui B&amp;W Films : fx_emulate_film_bw, fx_emulate_film_bw_preview(1)+
#@gui : Preset = choice{"None",
#@gui : "Agfa APX 100","Agfa APX 25","Fuji Neopan 1600","Fuji Neopan Acros 100","Ilford Delta 100","Ilford Delta 3200","Ilford Delta 400","Ilford FP4 Plus 125",
#@gui : "Ilford HP5 Plus 400","Ilford HPS 800","Ilford Pan F Plus 50","Ilford XP2","Kodak BW 400 CN","Kodak HIE (HS Infra)","Kodak T-Max 100","Kodak T-Max 3200",
#@gui : "Kodak T-Max 400","Kodak Tri-X 400","Polaroid 664","Polaroid 667","Polaroid 672","Rollei IR 400","Rollei Ortho 25","Rollei Retro 100 Tonal","Rollei Retro 80s"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator()
#@gui : Pseudo-Gray Dithering = int(0,0,5)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_bw :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
if {$1" && "$9} to_pseudogray $9,1 fi
_fx_emulate_film_bw :
u agfa_apx_100,agfa_apx_25,fuji_neopan_1600,fuji_neopan_acros_100,ilford_delta_100,ilford_delta_3200,ilford_delta_400,ilford_fp4_plus_125,\
ilford_hp5_plus_400,ilford_hps_800,ilford_pan_f_plus_50,ilford_xp2,kodak_bw_400_cn,kodak_hie_(hs_infra),kodak_t-max_100,kodak_t-max_3200,\
kodak_t-max_400,kodak_tri-x_400,polaroid_664,polaroid_667,polaroid_672,rollei_ir_400,rollei_ortho_25,rollei_retro_100_tonal,rollei_retro_80s
fx_emulate_film_bw_preview :
gui_split_preview "fx_emulate_film_bw $*",${-3--1}
#@gui FilterGrade Cinematic : fx_emulate_film_filtergrade, fx_emulate_film_filtergrade_preview(1)+
#@gui : Preset = choice{"None", "Cine Basic", "Cine Bright", "Cine Cold", "Cine Drama", "Cine Teal Orange 1", "Cine Teal Orange 2",
#@gui : "Cine Vibrant", "Cine Warm"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The 8 color LUTs proposed in this filter are provided by <b>FILTERGRADE</b>, and are freely available at:</small>")
#@gui : url = link("FilterGrade Free Cinematic LUTs Pack","https://filtergrade.com/free-cinematic-luts-video-editing/")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2019/02/05</i>.</small>")
fx_emulate_film_filtergrade :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_filtergrade :
u fgcinebasic,fgcinebright,fgcinecold,fgcinedrama,fgcinetealorange1,fgcinetealorange2,fgcinevibrant,fgcinewarm
fx_emulate_film_filtergrade_preview :
gui_split_preview "fx_emulate_film_filtergrade $*",${-3--1}
#@gui Fuji Xtrans : fx_emulate_film_fujixtransii, fx_emulate_film_fujixtransii_preview(1)+
#@gui : Preset = choice{"None",
#@gui : "Astia","Classic Chrome","Pro Neg Hi","Pro Neg Std","Provia","Velvia"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Stuart Sowerby</b>. More info at:</small>")
#@gui : url = link{"Fuji Film Simulation Profiles","http://blog.sowerby.me/fuji-film-simulation-profiles"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Stuart Sowerby</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/13/01</i>.</small>")
fx_emulate_film_fujixtransii :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_fujixtransii :
u fuji_xtrans_ii_astia_v2,fuji_xtrans_ii_classic_chrome_v1,fuji_xtrans_ii_pro_neg_hi_v2,fuji_xtrans_ii_pro_neg_std_v2,\
fuji_xtrans_ii_provia_v2,fuji_xtrans_ii_velvia_v2
fx_emulate_film_fujixtransii_preview :
gui_split_preview "fx_emulate_film_fujixtransii $*",${-3--1}
#@gui Instant [Consumer] : fx_emulate_film_instant_consumer, fx_emulate_film_instant_consumer_preview(1)+
#@gui : Preset = choice{"None",
#@gui : "Polaroid PX-100UV+ Cold --","Polaroid PX-100UV+ Cold -","Polaroid PX-100UV+ Cold","Polaroid PX-100UV+ Cold +","Polaroid PX-100UV+ Cold ++","Polaroid PX-100UV+ Cold +++",
#@gui : "Polaroid PX-100UV+ Warm --","Polaroid PX-100UV+ Warm -","Polaroid PX-100UV+ Warm","Polaroid PX-100UV+ Warm +","Polaroid PX-100UV+ Warm ++","Polaroid PX-100UV+ Warm +++",
#@gui : "Polaroid PX-680 --","Polaroid PX-680 -","Polaroid PX-680","Polaroid PX-680 +","Polaroid PX-680 ++",
#@gui : "Polaroid PX-680 Cold --","Polaroid PX-680 Cold -","Polaroid PX-680 Cold","Polaroid PX-680 Cold +","Polaroid PX-680 Cold ++","Polaroid PX-680 Cold ++a",
#@gui : "Polaroid PX-680 Warm --","Polaroid PX-680 Warm -","Polaroid PX-680 Warm","Polaroid PX-680 Warm +","Polaroid PX-680 Warm ++",
#@gui : "Polaroid PX-70 --","Polaroid PX-70 -","Polaroid PX-70","Polaroid PX-70 +","Polaroid PX-70 ++","Polaroid PX-70 +++",
#@gui : "Polaroid PX-70 Cold --","Polaroid PX-70 Cold -","Polaroid PX-70 Cold","Polaroid PX-70 Cold +","Polaroid PX-70 Cold ++",
#@gui : "Polaroid PX-70 Warm --","Polaroid PX-70 Warm -","Polaroid PX-70 Warm","Polaroid PX-70 Warm +","Polaroid PX-70 Warm ++",
#@gui : "Polaroid Time Zero (Expired) ---","Polaroid Time Zero (Expired) --","Polaroid Time Zero (Expired) -","Polaroid Time Zero (Expired)","Polaroid Time Zero (Expired) +","Polaroid Time Zero (Expired) ++",
#@gui : "Polaroid Time Zero (Expired) Cold ---","Polaroid Time Zero (Expired) Cold --","Polaroid Time Zero (Expired) Cold -","Polaroid Time Zero (Expired) Cold"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_instant_consumer :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_instant_consumer :
u polaroid_px-100uv+_cold_--,polaroid_px-100uv+_cold_-,polaroid_px-100uv+_cold,polaroid_px-100uv+_cold_+,polaroid_px-100uv+_cold_++,polaroid_px-100uv+_cold_+++,\
polaroid_px-100uv+_warm_--,polaroid_px-100uv+_warm_-,polaroid_px-100uv+_warm,polaroid_px-100uv+_warm_+,polaroid_px-100uv+_warm_++,polaroid_px-100uv+_warm_+++,\
polaroid_px-680_--,polaroid_px-680_-,polaroid_px-680,polaroid_px-680_+,polaroid_px-680_++,\
polaroid_px-680_cold_--,polaroid_px-680_cold_-,polaroid_px-680_cold,polaroid_px-680_cold_+,polaroid_px-680_cold_++,polaroid_px-680_cold_++_alt,\
polaroid_px-680_warm_--,polaroid_px-680_warm_-,polaroid_px-680_warm,polaroid_px-680_warm_+,polaroid_px-680_warm_++,\
polaroid_px-70_--,polaroid_px-70_-,polaroid_px-70,polaroid_px-70_+,polaroid_px-70_++,polaroid_px-70_+++,\
polaroid_px-70_cold_--,polaroid_px-70_cold_-,polaroid_px-70_cold,polaroid_px-70_cold_+,polaroid_px-70_cold_++,\
polaroid_px-70_warm_--,polaroid_px-70_warm_-,polaroid_px-70_warm,polaroid_px-70_warm_+,polaroid_px-70_warm_++,\
polaroid_time_zero_(expired)_---,polaroid_time_zero_(expired)_--,polaroid_time_zero_(expired)_-,polaroid_time_zero_(expired),polaroid_time_zero_(expired)_+,polaroid_time_zero_(expired)_++,\
polaroid_time_zero_(expired)_cold_---,polaroid_time_zero_(expired)_cold_--,polaroid_time_zero_(expired)_cold_-,polaroid_time_zero_(expired)_cold
fx_emulate_film_instant_consumer_preview :
gui_split_preview "fx_emulate_film_instant_consumer $*",${-3--1}
#@gui Instant [Pro] : fx_emulate_film_instant_pro, fx_emulate_film_instant_pro_preview(1)+
#@gui : Preset = choice{"None",
#@gui : "Fuji FP-100c --","Fuji FP-100c -","Fuji FP-100c","Fuji FP-100c +","Fuji FP-100c ++","Fuji FP-100c ++a","Fuji FP-100c +++",
#@gui : "Fuji FP-100c Cool --","Fuji FP-100c Cool -","Fuji FP-100c Cool","Fuji FP-100c Cool +","Fuji FP-100c Cool ++",
#@gui : "Fuji FP-100c Negative --","Fuji FP-100c Negative -","Fuji FP-100c Negative","Fuji FP-100c Negative +","Fuji FP-100c Negative ++","Fuji FP-100c Negative ++a","Fuji FP-100c Negative +++",
#@gui : "Fuji FP-3000b --","Fuji FP-3000b -","Fuji FP-3000b","Fuji FP-3000b +","Fuji FP-3000b ++","Fuji FP-3000b +++",
#@gui : "Fuji FP-3000b HC",
#@gui : "Fuji FP-3000b Negative --","Fuji FP-3000b Negative -","Fuji FP-3000b Negative","Fuji FP-3000b Negative +","Fuji FP-3000b Negative ++","Fuji FP-3000b Negative +++",
#@gui : "Fuji FP-3000b Negative Early",
#@gui : "Polaroid 665 --","Polaroid 665 -","Polaroid 665","Polaroid 665 +","Polaroid 665 ++",
#@gui : "Polaroid 665 Negative -","Polaroid 665 Negative","Polaroid 665 Negative +",
#@gui : "Polaroid 665 Negative HC",
#@gui : "Polaroid 669 --","Polaroid 669 -","Polaroid 669","Polaroid 669 +","Polaroid 669 ++","Polaroid 669 +++",
#@gui : "Polaroid 669 Cold --","Polaroid 669 Cold -","Polaroid 669 Cold","Polaroid 669 Cold +",
#@gui : "Polaroid 690 --","Polaroid 690 -","Polaroid 690","Polaroid 690 +","Polaroid 690 ++",
#@gui : "Polaroid 690 Cold --","Polaroid 690 Cold -","Polaroid 690 Cold","Polaroid 690 Cold +","Polaroid 690 Cold ++",
#@gui : "Polaroid 690 Warm --","Polaroid 690 Warm -","Polaroid 690 Warm","Polaroid 690 Warm +","Polaroid 690 Warm ++"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_instant_pro :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_instant_pro :
u fuji_fp-100c_--,fuji_fp-100c_-,fuji_fp-100c,fuji_fp-100c_+,fuji_fp-100c_++,fuji_fp-100c_++_alt,fuji_fp-100c_+++,\
fuji_fp-100c_cool_--,fuji_fp-100c_cool_-,fuji_fp-100c_cool,fuji_fp-100c_cool_+,fuji_fp-100c_cool_++,\
fuji_fp-100c_negative_--,fuji_fp-100c_negative_-,fuji_fp-100c_negative,fuji_fp-100c_negative_+,fuji_fp-100c_negative_++,fuji_fp-100c_negative_++_alt,fuji_fp-100c_negative_+++,\
fuji_fp-3000b_--,fuji_fp-3000b_-,fuji_fp-3000b,fuji_fp-3000b_+,fuji_fp-3000b_++,fuji_fp-3000b_+++,fuji_fp-3000b_hc,\
fuji_fp-3000b_negative_--,fuji_fp-3000b_negative_-,fuji_fp-3000b_negative,fuji_fp-3000b_negative_+,fuji_fp-3000b_negative_++,fuji_fp-3000b_negative_+++,fuji_fp-3000b_negative_early,\
polaroid_665_--,polaroid_665_-,polaroid_665,polaroid_665_+,polaroid_665_++,\
polaroid_665_negative_-,polaroid_665_negative,polaroid_665_negative_+,polaroid_665_negative_hc,\
polaroid_669_--,polaroid_669_-,polaroid_669,polaroid_669_+,polaroid_669_++,polaroid_669_+++,\
polaroid_669_cold_--,polaroid_669_cold_-,polaroid_669_cold,polaroid_669_cold_+,\
polaroid_690_--,polaroid_690_-,polaroid_690,polaroid_690_+,polaroid_690_++,\
polaroid_690_cold_--,polaroid_690_cold_-,polaroid_690_cold,polaroid_690_cold_+,polaroid_690_cold_++,\
polaroid_690_warm_--,polaroid_690_warm_-,polaroid_690_warm,polaroid_690_warm_+,polaroid_690_warm_++
fx_emulate_film_instant_pro_preview :
gui_split_preview "fx_emulate_film_instant_pro $*",${-3--1}
#@gui Negative [Color] : fx_emulate_film_negative_color, fx_emulate_film_negative_color_preview(1)+
#@gui : Preset = choice{"None",
#@gui : "Agfa Ultra Color 100","Agfa Vista 200","Fuji Superia 200","Fuji Superia HG 1600","Fuji Superia Reala 100","Fuji Superia X-Tra 800",
#@gui : "Kodak Elite 100 XPRO","Kodak Elite Color 200","Kodak Elite Color 400","Kodak Portra 160 NC","Kodak Portra 160 VC","Lomography Redscale 100"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_negative_color :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_negative_color :
u agfa_ultra_color_100,agfa_vista_200,fuji_superia_200,fuji_superia_hg_1600,fuji_superia_reala_100,fuji_superia_x-tra_800,\
kodak_elite_100_xpro,kodak_elite_color_200,kodak_elite_color_400,kodak_portra_160_nc,kodak_portra_160_vc,lomography_redscale_100
fx_emulate_film_negative_color_preview :
gui_split_preview "fx_emulate_film_negative_color $*",${-3--1}
#@gui Negative [New] : fx_emulate_film_negative_new, fx_emulate_film_negative_new_preview(1)+
#@gui : Preset = choice{"None","Fuji 160C","Fuji 400H","Fuji 800Z","Fuji Ilford HP5","Kodak Portra 160","Kodak Portra 400","Kodak Portra 800","Kodak TMAX 3200","Kodak TRI-X 400"}
#@gui : Effect = choice(1,"Low","Standard","High","Higher")
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_negative_new :
_fx_emulate_film $1,${arg\ {max(1,4*$1+$2-3)},${-_$0}},${3--1}
_fx_emulate_film_negative_new :
u fuji_160c_-,fuji_160c,fuji_160c_+,fuji_160c_++,\
fuji_400h_-,fuji_400h,fuji_400h_+,fuji_400h_++,\
fuji_800z_-,fuji_800z,fuji_800z_+,fuji_800z_++,\
fuji_ilford_hp5_-,fuji_ilford_hp5,fuji_ilford_hp5_+,fuji_ilford_hp5_++,\
kodak_portra_160_-,kodak_portra_160,kodak_portra_160_+,kodak_portra_160_++,\
kodak_portra_400_-,kodak_portra_400,kodak_portra_400_+,kodak_portra_400_++,\
kodak_portra_800_-,kodak_portra_800,kodak_portra_800_+,kodak_portra_800_++,\
kodak_tmax_3200_-,kodak_tmax_3200,kodak_tmax_3200_+,kodak_tmax_3200_++,\
kodak_tri-x_400_-,kodak_tri-x_400,kodak_tri-x_400_+,kodak_tri-x_400_++
fx_emulate_film_negative_new_preview :
gui_split_preview "fx_emulate_film_negative_new $*",${-3--1}
#@gui Negative [Old] : fx_emulate_film_negative_old, fx_emulate_film_negative_old_preview(1)+
#@gui : Preset = choice{0,"None","Fuji Ilford Delta 3200","Fuji Neopan 1600","Fuji Superia 100","Fuji Superia 400","Fuji Superia 800","Fuji Superia 1600",
#@gui : "Kodak Portra 160 NC","Kodak Portra 160 VC","Kodak Portra 400 NC","Kodak Portra 400 UC","Kodak Portra 400 VC"}
#@gui : Effect = choice(1,"Low","Standard","High","Higher")
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_negative_old :
_fx_emulate_film $1,${arg\ {max(1,4*$1+$2-3)},${-_$0}},${3--1}
_fx_emulate_film_negative_old :
u fuji_ilford_delta_3200_-,fuji_ilford_delta_3200,fuji_ilford_delta_3200_+,fuji_ilford_delta_3200_++,\
fuji_neopan_1600_-,fuji_neopan_1600,fuji_neopan_1600_+,fuji_neopan_1600_++,\
fuji_superia_100_-,fuji_superia_100,fuji_superia_100_+,fuji_superia_100_++,\
fuji_superia_400_-,fuji_superia_400,fuji_superia_400_+,fuji_superia_400_++,\
fuji_superia_800_-,fuji_superia_800,fuji_superia_800_+,fuji_superia_800_++,\
fuji_superia_1600_-,fuji_superia_1600,fuji_superia_1600_+,fuji_superia_1600_++,\
kodak_portra_160_nc_-,kodak_portra_160_nc,kodak_portra_160_nc_+,kodak_portra_160_nc_++,\
kodak_portra_160_vc_-,kodak_portra_160_vc,kodak_portra_160_vc_+,kodak_portra_160_vc_++,\
kodak_portra_400_nc_-,kodak_portra_400_nc,kodak_portra_400_nc_+,kodak_portra_400_nc_++,\
kodak_portra_400_uc_-,kodak_portra_400_uc,kodak_portra_400_uc_+,kodak_portra_400_uc_++,\
kodak_portra_400_vc_-,kodak_portra_400_vc,kodak_portra_400_vc_+,kodak_portra_400_vc_++
fx_emulate_film_negative_old_preview :
gui_split_preview "fx_emulate_film_negative_old $*",${-3--1}
#@gui PictureFX : fx_emulate_film_picturefx, fx_emulate_film_picturefx_preview(1)+
#@gui : Preset = choice{"None",
#@gui : "AnalogFX - Anno 1870 Color",
#@gui : "AnalogFX - Old Style I","AnalogFX - Old Style II","AnalogFX - Old Style III",
#@gui : "AnalogFX - Sepia Color","AnalogFX - Soft Sepia I","AnalogFX - Soft Sepia II",
#@gui : "GoldFX - Perfect Sunset 01min","GoldFX - Perfect Sunset 05min","GoldFX - Perfect Sunset 10min",
#@gui : "GoldFX - Spring breeze","GoldFX - Bright spring breeze",
#@gui : "GoldFX - Summer heat","GoldFX - Bright summer heat","GoldFX - Hot summer heat",
#@gui : "TechnicalFX - Backlight filter",
#@gui : "ZilverFX - B&amp;W Solarization","ZilverFX - Infrared","ZilverFX - Vintage B&amp;W"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been provided by <b>Marc Roovers</b>, and are freely available at:</small>")
#@gui : url = link("PictureFX - a free HaldCLUT set","http://www.digicrea.be/haldclut-set-style-a-la-nik-software")
#@gui : sep = separator(), note = note("<small>Authors: <i>Marc Roovers</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/21/10</i>.</small>")
fx_emulate_film_picturefx :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_picturefx :
u analogfx_anno_1870_color,\
analogfx_old_style_i,analogfx_old_style_ii,analogfx_old_style_iii,\
analogfx_sepia_color,analogfx_soft_sepia_i,analogfx_soft_sepia_ii,\
goldfx_perfect_sunset_01min,goldfx_perfect_sunset_05min,goldfx_perfect_sunset_10min,\
goldfx_spring_breeze,goldfx_bright_spring_breeze,goldfx_summer_heat,goldfx_bright_summer_heat,goldfx_hot_summer_heat,\
technicalfx_backlight_filter,\
zilverfx_b_w_solarization,zilverfx_infrared,zilverfx_vintage_b_w
fx_emulate_film_picturefx_preview :
gui_split_preview "fx_emulate_film_picturefx $*",${-3--1}
#@gui Print Films : fx_emulate_film_print, fx_emulate_film_print_preview(1)+
#@gui : Preset = choice{"None","Fuji 3510 (Constlclip)","Fuji 3510 (Constlmap)","Fuji 3510 (Cuspclip)",
#@gui : "Fuji 3513 (Constlclip)","Fuji 3513 (Constlmap)","Fuji 3513 (Cuspclip)",
#@gui : "Kodak 2383 (Constlclip)","Kodak 2383 (Constlmap)","Kodak 2383 (Cuspclip)",
#@gui : "Kodak 2393 (Constlclip)","Kodak 2393 (Constlmap)","Kodak 2393 (Cuspclip)"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been provided by <b>Juan Melara</b>, and are freely available at:</small>")
#@gui : url = link("Print Film Emulation LUTs For Download","http://juanmelara.com.au/print-film-emulation-luts-for-download/")
#@gui : sep = separator(), note = note("<small>Authors: <i>Juan Melara</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_print :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_print :
u fuji3510_constlclip,fuji3510_constlmap,fuji3510_cuspclip,\
fuji3513_constlclip,fuji3513_constlmap,fuji3513_cuspclip,\
kodak2383_constlclip,kodak2383_constlmap,kodak2383_cuspclip,\
kodak2393_constlclip,kodak2393_constlmap,kodak2393_cuspclip
fx_emulate_film_print_preview :
gui_split_preview "fx_emulate_film_print $*",${-3--1}
#@gui RocketStock Color Grading : fx_emulate_film_rocketstock, fx_emulate_film_rocketstock_preview(1)+
#@gui : Preset = choice{"None", "Arabica 12", "Ava 614", "Azrael 93", "Bourbon 64", "Byers 11", "Chemical 168", "Clayton 33", "Clouseau 54",
#@gui : "Cobi 3", "Contrail 35", "Cubicle 99", "Django 25", "Domingo 145", "Faded 47", "Folger 50", "Fusion 88", "Hyla 68", "Korben 214",
#@gui : "Lenox 340", "Lucky 64", "McKinnon 75", "Milo 5", "Neon 770", "Paladin 1875", "Pasadena 21", "Pitaya 15", "Reeve 38", "Remy 24",
#@gui : "Sprocket 231", "Teigen 28", "Trent 18", "Tweed 71", "Vireo 37", "Zed 32", "Zeke 39"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The 35 color LUTs proposed in this filter are provided by <b>ROCKETSTOCK</b>, and are freely available at:</small>")
#@gui : url = link("RocketStock 35 Free LUTs for Color Grading","https://www.rocketstock.com/free-after-effects-templates/35-free-luts-for-color-grading-videos/")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2019/02/05</i>.</small>")
fx_emulate_film_rocketstock :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_rocketstock :
u arabica12,ava614,azrael93,bourbon64,byers11,chemical168,clayton33,clouseau54,cobi3,contrail35,cubicle99,django25,domingo145,\
faded47,folger50,fusion88,hyla68,korben214,lenox340,lucky64,mckinnon75,milo5,neon770,paladin1875,pasadena21,pitaya15,reeve38,\
remy24,sprocket231,teigen28,trent18,tweed71,vireo37,zed32,zeke39
fx_emulate_film_rocketstock_preview :
gui_split_preview "fx_emulate_film_rocketstock $*",${-3--1}
#@gui Slide [Color] : fx_emulate_film_colorslide, fx_emulate_film_colorslide_preview(1)+
#@gui : Preset = choice{"None",
#@gui : "Agfa Precisa 100","Fuji Astia 100F","Fuji FP 100C","Fuji Provia 100F","Fuji Provia 400F","Fuji Provia 400X","Fuji Sensia 100",
#@gui : "Fuji Superia 200 XPRO","Fuji Velvia 50","Generic Fuji Astia 100","Generic Fuji Provia 100","Generic Fuji Velvia 100",
#@gui : "Generic Kodachrome 64","Generic Kodak Ektachrome 100 VS","Kodak E-100 GX Ektachrome 100","Kodak Ektachrome 100 VS","Kodak Elite Chrome 200",
#@gui : "Kodak Elite Chrome 400","Kodak Elite ExtraColor 100","Kodak Kodachrome 200","Kodak Kodachrome 25","Kodak Kodachrome 64","Lomography X-Pro Slide 200",
#@gui : "Polaroid 669","Polaroid 690","Polaroid Polachrome"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_colorslide :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_colorslide :
u agfa_precisa_100,fuji_astia_100f,fuji_fp_100c,fuji_provia_100f,fuji_provia_400f,fuji_provia_400x,fuji_sensia_100,\
fuji_superia_200_xpro,fuji_velvia_50,generic_fuji_astia_100,generic_fuji_provia_100,generic_fuji_velvia_100,\
generic_kodachrome_64,generic_kodak_ektachrome_100_vs,kodak_e-100_gx_ektachrome_100,kodak_ektachrome_100_vs,kodak_elite_chrome_200,\
kodak_elite_chrome_400,kodak_elite_extracolor_100,kodak_kodachrome_200,kodak_kodachrome_25,kodak_kodachrome_64,lomography_x-pro_slide_200,\
polaroid_669,polaroid_690,polaroid_polachrome
fx_emulate_film_colorslide_preview :
gui_split_preview "fx_emulate_film_colorslide $*",${-3--1}
#@gui User-Defined : fx_emulate_film_userdefined, fx_emulate_film_userdefined_preview(1)+
#@gui : Specify HaldCLUT As = choice(2,"Top Layer","Bottom Layer","Filename")
#@gui : HaldCLUT Filename = filein()
#@gui : note = note("<small><b>Note:</b> Do not forget to set the <i>Input layers</i> option if you select <i>Top layer</i> or <i>Bottom layer</i>.</small>")
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_userdefined : skip "${2=}"
if {$1<2}
if {$!<2} gui_warning_preview "Input layer with HaldCLUT is missing" return fi
ind={if($1,-1,0)} map_clut[^$ind] [$ind] rm[$ind]
else
l
0 nm. "$2" ext={x} rm.
if {lowercase(['$ext'])=='cube'} input_cube "$2"
else i "$2"
fi
onfail gui_warning_preview "Specified HaldCLUT filename not found" return
endl
map_clut[^-1] . rm.
if {iM>255} / 255 fi
fi
_fx_emulate_film 0,1,${3--1}
fx_emulate_film_userdefined_preview : skip "${2=}"
if {$1<2} gui_warning_preview "No preview available in this mode" return fi
gui_split_preview "fx_emulate_film_userdefined $1,\"$2\",${3--2}",${-3--1}
#@gui Various : fx_emulate_film_various, fx_emulate_film_various_preview(1)+
#@gui : Preset = choice{"None","60's","60's (faded)","60's (faded alt)","Alien green","Black &amp; White","Bleach bypass","Blue mono",
#@gui : "Color (rich)","Faded","Faded (alt)","Faded (analog)","Faded (extreme)","Faded (vivid)","Expired (fade)","Expired (polaroid)","Extreme","Fade",
#@gui : "Faux infrared","Golden","Golden (bright)","Golden (fade)","Golden (mono)","Golden (vibrant)","Green mono","Hong Kong","Light (blown)","Lomo",
#@gui : "Mono tinted","Muted fade","Mute shift","Natural (vivid)","Nostalgic","Orange tone","Pink fade","Purple","Retro","Rotate (muted)","Rotate (vibrant)",
#@gui : "Smooth crome-ish","Smooth fade","Soft fade","Solarize color","Solarized color2","Summer","Summer (alt)","Sunny","Sunny (alt)","Sunny (warm)",
#@gui : "Sunny (rich)","Super warm","Super warm (rich)","Sutro FX","Vibrant","Vibrant (alien)","Vibrant (contrast)","Vibrant (crome-ish)",
#@gui : "Vintage","Vintage (alt)","Vintage (brighter)","Warm","Warm (highlight)","Warm (yellow)"}
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>More info at:</small>")
#@gui : url = link{"Film Emulation Presets in G'MIC","https://gmic.eu/film_emulation/index.shtml"}
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>Patrick David</i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_emulate_film_various :
_fx_emulate_film $1,${arg\ {max(1,$1)},${-_$0}},${2--1}
_fx_emulate_film_various :
u 60{`39`}s,60{`39`}s_faded,60{`39`}s_faded_alt,alien_green,black_and_white,bleach_bypass,blue_mono,\
color_rich,faded,faded_alt,faded_analog,faded_extreme,faded_vivid,expired_fade,expired_polaroid,extreme,fade,\
faux_infrared,golden,golden_bright,golden_fade,golden_mono,golden_vibrant,green_mono,hong_kong,light_blown,lomo,\
mono_tinted,muted_fade,mute_shift,natural_vivid,nostalgic,orange_tone,pink_fade,purple,retro,rotate_muted,rotate_vibrant,\
smooth_cromeish,smooth_fade,soft_fade,solarized_color,solarized_color2,summer,summer_alt,sunny,sunny_alt,sunny_warm,\
sunny_rich,super_warm,super_warm_rich,sutro_fx,vibrant,vibrant_alien,vibrant_contrast,vibrant_cromeish,\
vintage,vintage_alt,vintage_brighter,warm,warm_highlight,warm_yellow
fx_emulate_film_various_preview :
gui_split_preview "fx_emulate_film_various $*",${-3--1}
_fx_emulate_film :
if $1
clut "$2"
repeat {$!-1}
if {$9%2} balance_gamma[$>] , fi
if {$3<100} +map_clut[$>] . j[$>] .,0,0,0,0,{$3%} rm.
else map_clut[$>] .
fi
done
rm.
fi
adjust_colors ${4-8},0,255
if {$9>1} repeat $! l[$>] split_opacity n[0] 0,255 a c endl done fi
#@gui _
#@gui <b>Frames</b>
#@gui Droste : fx_droste, fx_droste_preview(1)
#@gui : note = note("<span color=\"red\">Upper-left coordinates :</span>")
#@gui : X0 = float(20,0,100)
#@gui : Y0 = float(20,0,100)
#@gui : sep = separator(), note = note("<span color=\"magenta\">Upper-right coordinates :</span>")
#@gui : X1 = float(80,0,100)
#@gui : Y1 = float(20,0,100)
#@gui : sep = separator(), note = note("<span color=\"blue\">Lower-right coordinates :</span>")
#@gui : X2 = float(80,0,100)
#@gui : Y2 = float(80,0,100)
#@gui : sep = separator(), note = note("<span color=\"cyan\">Lower-left coordinates :</span>")
#@gui : X3 = float(20,0,100)
#@gui : Y3 = float(80,0,100)
#@gui : sep = separator()
#@gui : Iterations = int(1,1,10)
#@gui : X-Shift = float(0,-100,100)
#@gui : Y-Shift = float(0,-100,100)
#@gui : Angle = float(0,0,360)
#@gui : Zoom = float(1,0.1,5)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axes")
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui : Drawing Mode = choice{"Replace","Replace (Sharpest)","Behind","Below"}
#@gui : View Outlines Only = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/11/06</i>.</small>")
fx_droste :
repeat $!
if {$16==1} 100%,100%,1,1,'x' 100%,100%,1,1,'y' a[-2,-1] c fi
repeat $9
x0={round($1*w/100)} y0={round($2*h/100)} x1={round($3*w/100)} y1={round($4*h/100)}
x2={round($5*w/100)} y2={round($6*h/100)} x3={round($7*w/100)} y3={round($8*h/100)}
100%,100%,1,2,-32767 polygon. 4,$x0,$y0,$x1,$y1,$x2,$y2,$x3,$y3,1,-65535
sh. 0 f. 'if(i==-65535,x03=$x0+(y-$y0)/($y3-$y0)*($x3-$x0);x12=$x1+(y-$y1)/($y2-$y1)*($x2-$x1);(x-x03)/(x12-x03)*(w-1),i)' rm.
sh. 1 f. 'if(i==-65535,y01=$y0+(x-$x0)/($x1-$x0)*($y1-$y0);y32=$y3+(x-$x3)/($x2-$x3)*($y2-$y3);(y-y01)/(y32-y01)*(h-1),i)' rm.
xshift={w*$10/100} yshift={h*$11/100} alpha={-$12*pi/180} ca={cos($alpha)/$13} sa={sin($alpha)/$13} w2={w/2} h2={h/2}
f. 'if(i==-32767,i,X=i(x,y,0,0)-$w2;Y=i(x,y,0,1)-$h2;if(c==0,$w2-$xshift+X*$ca-Y*$sa,$h2-$yshift+X*$sa+Y*$ca))'
if {$14==0} sh. 0 f. 'if(i==-32767,x,i)' rm. sh. 1 f. 'if(i==-32767,y,i)' rm.
elif {$14==1} sh. 0 f. 'if(i==-32767,x,w-1-i)' rm. sh. 1 f. 'if(i==-32767,y,i)' rm.
elif {$14==2} sh. 0 f. 'if(i==-32767,x,i)' rm. sh. 1 f. 'if(i==-32767,y,h-1-i)' rm.
else sh. 0 f. 'if(i==-32767,x,w-1-i)' rm. sh. 1 f. 'if(i==-32767,y,h-1-i)' rm.
fi
if {$16<2} warp.. .,0,{$16==0},$15 rm.
else
+warp.. .,0,1,$15 rm..
if {$16==3} rv[-2,-1] fi
blend[-2,-1] alpha
fi
done
if {$16==1} warp.. .,0,1,1 rm. fi
mv. 0 done
fx_droste_preview :
if {!$17} fx_droste $* else polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,0.3,0,0,0,255 fi
polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,1,0xFFFFFFFF,0,0,0,255
ellipse $1%,$2%,3,3,0,1,255,0,0,255 ellipse $1%,$2%,3,3,0,1,0xFFFFFFFF,0,0,0,255
ellipse $3%,$4%,3,3,0,1,255,0,255,255 ellipse $3%,$4%,3,3,0,1,0xFFFFFFFF,0,0,0,255
ellipse $5%,$6%,3,3,0,1,0,0,255,255 ellipse $5%,$6%,3,3,0,1,0xFFFFFFFF,0,0,0,255
ellipse $7%,$8%,3,3,0,1,0,255,255,255 ellipse $7%,$8%,3,3,0,1,0xFFFFFFFF,0,0,0,255
#@gui Frame [Blur] : fx_frame_blur, fx_frame_blur(1)
#@gui : Horizontal Size (%) = float(30,0,100)
#@gui : Vertical Size (%) = float(30,0,100)
#@gui : sep = separator()
#@gui : Crop = float(0,0,100)
#@gui : Blur = float(5,0,10)
#@gui : Roundness = float(0,0,1)
#@gui : Apply Color Balance = bool(0)
#@gui : Balance Color = color(128,128,128)
#@gui : Normalization = choice("None","Stretch","Equalize")
#@gui : sep = separator()
#@gui : Outline Size = float(5,0,50)
#@gui : Outline Color = color(255,255,255)
#@gui : X-Shadow = float(2,-10,10)
#@gui : Y-Shadow = float(2,-10,10)
#@gui : Shadow Smoothness = float(1,0,5)
#@gui : Shadow Contrast = float(0,0,100)
#@gui : X-Centering = float(0.5,0,1)
#@gui : Y-Centering = float(0.5,0,1)
#@gui : Angle = float(0,-180,180)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/19/01</i>.</small>")
fx_frame_blur :
repeat $! l[$>] to_rgb
sx={$1%*max(w,h)} sy={$2%*max(w,h)}
+r {w+$sx},{h+$sy},1,100%,3 b[1] $4%
if $6 balance_gamma[1] ${7-9} fi
if {$10==1} n[1] 0,255 elif {$10==2} n[1] 0,255 equalize[1] 256 fi
rv
z[1] {$3/2}%,{$3/2}%,{100-$3/2}%,{100-$3/2}%
to_rgba[1]
if $5 r={1+1/$5} sh[1] 100% f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
c. $v,{$v+0.5/max(w,h)} n. 0,255 rm. fi
s={$11%*max(w,h)}
r[1] {w+$s},{h+$s},1,4,0,0,0.5,0.5
i[1] 100%,100%,1,3 fc[1] ${12-14} blend[1,2] alpha to_a.
if $5 sh[1] 100% f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
c. $v,{$v+0.5/max(w,h)} n. 0,255 rm. fi
rotate[1] $21,1,0
r[1] [0],[0],1,4,0,0,$19,$20
+channels[1] 100% b. $17%,0 c. 0,{max(1,100-$18)}% n. 0,255
shift. {round(w*$15%)},{round(h*$16%)},0,0,0 /. -255 +. 1 *[0,-1]
blend alpha
endl done
#@gui Frame [Cube] : frame_cube, frame_cube(1)
#@gui : Depth = float(3,0,30)
#@gui : X-Center = float(0,-2,2)
#@gui : Y-Center = float(0,-2,2)
#@gui : Left Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : Right Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : Upper Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : Lower Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;, Angelo Lama</i>.      Latest Update: <i>2012/29/01</i>.</small>")
#@gui Frame [Fuzzy] : fx_frame_fuzzy, fx_frame_fuzzy(0)
#@gui : Horizontal Size (%) = float(5,0,100)
#@gui : Vertical Size (%) = float(5,0,100)
#@gui : Fuzzyness = float(10,0,40)
#@gui : Smoothness = float(1,0,5)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_frame_fuzzy :
repeat $! l[$>]
sx={$1%*max(w,h)/2} sy={$2%*max(w,h)/2}
frame_fuzzy $sx,$sy,${3-8}
endl done
#@gui Frame [Mirror] : fx_frame_mirror, fx_frame_mirror_preview(1)
#@gui : note = note("<b>Frame size:</b>")
#@gui : Horizontal (%) = float(10,0,100)
#@gui : Vertical (%) = float(10,0,100)
#@gui : sep = separator(), note = note("<b>Image alignment:</b>")
#@gui : Horizontal (%) = float(50,0,100)
#@gui : Vertical (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<b>Frame dilation/shrinking:</b>")
#@gui : Left = float(0,-5,5)
#@gui : Right = float(0,-5,5)
#@gui : Up = float(0,-5,5)
#@gui : Bottom = float(0,-5,5)
#@gui : sep = separator()
#@gui : Preview Opacity (%) = float(0.75,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/08/20</i>.</small>")
fx_frame_mirror :
repeat $! l[$>]
{100+2*$1}%,{100+2*$2}%,1,100%,"
const boundary = 3;
const offx = (w - w#-1)*$3%;
const offy = (h - h#-1)*$4%;
const f_left = 2^$5;
const f_right = 2^$6;
const f_up = 2^$7;
const f_bottom = 2^$8;
x = x - offx;
y = y - offy;
x<0?(x*=-f_left):
x>=w#-1?(x = w#-1 - 1 - f_right*(x - w#-1));
y<0?(y*=-f_up):
y>=h#-1?(y = h#-1 - 1 - f_bottom*(y - h#-1));
I(#-1,x,y)"
k. endl done
fx_frame_mirror_preview :
repeat $! l[$>]
ws,hs={[w,h]} fx_frame_mirror $* wd,hd={[w,h]}
rr2d $_preview_width,$_preview_height wp,hp={[w,h]}
ws,hs={[$ws,$hs]*[$wp,$hp]/[$wd,$hd]}
coords={off=([$wp,$hp]-[$ws,$hs])*[$3,$4]%;[off,off+[$ws,$hs]-1]}
split_opacity 100%,100%,1,1,$9 rectangle. $coords,1,1 *[0,-1] a c
rectangle $coords,0.75,0xF0F0F0F0,255
rectangle $coords,0.75,0x0F0F0F0F,0,0,0,255
endl done
#@gui Frame [Painting] : fx_frame_painting, fx_frame_painting_preview(1)
#@gui : Size (%) = float(10,0,100)
#@gui : Contrast = float(0.4,0,1)
#@gui : Smoothness = float(6,0,30)
#@gui : Color = color(225,200,120)
#@gui : sep = separator()
#@gui : Vignette Size = float(2,0,50)
#@gui : Vignette Contrast = float(400,0,1000)
#@gui : sep = separator()
#@gui : Defects Contrast = float(50,0,512)
#@gui : Defects Density = float(10,0,100)
#@gui : Defects Size = float(1,0,10)
#@gui : Defects Smoothness = float(0.5,0,20)
#@gui : sep = separator()
#@gui : Serial Number = int(123456,0,1000000)
#@gui : Frame as a New Layer = _bool(false)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/07/06</i>.</small>")
fx_frame_painting :
if $14
repeat $! 100%,100%,1,4 frame_painting. $1%,$2,$3%,${4-6},$7%,${8-13}
rv[-2,-1] to_a. r. ..,..,1,4,0,0,0.5,0.5 mv[-2,-1] 0 done
else frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}
fi
fx_frame_painting_preview :
frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}
#@gui Frame [Pattern] : fx_frame_pattern, fx_frame_pattern_preview(1)
#@gui : Tiles = int(10,3,30)
#@gui : Pattern = choice(1,"Top Layer","Self Image")
#@gui : Iterations = int(1,1,10)
#@gui : Constrain Image Size = _bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/01/08</i>.</small>")
fx_frame_pattern :
if {$2||$!==1} repeat $3 frame_pattern $1,$4 done
else repeat $3 frame_pattern[^0] $1,[0],$4 done fi
fx_frame_pattern_preview :
fx_frame_pattern ${1-3},1
#@gui Frame [Regular] : fx_frame, fx_frame(1)
#@gui : note = note("<b>Crop parameters :</b>")
#@gui : X-Start (%) = int(0,0,100)
#@gui : X-End (%) = int(100,0,100)
#@gui : Y-Start (%) = int(0,0,100)
#@gui : Y-End (%) = int(100,0,100)
#@gui : sep = separator(), note = note("<b>Frame parameters :</b>")
#@gui : Width (%) = int(10,0,100)
#@gui : Height (%) = int(10,0,100)
#@gui : Color = color(0,0,0,255)
#@gui : Outline Size = int(1,0,100)
#@gui : Outline Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_frame :
to_rgba repeat $!
z. $1%,$3%,$2%,$4%
frame. $11,$11,${12-15}
sx={$5%*max(w,h)} sy={$6%*max(w,h)}
frame. $sx,$sy,${7-10}
mv. 0 done
#@gui Frame [Round] : fx_frame_round, fx_frame_round(1)
#@gui : Sharpness = float(6,0.1,40)
#@gui : Size (%) = float(20,0,100)
#@gui : Smoothness = float(0.1,0,15)
#@gui : Shade = float(0,0,1)
#@gui : Color = color(255,255,255,255)
#@gui : Blur Frame = float(0,0,100)
#@gui : Blur Shade = float(0.1,0,1)
#@gui : Blur Amplitude = float(3,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_frame_round :
frame_round ${1-8}
if $9 frame_blur $1,{min(99,$1+$9)},$3,$10,$11% fi
#@gui Frame [Smooth] : fx_frame_smooth, fx_frame_smooth(1)
#@gui : Width (%) = int(10,0,100)
#@gui : Height (%) = int(10,0,100)
#@gui : Roundness = float(0.25,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/25/04</i>.</small>")
fx_frame_smooth :
repeat $! l[$>]
sx={$1%*max(w,h)} sy={$2%*max(w,h)}
100%,100%,1,1,0
if $3 r={1+1/$3} f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))} <=. $v
fi
frame $sx,$sy,1
inpaint_diffusion[0] [1],100%,1,15
rm.
endl done c 0,255
#@gui Old Photograph : fx_old_photo, fx_old_photo(1)
#@gui : Vignette Strength = float(200,0,255)
#@gui : Vignette Min Radius = float(50,0,100)
#@gui : Vignette Max Radius = float(85,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_old_photo :
vignette ${1-3} old_photo
#@gui Polaroid : fx_polaroid, fx_polaroid(1)
#@gui : Frame Size = int(10,0,400)
#@gui : Bottom Size = int(20,0,400)
#@gui : X-Shadow = float(0,-20,20)
#@gui : Y-Shadow = float(0,-20,20)
#@gui : Smoothness = float(3,0,5)
#@gui : Curvature = float(0,0,1)
#@gui : Angle = float(20,-180,180)
#@gui : Vignette Strength = float(50,0,255)
#@gui : Vignette Min Radius = float(70,0,100)
#@gui : Vignette Max Radius = float(95,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_polaroid :
vignette ${8-10} polaroid $1,$2 drop_shadow $3%,$4%,$5%,$6 rotate $7,1,0
#@gui Tunnel : fx_tunnel, fx_tunnel(1)
#@gui : Depth = int(4,1,100)
#@gui : Factor = float(80,1,99)
#@gui : Center (%) = point(50,50)
#@gui : Opacity = float(0.2,0,1)
#@gui : Angle = float(0,-90,90)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/22/11</i>.</small>")
fx_tunnel :
tunnel $1,$2%,{[${3,4}]%},${5-6}
#@gui Vignette : fx_vignette, fx_vignette
#@gui : Strength = float(70,0,255)
#@gui : Min Radius = float(70,0,100)
#@gui : Max Radius = float(95,0,100)
#@gui : Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/24/10</i>.</small>")
fx_vignette :
repeat $! to_rgb l[$>]
to_rgba split_opacity
=. 0 vignette. ${1-3} a c +fc ${4-7} rv blend alpha
endl done
#@gui _
#@gui <b>Frequencies</b>
#@gui Bandpass : fx_bandpass, fx_bandpass_preview(0)
#@gui : Low Frequency = float(0,0,100)
#@gui : High Frequency = float(100,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice(2,"None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_bandpass :
repeat $! l[$>] split_opacity l[0]
ac "bandpass $1%,$2%",$3,$4
endl a c endl done
fx_bandpass_preview :
gui_split_preview "fx_bandpass $*",${-3--1}
#@gui Fourier Analysis : fx_display_fft, fx_display_fft(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_display_fft :
to_rgb display_fft
#@gui Fourier Transform : fx_fourier, fx_fourier_preview(1)
#@gui : Magnitude / Phase = choice{1,"One Layer (Horizontal)","One Layer (Vertical)","Two Layers"}
#@gui : Discard Transparency = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Apply this filter once to get the direct FFT, and once again to get the reverse transform.</small>"}
#@gui : url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=3137dDa6P4s")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/06/16</i>.</small>")
fx_fourier : skip ${2=0}
if $2 remove_opacity fi
magic="GMICFFT"
i=0 for {$i<$!} ni={$i+1} nm={$i,n}
is_ifft=0
+columns[$i] 100% l. mag,m0,M0,m1,M1=${u\ {t}} if {['$mag']=='$magic'} is_ifft=1 fi onfail endl rm.
if {!$is_ifft} +rows[$i] 100% l. mag,m0,M0,m1,M1=${u\ {t}} if {['$mag']=='$magic'} is_ifft=2 fi onfail endl rm. fi
if {!$is_ifft}
+rows[$i] 100% l. mag,m0,M0=${u\ {t}} if {['$mag']=='$magic'} is_ifft=3 fi onfail endl rm.
if {$is_ifft==3} is_ifft=0 +rows[$ni] 100% l. mag,m1,M1=${u\ {t}} if {['$mag']=='$magic'} is_ifft=3 fi onfail endl rm. fi
fi
if {!$is_ifft}
l[$i]
fftpolar +.. 1 log.. m0,M0,m1,M1={[im#0,iM#0,im#1,iM#1]} n[-2,-1] 0,255
if {$1==0} ({'$magic,$m0,$M0,$m1,$M1'},0) y. a x
elif {$1==1} ({'$magic,$m0,$M0,$m1,$M1'},0) a y
else ({'$magic,$m0,$M0'},0) a[-3,-1] y ({'$magic,$m1,$M1'},0) a[-2,-1] y
fi
nm $nm
endl
else
if {$is_ifft==1} columns[$i] 0,{$i,w-2} s[$i] x,2
elif {$is_ifft==2} rows[$i] 0,{$i,h-2} s[$i] y,2
else rows[$i,$ni] 0,{$i,h-2}
fi
l[$i,{$i+1}] n[0] $m0,$M0 n[1] $m1,$M1 exp[0] -[0] 1 ifftpolar c 0,255 endl
fi
i+={$1<2" || "$is_ifft>2?1:2}
done
fx_fourier_preview :
if $2 remove_opacity fi
dfft
#@gui Fourier Watermark : fx_watermark_fourier, _none_
#@gui : Text = text{"(c) G'MIC"}
#@gui : Size = int(53,13,128)
#@gui : sep = separator()
#@gui : note = note("<small><b>Note: </b> To make the watermark visible afterwards, use the 'Fourier Analysis' filter. </small>")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_watermark_fourier :
watermark_fourier "$1",$2 c 0,255
#@gui _
#@gui <b>Layers</b>
#@gui Align Layers : fx_align_layers, fx_align_layers_preview
#@gui : Alignment Type = choice(0,"Rigid","Non-Rigid")
#@gui : Smoothness = float(0.7,0,1)
#@gui : Scales = choice(0,"Auto","1","2","3","4","5","6","7","8")
#@gui : Revert Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_align_layers :
to_colormode 0
r ${-max_wh},1,100%,0,0,0.5,0.5
if ${4=0} _fx_revert_layers fi
remove_opacity
if $1 register_nonrigid[^-1] .,$2,0.1,$3
else register_rigid[^-1] .,{3*$2}
fi
fx_align_layers_preview :
fx_align_layers $1,$2,0 blend_edges 0.1
_fx_revert_layers :
repeat {int($!/2)} rv[{2*$>},{2*$>+1}] done
#@gui Blend [Average All] : fx_blend_average_all, fx_blend_average_all
#@gui : Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter takes multiple layers as input and average them. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/11/08</i>.</small>")
fx_blend_average_all :
if $! to_rgba
N=$! r ${-max_wh},1,100%,0,0,0.5,0.5
_gb_fwd $1
+ / $N
_gb_bwd $1
fi
_gb_fwd :
to_color
if {$1==1} repeat $! l[$>] sh 0,2 srgb2rgb. rm. endl done
elif {$1==2} repeat $! l[$>] sh 0,2 srgb2rgb. rgb2lab. rm. endl done
fi
_gb_bwd :
to_color
if {$1==1} repeat $! l[$>] sh 0,2 rgb2srgb. rm. endl done
elif {$1==2} repeat $! l[$>] sh 0,2 lab2rgb. rgb2srgb. rm. endl done
fi
#@gui Blend [Edges] : fx_blend_edges, fx_blend_edges(0)
#@gui : Opacity = float(1,0,1)
#@gui : Smoothness = float(0.8,0,5)
#@gui : Revert Layers = bool(0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/21/01</i>.</small>")
fx_blend_edges :
repeat {int($!/2)} l[$>,{$>+1}] if $3 rv fi +blend_edges[-2,-1] $2 rm... blend[-2,-1] alpha,$1 endl done
#@gui Blend [Fade] : fx_blend_fade, fx_blend_fade(1)
#@gui : Preset = choice{1,"Custom","Linear","Circular","Wave","Keftales"}
#@gui : Offset = float(0,-1,1)
#@gui : Thinness = float(0,0,10)
#@gui : Sharpness = float(5,1,20)
#@gui : Sharpest = bool(0)
#@gui : Revert Layers = bool(0)
#@gui : Colorspace = choice("sRGB","Linear RGB","Lab")
#@gui : note = note{\n<small>
#@gui : The parameters below are used in most presets.
#@gui : </small>}
#@gui : 1st Parameter = float(0,-1,1)
#@gui : 2nd Parameter = float(0,-1,1)
#@gui : 3rd Parameter = float(0,-1,1)
#@gui : note = note{\n<small>
#@gui : The formula below is used for the <i>Custom</i> preset.
#@gui : </small>}
#@gui : Formula = text{"cos(4*pi*x/w) * sin(4*pi*y/h)"}
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/21/01</i>.</small>")
fx_blend_fade :
if {$!==1} return fi
to_colormode 4
_gb_fwd $7
if {$1==0} [0],[0],1,1,"$11"
else _fx_blend_fade$1 $8,$9,$10 r. [0],[0],1,1,3
fi
n. {-($!-2)*$3},{($!-2)*(1+$3)}
-. {$2*(1+$3)*($!-2)}
c. 0,{$!-2}
if $6 rv[^-1] fi
if $5 round. 1
else roundify. $4
fi
blend_fade[^-1] . rm.
_gb_bwd $7
c 0,255
_fx_blend_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_fx_blend_fade2 : [0],[0],1,1,0 =. 1,{($1+1)*50}%,{($2+1)*50}% distance. 1
_fx_blend_fade3 : [0],[0],1,1,0 =. 1,{($1+1)*50}%,{($2+1)*50}% distance. 1 *. {0.01+$3/2} cos.
_fx_blend_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"
#@gui Blend [Median] : fx_blend_median, fx_blend_median(0)
#@gui : Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>Iain Fergusson</i>.      Latest Update: <i>2014/16/12</i>.</small>")
fx_blend_median :
_gb_fwd $1
blend_median
_gb_bwd $1
#@gui Blend [Seamless] : fx_blend_seamless, fx_blend_seamless_preview(1)
#@gui : Mixed Mode = bool(0)
#@gui : Inner Fading = float(0,0,100)
#@gui : Outer Fading = float(25,0,100)
#@gui : Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator()
#@gui : Output as Separate Layers = _bool(0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=10204")
#@gui : url = link("+ Video tutorial 1","http://www.youtube.com/watch?v=Nu-S1HmOCgE")
#@gui : url = link("+ Video tutorial 2","http://www.youtube.com/watch?v=zsHgQY6025I")
#@gui : url = link("+ Video tutorial 3","http://www.youtube.com/watch?v=2e6FikWMkaQ")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/04/05</i>.</small>")
fx_blend_seamless :
rv
_gb_fwd $4
to_a[^0] r[^0] [0],[0],1,100%,0
repeat $! pos=${gui_layer_pos[$>]} shift[$>] ${u\ $pos},0,0 done
if $5
+blend_seamless $1,$2%,$3%
remove_opacity[0,-1] k[0,-1] rv sub_alpha[0] [1],1
else
blend_seamless $1,$2%,$3%
fi
_gb_bwd $4
fx_blend_seamless_preview :
fx_blend_seamless ${1-4},0
#@gui Blend [Standard] : fx_blend, fx_blend_preview
#@gui : Mode = choice{6,"Add","Alpha","And","Average","Blue","Burn","Custom formula","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain Extract","Grain Merge","Green","Hard Light",
#@gui : "Hard Mix","Hue","Interpolation","Lighten","Lightness","Linear Burn","Linear Light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin Light","Red","Reflect","Saturation",
#@gui : "Shape Area Max","Shape Area Max0","Shape Area Min","Shape Area Min0","Shape Average","Shape Average0",
#@gui : "Shape Median","Shape Median0","Shape Min","Shape Min0","Shape Max","Shape Max0",
#@gui : "Soft Burn","Soft Dodge","Soft Light","Screen","Stamp","Subtract","Value","Vivid Light","Xor"}
#@gui : Process As = choice("Two-by-Two","Upper Layer is the Top Layer for All Blends","Lower Layer is the Bottom Layer for All Blends")
#@gui : Opacity (%) = float(100,0,100)
#@gui : Preview All Outputs = bool(1)
#@gui : sep = separator()
#@gui : Custom Formula = text{"1/2 - 1/4*cos(pi*a) - 1/4*cos(pi*b)"}
#@gui : note = note{"<small><b>Note:</b> In custom formulas, <tt>a</tt> and <tt>b</tt> respectively stand for the values of the <i>base layer<i> and the <i>blend layer</i>,
#@gui : and are defined in value range [0,1].</small>"}
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Do not forget to set the <i>Input layers</i> option below to handle multiple input layers.
#@gui : </small>"}
#@gui : url = link("Reference page for G'MIC blending modes","https://github.com/dtschump/gmic-community/wiki/Blending-modes")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/03/08</i>.</small>")
fx_blend :
mode=${arg\ 1+$1,add,alpha,and,average,blue,burn,custom_formula,darken,difference,\
divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
shapeaverage,shapeaverage0,shapemedian,shapemedian0,\
shapemin,shapemin0,shapemax,shapemax0,\
softburn,softdodge,softlight,screen,stamp,subtract,value,\
vividlight,xor}
m "_blend_custom_formula : f. \"a = i#0/255; b = i#1/255; 255*cut(($5),0,1)\""
if {$2==0} repeat {int($!/2)} l[$>,{$>+1}] rv blend $mode,{$3%} endl done
elif {$2==1" && "$!>1} blend[^0] [0],$mode,{$3%},0 rm[0]
elif {$2==2" && "$!>1} blend[^-1] .,$mode,{$3%},1 rm.
fi
uncommand _blend_custom_formula
fx_blend_preview :
fx_blend $"*"
if $4 append_tiles , fi
#@gui Colors to Layers : fx_split_colors, fx_split_colors_preview(1)
#@gui : Color Tolerance = float(50,0,256)
#@gui : Maximum Number of Output Layers = int(16,2,256)
#@gui : Minimal Area (%) = float(1,0,100)
#@gui : Autocrop Output Layers = bool()
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter decomposes an image into several layers each with a single color + a residual layer (if any).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/11/03</i>.</small>")
fx_split_colors : skip ${2=0}
to_rgb repeat $! l[$>]
nm=${-gui_layer_name}
min_area={max(1,w*h*$3%)}
split_colors $1,$2,$min_area
nm name($nm)
if $4 gui_autocrop_layers fi
endl done
fx_split_colors_preview :
repeat $! l[$>]
+fx_split_colors ${1-4} drgba
repeat $! l[$>] to ${arg\ {1+!!$>},"Original","#"$>},1,1,43,7,1,255 endl done
frame 1,1,0 frame 3,3,255 to_rgba append_tiles ,
endl done
#@gui Fade Layers : fx_fade_layers, fx_fade_layers_preview
#@gui : Inter-Frames = _int(10,2,100)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/04/08</i>.</small>")
fx_fade_layers :
if {$!<2} return fi
to_colormode 0
r ${-max_wh},1,100%,0,0,0.5,0.5
a z r 100%,100%,{(d-1)*$1+1},100%,3 s z
fx_fade_layers_preview :
if {$!<2} return fi
to_colormode 0
r ${-max_wh},1,100%,0,0,0.5,0.5
k[0,1] + / 2
#@gui Layers to Tiles : append_tiles, fx_append_tiles_preview(1)
#@gui : X-Tiles = int(0,0,256)
#@gui : Y-Tiles = int(0,0,256)
#@gui : note = note("<small>For both parameters, <i>0</i> means <i>automatic</i>.</small>")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_append_tiles_preview :
frame 1,1,0,0,0,255 append_tiles $1,$2
#@gui Morph Layers : fx_morph, gui_no_preview
#@gui : Inter-Frames = _int(10,2,100)
#@gui : Smoothness = _float(0.2,0,2)
#@gui : Precision = _float(0.1,0,2)
#@gui : Revert Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_morph :
if ${4=0} _fx_revert_layers fi
to_rgb morph $1,$2,$3
#@gui Multiscale Operator : fx_apply_multiscale, fx_apply_multiscale_preview(1)
#@gui : Number of Scales = int(4,2,16)
#@gui : sep = separator()
#@gui : Starting Scale (%) = float(25,0,400)
#@gui : Ending Scale (%) = float(100,0,400)
#@gui : Non-Linearity = float(0,-1,1)
#@gui : Rescaling = choice(3,"Bloc","Linear","Cubic","Lanczsos")
#@gui : sep = separator()
#@gui : X-Centering = float(0.5,0,1)
#@gui : Y-Centering = float(0.5,0,1)
#@gui : Angle = float(0,-180,180)
#@gui : sep = separator()
#@gui : Enable Interpolated Motion = bool(0)
#@gui : Ending X-Centering = float(0.5,0,1)
#@gui : Ending Y-Centering = float(0.5,0,1)
#@gui : Ending Angle = float(0,-180,180)
#@gui : sep = separator()
#@gui : G'MIC Operator = text("")
#@gui : Return Scaling = choice("None","Bloc","Linear","Cubic","Lanczos")
#@gui : Lock Return Scaling to Source Layer = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/30/03</i>.</small>")
fx_apply_multiscale : skip "${13=}"
repeat $! l[$<]
w0={w} h0={h}
apply_scales "$13",$1,$2%,$3%,{10^$4},{arg(1+$5,1,3,5,6)}
if {$8||($9&&$8!=$12)} to_a N=$! repeat $!
angle={$9?$8+($12-$8)*$>/max($N-1,1):$8}
rotate[$>] $angle
done fi
if $14
if $15 siz=$w0,$h0 else siz=${-max_wh} fi
r $siz,1,100%,{arg($14,1,3,5,6)}
c 0,255
fi
w=${-max_w} h=${-max_h} N=$!
repeat $!
cx={$9?$6+($10-$6)*$>/max($N-1,1):$6}
cy={$9?$7+($11-$7)*$>/max($N-1,1):$7}
gui_set_layer_pos[$>] {$>,($w-w)*$cx},{$>,($h-h)*$cy}
done
endl done
fx_apply_multiscale_preview :
repeat $! l[$>]
fx_apply_multiscale $"*"
N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
to_rgba
max_wh=${-max_wh}
N=$! repeat $! l[$>]
cx={$9?$6+($10-$6)*$>/max($N-1,1):$6}
cy={$9?$7+($11-$7)*$>/max($N-1,1):$7}
r $max_wh,1,100%,0,0,$cx,$cy
0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0]
endl done
frame 1,1,0 frame 3,3,255 append_tiles ,
endl done
#@gui Pack : fx_pack, fx_pack_preview(1)
#@gui : Order By = choice(2,"Width","Height","Maximum Dimension","Area")
#@gui : Tends to Be Square = bool(0)
#@gui : Force Transparency = bool(1)
#@gui : sep = separator()
#@gui : Output Coordinates File = _bool(0)
#@gui : Output Folder = _folder()
#@gui : sep = separator()
#@gui : note = note{"<small>This filter tries to pack all input layers into a single image, while trying to minimize the empty areas.
#@gui : This problem being NP-hard, the algorithm finds (of course) a <b>non-optimal</b>, but often acceptable solution to this packing problem.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/11/05</i>.</small>")
fx_pack : skip "${5=}"
if $3 to_a fi
if $4 repeat $! nm$>=${gui_layer_name[$>]} done fi
c0="w" c1="h" c2="max(w,h)" c3="w*h"
pack $2,${c$1} coords=${}
if $4
repeat 256 filename "$5/gmic_pack.txt",$> filename=${} if $filename else break fi done
if {!narg($filename)} filename="$5/gmic_pack.txt" fi
l[] repeat {narg($coords)/2}
x={arg(1+2*$>,$coords)} y={arg(2+2*$>,$coords)}
({'"Image ""#"{1+$>}" ("${nm$>}"): "$x,$y\n'})
done a x o raw:$filename,uchar rm endl
fi
nm "name(G'MIC packing),pos(0,0),mode(normal)"
fx_pack_preview :
if {!$!} return fi
w={w} h={h}
filled=0 repeat $! filled={$>,$filled+w*h} done
fx_pack $1,$2,$3,0
area={w*h}
to_rgba rr2d $w,$h,0
i[0] $w,16,1,4,255 t[0] "Filled: "{round(100*$filled/$area)}%,3,1,14,1,0,0,0,255
a y,0.5
#@gui Stroke : fx_stroke, fx_stroke_preview(0)
#@gui : Thickness (px) = int(3,1,256)
#@gui : Threshold (%) = float(50,0,100)
#@gui : Smoothness (px) = float(0,0,10)
#@gui : Shape = choice(2,"Square","Diamond","Round")
#@gui : Direction = choice(1,"Inward","Outward")
#@gui : sep = separator()
#@gui : Zoom (%) = float(100,1,300)
#@gui : X-Shift (px) = int(0,-256,256)
#@gui : Y-Shift (px) = int(0,-256,256)
#@gui : sep = separator()
#@gui : Starting Color = color(255,255,255,255)
#@gui : Ending Color = color(255,255,255,255)
#@gui : Inside Color = color(0,0,0,0)
#@gui : Outside Color = color(0,0,0,0)
#@gui : sep = separator()
#@gui : Output Stroke Layer On = choice(1,"Bottom","Top")
#@gui : Keep Original Image Size = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/24/06</i>.</small>")
fx_stroke :
to_a repeat $! l[$<] nm={n}
if {!$26" && "$5} expand_xy $1,0 is_frame1=0 else expand_xy 1,0 is_frame1=1 fi
split_opacity +l.
b $3
if {$6>=100}
shift $7,$8
if {$6!=100} wh={w},{h} r $6%,$6%,1,1,3 r $wh,1,1,0,0,0.5,0.5 fi
else
if {$6!=100} wh={w},{h} r $6%,$6%,1,1,3 r $wh,1,1,0,0,0.5,0.5 fi
shift $7,$8
fi
> {99.99-min(99.99,$2)}%
distance $5,$4
($9^$10^$11^$12)
if {$1>1} ($13^$14^$15^$16) a[-2,-1] x r. $1,1,1,4,3 c. 0,255 fi
i.. ($21^$22^$23^$24) ($17^$18^$19^$20) if $5 rv[-3,-1] fi
a[-3--1] x map.. .,1 rm.
nm $nm
endl
a[0,1] c
if $is_frame1 shrink_xy 1 fi
if $25 rv fi
endl done
fx_stroke_preview :
repeat $! l[$>]
fx_stroke $*
nm foo
gui_merge_layers
endl done
#@gui Tiles to Layers : split_tiles, fx_tiles2layers_preview(1)
#@gui : X-Tiles = int(3,1,100)
#@gui : Y-Tiles = int(3,1,100)
#@gui : Force Tiles to Have Same Size = _bool(false)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_tiles2layers_preview :
split_tiles $1,$2,$3 to_rgba frame 1,1,0,0,0,255 frame 3,3,0,0,0,0 append_tiles ,
#@gui Tones to Layers : fx_tones2layers, fx_tones2layers_preview(0)
#@gui : Number of Tones = int(3,2,10)
#@gui : Start of Mid-Tones = int(85,0,255)
#@gui : End of Mid-Tones = int(170,0,255)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Alpha = choice("Binary","Scalar")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/05/04</i>.</small>")
fx_tones2layers :
sval=$2 eval={max($2,$3)}
remove_opacity repeat $! l[$<]
+luminance rv
repeat {$1-1}
[1]
val0={$sval+($eval-$sval)*$>/($1-2)}
val1={$sval+($eval-$sval)*($>+1)/($1-2)-1}
+ir[0] $val0,$val1
if $5 *. [0] b. $4% n. 0,255
else b. $4% n. 0,255
fi
a[-2,-1] c
done
rm[0] rv
endl done
fx_tones2layers_preview :
fx_tones2layers $* rv
r {100/$!}%,{100/$!}%,1,100%,2
to_rgba frame 1,1,0,0,0,255 frame 3,3,0,0,0,0 append_tiles ,
#@gui _
#@gui <b>Lights &amp; Shadows</b>
#@gui Burn : fx_burn, fx_burn_preview(1)
#@gui : Amplitude = float(0.5,0,1)
#@gui : Scale = float(30,1,100)
#@gui : Smoothness = float(1,0,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/24/11</i>.</small>")
_fx_burn :
repeat $! l[$>]
w={w} h={h}
+norm
fx_fourier. 0
+rows. 0,{$h-1} r. $2%,$2%,1,100%,0,0,0.5,0.5 b. $3%
j.. .,{($w-w)/2},{($h-h)/2} rm.
fx_fourier. 1
blend overlay,$1
endl done
fx_burn :
ac "_fx_burn ${1-3}",$4,$5
fx_burn_preview :
gui_split_preview "fx_burn ${^0}",${-3--1}
#@gui Contrast Swiss Mask : fx_contrast_swm , fx_contrast_swm(0)
#@gui : sep = separator()
#@gui : Blur the Mask = float(2,0.5,10)
#@gui : sep = separator()
#@gui : note = note ("Contrast Mask need the negative of the mask")
#@gui : Skip to Use the Mask to Boost = bool(false)
#@gui : note = note ("Uncheck for Contrast Mask,Check for Contrast Boost")
#@gui : sep = separator()
#@gui : note = note("Merge the Mask")
#@gui : Intensity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest Update: <i>2011/01/01</i>.</small>")
#@gui : url = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=864")
fx_contrast_swm :
repeat $! l[$>] split_opacity l[0]
+luminance to_rgb
blur_xy[1] $1,$1
if {$2==0} negate[1] fi
rv blend hardlight,$3
endl a c endl done
#@gui Dodge and Burn : fx_dodgeburn, fx_dodgeburn_preview(1)
#@gui : note = note("automatic dodging and burning")
#@gui : sep = separator()
#@gui : Highlights Selection = float(15,0,100)
#@gui : Highlights Abstraction = float(1.5,0,10)
#@gui : Dodge Strength = float(25,0,256)
#@gui : Dodge Blur = float(10,0,20)
#@gui : Shadows Selection = float(40,0,100)
#@gui : Shadows Abstraction = float(1.5,0,10)
#@gui : Burn Strength = float(25,0,256)
#@gui : Burn Blur = float(10,0,20)
#@gui : sep = separator()
#@gui : note = note("Advanved: output dodge and burn layer separate")
#@gui : Keep Layers Seperate = bool(0)
#@gui : Keep Original Layer = bool(0)
#@gui : Blur Dodge and Burn Layer = float(10,0,20)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2011/15/02</i>.</small>")
fx_dodgeburn :
-repeat $! -l[$>] --luminance -if {$9==1} --fc[0] 128,128,128,255 -endif
-tk_fx_channel_processing[1] 1,1,0,$2,4,0,{100-$1},256,0,1,0,2,0,0
-tk_fx_channel_processing[1] 1,1,{-{256-$3}},0,0,0,100,256,0,0,0,2,0,0
-fx_gaussian_blur[1] $4,0,0,1,0,0,0 --luminance[0]
-if {$9==0} -compose_dodge[0,1] -else -rv[1,2] -compose_dodge[1,2] -endif
-tk_fx_channel_processing[-1] 1,1,0,$6,4,$5,100,256,0,0,0,2,0,0
-tk_fx_channel_processing[-1] 1,1,{256-$7},0,0,0,100,256,0,0,0,2,0,0
-fx_gaussian_blur[-1] $8,0,0,1,0,0,0
-if {$9==0} -compose_colorburn[0,1] -else -compose_colorburn[-1,-2] -endif
-if {$9==1} -fx_gaussian_blur[-1] $11,0,0,1,0,0,0 -endif
-if {$10==0} -if {$9==1} -rm[0] -endif -endif -endl -done
fx_dodgeburn_preview :
-gui_split_preview "-fx_dodgeburn ${1--2}",$-1
fx_split_freq :
-repeat $!
--b[-1] $1 --[-2] [-1] -/[-2] 2 -+[-2] 128 -rv[-2,-1]
-mv[-2,-1] 0 -done
fx_compose_freq :
-repeat {int($!/2)}
--[-1] 128 -*[-1] 2 -+[-2,-1] -c[-1] 0,255
-mv[-1] 0 -done
compose_alpha :
-e[^-1] "Compose image$? two-by-two, using alpha blending."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-r[-1] [-2],[-2],[-2],100%,0,0,0.5,0.5
-to_colormode[-2] {a1=!({-2,s}%2);a2=!(s%2);max({-2,s}-a1,s-a2)+a1}
-to_colormode[-1] {a=max({-2,s},s);a+(a%2)}
-if {-2,s==2" || "s==4}
-_compose_alpha[-2] -_compose_alpha[-1]
-sh[-1] {s-1},{s-1} --*[-3,-1] -rm[-2] -+[-3,-2] --[-2,-1]
-sh[-1] 0,{s-2} -sh[-2] {-2,s-1},{-2,s-1}
-max[-1] 1e-10 -/[-2] [-1] -*[-1] 255 -rm[-2,-1]
-else
-sh[-1] 0,{s-2} -sh[-2] {-2,s-1},{-2,s-1} --[-2] [-4] -*[-2,-1] -/[-1] 255 -rm[-1] -+[-2,-1]
-endif
-endl -done -c 0,255 -v +
_compose_alpha :
-sh[-1] 0,{s-2} -sh[-2] {-2,s-1},{-2,s-1} -max[-1] 1e-10 -/[-1] 255 -*[-2,-1] -rm[-1]
fx_compose_alpha :
-if ${2=0} -_fx_revert_layers -endif
-repeat {int($!/2)}
-to_rgba[-1] -sh[-1] 3,3 -*[-1] $1 -rm[-1]
-blend[-2,-1] alpha
-mv[-1] 0 -done
#@cli sol : eq. to '_solarize'.
sol :
_solarize
#@cli _solarize :
#@cli : Solarize values. If values are greater than .5 (0-1 range assumed), then the values becomes inverted. Finally, it is normalized. Note that this doesn't work on -1,1 though.
_solarize :
+negate
blend darken mul 2
#@cli modo :
#@cli : (eq. to 'modular_operation').
#@cli : $ modo 1, 255, {128/255}, 1
modo : modular_operation $*
#@cli modular_operation : 0>=operation<=5,chan_v>0, 0>value(%)<=1,two_layers=0|two_layers=1
modular_operation :
if {$4==0} repeat $! l[$>] split_opacity _modular_formula[0] $1,$2,$3,0 a c -endl done rv
elif {$4==1} repeat {int($!/2)} l[{$>*2},{$>*2+1}] _modular_blending_pre[0,1] $1,$2,$3,1
endl done fi
_modular_blending_pre :
split_opacity rv[1,2] +f[3] "255-i" +f[0] "(i#2/255+i#4/255*i#3/255)*255" rm[2-4] l[0,1] +rv l[0,1] _modular_formula[0,1] $1,$2,$3,1 rm[1] endl l[1,2]  _modular_formula[0,1] $1,$2,$3,1 rm[1] endl
endl compose_channels[2] max [2] a[0,2] c a[1,2] c rv
#@cli modf:
#@cli : (eq. to '_modular_formula)
#@cli : $ modf 3,255,{128/255},0
modf : _modular_formula $*
#@cli _modular_formula : 0>=operation<=5,chan_v>0, 0>value(%)<=1,two_layers=0|two_layers=1
_modular_formula :
if {$1==0} f "eps=.0000000000001;img=i#0;vp=$4==1?i#1/$2:$3;mv=($2*vp)+eps;f=img-mv*floor(img/mv);f>$2*vp?$2*vp:f"
elif {$1==1} f "eps=.0000000000001;img=i#0;vp=$4==1?i#1/$2:$3;mv=($2*vp)+eps;nf=img-mv*floor(img/mv);minm=$2*vp;e=ceil((i#0/minm))%2>0?$2:0;cinv=i#0>0?e:$2;cinv>0?nf:mv-nf"
elif {$1==2} f "eps=.0000000000001;img=i#0;vp=$4==1?i#1/$2:$3;ivp=1/vp;simg=ivp*img;maxm=$2+eps;f=simg-maxm*floor(simg/maxm)"
elif {$1==3} f "eps=.0000000000001;img=i#0;vp=$4==1?i#1/$2:$3;ivp=1/vp;simg=ivp*img;maxm=$2+eps;f=simg-maxm*floor(simg/maxm);minm=$2*vp;e=ceil((i#0/minm))%2>0?$2:0;cinv=i#0>0?e:$2;cinv>0?f:$2-f"
elif {$1==4} f "eps=.0000000000001;img=i#0;vp=$4==1?i#1/$2:$3;vpi=vp*$2;fimg=img+vpi;maxm=$2+eps;fimg-maxm*floor(fimg/maxm)"
elif {$1==5} f "eps=.0000000000001;img=i#0;vp=$4==1?i#1/$2:$3;vpi=vp*$2;fimg=img+vpi;maxm=$2+eps;f=fimg-maxm*floor(fimg/maxm);cinv=fimg>maxm?$2:0;cinv>0?maxm-f:f" fi
#@gui Drop Shadow : fx_drop_shadow, fx_drop_shadow(1)
#@gui : X-Shadow = float(3,-20,20)
#@gui : Y-Shadow = float(3,-20,20)
#@gui : Smoothness = float(1.8,0,5)
#@gui : Curvature = float(0,0,1)
#@gui : Corner Brightness = float(0,0,1)
#@gui : Angle = float(0,0,360)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/14/11</i>.</small>")
fx_drop_shadow :
* -1 + 255 vignette {255*$5},80,95 * -1 + 255
drop_shadow $1%,$2%,$3%,$4 rotate $6,1,0
#@gui Drop Shadow 3D : fx_drop_shadow3d, fx_drop_shadow3d_preview(1)
#@gui : X-Angle = float(0,-90,90)
#@gui : Y-Angle = float(0,-90,90)
#@gui : Z-Angle = float(0,-90,90)
#@gui : Zoom = float(0,-100,100)
#@gui : X-Offset = float(1,-50,50)
#@gui : Y-Offset = float(1,-50,50)
#@gui : Perspective = float(2,0,10)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Color = color(0,0,0,200)
#@gui : Preview Only Shadow = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/02/07</i>.</small>")
fx_drop_shadow3d :
repeat $! l[$<]
+_fx_drop_shadow3d $*
endl done
fx_drop_shadow3d_preview :
repeat $! l[$<]
if $13 _fx_drop_shadow3d $*
else +_fx_drop_shadow3d $* rv blend alpha
fi
endl done
_fx_drop_shadow3d :
point3d 0,0,1 r3d. 1,0,0,$1 r3d. 0,1,0,$2 r3d. 0,0,1,$3
u={i(0,8)} v={i(0,9)} w={i(0,10)} rm.
to_a channels 100% if {im==iM} return fi
+f 'X=x/w-0.5;Y=y/h-0.5;A=($7-$4*$7/100)*$w/(X*$u+Y*$v+$7*$w);if(A<0,1e8,A)'
+*. 'y/h-0.5' *.. 'x/w-0.5' +.. {0.5-$5/100} +. {0.5-$6/100} *.. {w} *. {h}
a[-2,-1] c warp[0] .,0,1,0 rm.
b $8% n 0,$12 i.. ($9^$10^$11) r.. .,.,1,3 a[-2,-1] c
#@gui Equalize Shadow : fx_equalize_shadow, fx_equalize_shadow_preview(1)
#@gui : Amplitude = float(1,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Francois Grassard</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/24/11</i>.</small>")
fx_equalize_shadow :
repeat $! l[$>] +negate blend softlight,$1 endl done
fx_equalize_shadow_preview :
gui_split_preview "fx_equalize_shadow $1",${-3--1}
#@gui Illuminate 2D Shape : fx_illuminate_shape2d,fx_illuminate_shape2d_preview(1)+
#@gui : note = note("<small><b>Input / Output:</b></small>)
#@gui : Input Type = choice{"Single Opaque Shapes Over Transp. BG","Multiple Colored Shapes Over Transp. BG","Bump Map","Normal Map"}
#@gui : Output Type = choice{"Illumination","Bump Map","Normal Map"}
#@gui : Input Guide Color = color(255,0,0,255)
#@gui : Keep Base Layer as Input Background = bool(1)
#@gui : Keep Transparency in Output = bool(1)
#@gui : sep = separator(), note = note("<small><b>Shape:</b></small>)
#@gui : Minimal Shape Area = int(4,1,100)
#@gui : note = note{"<small>Parameter <i>Minimal shape area</i> is only active in <i>Multiple colored shapes</i> input mode.</small>"}
#@gui : Preview Detected Shapes = bool(0)
#@gui : Erosion / Dilation = float(0,-10,10)
#@gui : Smoothness = float(3,0,6)
#@gui : Bump Factor = float(1,-5,5)
#@gui : Avg / Max Weight = float(1,0,1)
#@gui : Resolution = choice{4,"Full (Slower)","2048","1024","512","256","128","64 (Faster)"}
#@gui : sep = separator()
#@gui : note = note("<small><b>Illumination:</b></small>)
#@gui : Blending Mode = choice(10,"Normal","Lighten","Screen","Dodge","Add","Darken","Multiply","Burn","Overlay","Soft Light","Hard Light","Grain Merge")
#@gui : Opacity (%) = float(75,0,100)
#@gui : Ambient (%) = float(30,-100,100)
#@gui : Diffuse (%) = float(40,0,200)
#@gui : Specular (%) = float(40,0,300)
#@gui : Shininess = float(80,0,100)
#@gui : Smoothness = float(0.2,0,5)
#@gui : Flatness = float(1,0,3)
#@gui : Linearity = float(0,-100,100)
#@gui : Levels = int(0,0,16)
#@gui : Light-X = float(2,-20,20)
#@gui : Light-Y = float(-2,-20,20)
#@gui : Light-Z = float(2,0,20)
#@gui : Normalize Illumination = bool(0)
#@gui : sep = separator()
#@gui : Open Interactive Preview = button()
#@gui : Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note{"<small><b>Note:</b> This filter automatically adds illumination to an opaque shape defined over a transparent background.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/05/18</i>.</small>")
fx_illuminate_shape2d :
input_type,\
output_type,\
keep_input_bg,\
preview_shapes,\
blending_mode,\
opacity=$1,$2,$7,$10,$16,$17
blending_mode=${arg\ 1+$blending_mode,normal,lighten,screen,dodge,add,darken,multiply,burn,overlay,softlight,hardlight,grainmerge}
keep_input_bg&={$!>1}
if $output_type
repeat {$!-$keep_input_bg} _fx_illuminate_shape2d[$>] $* done
else
repeat {$!-$keep_input_bg} if $keep_input_bg sel=$>,-1 else sel=$> fi l[$sel]
if {!$keep_input_bg" && "$input_type>=2}
_fx_illuminate_shape2d $*
elif {$keep_input_bg" && "$input_type>=2}
_fx_illuminate_shape2d[0] $*
elif {!$keep_input_bg" && "$input_type<=1}
+_fx_illuminate_shape2d $* rv
else
_fx_illuminate_shape2d[0] $*
fi
if {!$preview_shapes" || "0$_is_preview!=1}
gui_set_layer_mode[0] $blending_mode
gui_set_layer_opacity[0] $opacity
if {$!>1" && "(0$_output_mode==0" || "0$_is_preview==1)}
if {$keep_input_bg" && "!0$_is_preview} . fi
gui_merge_layers[0,1]
else k[0] fi
fi
endl done
fi
fx_illuminate_shape2d_preview :
_is_preview=1
input_type,\
keep_input_bg,\
preview_interactive=$1,$7,$-2
keep_input_bg&={$!>1}
if $preview_interactive fx_illuminate_shape2d_preview_interactive $* fi
if $keep_input_bg
repeat {$!-1} l[$>,-1]
fx_illuminate_shape2d $*
rv to_colormode 0 a z
gui_split_preview "slices 50%,100%",$-1
endl done
else
gui_split_preview "fx_illuminate_shape2d $*",$-1
fi
fx_illuminate_shape2d_preview_interactive :
_output_mode=0
input_type,\
keep_input_bg=$1,$7
keep_input_bg&={$!>1}
repeat {$!-$keep_input_bg} if $keep_input_bg sel=$>,-1 else sel=$> fi +l[$sel]
to_rgba
+_fx_illuminate_shape2d[0] $1,2,${3-6},0,1,""$9,0,${11-15},""${16-29},""0,0
if {$!>2} rm[0] elif {$input_type>=2} sh[0] 0,2 f. 128 rm. fi
siz=${fitscreen\ {w},{h},1,256,640}
wsiz0=${fitscreen\ $siz,1,30%,100%}
wsiz=$wsiz0
r $siz,1,100%,3
s. c,-3 !=. 0 l.. - 128 / 127 s c,-2 / endl a[-2,-1] c
rv s. c,-3
(160,128;128,160) r. 16,16 r. ..,..,1,3,0,2
30,30,1,1 circle. 50%,50%,15%,1,1 b. 4 n. 0,1
100%,100%,1,3,[255,255,0]
nm normal,rgb,alpha,background,light_alpha,light_rgb
w[] $wsiz,0,0,{rgb,([{*,u},{*,v}]-[$wsiz])/2},"[G'MIC] Illuminate 2D Shape"
cursor 0
x0,y0,ox,oy,ob,olightz=-1
lightz=2 clicked=0
do
x,y,b,mw={rgb,[{*,x},{*,y}]*[w,h]/[{*,w},{*,h}]},{*,b},{*,-o}
lightz={cut($lightz-0.3*sign($mw)+($y0>=0?3*($y-$y0)/h),0.1,4)}
if {$x<0} x,y={rgb,ang=$|;(1+[cos(1.4*ang),sin(0.85*ang)])*[w,h]/2} fi
if {!$b" || "($b&1)}
if {$b" && "!$clicked} x0,y0=$x,$y
elif {!$b} x0,y0=-1
fi
lightx,lighty={rgb,3.5*(2*[$x/w,$y/h]-1)}
if {[$ox,$oy,$ob,$olightz]!=[$x,$y,$b,$lightz]}
+fx_illuminate_shape2d[normal,rgb] 4,0,${3-6},1,1,""$9,0,${11-15},""${16-25},$lightx,$lighty,$lightz,$29,""0,0
+j[background] .,0,0,0,0,1,[alpha],255 rm..
+r2dx[light_alpha,light_rgb] {light_rgb,8+$lightz*(w-8)} j... .,{[$x,$y]-[w,h]/2},0,0,1,.. rm[-2,-1]
r. $wsiz,1,100% to. "Light: ("{``{_round([$lightx,$lighty,$lightz],0.1)}}")",2,2,16
w.  rm. wait 20
else wait
fi
clicked=$b
elif {$b&2}
+j[background] [rgb],0,0,0,0,1,[alpha],255
+r2dx[light_alpha,light_rgb] {light_rgb,8+$lightz*(w-8)} j... .,{[$x,$y]-[w,h]/2},0,0,1,.. rm[-2,-1]
w. rm. wait
fi
if {{*,CTRLLEFT}&&{*,-D}} w[] {1.5*[{*,w},{*,h}]} wsiz={*,w},{*,h}
elif {{*,CTRLLEFT}&&{*,-C}} w[] {0.75*[{*,w},{*,h}]} wsiz={*,w},{*,h}
elif {{*,CTRLLEFT}&&{*,-R}} w[] $wsiz0
fi
ox,oy,ob=$x,$y,$b
while {{*}" && "!{*,ESC}" && "!{*,Q}}
w 0
rm endl done
_fx_illuminate_shape2d :
input_type,\
output_type,\
gR,gG,gB,gA,\
keep_input_bg,\
keep_output_transparency,\
min_shape_area,\
preview_shapes,\
dilation,\
shape_smoothness,\
bump_factor,\
weight_avg_max,\
resolution,\
blending_mode,\
opacity,\
ambient,\
diffuse,\
specular,\
shininess,\
light_smoothness,\
flatness,\
linearity,\
levels,\
lightx,\
lighty,\
lightz,\
normalize_illumination,\
preview_interactive,\
preview_mode=${1-31}
nm={n}
if {$input_type==0}
to_rgba
+channels. 100% >. 0 .
select_color... 0,$gR,$gG,$gB,$gA
mv... $! -[-2,-1]
elif {$input_type==1}
to_rgba
+channels. 100% >. 0 *[-2,-1]
if {$min_shape_area>1} +quantize_area. {$min_shape_area^2} fi
s. c,-{s-1} >. 0 rv[-2,-1]
if {s>1} f. "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm. round. 0.01 fi
label. 0,0 f. "j(1)!=i || j(0,1)!=i" thinning. 1 ==. 0 *. ..
select_color... 0,$gR,$gG,$gB,$gA
mv... $! -[-2,-1]
elif {$input_type==2}
to_a
s c,-{s-1} >. 0 *.. . rv s. c S={$!-1} +[^0] /. $S
elif {$input_type==3}
+channels 100% >. 0 *.. . rv
f. "I==vector4(0)?[128,128,255,255]:I"
channels. 0,2
else
+channels 100% rv
fi
if {0$_is_preview" && "$preview_shapes}
if {$input_type==3} k[0] else k. fi
+dilate. 3
label_fg.. 0 srand 0 {-2,iM+1},1,1,3,'x==0?[0,0,0]:x==1?[255,255,255]:u([255,255,255])' map... . rm.
*. 255 a c
return
fi
if {$input_type<=1} shape2bump. {arg($resolution,2048,1024,512,256,128,64)},$weight_avg_max,{$dilation%*max(w,h)},{$shape_smoothness*50} fi
if {$input_type<=2}
if {$input_type==2" && "$shape_smoothness} mM={[im,iM]} guided. ..,$shape_smoothness%,100 n. $mM fi
*. $bump_factor
fi
if {$output_type==1}
if {$input_type<=2}
if $keep_output_transparency k[-2,-1] n 0,255 rv a c
else k. n 0,255
fi
else
rm gui_error_preview "Cannot convert a normal map to a bump map." return
fi
elif {$output_type==2}
if {$input_type<=2} round 0.0001 bump2normal. f. "i(#-2)?I:[128,128,255]" fi
if $keep_output_transparency k[-2,-1] rv *. 255 a c
else k.
fi
else
if {$input_type<=2} g. xy a[-2,-1] c
elif {$input_type==3} -. 128 /. 127 s. c,-2 /[-2,-1]
fi
f. "*
begin(
const flatness = "$flatness";
const ka = "$ambient"%;
const kd = "$diffuse"%;
const ks = "$specular"%;
const alpha = "$shininess";
const m1 = max(1,"$lightz");
const mwh1 = max(w,h) - 1;
light = [ "m1*$lightx,m1*$lighty,-$lightz" ];
camera = [ 0,0,-"$lightz" ];
);
res = i#0?(
P = [ 2*x/mwh1 - 1,2*y/mwh1 - 1,0 ];
L = light - P;
L/=norm(L);
V = camera - P;
V/=norm(V);
N = -[ i0,i1,flatness ];
N/=norm(N);
R = 2*dot(N,L)*N - L;
res = ka + kd*dot(L,N) + ks*max(dot(R,V),0)^alpha;
):0;
[ res,0 ]"
channels. 0 *. 255 c. 0,255
if {$light_smoothness" || "$linearity}
mM={[im,iM]}
if $light_smoothness b. $light_smoothness% fi
if $linearity n. 0,1 ^. {10^-($linearity%)} fi
n. $mM
fi
if $levels quantize. $levels,1,1 fi
if $normalize_illumination n. 0,255 fi
rv[-2,-1] *. 255 a[-2,-1] c
nm $nm
if {!$keep_output_transparency} remove_opacity. fi
fi
nm $nm
#@gui Light Glow : fx_lightglow, fx_lightglow_preview(0)
#@gui : Density = float(30,0,100)
#@gui : Amplitude = float(0.5,0,2)
#@gui : Mode = choice(8,"Burn","Dodge","Freeze","Grain Merge","Hard Light","Interpolation","Lighten","Multiply","Overlay","Reflect","Soft Light","Stamp","Value")
#@gui : Opacity = float(0.8,0,1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/21/02</i>.</small>")
_fx_lightglow :
mode=${arg\ 1+$3,burn,dodge,freeze,grainmerge,hardlight,interpolation,lighten,multiply,overlay,reflect,softlight,stamp,value}
repeat $!
+gradient_norm. >=. {100-$1}% distance. 1 ^. $2 *. -1 n. 0,255 blend $mode,$4
mv. 0 done
fx_lightglow :
ac "_fx_lightglow ${1-4}",$5
fx_lightglow_preview :
gui_split_preview "fx_lightglow $*",${-3--1}
#@gui Light Leaks : fx_light_leaks, fx_light_leaks_preview(1)
#@gui : Leak Type = int(0,0,70)
#@gui : Angle = float(0,-180,180)
#@gui : X-Scale = float(1,1,10)
#@gui : Y-Scale = float(1,1,10)
#@gui : Hue = float(0,-180,180)
#@gui : Opacity = float(0.85,0,1)
#@gui : Blend Mode = choice(2,"Normal","Lighten","Screen","Dodge","Add","Darken","Multiply","Burn","Overlay","Soft Light","Hard Light","Difference","Subtract","Grain Extract","Grain Merge","Divide","Hue","Saturation","Value")
#@gui : Output as Separate Layers = _bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small>This filter uses the free light leaks dataset available at :</small>"}
#@gui : url = link{"Lomo Light Leaks","http://www.photoshoptutorials.ws/downloads/mockups-graphics/lomo-light-leaks/"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/01/07</i>.</small>")
fx_light_leaks :
filename=lightleak_${"padint $1",6}.cimgz
if ${_path_rc}$filename i ${_path_rc}$filename
else i https://gmic.eu/data_lightleaks/$filename o. ${_path_rc}$filename
fi
mode=${arg\ 1+$7,normal,lighten,screen,dodge,add,darken,multiply,burn,overlay,softlight,hardlight,difference,subtract,grainextract,grainmerge,divide,hue,saturation,value}
mv. 0
repeat {$!-1} l[0,{1+$<}]
+r[0] {1,w},{1,h},1,3,5
rotate. $2,1,1,50%,50%
if {$3>1" || "$4>1} f. 'w2=w/2;h2=h/2;X=x-w2;Y=y-h2;i(w2+X/$3,h2+Y/$4,0,c,1,0)' fi
c. 0,255
if $5 rgb2hsv. sh. 0 +. $5 rm. hsv2rgb. fi
if $8
nm=${gui_layer_name[1]}
nm. name($nm),opacity({$6*100}),mode($mode) rv[-2,-1]
else blend[1,-1] $mode,$6 fi
endl done
rm[0]
fx_light_leaks_preview :
gui_split_preview "fx_light_leaks ${1--5},0",${-3--1}
_fx_light_leaks :
u="" repeat 71 if {narg($u)} u=$u, fi u=${u}lightleak_${"padint "$>,6} done
u $u
#@gui Light Patch : fx_light_patch, fx_light_patch(0)
#@gui : Density = int(5,2,30)
#@gui : Darkness = float(0.7,0,1)
#@gui : Lightness = float(2.5,1,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_light_patch :
repeat $! l[$>] split_opacity l[0]
ac "light_patch $1,$2,$3",$4
endl a c endl done
#@gui Light Rays : fx_lightrays, fx_lightrays(1)
#@gui : Density = float(80,0,100)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Length = float(1,0,1)
#@gui : Attenuation = float(0.5,0,1)
#@gui : Transparency = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/03/01</i>.</small>")
fx_lightrays :
lightrays $1,$2%,$3%,$4,$5
if $6 repeat $! r[$>] 100%,100%,1,{{$>,s}+({$>,s}%2)} done fi
#@gui Pop Shadows : fx_pop_shadows, fx_pop_shadows_preview(1)
#@gui : Strength = float(0.75,0,1)
#@gui : Scale = float(5,0,20)
#@gui : Post-Normalize = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Morgan Hardwood</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/03/05</i>.</small>")
fx_pop_shadows :
repeat $! l[$>] split_opacity l[0]
.x2
luminance.. negate.. imM={-2,[im,iM]} b.. $2% n.. $imM
blend[0,1] overlay,$1
max
if $3 n 0,255 fi
endl a c endl done
fx_pop_shadows_preview :
gui_split_preview "fx_pop_shadows $*",${-3--1}
#@gui Relief Light : fx_light_relief, fx_light_relief(1)
#@gui : Ambient Lightness = float(0.3,0,5)
#@gui : Specular Lightness = float(0.2,0,2)
#@gui : Specular Size = float(0.2,0,1)
#@gui : Darkness = float(0,0,1)
#@gui : Light Smoothness = float(1,0,5)
#@gui : XY-Light = point(50,50,0,1,255,255,128,200,10)
#@gui : Z-Light = float(5,0,20)
#@gui : Z-Scale = float(0.5,0,3)
#@gui : Opacity as Heightmap = bool(0)
#@gui : Image Smoothness = float(0,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_light_relief :
b $11% light_relief ${1-5},{[$6,$7]%},${8-10}
#@gui Shadow Patch : fx_shadow_patch, fx_shadow_patch(1)
#@gui : Opacity = float(0.7,0,1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_shadow_patch :
repeat $! l[$>] split_opacity l[0]
ac "shadow_patch $1",$2
endl a c endl done
#@gui Slice Luminosity : fx_slice_luminosity, fx_slice_luminosity_preview
#@gui : Luminosity Type = choice(1,"Average RGB","Luminance","Lightness","Value")
#@gui : Output As = _choice(1,"Mask","Masked Image")
#@gui : Preview Type = choice(2,"Mask","Mask + Background","Image","Image + Background")
#@gui : sep = separator(), note = note{"<small><b>Slice 1</b> (shadows):</small>"}
#@gui : Activate Slice 1 = bool(1)
#@gui : Starting Value = int(0,0,255)
#@gui : Ending Value = int(64,0,255)
#@gui : Starting Feathering = int(0,0,255)
#@gui : Ending Feathering = int(0,0,255)
#@gui : sep = separator(), note = note{"<small><b>Slice 2</b> (low midtones):</small>"}
#@gui : Activate Slice 2 = bool(1)
#@gui : Starting Value = int(64,0,255)
#@gui : Ending Value = int(128,0,255)
#@gui : Starting Feathering = int(0,0,255)
#@gui : Ending Feathering = int(0,0,255)
#@gui : sep = separator(), note = note{"<small><b>Slice 3</b> (high midtones):</small>"}
#@gui : Activate Slice 3 = bool()
#@gui : Starting Value = int(128,0,255)
#@gui : Ending Value = int(192,0,255)
#@gui : Starting Feathering = int(0,0,255)
#@gui : Ending Feathering = int(0,0,255)
#@gui : sep = separator(), note = note{"<small><b>Slice 4</b> (highlights):</small>"}
#@gui : Activate Slice 4 = bool()
#@gui : Starting Value = int(192,0,255)
#@gui : Ending Value = int(255,0,255)
#@gui : Starting Feathering = float(0,0,255)
#@gui : Ending Feathering = float(0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/22/09</i>.</small>")
fx_slice_luminosity :
remove_opacity repeat $! l[$<] to_rgb
_fx_slice_luminosity $*
if $2 i[0] [0] a[-2,-1] c fi
rv
endl done
fx_slice_luminosity_preview :
remove_opacity  repeat $! l[$>] to_rgb
_fx_slice_luminosity $*
if {$3==0} rm[0] channels {s-1}
elif {$3==1} 100%,100%,1,1,128 a[0,-1] c r. 100%,100%,1,4 blend alpha
elif {$3==2} a c
else +. 96 c. 0,255 a c
fi
endl done
_fx_slice_luminosity :
if {$1==0} +compose_channels + /. 3
elif {$1==1} +luminance
elif {$1==2} +srgb2lab8. channels. 0
else +compose_channels max
fi
if $4 +apply_curve[1] 0,{$5-$7-0.1},0,$5,255,$6,255,{$6+$8+0.1},0,512,0 fi
if $9 +apply_curve[1] 0,{$10-$12-0.1},0,$10,255,$9,255,{$11+$13+0.1},0,512,0 fi
if $14 +apply_curve[1] 0,{$15-$17-0.1},0,$15,255,$16,255,{$16+$18+0.1},0,512,0 fi
if $19 +apply_curve[1] 0,{$20-$22-0.1},0,$20,255,$21,255,{$21+$23+0.1},0,512,0 fi
rm[1] max[^0]
#@gui _
#@gui <b>Patterns</b>
#@gui Bayer Filter : rgb2bayer, rgb2bayer(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : Keep Colors = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Box Fitting : fx_boxfitting, fx_boxfitting_preview(0)
#@gui : Minimal Size = int(3,1,32)
#@gui : Maximal Size = int(0,0,32)
#@gui : note = note("<small><b>Note:</b> Set <i>Maximal size</i> to <i>0</i> to allow any size for the squares.</small>")
#@gui : Initial Density = float(0.1,0,1)
#@gui : Transparency = bool(0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> This filter has been highly inspired by the work of Jared Tarbell, described on the page:</small>")
#@gui : url = link("http://www.complexification.net/gallery/machines/boxFittingImg/")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/06/06</i>.</small>")
fx_boxfitting :
boxfitting ${1-3},3
if $4 to_rgba replace_color 0,0,0,0,0,255,0,0,0,0 fi
fx_boxfitting_preview :
boxfitting ${1-3},1
if $4 to_rgba replace_color 0,0,0,0,0,255,0,0,0,0 fi
#@gui Camouflage : fx_camouflage, fx_camouflage
#@gui : Scale = int(9,2,12)
#@gui : Levels = int(12,2,32)
#@gui : Coherence = float(100,0,1000)
#@gui : Color 1 = color(30,46,33)
#@gui : Color 2 = color(75,90,65)
#@gui : Color 3 = color(179,189,117)
#@gui : Color 4 = color(255,246,158)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/26/10</i>.</small>")
fx_camouflage :
repeat $! l[$>] split_opacity l[0]
channels 0 r {w+16},{h+16},1,1,0 rand 0,16
amp=$3 do smooth {min(50,$amp)},0,1 amp-=50 while {$amp>0}
shrink_xy. 8 n 1,$2 round
repeat $1 +area 0,0 <. {1+2^$>} inpaint[0] [1],0,3 rm. done
+colormap 0 n.. 0,{w-1}
4,1,1,3,"col=[${4-15}];col[3*x,3]"
r. ..,..,1,3,3 rm.. map.. . rm.
endl a c endl done
#@gui Canvas : fx_canvas, fx_canvas_preview(0)
#@gui : note = note{"<b>First direction :</b>"}
#@gui : Amplitude = float(70,0,300)
#@gui : Angle = float(45,0,180)
#@gui : Sharpness = float(400,0,2000)
#@gui : note = note{"\n<b>Second direction : </b>"}
#@gui : Activate Second Direction = bool(true)
#@gui : Amplitude = float(70,0,300)
#@gui : Angle = float(135,0,180)
#@gui : Sharpness = float(400,0,2000)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_canvas :
repeat $! l.
if $4
({cos($2*pi/180)}^{sin($2*pi/180)}) vector2tensor. r. ..,.. +smooth.. .,$1 rm.. sharpen. $3 c. 0,255
({cos($6*pi/180)}^{sin($6*pi/180)}) vector2tensor. r. ..,.. smooth... .,$5 rm. sharpen.. $7 c.. 0,255 +[-2,-1] /. 2
else
({cos($2*pi/180)}^{sin($2*pi/180)}) vector2tensor. r. ..,.. smooth.. .,$1 rm. sharpen. $3 c. 0,255
fi
endl mv. 0 done
fx_canvas_preview :
gui_split_preview "fx_canvas $*",${-3--1}
#@gui Canvas Texture : texturize_canvas, texturize_canvas(0)
#@gui : Amplitude = float(20,0,256)
#@gui : Fibrousness = float(3,0,20)
#@gui : Emboss = float(0.6,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Clouds : jeje_clouds, jeje_clouds_preview
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(.5,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_clouds :
--clouds $1%,1,$2 -blend alpha
jeje_clouds_preview :
-jeje_clouds $1,$2
#@gui Cracks : fx_cracks, fx_cracks_preview(0)
#@gui : Density (%) = float(30,0,100)
#@gui : Relief = bool(true)
#@gui : Color = color(255,255,255,128)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/07</i>.</small>")
fx_cracks :
ac "cracks $1,$2,{$6/255},${3-5},255",$7
fx_cracks_preview :
gui_split_preview "fx_cracks $*",${-3--1}
#@gui Crystal : fx_crystal, fx_crystal_preview(0)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(0.2,0,2)
#@gui : Edges = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/19/01</i>.</small>")
fx_crystal :
repeat $! l[$>] split_opacity l[0]
s={s}
+gradient_norm >=. {(100-$3)/5} remove_pixels. {100-max(0.1,$1*$3%)}%,{is} *
+norm !=. 0 a c
sigma=0.2
do
+b. $sigma sigma*={(1+$2)}
sh[0,-1] $s max. .. rm[-2,-1]
f. 'W=i(x,y,z,$s);if(W<0.001||W>=1,0,if(c<$s,i/W,1))'
if {!iM} rm[1] break fi
sh. $s
j[0] [1],0,0,0,0,1,[2] k[0]
while 1
channels 0,{$s-1}
endl a c endl done
fx_crystal_preview :
gui_split_preview "fx_crystal $*",${-3--1}
#@gui Crystal Background : fx_crystal_background, fx_crystal_background
#@gui : Iterations = int(10,1,32)
#@gui : Density (%) = float(25,0,100)
#@gui : Random Seed = int(0,0,65535)
#@gui : Opacity (%) = float(100,0,100)
#@gui : Color = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/18/10</i>.</small>")
fx_crystal_background :
repeat $! l[$>] split_opacity l[0]
N={2*max(3,round((${"is_percent $2"}?4*wh*$2:$2)))}
if $5 col="u([255,255,255])" else col="u(255)" fi
srand $3 M={max(w,h)} 2,$N
repeat $1 rand. {-$M/2},{3*$M/2} polygon.. $N,{^},{-$4%},{$col} done
rm. n 0,255
endl a c endl done
#@gui Denim : Denim_samj_en, Denim_samj_en(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Texture</small></span>")
#@gui : Dimension A = int(5,2,30)
#@gui : Dilate = int(2,0,5)
#@gui : Flip The Pattern = bool(0)
#@gui : Noise A = int(40,0,200)
#@gui : Noise B = int(40,0,200)
#@gui : Noise C = int(25,0,100)
#@gui : Noise D = int(50,0,100)
#@gui : Sharpness = float(0,0,500)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Color</small></span>")
#@gui : Denim = color(43,108,126,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/31</i>.</small>")
Denim_samj_en :
-Denim_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
#@gui Fibers : jeje_fibers, jeje_fibers_preview
#@gui : Number = int(10,1,100)
#@gui : Length = int(50,1,100)
#@gui : Smoothness = float(10,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/07/17</i>.</small>")
jeje_fibers :
100%,100%,1,1,0
-l[-1]
-fibers $1,$2%,$3
-gt 0
-n 0,255
-endl
-r[-1] [0]
-max
jeje_fibers_preview :
-gui_split_preview "-jeje_fibers $1,$2,$3",$-1
#@gui Freqy Pattern : jeje_freqy_pattern, jeje_freqy_pattern_preview
#@gui : Random = float(50,0,100)
#@gui : Scale 1 = float(33,1,100)
#@gui : Scale 2 = float(50,1,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/09/25</i>.</small>")
jeje_freqy_pattern:
noise {$1*4}
freqy_pattern {50/$2}%,{$3*2} n 0,255
jeje_freqy_pattern_preview:
gui_split_preview "jeje_freqy_pattern $1,$2,$3",$4
#@gui Halftone : fx_halftone, fx_halftone_preview(0)
#@gui : note = note("<b><small>Image parameters :</small></b>")
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Smoothness = float(0,0,10)
#@gui : sep = separator(), note = note("<b><small>Halftone parameters :</small></b>")
#@gui : Number of Tones = int(5,2,32)
#@gui : Size for Dark Tones = int(8,2,256)
#@gui : Size for Bright Tones = int(8,2,256)
#@gui : Shape = choice{5,"Square","Diamond","Circle","Square (Inv.)","Diamond (Inv.)","Circle (Inv.)"}
#@gui : Smoothness = float(0.1,0,32)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/23/07</i>.</small>")
fx_halftone :
adjust_colors ${1-3},0,0,0,255 b $4
repeat $! l[$>] split_opacity
halftone[0] ${5-9}
a c endl done
fx_halftone_preview :
gui_split_preview "fx_halftone $*",${-3--1}
#@gui Halftone Shapes : iain_halftone_shapes, iain_halftone_shapes(0)
#@gui : Scale = float(100,10,200)
#@gui : Negative =bool(0)
#@gui : Shape = choice("Circle","Star","Triangle","Heart")
#@gui : Oversample = bool(0)
#@gui : Rotate = float(0,0,180)
#@gui : Twirl = float(0,0,2)
#@gui : sep = separator()
#@gui : note = note("Oversample gives smoother results but takes much longer.")
#@gui : note = note("Twirl distorts the hafltone grid. The preview is not accurate. For best results use with oversample.")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
iain_halftone_shapes:
-remove_opacity
scale=$1
-luminance
-if {$4==1}
-resize 400%,400%,1,1,3
scale={$scale*4}
-endif
-if {$3==0}
sx1=353
sx2=515
sx3=677
sx4=1000
sx5=1323
sx6=1485
sx7=1647
sx8=1485
sx9=1323
sx10=1000
sx11=677
sx12=515
sy1=1000
sy2=1280
sy3=1560
sy4=1560
sy5=1560
sy6=1280
sy7=1000
sy8=720
sy9=440
sy10=440
sy11=440
sy12=720
level=19
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 19
-polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level
sy3={$sy3-(78/16)}
sy5={$sy5-(78/16)}
sy9={$sy9+(78/16)}
sy11={$sy11+(78/16)}
sx1={$sx1+(90/16)}
sx3={$sx3+(45/16)}
sx5={$sx5-(45/16)}
sx7={$sx7-(90/16)}
sx9={$sx9-(45/16)}
sx11={$sx11+(45/16)}
level={$level+10}
-done
radius={560}
level=209
-repeat 57
-circle 50%,50%,$radius,1,$level
radius={$radius-10}
level={$level+10}
-done
-n 0,255
--shift[0] 972,560,0,0
--shift[0] 972,-560,0,0
--shift[0] -972,560,0,0
--shift[0] -972,-560,0,0
-add
-crop 29,440,1972,1560
-endl
-resize[1] 194,112,1,1,2
-equalize[1] 65555
-resize[1] $scale%,$scale%,1,1,3
-if {$2==1}
-negate[1]
-endif
-endif
-if {$3==1}
sx1=50
sx2=194
sx3=281
sx4=511
sx5=742
sx6=829
sx7=972
sx8=829
sx9=742
sx10=511
sx11=281
sx12=192
sy1=450
sy2=633
sy3=849
sy4=817
sy5=849
sy6=633
sy7=450
sy8=267
sy9=50
sy10=83
sy11=50
sy12=267
level=10
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 128
-polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level
sx2={$sx2+(40/16)}
sx6={$sx6-(40/16)}
sx8={$sx8-(40/16)}
sx12={$sx12+(40/16)}
sy2={$sy2-(23/16)}
sy4={$sy4-(47/16)}
sy6={$sy6-(23/16)}
sy8={$sy8+(23/16)}
sy10={$sy10+(47/16)}
sy12={$sy12+(23/16)}
level={$level+12}
-done
-n 0,255
-resize 200,200,1,1,3
--shift[0] -69,-40,0,0
--shift[0] -69,40,0,0
--shift[0] 69,-40,0,0
--shift[0] 69,40,0,0
-add
-crop 5,5,142,84
-endl
-resize[1] 194,112,1,1,2
-equalize[1] 65555
-resize[1] $scale%,$scale%,1,1,3
-if {$2==1}
-negate[1]
-endif
-endif
-if {$3==2}
sx1=161
sx2=1000
sx3=1839
sy1=273
sy2=1727
sy3=273
level=10
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 375
-polygon 3,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,1,$level
sx1={$sx1+2.21}
sx3={$sx3-2.21}
sy1={$sy1+1.28}
sy2={$sy2-2.56}
sy3={$sy3+1.28}
level={$level+1}
-done
--rotate[0] 180
--shift[1] {840+2}
-shift[1] -840
-add
-crop 160,{216+56},1842,1727
-n 0,255
-endl
-equalize[1] 256
-resize[1] 168,145,1,1,2
-resize[1] $scale%,$scale%,1,1,3
-if {$2==1}
-negate[1]
-endif
-endif
-if {$3==3}
-luminance
--l
-rm
-l
190,190,1,1,0
-circle 50,50,50,1,10
-circle 140,50,50,1,10
-polygon 5,10,80,50,50,140,50,180,80,95,190,1,10
-resize[-1] {0,w+2},{0,h+2},1,1,0,0,0.5,0.5
--resize[0] 95%,95%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 90%,90%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 85%,85%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 75%,75%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 65%,65%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 55%,55%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 50%,50%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 45%,45%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 40%,40%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 35%,35%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 30%,30%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 25%,25%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 20%,20%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 15%,15%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 10%,10%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 5%,5%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
-add
-endl
[0]
-append y
-resize 200%,100%,1,1,0,0,0.5,0.5
--shift[0] 160,100,0,0
--shift[0] -160,100,0,0
-add
-crop 30,190,350,100%
-n 0,255
-endl
-resize[-1] $scale,$scale,1,1,2
-if {$2==1}
-negate[1]
-endif
-endif
width={w}
height={h}
w_tiles={round({0,w}/$width)}
h_tiles={round({0,h}/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
-append_tiles[1--1] $w_tiles,$h_tiles
-equalize[-1] 256
-rotate[-1] $5,1,2,50%,50%
-twirl[-1] $6,.5,.5,2
-blend alpha,0.5,1
-gt 128
-mul 255
-if {$4==1}
-resize 25%,25%,1,1,3
-endif
#@gui Hearts : fx_hearts, fx_hearts_preview(0)
#@gui : Density = float(2,0,30)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_hearts :
ac "hearts $1",$2
fx_hearts_preview :
gui_split_preview "fx_hearts $*",${-3--1}
#@gui Hedcut (Experimental) : hedcut, gtutor_hedcut_preview(0)
#@gui : note = note("<b>Photometric:</b>")
#@gui : Contrast = float(0.5,0,1)
#@gui : Luminance Level = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Pattern:</b>")
#@gui : Smoothing = float(0.5,0,1)
#@gui : Size = float(0.0,0,1)
#@gui : Step = float(0.5,0,1)
#@gui : note = note("<b>Choice:</b>")
#@gui : Quality =  bool(0)
#@gui : Force Gray = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Garry R. Osgood</i>. Latest update: <i>2015/03/05</i>.</small>")
#@gui : url = link("Hedcut instructions and tutorial","http://gmic.eu/tutorial/hedcut-filter.shtml")
gtutor_hedcut_preview :
-gui_split_preview "-hedcut ${^0}",$-1
#@cli hedcut : _contrast=0.5, _lumlevel=0.5, _patsmooth=0.5, _patsize=0.0, _patstep=0.5, _patquality=0 (low=0,high=1), _forcegray=1 (no=0,yes=1)
#@cli : Make a hedcut with a faux intaglio etch pattern. Unless noted, all
#@cli : arguments are floats that range from 0.0 to 1.0. contrast: larger
#@cli : values increase contrast. lumlevel: larger values increases
#@cli : brightness. patsmooth: larger values forces pattern to follow
#@cli : geometry; lower induces turbulence. patsize: larger values increases
#@cli : pattern size. patstep: values alter pattern geometry. Adjust to
#@cli : taste. patquality: Boolean flag. 1=True/On/Yes. Renders oversize for
#@cli : quality.  Longer rendering time and more memory will be required (2
#@cli : GiB minimum for 3000x3000).  forcegray: Boolean
#@cli : flag. 1=True/On/Yes. RGB input will be forced to single channel
#@cli : grayscale before processing and returned to RGB after. Output: image
#@cli : in 0-255 range. Channels match input.
hedcut : -check "${1=0.5}<=1 && $1>=0 && ${2=0.5}<=1 && $2>=0 && ${3=0.5}<=1 && $3>=0 && ${4=0.0}<=1 && $4>=0 && ${5=0.5}<=1 && $5>=0 && isbool(${6=0}) && isbool(${7=1})"
-echo[^-1] "Applying faux intaglio etch to selected images. Contrast: "{$1}". Lumenance Level: "$2". Pattern smoothing: "$3". Pattern size: "$4". Pattern stepping: "$5". Quality (low=0,1=high): "$6". Force gray (0=no,1=yes):"$7"."
-verbose -
con={(9.0^$1)}
llv={round(20000*(0.5-$2))/100}
smt={(round((100*(10^$3)/2))/100)+4*$4}
psz={0.0001*(1+99*(1-$4))}
del={$psz+round(1000*(10^(-$4-2)))/1000}
stp={round(2+10*$5)}
qfc={$6}
gry={$7}
tol=30
spn=0
-repeat $!
-local[$>]
-remove_opacity[-1]
-if {$gry}
-luminance[-1]
-endif
-split[-1] c
-repeat $!
-local[$>]
-if $qfc
--resize2dx[-1] 400%,5
-else
[-1]
-endif
spn={(iM-im)/2}
-mv[-1] 0
-_multigrad[-1] $stp,$tol,$smt
-bandpass[-1] {$psz},{$del}
-orientation[-1]
-if $qfc
-resize[-1] [-2],[-2],[-1],[-1],5,1
-blur[-1] {$con},1,1
-else
-blur[-1] {$con/4},1,1
-endif
-normalize[-2,-1] {-$spn},{$spn}
-add[-1] [-2]
-normalize[-1] -{(iM-im)/2},{(iM-im)/2}
-rm[-2]
-threshold[-1] {$llv}
-if $qfc
-resize2dx[-1] 25%,5
-endif
-normalize[-1] 0,255
-endlocal
-done
-append c
-if {$gry}
-to_rgb
-endif
-endlocal
-done
-verbose +
#@cli _multigrad : _stepsize=5 _tolerance=10 _smooth=5
_multigrad : -skip ${1=50},${2=10},${3=5}
smt={$3}
stp={$1}
tol={$2}
-repeat $!
-local[$>]
-blur {$smt}
-normalize_local 3,32,4%,2%,1,0,255
-gradient_norm[-1]
ld={log(iM)}
-add[-1] 1e-10
-log[-1]
-div[-1] {$ld}
-cut[-1] 0,1
--ge[-1] $tol%
-if {round($smt)}
-erode_circ[-1] {round(1.5*$smt)}
-dilate_circ[-1] {round(1.5*$smt)}
-endif
-negate[-2]
-normalize[-2] 0,1
--distance[-1] 1,[-2],0
-rm[-3]
-round[-1] 2
-mod[-1] {1+$stp}
-threshold 90%
-add[-2,-1]
-mul[-1] -1
-add[-1] 1
-endlocal
-done
#@cli tiletex : _texscale=8 autoangle=-1 _keepimag=0
#@cli : Renders a tilable texture on selected images, taking polar formatted
#@cli : (magnitude, phase angle) seed values from pairs of selected,
#@cli : alternating "Magnitude" and "Angle" images or, if these are constant
#@cli : black, then from internally generated random values. Unless
#@cli : 'autoangle' is positive, input images must form "Magnitude" and
#@cli : "Angle" pairs and each pair must have an equal number of
#@cli : channels. Produces "real" and "imaginary" output images (But note
#@cli : _keepimag, below). 'texscale' sets the size of a square window around
#@cli : the spectral origin where random seeds are set. Larger 'texscales'
#@cli : settings admit higher frequency coefficients, giving rise to finer
#@cli : output details. 'texscale' ranges from 1 upward and defaults to 8. It
#@cli : is ignored if the user has preset coefficients within the input
#@cli : images. Setting 'autoangle' to a positive value in the range [0, 255]
#@cli : eliminates the need for providing "Angle" input images. The provided
#@cli : argument is applied as a default phase angle to all "Magnitude" data
#@cli : and input images are taken to be "Magnitude" data only. 'keepimag' is
#@cli : a trivalued flag: 0, 1 or 2. '0' requests both "Real" and "Imaginary"
#@cli : output pairs and is the default. '1' requests the "Real" output image
#@cli : only; '2' requests the "Imaginary" output image only.
#@cli : Output images are unnormalized and range from negative to positive
#@cli : values, Normalize data accordingly for use with bitmap editors.
tiletex : -check "${1=8}>0 && isval(${2=-1.0}) && ${3=0}>=0 && ${3}<3"
-verbose -
-if {$2>=0}
addenda2="Common default angle: $2."
-else
addenda2="Explicit angles from provided images."
-endif
addenda3="Real and imaginary"
-if {$3!=0}
-if {$3==1}
addenda3="Real"
-else
addenda3="Imaginary"
-endif
-endif
-verbose +
-echo[^-1] "Rendering tilable texture on $? at window size $1 "$addenda2". "$addenda3" output to be provided."
-verbose -
rsz={$1}
impla={2*pi*$2/255.0}
all={$3}
iszed=1
ccc={0,s}
badccc="Selected images have different number of channels. Have you accidently included alpha channels in some (but not all) images?"
-repeat $!
-if {$>,round(ia)!=0" || "round(iM-im)!=0}
iszed=0
-break
-endif
-done
-if $iszed
-repeat $!
-local[$<]
-if {$<,$ccc!=s}
-error $badccc
-endif
-input [-1]
-append[-2,-1] c
-input {2*$rsz+1},{2*$rsz+1},1,{s},(2*u-1)*{wh}
-image[-2] [-1],{({-2,w}-w)/2},{({-2,h}-h)/2},0,0,1
-remove[-1]
-endlocal
-done
-else
-if {$impla<0}
-if {$!%2!=0}
-error "Selected images contain data, but selection count is odd. Cannot determine angles for some coefficients. Consider setting an implied angle or providing an even number of images."
-endif
-repeat {$!/2}
-local[{2*$<},{2*$<+1}]
-if {$ccc!={$<,s}" || "$ccc!={{$<+1},s}}
-error $badccc
-endif
-split[-2,-1] c
-repeat {$!/2}
-local[{$>},{$!/2+$>}]
-div[0,1] 255
-mul[1] {2*pi}
-polar2complex[0,1]
-endlocal
-done
-append[0--1] c
-endlocal
-done
-else
-repeat $!
-local[$<]
-if {$ccc!={$<,s}}
-error $badccc
-endif
-input [0]
-split[-2,-1] c
-repeat {$!/2}
-local[{$>},{$!/2+$>}]
-div[0,1] 255
-mul[0] {cos($impla)}
-mul[1] {sin($impla)}
-endlocal
-done
-append[0--1] c
-endlocal
-done
-endif
-endif
-repeat $!
-local[$<]
-shift[-1] {-round(w/2)},{-round(h/2)},0,0,2
-split[-1] c,2
-ifft[-2,-1]
-if {$all!=0}
-if {$all==1}
-remove[-1]
-else
-remove[-2]
-endif
-endif
-endlocal
-done
-verbose +
#@gui Lava : fx_lava, fx_lava_preview(0)
#@gui : Perturbation = int(8,0,15)
#@gui : Smoothness = float(5,0,100)
#@gui : Scale = float(3,0,20)
#@gui : Sharpness = float(0,0,1000)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/26/11</i>.</small>")
fx_lava :
repeat $! l[$>] split_opacity l[0] norm
100%,100% plasma. 1,1,{16-$1} smooth. $2,0,1,$3,$3,0.8,90 *
gradient_norm n 0,255
equalize map 3
sharpen $4
endl a c endl done
fx_lava_preview :
gui_split_preview "fx_lava $*",${-3--1}
#@gui Marble : fx_marble, fx_marble
#@gui : Image Weight = float(.5,0,30)
#@gui : Pattern Weight = float(1,0,30)
#@gui : Pattern Angle = float(0,0,360)
#@gui : Amplitude = float(0,0,1000)
#@gui : Sharpness = float(.4,0,5)
#@gui : Anisotropy = float(.6,0,1)
#@gui : Alpha = float(.6,0,20)
#@gui : Sigma = float(1.1,0,20)
#@gui : Cut Low = float(0,0,100)
#@gui : Cut High = float(100,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_marble :
repeat $! l[$>] split_opacity l[0]
marble $1/10,$2/10,$3,$4,$5,$6,$7,$8,$9%,$10%
endl a c endl done
#@gui Maze : fx_maze, fx_maze
#@gui : Cell Size = int(24,1,256)
#@gui : Thickness = int(1,1,10)
#@gui : Masking = choice("None","Render on Dark Areas","Render on White Areas")
#@gui : Preserve Image Dimension = bool(1)
#@gui : Maze Type = choice("Dark Walls","White Walls")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/02/09</i>.</small>")
fx_maze :
repeat $! l[$>]
w={w} h={h}
r. {100/$1}%,{100/$1}%,1,100%,2
if {$3==0} f. 1
elif {$3==1} negate.
fi
maze_mask. $1 dilate. $2 *. 255
if {!$5} negate. fi
if $4 r. $w,$h,100%,100% fi
endl done
#@gui Mineral Mosaic : fx_mineral_mosaic,fx_mineral_mosaic(0)
#@gui : Density = float(1,0,3)
#@gui : Area = float(2,0,32)
#@gui : Smoothness = float(1,0,10)
#@gui : Shade Strength = float(100,0,255)
#@gui : Shade Angle = float(0,0,360)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/01/02</i>.</small>")
fx_mineral_mosaic :
repeat $! l[$>] to_rgb
+b $3 segment_watershed. $1 +norm.
area. 0 +<=. {$2^2} inpaint.. . rm. label.
+f[0] 'if(c==0,x,y)' rv[-2,-1] +blend[-2,-1] shapeaverage,1,1
-[-3,-1] rm[0,-2] channels. 0,1
alpha={$5*pi/180} sh. 0 *. {cos($alpha)} rm. sh. 1 *. {sin($alpha)} rm. compose_channels. +
normalize_local. 1000 n. -$4,$4
+ c 0,255
endl done
#@gui Mosaic : fx_mosaic, fx_mosaic_preview(0)
#@gui : Density (%) = float(50,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/19/07</i>.</small>")
fx_mosaic :
ac "repeat $! l[$>] split_opacity mosaic[0] $1 a c endl done",$2
fx_mosaic_preview :
gui_split_preview "fx_mosaic $*",${-3--1}
#@gui Op Art : fx_shapes,fx_shapes_preview(0)
#@gui : Shape = choice{1,"Custom Layers","Circles","Squares","Diamonds","Triangles","Horizontal Stripes","Vertical Stripes","Balls","Hearts","Stars","Arrows","Truchet",
#@gui : "Circles (Outline)","Squares (Outline)","Diamonds (Outline)","Triangles (Outline)","Hearts (Outline)","Stars (Outline)","Arrows (Outline)"}
#@gui : Number of Scales = int(16,2,24)
#@gui : Resolution = float(10,1,50)
#@gui : Zoom Factor = _int(2,1,8)
#@gui : Minimal Size = float(5,0,150)
#@gui : Maximal Size = float(90,0,150)
#@gui : Stencil Type = choice(0,"Black &amp; White","RGB","Color")
#@gui : Allow Angle = choice("0 deg.","90 deg.","180 deg.")
#@gui : Negative = bool(1)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : If you set the parameter <i>Shape</i> to <i>Custom layers</i>, the different shapes used to map the pixel intensities will be defined as
#@gui : the <i>Number of scales</i> top layers of your image. Don't forget to set also <i>Input layers</i> to <i>All</i> to be sure
#@gui : these layers are passed to the filter.
#@gui : </small>"}
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/16/12</i>.</small>")
fx_shapes :
if $1
remove_opacity repeat $! l[$>]
if {!$7} _fx_shapes $* * 255
elif {$7==1} split_opacity to_rgb[0] s[0] c repeat 3 _fx_shapes[$>] $* done *[0-2] 255 a[0-2] c a c
else +_fx_shapes $* r[0] $3%,$3% r[0] [1],[1] *
fi
endl done
else
if {$!<=$2} error[] "Command '$0': Some layers are missing in 'Custom layers' mode ("{$2+1}" expected at least, "$!" provided)." fi
to_colormode[0-{$2-1}] ${max_s[0-{$2-1}]} remove_opacity[$2--1]
repeat {$!-$2} l[0-{$2-1},{$2+$>}]
norm. w={w} h={h} r. $3%,$3%,1,1,2
s={$4*max(round($w/w),round($h/h))}
r0={$s*$5%} r1={$s*$6%}
repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} if $r +r[$>] $r,$r,1,100%,3 else 1,1 fi done
r[-$2--1] $s,$s,1,100%,0,0,0.5,0.5
map_sprites[$2--1] $2,$8
endl done rm[0-{$2-1}]
fi
fx_shapes_preview :
if $1 repeat $! l[$>]
w={w} h={h}
gui_split_preview "fx_shapes ${1-3},1,${5--2}",$-1
r $w,$h,1,100%,0,0,0.5,0.5
endl done
else
if {$!>$2} repeat {$!-$2} l[0-{$2-1},{$2+$>}]
w={w} h={h}
+fx_shapes ${1-3},1,${5--2} rm..
r. $w,$h,1,100%,0,0,0.5,0.5
endl done rm[0-{$2-1}]
else gui_warning_preview "Missing input layers!"
fi
fi
_fx_shapes :
norm w={w} h={h} r $3%,$3%,1,1,2
s={(1+$10)*$4*max(round($w/w),round($h/h))}
r0={$s*$5%} r1={$s*$6%}
repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} if $r _fx_shapes{$1-1}[] $r,$s else 1,1 fi done
r[-$2--1] $s,$s,1,1,0,0,0.5,0.5
if $9 rv[-$2--1] *[-$2--1] -1 +[-$2--1] 1 fi
map_sprites $2,$8
if $10 r 50%,50%,1,1,2 fi
_fx_shapes0 :
shape_circle $1
_fx_shapes1 :
$1,$1,1,1,1
_fx_shapes2 :
$1,$1,1,1 = 1,50%,50% distance 1,1 < {$1/2}
_fx_shapes3 :
$2,$2,1,1,'x+y<=2*$1-1'
_fx_shapes4 :
$2,$1,1,1,1
_fx_shapes5 :
$1,$2,1,1,1
_fx_shapes6 :
ball $1,200 n 0,1
_fx_shapes7 :
shape_heart 65 r $1,$1,1,1,2 >= 50%
_fx_shapes8 :
shape_star $1
_fx_shapes9 :
arrow3d 0,0,0,1,0,0,15%,40%,30% col3d 1 *3d $1 c3d
$2,$2 j3d. ..,50%,50%,0,1,2,0,0
rm.. +mirror y max
_fx_shapes10 :
S={$2+1-($2%2)}
$S,$S,1,1,"X=x/(w-1);Y=y/(h-1);r=abs(0.5-sqrt(X^2+Y^2));a=atan2(y,x);r<0.1-0.17*(0.5-$1/$2)*sin(2*a)"
+mirror xy max
_fx_shapes11 :
_fx_shapes0 $* expand_xy 1,0 +erode 3 -
_fx_shapes12 :
_fx_shapes1 $* expand_xy 1,0 +erode 3 -
_fx_shapes13 :
_fx_shapes2 $* expand_xy 1,0 +erode 3 -
_fx_shapes14 :
_fx_shapes3 $* expand_xy 1,0 +erode 3 -
_fx_shapes15 :
_fx_shapes7 $* expand_xy 1,0 +erode 3 -
_fx_shapes16 :
_fx_shapes8 $* expand_xy 1,0 +erode 3 -
_fx_shapes17 :
_fx_shapes9 $* expand_xy 1,0 +erode 3 -
#@gui Pack Sprites : fx_pack_sprites, gui_no_preview
#@gui : Number of Scales = int(5,1,16)
#@gui : Minimal Scale (%) = float(25,1,100)
#@gui : Allow Angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gui : Spacing = int(1,-16,16)
#@gui : Precision = int(7,1,32)
#@gui : sep = separator()
#@gui : Masking = choice("No Masking","Mask as Bottom Layer")
#@gui : Width = int(512,32,2048)
#@gui : Height = int(512,32,2048)
#@gui : note = note("<small><b>Notes:</b>\n - Parameters <i>Width</i> and <i>Height</i> are considered only when <i>No masking</i> mode is selected.\n
#@gui : - Set different sprites on different layers to pack multiple sprites at the same time.</small>")
#@gui : url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=bpg7CGH7vCM")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/24/06</i>.</small>")
fx_pack_sprites :
if $6
if {$!<2} error[] "Command '$0': Masking requires at least two input layers ! (please check that 'Input Layers' is correctly set)." fi
repeat {$!-1} l[$>] to_rgba split_opacity +!=[1] 0 *[0] . a c autocrop 0 endl done
remove_empty[0--2] +channels. 100% channels. -4,0 mv. 0
pack_sprites[0--2] ${1-5}
else
repeat $! l[$>] to_rgba split_opacity +!=[1] 0 *[0] . a c autocrop 0 endl done
remove_empty i[0] $7,$8,1,5 pack_sprites ${1-5}
fi
channels[0] 0,{0,s-2}
#@gui Paper Texture : fx_paper, fx_paper_preview(0)
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_paper :
ac "texturize_paper",$1
fx_paper_preview :
gui_split_preview "fx_paper $*",${-3--1}
#@gui Periodic Dots : jeje_periodic_dots, jeje_periodic_dots_preview
#@gui : Number = int(6,2,32)
#@gui : Scale = float(4,1,12)
#@gui : Angle = float(0,0,360)
#@gui : Repeat = int(1,1,10)
#@gui : Map = choice(None,default,HSV,lines,hot,cool,jet,flag,cube)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_periodic_dots:
tW={max(w,h)/$4}
$tW,$tW
-periodic_dots[-1] $*
-repeat {$4*$4-1}
-i [-1]
-done
-append_tiles[1--1] $4,$4 -k[-1]
-if {$5>0} -n 0,255 -map {$5-1} -endif
jeje_periodic_dots_preview:
-jeje_periodic_dots $*
#@gui Plaid : fx_plaid_texture,fx_plaid_texture(1)
#@gui : Line = float(50,0,100)
#@gui : Number of Angles = int(2,1,8)
#@gui : Starting Angle = float(0,0,360)
#@gui : Angle Range = float(90,0,360)
#@gui : Smoothness = float(1,0,5)
#@gui : Sharpen = float(300,0,1000)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/16/05</i>.</small>")
fx_plaid_texture :
repeat $! l[$>]
w={w} h={h} s={s}
rows $1%
b $5% sharpen $6
r $w,$h,1,$s,2
+rotate[0] $3,1,2,50%,50%
repeat {$2-1} +rotate[0] {$3+$4*($>+1)/($2-1)},1,2,50%,50% +[-2,-1] done rm[0]
/ $2
endl done
#@gui Polka Dots : fx_polka_dots, fx_polka_dots(1)
#@gui : Size = float(80,0,100)
#@gui : Density = float(20,0.1,100)
#@gui : First Offset = float(50,0,100)
#@gui : Second Offset = float(50,0,100)
#@gui : Angle = float(0,0,180)
#@gui : Aliasing = float(0.5,0.1,1)
#@gui : Shading = float(0.1,0.1,1)
#@gui : Opacity = float(1,0,1)
#@gui : Color = color(255,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_polka_dots :
to_rgba polka_dots {$1*$2/100},${2--1}
#@gui Random Color Ellipses : fx_color_ellipses, fx_color_ellipses(1)
#@gui : Density = int(400,0,3000)
#@gui : Radius = float(8,0,30)
#@gui : Opacity = float(0.1,0.01,0.5)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_color_ellipses :
color_ellipses $1,$2,$3
#@gui Rays : jeje_rays, jeje_rays_preview
#@gui : X Center = float(50,0,100)
#@gui : Y Center = float(50,0,100)
#@gui : Frequency = float(10,0,100)
#@gui : Angle = float(0,0,360)
#@gui : Proportion = float(0.5,0,1)
#@gui : Color 1 = color(255,0,0)
#@gui : Color 2 = color(255,255,0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/29</i>.</small>")
jeje_rays :
-s c
-l[0] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $6,$9 -endl
-l[1] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $7,$10 -endl
-l[2] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $8,$11 -endl
-a c
jeje_rays_preview:
-gui_split_preview "-jeje_rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11",$-1
#@gui Reptile : samj_reptile_en, samj_reptile_en(1)
#@gui : note = note("samj_reptile_en")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Skin Texture</b></span>")
#@gui : Form = choice(0,"Hexagonal","Grid","Triangular Ha","Triangular Hb","Triangular Va","Triangular Vb")
#@gui : Resolution = int(64,32,128)
#@gui : Spread = int(25,5,100)
#@gui : Color = float(2,0,10)
#@gui : Orientation = float(0,0,1)
#@gui : Light = int(40,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/01/22</i>.</small>")
samj_reptile_en :
-samj_reptile $1,$2,$3,$4,{$5/100},$6,$7
#@gui Resynthetize Texture [FFT] : syntexturize, fx_syntexturize_preview(1)
#@gui : Width = _int(1024,32,8192)
#@gui : Height = _int(1024,32,8192)
#@gui : Equalize Light = float(0,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter tries to re-synthetize a <b>micro</b>-texture (given as the input image) onto an output (seamless) image with an arbitrary size.
#@gui : It uses a phase randomization technique, as described in:</small>"}
#@gui : url = link("Micro-Texture Synthesis by Phase Randomization","http://www.ipol.im/pub/art/2011/ggm_rpn/")
#@gui : note = note("<small>This filter is based on the work of <i>Bruno Galerne</i>, <i>Yann Gousseau</i> and <i>Jean-Michel Morel</i>.</small>")
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=10141")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>J&#233;rome Boulanger</i>.      Latest Update: <i>2014/09/04</i>.</small>")
fx_syntexturize :
repeat $! l[$>]
if $3 +b {20.5-$3/50}% -[0] [1] fc. ${average_colors.} + c 0,255 fi
syntexturize $1,$2
endl done
fx_syntexturize_preview :
gui_split_preview "fx_syntexturize 100%,100%,$3",${-3--1}
#@gui Resynthetize Texture [Patch-Based] : syntexturize_matchpatch, fx_syntexturize_matchpatch_preview(1)
#@gui : Width = _int(512,32,8192)
#@gui : Height = _int(512,32,8192)
#@gui : Number of Scales = int(0,0,16)
#@gui : Patch Size = int(7,1,32)
#@gui : Blending Size = int(5,1,24)
#@gui : Precision = float(1,0,5)
#@gui : Equalize Light = float(0,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter tries to re-synthetize an input texture image onto a bigger output image (with an arbitrary size).
#@gui : Beware, this filter is quite slow to compute!</small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/22/10</i>.</small>")
_fx_syntexturize_matchpatch_preview :
repeat $! l[$>]
if $7 +b {20.5-$7/50}% -[0] [1] fc. ${average_colors.} + c 0,255 fi
w={w} h={h}
syntexturize_matchpatch 100%,100%,${3--1}
to_rgba r $w,$h,1,4,0,0,0.5,0.5
endl done
fx_syntexturize_matchpatch_preview :
gui_split_preview "_fx_syntexturize_matchpatch_preview ${1--2}",${-3--1}
#@gui Rorschach : fx_rorschach, fx_rorschach
#@gui : Scale = float(3,0,10)
#@gui : Mirror = choice(1,"None","X-Axis","Y-Axis","XY-Axes")
#@gui : Stencil Type = choice(2,"Black &amp; White","RGB","Color")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/12/03</i>.</small>")
fx_rorschach :
repeat $! remove_opacity l[$>]
if {$3==0} norm rorschach $1%,$2 * 255
elif {$3==1} to_rgb rorschach $1%,$2 * 255
else +norm rorschach. $1%,$2 blend shapeaverage0
fi
endl done
#@gui Satin : fx_satin, fx_satin(1)
#@gui : Iterations = int(20,4,128)
#@gui : Smoothness (%) = float(1,0,5)
#@gui : Seed = int(0,0,65535)
#@gui : sep = separator()
#@gui : Dark Color = color(0,0,0,255)
#@gui : Light Color = color(255,255,255,255)
#@gui : Stretch Contrast = bool(0)
#@gui : sep = separator()
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(-50,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator(), note = note{"This filter has been inspired by <a href="https://fence-post.deviantart.com/art/Satin-Texture-in-GIMP-46937633">this tutorial</a> from DeviantArt user <i>fence-post</i>."}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/11/27</i>.</small>")
fx_satin :
($4,$8^$5,$9^$6,$10^$7,$11) srgb2rgb. r. 256,1,1,4,3 rgb2srgb.
repeat {$!-1} l[$>]
srand $3 channels 0 f 0
repeat $1
100%,100%,1,1,"begin(
A = u([0,0],[w,h]-1);
B = u([0,0],[w,h]-1);
N = [0,-1,1,0]*(B - A);
D = A + N;
C = B + N;
abc = solve([A,1,B,1,C,1,D,1],[0,255,255,0]);
);
dot(abc,[x,y,1])"
c. 0,255 -- abs
done
b $2% gradient_norm negate n 0,255
if $12 normalize_local , fi
pass. 1 map.. . rm.
sh. 0,2 adjust_colors. ${13-17} rm.
endl done
rm.
#@gui Seamless Deco : fx_mad_rorscharchp,fx_mad_rorscharchp
#@gui : Scale = float(3,0,15)
#@gui : Mixer = choice ("Average","Grain Extract","Vivid Edges","Difference", "Exclusion"," Negation")
#@gui : sep = separator()
#@gui : Line = float(50,0,100)
#@gui : Smoothness = float(1,0,5)
#@gui : Sharpen = float(300,0,1000)
#@gui : sep = separator()
#@gui : Remix = choice ( "Vivid Edges", "Average", "Difference","Negation","Dark Edges")
#@gui : PhotoComix Preset = choice( "Neat Merge","Lighty Smooth","Dream","Moody" "Soft","Naif","Dark Boost","Whitening"," None- Skip" )
#@gui : Activate Mirror = choice ("No-Skip", XY Mirror"," 2XY Mirror")
#@gui : sep = separator()
#@gui : note = note("WARNING,"Expanding Mirrors" multiply image size of x4 or if "2XY Mirrors" x9")
#@gui : sep = separator()
#@gui : Expanding Mirrors = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComix</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_mad_rorscharchp :
-fx_rorschach $1,1,1
--mirror y
-if {$2==0} -fx_compose_average 1,0
-elif {$2==1} -fx_compose_grainextract 1,0
-elif {$2==1} -fx_compose_vividedges 1,1,0.5,1 -endif
--fx_plaid_texture $3,2,0,90,$4,$5
-if {$6==0} -fx_compose_vividedges 1,1,0.5,1
-elif {$6==1} -fx_compose_average 1,0
-elif {$6==2} -fx_compose_difference 1,0
-elif {$6==3} -fx_compose_negation 1,0
-elif {$6==4} -fx_compose_negation 1,0
-elif {$6==5} -fx_compose_darkedges 1,1,0.8,1 -endif
-if {$7==0} -fx_graphic_novelfxl 0,2,6,5,20,0,0.62,14,0,1,0.5,0.78,1.92,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==1}-fx_graphic_novelfxl 0,7.2,14.65,5,20,0,1.06,36.14,0,1,0.5,0.85,1.93,0,0,8,1,1,1,0.5,0.95,2.89,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==2} -fx_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.6,36.1,0,1,0.5,0.6,3.6,0,0,11,1,1,1,0.5,0.8,2.16,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$7==3}  -fx_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,17,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$7==4} -fx_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.855422,1.92771,0,0,8,1,1,1,0.5,0.373494,2.89157,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==5} -fx_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,14,0,1,0.5,0.855422,1.3253,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==6} -fx_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,36.1446,0,1,0.5,0.855422,1.92771,0,0,7,1,1,1,0.5,0.951807,1.92771,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==7} -fx_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,18,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1 -endif
-if {$8==1} -fx_array_mirror 1,0,0,2,0,$9
-elif {$8==2} -fx_array_mirror 1,0,0,3,0,$9 -endif
#@gui Seamless Turbulence : fx_seamless_turbulence, fx_seamless_turbulence(0)
#@gui : Amplitude = float(15,0,30)
#@gui : Smoothness = float(20,0,40)
#@gui : Orientation = float(0,0,180)
#@gui : Deviation = float(1,0,1)
#@gui : Contrast = float(3,0,4)
#@gui : Color Rendering = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/02/04</i>.</small>")
fx_seamless_turbulence :
repeat $! l[$>]
wh={w},{h} rm
$wh,1,{if($6,3,1)} rand. 0,255
$wh rand. {$3*pi/180-$4*10*pi},{$3*pi/180+$4*10*pi} +sin. cos.. a[-2,-1] c
r[-2,-1] 130%,130%,1,100%,0,2,0.5,0.5 b. $2 orientation.
vector2tensor.
smooth.. .,$1,0.5,20 rm.
r. $wh,1,100%,0,0,0.5,0.5
if {$5!=1} ia={ia} - $ia * $5 + $ia fi
endl done
c 0,255 n 0,255
#@gui Shock Waves : fx_shockwaves, fx_shockwaves_preview
#@gui : Amplitude = float(10,0,100)
#@gui : Low Frequency = float(10,0,100)
#@gui : Frequency Range = float(20,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/01/12</i>.</small>")
_fx_shockwaves :
dct
100%,100%,1,1,1 circle. 0,0,{$2+$3}%,1,{$1+1} circle. 0,0,$2%,1,1
* idct c 0,255
fx_shockwaves :
ac "_fx_shockwaves ${1-3}",$4
fx_shockwaves_preview :
gui_split_preview "fx_shockwaves $*",${-3--1}
#@gui Soft Random Shades : samj_Soft_Random_Shades, samj_Soft_Random_Shades(1)
#@gui : sep = separator(), note = note("<span foreground="orangered">samj_Soft_Random_Shades</span>")
#@gui : Background Color = color(140,120,220,255)
#@gui : Variation A = int(0,0,4)
#@gui : Variation B = int(20,20,120)
#@gui : Variation C = float(0,0,0.25)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/12/06</i>.</small>")
samj_Soft_Random_Shades :
R_a=$1
V_a=$2
B_a=$3
A_a=$4
Variation_A=$5
Variation_B=$6
Variation_C=$7
Largeur={w}
Hauteur={h}
{$Largeur},{$Hauteur},1,4
{$Largeur},{$Hauteur},1,4
-rm[-3]
-fill_color[-1,-2] $R_a,$V_a,$B_a,$A_a
-samj_Random_Plasma[-1] $Variation_A,$Variation_B
-blend[-1,-2] luminance
-if {$Variation_C==0}
-else
{$Largeur},{$Hauteur},1,4
{$Largeur},{$Hauteur},1,4
-fill_color[-1,-2] $R_a,$V_a,$B_a,$A_a
-samj_Random_Plasma[-1] $Variation_A,$Variation_B
-blend[-1,-2] luminance
-blend[-1,-2] edges,{0.5+$Variation_C},0
-endif
-crop[-1] 0,0,{$Largeur-8},{$Hauteur-1}
-resize[-1] {$Largeur},{$Hauteur}
#@gui Sponge : fx_sponge, fx_sponge_preview(0)
#@gui : Size = int(13,3,21)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sponge :
ac "sponge $1",$2
fx_sponge_preview :
gui_split_preview "fx_sponge $*",${-3--1}
#@gui Stained Glass : fx_stained_glass, fx_stained_glass_preview(0)
#@gui : Edges = float(20,0,100)
#@gui : Shading = float(0.1,0,0.5)
#@gui : Thin Separators = bool(1)
#@gui : sep = separator()
#@gui : Equalize = bool(1)
#@gui : Colors = float(1,0,3)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/18/03</i>.</small>")
fx_stained_glass :
repeat $! l[$>] split_opacity l[0] to_rgb
stained_glass $1,$2,$3
n 0,255
if $4 equalize. fi
rgb2lab. sh. 1,2 *. $5 rm. lab2rgb.
adjust_colors. ${6-8}
endl a c endl done
fx_stained_glass_preview :
gui_split_preview "fx_stained_glass $*",${-3--1}
#@gui Stars : fx_stars, fx_stars(0)
#@gui : Density = float(10,0,200)
#@gui : Depth = float(0,0,5)
#@gui : Size = int(32,8,128)
#@gui : Branches = int(5,3,16)
#@gui : Thickness = float(0.38,0.1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,100,200)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/01/10</i>.</small>")
fx_stars :
repeat $! l[$>] split_opacity rv
stars $1%,$2,$3,$4,$5,$6%,${7-9},{$10/255}
rv a c endl done
#@gui Stencil : fx_stencil, fx_stencil_preview(0)
#@gui : Radius = float(3,0,10)
#@gui : Smoothness = float(0,0,30)
#@gui : Iterations = int(8,1,100)
#@gui : Aliasing = float(0,0,5)
#@gui : Stencil Type = choice(2,"Black &amp; White","RGB","Color")
#@gui : Transparency = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_stencil :
if {$5==0} norm stencil $1,$2,$3
elif {$5==1} stencil $1,$2,$3
else repeat $!
+norm. stencil. $1,$2,$3 >=. 50% blend[-2,-1] shapeaverage0
mv. 0 done fi
if $6 to_rgba replace_color 0,0,0,0,0,255,0,0,0,0 fi
if $4 smooth {30*$4},0,1,1 fi
fx_stencil_preview :
gui_split_preview "fx_stencil $*",${-3--1}
#@gui Strip : jeje_strip, jeje_strip_preview
#@gui : Angle = float(45,0,90)
#@gui : Frequency = float(50,0,100)
#@gui : Phase =  float(0,0,180)
#@gui : Amplitude = float(1,0,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_strip :
theta={pi*$1/180}
-f '0.5*i*(1+$4*sin(2*pi*$2*(cos($theta)*x/w+sin($theta)*y/h)+2*pi*$3/180))'
-c 0,255
jeje_strip_preview :
-gui_split_preview "-jeje_strip $*",$-1
#@gui Tetris : fx_tetris, fx_tetris(0)
#@gui : Scale = int(10,1,20)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_tetris :
tetris $1
#@gui Truchet : fx_truchet, fx_truchet(0)
#@gui : Scale = int(32,1,256)
#@gui : Radius = int(5,1,64)
#@gui : Smoothness = float(1,0,10)
#@gui : Type = choice(1,"Straight","Curved")
#@gui : Color = choice("White on Black","Black on White","White on Transparent","Black on Transparent","Transparent on White","Transparent on Black","Random")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/26/10</i>.</small>")
fx_truchet :
repeat $! l[$>]
100%,100% truchet $1,$2,$4 rm..
if {$5==1} * -1
elif {$5==2} i[0] 100%,100%,1,1,1
elif {$5==3} i[0] 100%,100%
elif {$5==4} * -1 i[0] 100%,100%
elif {$5==5} * -1 i[0] 100%,100%,1,1,-1
elif {$5==6} label 0,1 {iM+1},1,1,3 rand. 0,255 map.. . rm.
fi
a c b $3 n 0,255
endl done
#@gui Turbulent Halftone : iain_turbulent_halftone_preview, iain_turbulent_halftone(0)
#@gui : Amplitude = float(15,0,30)
#@gui : Smoothness = float(20,0,40)
#@gui : Orientation = float(0,0,180)
#@gui : Deviation = float(1,0,1)
#@gui : Tile Size = int(512,128,2048)
#@gui : Blur = float(0.75,0,4)
#@gui : Colour Model = choice("RGB","CMYK","Luminance")
#@gui : Enhance Detail = float(0,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>Iain Fergusson</i>.      Latest update: <i>2018/08/24</i>.</small>")
iain_turbulent_halftone:
-if {$8>0}
--iain_fast_denoise $8,0,1,0,0
-sub[1] [0]
-mul[1] -1
-add
-endif
-if {$7==1}
-rgb2cmyk
-endif
-if {$7==2}
-luminance
-endif
-split c
-repeat $! -local[$>]
--l[0]
-channels 0
tsize={min($5,w,h)}
xtile={(round(w/$tsize))+1}
ytile={(round(h/$tsize))+1}
$tsize,$tsize
-fx_seamless_turbulence[-1] $1,$2,$3,$4,.25,0
[-1]x{$xtile*$ytile}
-append_tiles[1--1] $xtile,$ytile
-remove[-1]
-crop[-1] 0,0,{0,w},{0,h}
-keep[-1]
-endl
-blur[-1] $6
-equalize[-1] 256
-blend alpha,0.5,1
-gt 128
-mul 255
-endlocal -done
-append c
-if {$7==1}
-cmyk2rgb
-endif
iain_turbulent_halftone_preview:
-iain_turbulent_halftone $1,$2,$3,$4,{0,w},$6,$7,$8
#@gui Turing : jeje_turing_pattern,gui_no_preview
#@gui : Scale = float(1,0,1)
#@gui : Iterations = int(2000,1,10000)
#@gui : Time Step = float(.1,.01,1)
#@gui : Alpha = float(.899,0,2)
#@gui : Beta = float(-.91,-2,2)
#@gui : Q = float(2,0,3)
#@gui : R = float(.1,0,3)
#@gui : Diffusivity = float(.25,.01,.6)
#@gui : sep = separator(), note = note(<small>Generate turing pattern using a system of coupled reaction/diffusion equations. The patterns can change from line to spots like structures depending on the parameters. You may use the 'Stencil' filter to achieve similar effects. http://en.wikipedia.org/wiki/The_Chemical_Basis_of_Morphogenesis</small>), note=note(<small>Since the computation is long there is no preview. </small>)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/01/16</i>.</small>")
jeje_turing_pattern:
--l
-r {$1*w},{$1*h},1,2
-turing_pattern $2,$3,$4,$5,$6,$7,$8
-endl
-r[1] 100%,100%,100%,3,0 -r[1] [0],[0],1,100%,5 -rm[0] -blur .75 -n 0,255
#@gui Weave : weave, weave(1)
#@gui : Density = int(6,1,32)
#@gui : Thickness = float(65,0,100)
#@gui : Shadow = float(0,0,100)
#@gui : Shading = float(0.5,0,3)
#@gui : Fibers Amplitude = float(0,0,255)
#@gui : Fibers Smoothness = float(0,0,10)
#@gui : Angle = choice("0 deg.","22.5 deg.","45 deg.","67.5 deg.")
#@gui : X-Curvature = float(0,-1,1)
#@gui : Y-Curvature = float(0,-1,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/18/01</i>.</small>")
#@gui Whirls : fx_whirls, fx_whirls_preview(0)
#@gui : Density = int(7,3,20)
#@gui : Smoothness = float(2,0,10)
#@gui : Darkness = float(0.2,0,1)
#@gui : Lightness = float(1.8,1,3)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_whirls :
ac "whirls $1,$2,$3,$4",$5
fx_whirls_preview :
gui_split_preview "fx_whirls ${1-5}",${-3--1}
#@gui _
#@gui <b>Rendering</b>
#@gui 3D Blocks : fx_blocks3d, fx_blocks3d(1)
#@gui : Resolution = int(32,1,128)
#@gui : Smoothness = float(0,0,40)
#@gui : Elevation = float(4,-10,10)
#@gui : Size = float(1.5,0,3)
#@gui : Angle = float(30,0,360)
#@gui : Tilt = float(60,0,90)
#@gui : FOV = float(45,1,90)
#@gui : Centering (%) = point(50,50)
#@gui : sep = separator()
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(-50,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Use Light = bool(1)
#@gui : Antialiasing = bool(1)
#@gui : Outline Color = color(0,0,0,128)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/10/02</i>.</small>")
fx_blocks3d :
repeat $! l[$>]
nm=${"gui_layer_name"}
W={w} H={h} M={max(w,h)}
if {w>h} r2dx $1 else r2dy $1 fi
w={w} h={h} m={max(w,h)}
if {$3>0} mirror y fi
imageblocks3d $3,$2%
-3d. {$w/2},{$h/2} f={$4*$M/($m*(2-$16))} *3d $f,$f,{$f*abs($3*$1/100)}
if {$3>0} r3d 1,0,0,180 fi
r3d 0,0,1,$5 r3d 1,0,0,-$6
if $16 {2*$M},{2*$M},1,4,-1 else $M,$M,1,4,-1 fi
f3d={0.5*w/tan($7*pi/360)} f3d $f3d
l3d {$10*$f3d},{$11*$f3d},{$12*$f3d} sl3d $13 ss3d $14
j3d. [0],$8%,$9%,0,1,{if($15,3,2)},0,1
sh. 100% +. 1 *. 255 rm.
if $20
.,.,1,3,-1
j3d. [0],$8%,$9%,0,1,3,0,1 rm[0]
g. xy,1 +[-2,-1] norm. !=. 0
+r. 100%,100%,1,3
sh. 0 *. $17 rm.
sh. 1 *. $18 rm.
sh. 2 *. $19 rm.
j[0] .,0,0,0,0,{$20/255},.. rm[-2,-1]
else rm[0]
fi
replace_color 0,0,-1,-1,-1,0,0,0,0,0
if $16 r 50%,50%,1,4,2 fi
c 0,255 nm name($nm)
endl done
#@gui 3D Colored Object : fx_coloredobject3d, fx_coloredobject3d_preview(1)
#@gui : Type = choice{1,"Plane","Box","Pyramid","Ellipsoid","Torus","Gyroid","Weird","Cup"}
#@gui : Color = color(128,128,128,255)
#@gui : sep = separator()
#@gui : Size-1 = float(0.5,0,3)
#@gui : Size-2 = float(0.5,0,3)
#@gui : Size-3 = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/16/05</i>.</small>")
_fx_coloredobject3d :
to_rgb _fx_coloredobject3d$1$2 ${6-8} col3d. ${3-5}
db3d 0
fx_coloredobject3d :
_fx_coloredobject3d "_",${1-4,6-8}
repeat {$!-1}
+fx_render3d. {$>,w},{$>,h},$6,${9--1}
sh. 3 *. {$5/255} rm.
blend[$>,-1] alpha
done
rm.
fx_coloredobject3d_preview :
_fx_coloredobject3d "_preview_",${1-4,6-8}
repeat {$!-1}
+fx_render3d. {$>,w},{$>,h},$6,${9--1}
sh. 3 *. {$5/255} rm.
blend[$>,-1] alpha
done rm.
_fx_coloredobject3d_0 : plane3d 1 *3d. $1,$2,1
_fx_coloredobject3d_1 : box3d 1 *3d. $1,$2,$3
_fx_coloredobject3d_2 : pyramid3d 1,1 *3d. $1,$2,$3
_fx_coloredobject3d_3 : sphere3d 1 *3d. 1,{2*$2},{2*$3}
_fx_coloredobject3d_4 : torus3d $1,{$2/2},100,50 *3d. $3,0.5,0.5
_fx_coloredobject3d_5 : gyroid3d 24 *3d. $1,$2,$3
_fx_coloredobject3d_6 : weird3d 32 *3d. $1,$2,$3
_fx_coloredobject3d_7 : cup3d 128 *3d. $1,$2,$3
_fx_coloredobject3d_preview_0 : plane3d 1 *3d. $1,$2,1
_fx_coloredobject3d_preview_1 : box3d 1 *3d. $1,$2,$3
_fx_coloredobject3d_preview_2 : pyramid3d 1,1 *3d. $1,$2,$3
_fx_coloredobject3d_preview_3 : sphere3d 1 *3d. 1,{2*$2},{2*$3}
_fx_coloredobject3d_preview_4 : torus3d $1,{$2/2},100,50 *3d. $3,0.5,0.5
_fx_coloredobject3d_preview_5 : gyroid3d 8 *3d. $1,$2,$3
_fx_coloredobject3d_preview_6 : weird3d 12 *3d. $1,$2,$3
_fx_coloredobject3d_preview_7 : cup3d 64 *3d. $1,$2,$3
#@gui 3D Elevation : fx_elevation3d, fx_elevation3d_preview(1)
#@gui : Factor = float(100,-1000,1000)
#@gui : Smoothness = float(1,0,10)
#@gui : sep = separator()
#@gui : Width = _int(1024,8,4096)
#@gui : Height = _int(1024,8,4096)
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(25,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(2,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_elevation3d :
repeat {$!/2} l[$>,{min($>+1,$!-1)}]
if {$!==1} +norm else r[1] [0],3 fi
n[1] 0,{abs($1)} *[1] {sign($1)} b[1] $2
elevation3d[0] [1] rm[1]
endl done
db3d
fx_elevation3d :
_fx_elevation3d ${1-2} fx_render3d ${3--1}
fx_elevation3d_preview :
fx_elevation3d ${1-2},{w},{h},${5--1}
#@gui 3D Extrusion : fx_extrude3d, fx_extrude3d_preview(1)
#@gui : Depth = float(10,1,1024)
#@gui : Resolution = int(512,1,1024)
#@gui : Smoothness = float(0.6,0,3)
#@gui : sep = separator()
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_extrude3d :
repeat {$!/2} l[$>,{min($>+1,$!-1)}]
extrude3d. $1,$2,$3%
if {$!==2} t3d. .. rm.. fi
endl done
db3d 0
fx_extrude3d :
_fx_extrude3d ${1-3} fx_render3d ${4--1}
fx_extrude3d_preview :
fx_extrude3d ${1-3},{w},{h},${6--1}
#@gui 3D Image Object : fx_imageobject3d, fx_imageobject3d_preview(1)
#@gui : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gui : sep = separator()
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_imageobject3d :
to_rgb repeat $! l[$>] _fx_imageobject3d$1$2 endl done
db3d 0
fx_imageobject3d :
_fx_imageobject3d "_",$1 fx_render3d ${2--1}
fx_imageobject3d_preview :
w={w} h={h} _fx_imageobject3d "_preview_",$1 fx_render3d $w,$h,${4--1}
_fx_imageobject3d_0 : imageplane3d
_fx_imageobject3d_1 : imagecube3d
_fx_imageobject3d_2 : imagepyramid3d
_fx_imageobject3d_3 : imagesphere3d 64,32
_fx_imageobject3d_4 : torus3d 100,30,100,50 t3d. .. rm..
_fx_imageobject3d_5 : gyroid3d 24 t3d. .. rm..
_fx_imageobject3d_6 : weird3d 32 t3d. .. rm..
_fx_imageobject3d_7 : cup3d 128 t3d. .. rm..
_fx_imageobject3d_8 : imagerubik3d 5,5
_fx_imageobject3d_preview_0 : imageplane3d
_fx_imageobject3d_preview_1 : imagecube3d
_fx_imageobject3d_preview_2 : imagepyramid3d
_fx_imageobject3d_preview_3 : imagesphere3d 16,8
_fx_imageobject3d_preview_4 : torus3d 100,30,100,50 t3d. .. rm..
_fx_imageobject3d_preview_5 : gyroid3d 8 c3d. n3d. t3d. .. rm..
_fx_imageobject3d_preview_6 : weird3d 12 t3d. .. rm..
_fx_imageobject3d_preview_7 : cup3d 64 t3d. .. rm..
_fx_imageobject3d_preview_8 : imagerubik3d 3,3,5,5
#@gui 3D Lathing : fx_lathing3d, fx_lathing3d_preview(1)
#@gui : Resolution = int(76,1,1024)
#@gui : Smoothness = float(2,0,5)
#@gui : Max Angle = float(361,0,361)
#@gui : sep = separator()
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_lathing3d :
repeat {$!/2} l[$>,{min($>+1,$!-1)}]
lathe3d. $1,$2%,$3
if {$!==2} t3d. .. rm.. fi
endl done
db3d 0
fx_lathing3d :
_fx_lathing3d ${1-3} fx_render3d ${4--1}
nm name("[3D lathing]"),pos(0,0),mode(alpha)
fx_lathing3d_preview :
fx_lathing3d ${1-3},{w},{h},${6--1}
#@gui 3D Random Objects : fx_random3d, fx_random3d(1)
#@gui : Type = choice("Cube","Cone","Cylinder","Sphere","Torus")
#@gui : Density = int(50,1,300)
#@gui : Size = float(3,1,20)
#@gui : Z-Range = float(100,0,300)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(3,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_random3d :
repeat $! l[$>]
f3d={0.5*max(w,h)/tan($5*pi/360)} f3d $f3d l3d {$6*$f3d},{$7*$f3d},{$8*$f3d} sl3d $9 ss3d $10
to_rgb ({w},{h},{d},{s}) /. 2 repeat $2
({1,@0}) +. {1,@1} *. $3 /. 100 _fx_random3d$1 {^} rm..
r3d. 1,1,0,{u(0,360)}
({u(-1,1)}) *. {1,@0} ({u(-1,1)}) *. {1,@1}
+3d... {-2,^},{^},{u(-$4,$4)} rm[-2,-1]
col3d. {u(255)},{u(255)},{u(255)} done +3d[2--1] j3d[0] .,50%,50%,0,$12,$11,0,1
k[0]
endl done
_fx_random3d0 : box3d $1
_fx_random3d1 : ($1) /. 2 cone3d {^},$1 rm..
_fx_random3d2 : ($1) /. 2 cylinder3d {^},$1 rm..
_fx_random3d3 : sphere3d $1,2
_fx_random3d4 : ($1) /. 3 torus3d $1,{^} rm..
#@gui Ball : fx_ball, fx_ball_preview(0)
#@gui : Radius = int(128,1,1024)
#@gui : Specular Light = float(0.8,0,8)
#@gui : Specular Size = float(1,0,8)
#@gui : Shadow = float(1.5,0,4)
#@gui : Color = color(255,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/11</i>.</small>")
fx_ball :
ball $1,${5-7},${2-4}
if {$!>1} mv. 0 nm[0] "name(Ball),pos("{0,0.5*([${-max_wh}]-[w,h])}")" else nm[0] "name(Ball)" fi
fx_ball_preview :
fx_ball $*
if {$!>1} rv[-2,-1] blend[-2,-1] alpha fi
#@gui Circle Art : fx_circle_art, fx_circle_art
#@gui : Type = choice(1,"Random","Lissajous spiral")
#@gui : Density = float(15,0,100)
#@gui : Radius = float(0.5,0,1)
#@gui : Modulo = int(8,2,16)
#@gui : Anti-Aliasing = bool(1)
#@gui : Random Colors = bool(1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Lissajous parameters:</b></small>")
#@gui : Curve Length = float(15,0,50)
#@gui : Curve Angle = float(0,0,360)
#@gui : Minimal Radius = float(0,-5,5)
#@gui : Maximal Radius = float(0.5,-5,5)
#@gui : X-Dispersion = float(1,0,4)
#@gui : Y-Dispersion = float(1,0,4)
#@gui : X-Factor = int(1,0,16)
#@gui : Y-Factor = int(1,0,16)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/22/08</i>.</small>")
fx_circle_art :
if {!$2} f 0 return fi
if {$1==0}
{round(2*($2^1.5))}
rand. -1,1 +rand. -1,1 +rand. -$3,$3 a[-3--1] y
else
{max(1,round($2*$7))}
t0={$8*2*pi/180}
rows. 0,2 f. 'r=x/(w-1);t=2*pi*x/$2;if(y==0,(r^$11)*cos($t0+$13*t),if(y==1,(r^$12)*sin($t0+$14*t),max(0,$3*($9+($10-$9)*r))))'
fi
l.
transpose s x,-1 h={h}
i[0] ({'CImg3d'},{2*$h},$h)
++... . -[-4,-2] i .. i[-3,-1] 1,100% a[-6--1] x
1,$h,1,1,5 1,$h,1,1,2*y ++. 1 a[-3--1] x z. 0,5
3,$h,1,1,1 1,$h,1,1,-1 y a y
endl
repeat {$!-1} l[$>,-1]
s={0,max(w,h)} rm[0]
if $5 {2*$s},{2*$s} +*3d[0] $s
else $s,$s +*3d[0] {$s/2}
fi
j3d[1] [2],50%,50%,0,1,2,0,0 rm[2]
%. $4
if $6 i.. 100%,100%,1,3 rand.. 0,255 plasma.. 1,1 equalize.. 256 n.. 0,255 blend[-2,-1] shapeaverage fi
rv
endl done
rm.
n 0,255
if $5 r 50%,50%,1,100%,2 fi
#@gui Disco : disco, disco_preview(1)
#@gui : Red Wavelength = int(10,1,50)
#@gui : Green Wavelength = int(15,1,50)
#@gui : Blue Wavelength = int(20,1,50)
#@gui : Zoom = float(250,0,3000)
#@gui : sep = separator()
#@gui : note = note("<small>This is a failed attempt on a conversion of a Mathmap script written by persons unknown</small>")
#@gui : note = note("<small>I prefer this over the filter I was attempting to recreate!!!.</small>")
#@gui : note = note("<small>Create a light effect with the size and aspect ratio of the input image.</small>")
disco_preview :
-disco ${1--1}
disco :
-repeat $! -l[$>]
-sh. 0
-f. "
begin(
rl=$1;
gl=$2;
bl=$3;
zoom=$4;
q=2*pi;
);
X=(2*x/(w-1))-1;
Y=1-(2*y/(h-1));
a=atan2(Y,X);
if (a<0,a=a+(2*pi));
r=sqrt(X*X+Y*Y);
rz=r*zoom;
RRR=abs(sin(rz/rl+q)+sin(a*rl+q));
GGG=abs(sin(rz/gl+q)+sin(a*gl+q));
BBB=abs(sin(rz/bl+q)+sin(a*bl+q));
i(#0,x,y,0,1)=GGG*255;
i(#0,x,y,0,2)=BBB*255;
RRR*255"
-rm.
-endl -done
#@gui Equation Plot [Parametric] : fx_equation_parametric, fx_equation_parametric
#@gui : X(t) = text{"sin(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gui : Y(t) = text{"cos(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gui : Min-t = float(0,-1000,1000)
#@gui : Max-t = float(100,-1000,1000)
#@gui : Resolution = int(4096,2,32768)
#@gui : Outline Opacity = float(1,0,1)
#@gui : Dot Size = int(0,0,16)
#@gui : Start Color = color(64,0,0)
#@gui : End Color = color(128,0,0)
#@gui : Colored Outline = bool(1)
#@gui : Antialiasing = bool(1)
#@gui : Decoration = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/13/11</i>.</small>")
fx_equation_parametric :
repeat $! l[$>]
w={w} h={h} rm
$5,1,1,2,'"t=$3+x*($4-$3)/($5-1);if(c==0,$1,$2)"'
channels. 0,2
($8,$11^$9,$12^$10,$13) r. {-2,w},1,1,3,3 a c
display_parametric $w,$h,{$6+$14*1.001},$7,$15,$16
endl done
#@gui Equation Plot [Y=f(X)] : fx_equation_plot, fx_equation_plot
#@gui : F(X) = text{"X*c+10*cos(X+c+u)"}
#@gui : X-Min = float(-10,-100,100)
#@gui : X-Max = float(10,-100,100)
#@gui : Resolution = int(100,2,1024)
#@gui : Channels = int(3,1,32)
#@gui : Plot Type = choice(2,"None","Lines","Splines","Bars")
#@gui : Vertex Type = choice(0,"None","Points","Crosses 1","Crosses 2","Circles 1","Circles 2","Square 1","Square 2")
#@gui : sep = separator()
#@gui : note = note("<small><b>Note</b> :
#@gui : Use variable <b>X</b> instead of <b>x</b> in the above equation to take care of the X-min/max settings.
#@gui : Variable <b>c</b> refers to the current channel number.
#@gui : Variable <b>u</b> refers to a uniformly distributed random value in [0,1].
#@gui : Reduce resolution to be able to view
#@gui : separate graph vertices.</small>")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_equation_plot :
repeat $! l[$>]
w={w} h={h} rm
$4,1,1,$5,"X=$2+($3-$2)*x/($4-1);$1"
dg $w,$h,$6,$7,$2,$3
endl done
#@gui Gradient [Corners] : fx_corner_gradient, fx_corner_gradient
#@gui : Color 1 (Up/Left Corner) = color(255,255,255,128)
#@gui : Color 2 (Up/Right Corner) = color(255,0,0,255)
#@gui : Color 3 (Bottom/Left Corner) = color(0,255,0,255)
#@gui : Color 4 (Bottom/Right Corner) = color(0,0,255,255)
#@gui : sep = separator(), Colorspace = choice(1,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_corner_gradient : skip ${17=0}
repeat $! l[$>]
wh={w},{h} rm
($1,$5;$9,$13^$2,$6;$10,$14^$3,$7;$11,$15^$4,$8;$12,$16)
_gb_fwd $17
r. $wh,1,100%,3
_gb_bwd $17
endl done
#@gui Gradient [Custom Shape] : fx_custom_gradient, fx_custom_gradient_preview(1)
#@gui : note = note("<small><b>Shape selection:</b></small>")
#@gui : Select By = choice("Auto","Dark Pixels","Bright Pixels","Opaque Pixels")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(0,0,100)
#@gui : Preview Shape = bool(1)
#@gui : note = note("<small><b>Note:</b> Shapes with small strokes may lead to incorrect previews.</small>")
#@gui : sep = separator()
#@gui : note = note("<small><b>Gradient parameters:</b></small>")
#@gui : Number of Colors = int(4,2,10)
#@gui : Cycles = float(1,1,16)
#@gui : Offset = float(0,0,100)
#@gui : Shading = float(128,1,256)
#@gui : Inner Length = float(100,0,100)
#@gui : Outer Length = float(100,0,100)
#@gui : Spatial Metric = choice(2,"Chebyshev","Manhattan","Euclidean")
#@gui : Color Metric = choice("RGB","HSV","Lab")
#@gui : Shade Back to First Color = bool(1)
#@gui : Preview Gradient = bool(0)
#@gui : Save Gradient As = _text("")
#@gui : sep = separator()
#@gui : note = note("<small><b>Color definitions:</b></small>")
#@gui : Colormap Type = choice(1,"Pre-Defined","User-Defined")
#@gui : Pre-Defined Colormap = int(0,0,65535)
#@gui : 1st Color = color(0,0,0,255)
#@gui : 2nd Color = color(255,0,0,255)
#@gui : 3rd Color = color(255,255,0,255)
#@gui : 4th Color = color(255,255,255,255)
#@gui : 5th Color = color(0,255,255,255)
#@gui : 6th Color = color(0,255,0,255)
#@gui : 7th Color = color(0,0,255,255)
#@gui : 8th Color = color(128,128,128,255)
#@gui : 9th Color = color(255,0,255,255)
#@gui : 10th Color = color(0,0,0,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/03/10</i>.</small>")
fx_custom_gradient_preview : skip "${15=}"
repeat $! l[$>]
if $4
+_fx_custom_gradient1 ${1-14},"$15",${16--1} +erode. 3 -[-2,-1] +dilate. 5 a[-2,-1] c n. 0,255
fx_custom_gradient[0] ${1-14},"$15",${16--1},-1 blend alpha
else fx_custom_gradient ${1-14},"$15",${16--1},-1
fi
if $14
+_fx_custom_gradient0[] ${1-14},"$15",${16--1} r. {{0,w}-16},16,1,4 frame. 1,1,0 j[0] .,8,{0,h-25} rm.
fi
endl done
fx_custom_gradient : skip "${15=}"
_fx_custom_gradient0 ${1-14},"$15",${16--1}
if {$-1>=0&&narg("$15")}
dir_ggr=${-path_gimp}gradients
0 nm. ${"normalize_filename \"$15\""} name_ggr={b} rm. output_ggr. $dir_ggr/$name_ggr.ggr,"$15"
fi
i.. (0^0^0^0) a[-2,-1] x
repeat {$!-1} l[$>,-1]
_fx_custom_gradient1[0] ${1-14},"$15",${16--1}
+distance[0] 1,$11 +distance[0] 0,$11 *. -1 +[0] 1 +[0,-2,-1]
m={$9%*{0,im}} M={$10%*{0,iM}}
-[0] $m *[0] {1,(w-2)/($M-$m)} +[0] 1
round[0] map[0] .
endl done
rm.
_fx_custom_gradient0 :
if $16 4,8,1,1,${18-56} permute. yzcx
else 8,1,1,3 srand $17 rand. 0,255 to_rgba.
fi
z. 0,{$5-1}
if $13
r. {200*$6}%,1,1,4,0,2
__fx_custom_gradient0. $12,$8
shift. {-round(w*0.5*$7%)},0,0,0,2 z. 0,{w/2-1}
else
__fx_custom_gradient0. $12,$8
r. {100*$6}%,1,1,4,0,2 shift. {-round(w*$7%)},0,0,0,2
fi
__fx_custom_gradient0 :
if {$1==1} sh. 0,2 rgb2hsv. rm.
elif {$1==2} sh. 0,2 srgb2rgb. rgb2lab. rm.
fi
r. {$2*w},1,1,4,3
if {$1==1} sh. 0,2 hsv2rgb. rm.
elif {$1==2} sh. 0,2 lab2rgb. rgb2srgb. rm.
fi
_fx_custom_gradient1 :
b $2%
if {$1==0}
to_a split_opacity
if {iM>im+32}
rm.. >=[0] {100-$3}%
else
rm. norm n 0,1
if {ia>0.5} <=[0] $3% else >=[0] {100-$3}% fi
fi
elif {$1==1}
remove_opacity norm <= $3%
elif {$1==2}
remove_opacity norm >= {100-$3}%
else
to_a channels 100% >= {100-$3}%
fi
#@gui Gradient [from Line] : fx_line_gradient, fx_line_gradient_preview(1)
#@gui : Starting Point (%) = point(0,0,0,1,255,0,0)
#@gui : Ending Point (%) = point(100,100,0,1,64,128,255)
#@gui : Sampling = float(100,0,100)
#@gui : Length = int(0,0,4096)
#@gui : note = note("<small><b>Note:</b> Set length to <i>0</i> to release gradient length constraints.</small>")
#@gui : Sort Colors = choice("Don't Sort","By Red Component","By Green Component","By Blue Component","By Luminance","By Blue Chrominance","By Red Chrominance","By Lightness")
#@gui : Reverse Gradient = bool(0)
#@gui : sep = separator()
#@gui : Preview Gradient = bool(1)
#@gui : Save Gradient As = _text("")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_line_gradient : skip "${10=}"
_fx_line_gradient $*
if {narg("$10")}
dir_ggr=${-path_gimp}gradients
0 nm. ${"normalize_filename \"$10\""} name_ggr={b} rm. output_ggr. $dir_ggr/$name_ggr.ggr,"$10"
fi
repeat $! r[$>] 100%,64,1,100% done
fx_line_gradient_preview :
repeat $! l[$>]
to_rgba
if $9 +_fx_line_gradient $* fi
l[0]
line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,255,255,255,255
line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,0,0,0,255
endl
if {$!>1} r. {{0,w}-32},32,1,4,1 frame. 1,1,0,0,0,255 j[0] [1],16,{{0,h}-48} rm. fi
endl done
_fx_line_gradient :
at_line $1%,$2%,0,$3%,$4%,0 r {max(0.1,$5)}%,1,1,100%,1
m "feature1 : channels 0"
m "feature2 : channels 1"
m "feature3 : channels 2"
m "feature4 : to_rgb luminance"
m "feature5 : to_rgb rgb2ycbcr channels 1"
m "feature6 : to_rgb rgb2ycbcr channels 2"
m "feature7 : to_rgb srgb2rgb rgb2lab channels 0"
if $7 repeat $! l[$>] +feature$7 rv a y sort +,x rows 1 endl done fi
if $6 r $6,1,1,100%,3 fi
if $8 mirror x fi
#@gui Gradient [Linear] : fx_linear_gradient, fx_linear_gradient
#@gui : Starting Color = color(0,0,0,255)
#@gui : Ending Color = color(255,255,255,255)
#@gui : Swap Colors = bool(0)
#@gui : Angle = float(45,0,360)
#@gui : Fade Start = float(0,0,100)
#@gui : Fade End = float(100,0,100)
#@gui : sep = separator(), Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_linear_gradient : skip ${13=0}
repeat $! l[$>]
wh={w},{h} rm
($1^$2^$3^$4) ($5^$6^$7^$8)
if $9 rv[-2,-1] fi
r $wh
_gb_fwd $13
fade_linear $10,$11,$12
_gb_bwd $13
endl done
#@gui Gradient [Radial] : fx_radial_gradient, fx_radial_gradient
#@gui : Starting Color = color(0,0,0,255)
#@gui : Ending Color = color(255,255,255,255)
#@gui : Swap Colors = bool(0)
#@gui : Fade Start = float(0,0,100)
#@gui : Fade End = float(100,0,100)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : sep = separator(), Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_radial_gradient : skip ${14=0}
repeat $! l[$>]
wh={w},{h} rm
($1^$2^$3^$4) ($5^$6^$7^$8)
if $9 rv[-2,-1] fi
r $wh
_gb_fwd $14
100%,100% =. 1,$12%,$13% distance. 1 _fade $10,$11
_gb_bwd $14
endl done
#@gui Gradient [Random] : fx_random_gradient, fx_random_gradient
#@gui : Density = int(32,1,1024)
#@gui : Seed = int(0,0,65535)
#@gui : Smoothness = float(0,0,10)
#@gui : Color Balance = color(128,128,128)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/08/04</i>.</small>")
fx_random_gradient :
repeat $! l[$>]
to_rgba 100%,100% srand $2
eval "for (n=0, n<$1, ++n,
x = round(u(w-1));
y = round(u(h-1));
i(x,y) = 1;
i(#0,x,y,0,0) = round(u(255));
i(#0,x,y,0,1) = round(u(255));
i(#0,x,y,0,2) = round(u(255));
i(#0,x,y,0,3) = $7*255 + (1-$7)*round(u(255));
)"
if {$7!=1} sh.. 100% n. 0,255 rm. fi
==. 0
sh.. 0,2 srgb2rgb. rm.
inpaint_diffusion.. [1],100%,1 rm.
b $3% n 0,255
sh 0,2 rgb2srgb. balance_gamma. ${4-6} rm.
endl done
#@gui Hair Locks : gtutor_hairlock, gtutor_hairlock_preview(0)
#@gui : note = note("<b>Geometry</b>")
#@gui : Spread = float(0.5,0,1)
#@gui : Thickness = float(0.5,0,1)
#@gui : Length = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Color</b>")
#@gui : Color = color(255,255,0,255)
#@gui : Variance = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Lighting</b>")
#@gui : Azimuth = float(45,0,360)
#@gui : Highlight = float(0.5,0,1)
#@gui : Specular = float(0.5,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Garry R. Osgood</i>. Latest update: <i>2014/12/11</i>.</small>")
#@gui : note = link("Hairlock instructions and tutorial.","http://gmic.eu/tutorial/the-hairlock-filter.shtml")
gtutor_hairlock :
($4^$5^$6)
-rgb2hsl[-1]
hue={i[0]}
sat={0.97*i[1]}
light={i[2]}
opac={$7/255}
var={0.1*$8}
-rm[-1]
-repeat $!
-local[$>]
--diffusiontensors[-1] 1,0,0.1,{8*$1},0
-diffusiontensors[-2] 0,1,0.1,{20*$1},0
-eigen[-2,-1]
-rm[-1]
-split[-1] c
-rm[-1]
-mul[-1] -1
-add[-1]
-normalize[-1] 0,1
-mv[-1] 0
-split[-2] c
-rm[-3]
-mul[-2] -1
-add[-2] 1
--mul[-2] 0
-reverse[-1,-2]
-append[-3,-2] c
-eigen2tensor[-2,-1]
-input 100%,100%,1,3
-_hcolor[-1] $hue,$sat,$light,$var,{0.05+0.5*$2},0.98,1
-dilate_circ[-1] {2+2*$2}
--luminance[-1]
-gt[-1] 0.01
-mul[-4,-1]
-normalize[-1] 0,255
-replace_color[-1] 0,0,0,0,0,$4,$5,$6
-reverse[-2,-1]
-repeat 3
-smooth[-3,-2] [-1],{5+595*$3}
-done
-rm[-1]
-reverse[-2,-1]
-sharpen[-1] {1.2*(1-$2)}
-normalize[-1] 0,1
--_hlight[-1] $9,$10,1
-mul[-1] [-3]
-add[-3,-1]
--_hlight[-1] $9,$10,$11
-input [-3],[-3],[-3],[-3],255,255,255
-image[-4] [-1],0,0,0,0,1,[-2]
-keep[-4,-3]
-normalize[-1] 0,{51*(1+4*$opac)}
-append[-2,-1] c
-normalize[-1] 0,255
-endlocal
-done
gtutor_hairlock_preview :
-gui_split_preview "-gtutor_hairlock ${^0}",$-1
_hlight : -check "${1=45}<=360 && $1>=0 && ${2=0.5}>=0 && ${3=0.5}>=0"
-if {$2>0}
-resize2dx[-1] 400%,5
-blur[-1] 2,1
-gradient_orientation[-1] 2
-append[-2,-1] c
-input ({cos(2*$1*pi/360)}^{sin(2*$1*pi/360)})
-resize[-1] [-2],[-2],[-1],[-1],1
-mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-normalize[-1] {195*$3-200},0
-exp[-1]
-resize2dx[-1] 25%,5
-normalize[-1] 0,{$2}
-else
-fill_color[-1] 0
-endif
-to_rgb[-1]
#@cli _hcolor : h_mean,s_mean,l_mean,var,density,coverage,is_mod
#@cli : Plot in selected images impulses centered around h,s,l means +/- var
#@cli : at relative 0<=density<=1 wrt 1/2 image area: related to density=1
#@cli : coverage: wrt image area, relative coverage 0<=coverage<=1 smaller
#@cli : values give rise to unplotted regions around edges equal 1.0-coverage.
#@cli : is_mod, boolean, if true, wraps negative values around to one.
#@cli : Default values: mean=40,var=0,density=0.5,coverage=1,is_mod=True
_hcolor : -skip ${1=40},${2=0.5},${3=0.5},${4=0},${5=0.5},${6=1},${7=1}
-repeat $!
-local[$>]
pcnt={0.5*w*h*$5}
{$pcnt},1,1,1,({0,w}*(1-$6)/2)+{0,w}*$6*u
{$pcnt},1,1,1,({0,h}*(1-$6)/2)+{0,h}*$6*u
{$pcnt},1,1,1
ra={$1/360.0}
-if $7
{$pcnt},{s},1,1,360.0*($ra+$4*(2*g-1))%1
{$pcnt},{s},1,1,($2+$4*(2*g-1))%1
{$pcnt},{s},1,1,($3+$4*(2*g-1))%1
-else
{$pcnt},{s},1,1,360.0*($ra+$4*(2*g-1))
{$pcnt},{s},1,1,$2+$4*(2*g-1)
{$pcnt},{s},1,1,$3+$4*(2*g-1)
-endif
-append[^0] y
-pointcloud[-1] 0,{-2,w},{-2,h},1,{-2,s}
-rm[-2]
-hsl2rgb[-1]
-endlocal
-done
#@gui Kitaoka Spin Illusion : KittyRings, KittyRings_preview(1)
#@gui : Sectors = float(30,10,80)
#@gui : Zoom = float(8,1,30)
#@gui : Inner Radius = float(0,0,2)
#@gui : Outer Radius = float(1,0,2)
#@gui : 1st Color = color(113,0,113)
#@gui : 2nd Color = color(0,255,0)
#@gui : sep = separator()
#@gui : note = note("<small>This filter is a conversion of the Mathmap script originally written by step7 - 2012</small>")
#@gui : note = note("<small>Renders positional displacement illusion 'Spinning Sectors' based on Akiyoshi Kitaoka's 'Rotating Snakes'</small>")
KittyRings_preview :
-KittyRings ${1--1}
KittyRings :
-repeat $! -l[$>]
-sh. 0
-f. "
begin(
sectors=$1;
zoom=$2;
inner=$3;
outer=$4;
R1=$5;
G1=$6;
B1=$7;
R2=$8;
G2=$9;
B2=$10
);
X=(2*x/(w-1))-1;
Y=1-(2*y/(h-1));
a=atan2(Y,X);
if (a<0,a=a+(2*pi));
r=sqrt(X*X+Y*Y);
rfloor=int(log(r)*zoom);
if(log(r)*zoom<0,rfloor=rfloor-1);
v=(sectors*a/(pi*2))+(rfloor*0.5);
vfloor=int(v);
if(v<0,vfloor=vfloor-1);
v=v-vfloor;
outR=0;
outG=0;
outB=0;
if (r>inner && r<outer,
if (v>0.15 && v <0.5,outR=R1; outG=G1; outB=B1);
if (v>0.5 && v <0.65,outR=255; outG=255; outB=255);
if (v>0.65 && v <1,outR=R2; outG=G2; outB=B2);
);
i(#0,x,y,0,1)=outG;
i(#0,x,y,0,2)=outB;
outR"
-rm[-1]
-endl -done
#@gui Lightning : fx_lightning, fx_lightning_preview
#@gui : note = note{"<small><b>Global parameters:</b></small>"}
#@gui : Number of Streaks = int(20,1,1024)
#@gui : Size (%) = float(90,0,150)
#@gui : Resolution = int(256,2,4096)
#@gui : Randomness = float(3,0,16)
#@gui : Smoothness = float(1.5,0,10)
#@gui : Balance = float(0.75,0,1)
#@gui : Color = color(255,255,255,255)
#@gui : Seed = int(0,0,65535)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Initial streak:</b></small>"}
#@gui : XY-Coordinates (%) = point(50,5,0,1)
#@gui : Angle (deg) = float(0,-180,180)
#@gui : Thickness (px) = int(6,1,64)
#@gui : Blur = float(0.2,0,3)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Auxiliary streaks:</b></small>"}
#@gui : Min Offset (%) = float(25,0,100)
#@gui : Max Offset (%) = float(60,0,100)
#@gui : Min Length (%) = float(95,0,200)
#@gui : Max Length (%) = float(100,0,200)
#@gui : Min Angle Deviation (deg) = float(30,0,180)
#@gui : Max Angle Deviation (deg) = float(40,0,180)
#@gui : Thickness Factor = float(-0.25,-1,1)
#@gui : Blur Factor = float(-0.1,-1,1)
#@gui : Opacity Factor = float(-0.20,-1,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/27/11</i>.</small>")
fx_lightning :
repeat $! l[$<]
100%,100% l. fact={max(w,h)/$3*$2%} srand $11
repeat $1
if {$!<=1}
i=0
new_level=1
new_length=$3
new_x=0
new_y=0
new_angle=$14
else
i={round(u(1,max(1,($!-1)*$6)))}
level={$i,@-2}
angle={$i,@-1}
nb_points={$i,i[6]}
p={round(($nb_points-2)*u($17%,$18%))}
new_level={$level+1}
new_length={max(2,round(($nb_points-$p)*u($19%,$20%)))}
new_x={$i,i[8+3*$p]}
new_y={$i,i[9+3*$p]}
new_angle={$angle+u($21,$22)*if(u>0.5,1,-1)}
fi
_fx_lightning $new_length,$4,$5
r3d. 0,0,1,$new_angle
+3d. $new_x,$new_y
+*3d. $fact [0],[0] j3d. ..,$12%,$13%,0,1,1,0,0 rm..
dilation={$15*(if($23>0,1.5,10)^($23*($new_level-1)))}
blur={max(0,-1+(1+$16)*(if($24>0,2,5)^($24*($new_level-1))))}
opacity={min(1,$10/255*(2^($25*($new_level-1))))}
dilate. $dilation b. $blur% n. 0,1 *. $opacity max[0,-1]
($new_level;$new_angle) a[-2,-1] y
progress {($>*100)/($1-1)}
done
k[0] * 255 i[0] 100%,100%,1,3 fc[0] ${7-9} a c
endl
rv
endl done
fx_lightning_preview :
repeat $! l[$>]
fx_lightning $* rv blend alpha
endl done
_fx_lightning :
l[]
({'CImg3d'},$1,{$1-1})
1,$1 noise. $2,1 cumulate. b. $3 shift. 0,1 1,100%,1,1,y 1,100% a[-3--1] x
1,{h-1},1,1,2 +f. y ++. 1 a[-3--1] x
4,100%,1,1,1
y a y
endl
#@gui Lissajous : fx_lissajous, fx_lissajous(1)
#@gui : Resolution = int(4096,2,8192)
#@gui : sep = separator()
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : Z-Size = float(3,1,10)
#@gui : sep = separator()
#@gui : X-Multiplier = float(8,0,32)
#@gui : Y-Multiplier = float(7,0,32)
#@gui : Z-Multiplier = float(0,0,32)
#@gui : sep = separator()
#@gui : X-Offset = float(0,0,1)
#@gui : Y-Offset = float(0,0,1)
#@gui : Z-Offset = float(0,0,1)
#@gui : sep = separator()
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : sep = separator()
#@gui : Thickness = float(0,0,50)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/18/04</i>.</small>")
fx_lissajous :
repeat $! l[$>] to_rgba
{w},{h}
f3d {0.5*max(w,h)/tan($4*pi/360)}
lissajous3d $1,$5,$8,$6,$9,$7,$10
r3d. 0,0,1,$13 r3d. 0,1,0,$12 r3d. 1,0,0,$11
*3d. {0.5*$2*{-2,w}},{0.5*$3*{-2,h}},{0.5*$4*max({-2,w},{-2,h})}
col3d. 1 j3d.. .,50%,50%,0,1,1,0,0 rm.
distance. 1 >. $14% *.. . ==. 0
r. 100%,100%,1,4
sh. 0 *. $15 rm.
sh. 1 *. $16 rm.
sh. 2 *. $17 rm.
sh. 3 *. $18 rm.
+[-2,-1]
endl done
#@gui Mandelbrot - Julia Sets : fx_mandelbrot, fx_mandelbrot_preview
#@gui : X0 = value(-2)
#@gui : Y0 = value(-2)
#@gui : X1 = value(2)
#@gui : Y1 = value(2)
#@gui : note = note{"<small><b>Fractal Type:</b></small>"}
#@gui : Fractal Set = choice("Mandelbrot","Julia")
#@gui : Iterations = int(1024,16,65535)
#@gui : X-Seed (Julia) = float(0.317,-2,2)
#@gui : Y-Seed (Julia) = float(0.03,-2,2)
#@gui : sep = separator(), note = note{"<small><b>Colormap:</b></small>"}
#@gui : Number of Colors = int(16,2,2048)
#@gui : Smoothness = int(8,1,256)
#@gui : Seed = int(255,0,65536)
#@gui : sep = separator(), note = note{"<small><b>Navigation:</b></small>"}
#@gui : Zoom Center = point(50,50,0,0,255,255,255,200)
#@gui : Zoom Factor = float(0.25,0,1)
#@gui : Zoom In = button()
#@gui : Center = button()
#@gui : Zoom Out = button()
#@gui : Display Coordinates = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/06/27</i>.</small>")
fx_mandelbrot :
if {!narg($_size)} _size={max(w,h)} fi
rm $_size,$_size
mandelbrot ${1-4},$6,{$5?[1,$7,$8]:[0,0,0]}
srand $11 $9,1,1,3 rand. 0,255 r. {$9*$10},1,1,3,3 point. 0 map.. .,3 rm.
fx_mandelbrot_preview :
_size={min(${-gui_preview_wh})}
if {"$15 || $16 || $17"}
x0,y0,x1,y1={"P0 = [${1,2}]; dP = [${3,4}] - P0; C = P0 + [${12,13}]%*dP; zfact = $14*($15?1:$16?0:-2); dC = 0.5*dP*(1 - 0.98*zfact); [C - dC,C + dC]"}
status=\{$x0\}\{$y0\}\{$x1\}\{$y1\}\{$5\}\{$6\}\{$7\}\{$8\}\{$9\}\{$10\}\{$11\}\{50,50\}\{$14\}\{0\}\{0\}\{0\}\{$18\}
px,py=50
else
x0,y0,x1,y1=${1-4}
status=
px,py=${12,13}
fi
fx_mandelbrot $x0,$y0,$x1,$y1,${5--1}
x0r,y0r,x1r,y1r={"C = ["$px,$py"]%*w; dC = 0.5*w*(1 - 0.98*$14); round([C - dC, C + dC - 1])"}
rectangle $x0r,$y0r,$x1r,$y1r,0.7,0xF0F0F0F0,255,255,255,255
rectangle $x0r,$y0r,$x1r,$y1r,0.7,0x0F0F0F0F,0,0,0,255
if $18 to "C0 = ( "$x0" , "$y0" )\nC1 = ( "$x1" , "$y1" )",2,2,16 fi
u $status
#@gui Neon Lightning : fx_neon_lightning, fx_neon_lightning(1)
#@gui : Source (%) = point(50,50)
#@gui : R0 = float(0,0,100)
#@gui : Destination (%) = point(50,50)
#@gui : R1 = float(100,0,100)
#@gui : sep = separator()
#@gui : Density = int(50,1,512)
#@gui : Glow = float(0.7,0,5)
#@gui : Thickness = float(3,0,20)
#@gui : sep = separator()
#@gui : Color = color(130,80,50)
#@gui : Color Dispersion = float(0.25,0,1)
#@gui : Transparency = float(0,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/30/06</i>.</small>")
fx_neon_lightning :
d={$13*255}
repeat $! l[$>]
100%,100%,1,4 rm[0]
repeat $7
x0={max(0,min(w,$1+u(-$3,$3)))} y0={max(0,min(h,$2+u(-$3,$3)))}
x1={max(0,min(w,$4+u(-$6,$6)))} y1={max(0,min(h,$5+u(-$6,$6)))}
u0={u(0,100)} v0={u(0,100)} u1={u(0,100)} v1={u(0,100)}
R={max(0,min(255,u($10-$d,$10+$d)))}
G={max(0,min(255,u($11-$d,$11+$d)))}
B={max(0,min(255,u($12-$d,$12+$d)))}
spline $x0%,$y0%,$u0%,$v0%,$x1%,$y1%,$u1%,$v1%,1,$R,$G,$B,1
done
s c,-3
b[0] 3%
distance. 1 *. -1 c. -{$9+1e-5},0 n. 0,1 sqrt.
+b. $8%,1 n. 0,1 sqrt. n[-2,-1] 0,255 max[-2,-1]
. blend[0,1] value
smooth 5,0,1,0.5,2,10,0
/. 255 ^. $14 *. 255
a c c 0,255
endl done
#@gui Plasma : fx_plasma, fx_plasma(0)
#@gui : Alpha = float(0.5,0,5)
#@gui : Beta = float(0,0,100)
#@gui : Scale = int(8,2,10)
#@gui : Randomize = bool(0)
#@gui : Transparency = bool(0)
#@gui : Color Balance = color(128,128,128)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/20/03</i>.</small>")
fx_plasma :  skip ${4=0},${5=0}
if $5 to_rgba else to_rgb fi
if $4 rand 0,255 fi
plasma $1,$2,$3 n 0,255
balance_gamma ${6-8}
#@gui Pythagoras Tree : samj_Arbre_Pythagore , samj_Arbre_Pythagore_preview
#@gui : sep = separator(), url = link("Source code from rosettacode.org","https://rosettacode.org/wiki/Pythagoras_tree")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(95,0,100)
#@gui : Depth = int(11,1,14)
#@gui : Dimension [Diff] = Float(12,4,100)
#@gui : Color = color(255,0,0,255)
#@gui : Color Variation [Random -1] = int(20,-1,255)
#@gui : Rendering = choice("A","B","C")
#@gui : Dilatation = int(1,1,8)
#@gui : Rotate Tree = Float(0,-180,180)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [Antialias] = bool(0)
#@gui : Amplitude = float(0.25,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/20</i>.</small>")
samj_Arbre_Pythagore :
-repeat $! -l[$>]
x1={round({{w}/100*$1})}
y1={round({{h}/100*$2})}
depth_max=$3
diff={round({{w}/$4})}
R_a=$5
V_a=$6
B_a=$7
A_a=$8
Variation_Couleur=$9
Rendu=$10
Dilatation=$11
Rotation=$12
Validation_Smooth_Antialias=$13
V_Amplitude=$14
V_Edge_Threshold=$15
V_Smoothness=$16
-to_rgba[-1]
{w},{h},1,4
#  -samj_pythagoras_tree  x1 , y1 , x2 , y2 , depth , R_a , V_a , B_a , A_a , Variation_Couleur , depth_max , Rendu
-samj_pythagoras_tree[-1] {$x1-$diff},$y1,{$x1+$diff},$y1,0,$R_a,$V_a,$B_a,$A_a,$Variation_Couleur,$depth_max,$Rendu
-if {$Rotation!=0} -rotate[-1] $Rotation -endif
-dilate[-1] $Dilatation
-if {$Validation_Smooth_Antialias==1} -fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness -endif
-blend[-1,-2] alpha
-endl -done
samj_Arbre_Pythagore_preview :
-gui_split_preview "-samj_Arbre_Pythagore $*",$-1
samj_pythagoras_tree :
x1=$1
y1=$2
x2=$3
y2=$4
depth=$5
R_DT=$6
V_DT=$7
B_DT=$8
A_DT=$9
Variation_Couleur=$10
depth_max=$11
Rendu=$12
-if {$depth<$depth_max}
dx={$x2-$x1}
dy={$y1-$y2}
x3={$x2-$dy}
y3={$y2-$dx}
x4={$x1-$dy}
y4={$y1-$dx}
x5={$x4+{{$dx-$dy}/2}}
y5={$y4-{{$dx+$dy}/2}}
-if {$Variation_Couleur<0}
R_DT={round(u(0,255))}
V_DT={round(u(0,255))}
B_DT={round(u(0,255))}
-elif {$Variation_Couleur>0}
R_DT={$Variation_Couleur+$R_DT}
V_DT={$Variation_Couleur+$V_DT}
B_DT={$Variation_Couleur+$B_DT}
-if {$R_DT}>255}
R_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-if {$V_DT}>255}
V_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-if {$B_DT}>255}
B_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-endif
-if {$Rendu==0}
-line[-1] $x1,$y1,$x2,$y2,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x2,$y2,$x3,$y3,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x3,$y3,$x4,$y4,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x4,$y4,$x1,$y1,1,$R_DT,$V_DT,$B_DT,$A_DT
-elif {$Rendu==1}
-if {{($depth%2)}==0}
-line[-1] $x1,$y1,$x2,$y2,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x2,$y2,$x3,$y3,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x3,$y3,$x4,$y4,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x4,$y4,$x1,$y1,1,$R_DT,$V_DT,$B_DT,$A_DT
-else
-line[-1] $x1,$y1,$x2,$y2,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-line[-1] $x2,$y2,$x3,$y3,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-line[-1] $x3,$y3,$x4,$y4,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-line[-1] $x4,$y4,$x1,$y1,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-endif
-elif {$Rendu==2}
-if {{($depth%2)}==0}
-line[-1] $x1,$y1,$x2,$y2,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-line[-1] $x2,$y2,$x3,$y3,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-line[-1] $x3,$y3,$x4,$y4,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-line[-1] $x4,$y4,$x1,$y1,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
-else
-line[-1] $x1,$y1,$x2,$y2,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x2,$y2,$x3,$y3,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x3,$y3,$x4,$y4,1,$R_DT,$V_DT,$B_DT,$A_DT
-line[-1] $x4,$y4,$x1,$y1,1,$R_DT,$V_DT,$B_DT,$A_DT
-endif
-endif
-samj_pythagoras_tree[-1] $x4,$y4,$x5,$y5,{$depth+1},$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$depth_max,$Rendu
-samj_pythagoras_tree[-1] $x5,$y5,$x3,$y3,{$depth+1},$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$depth_max,$Rendu
-endif
#@gui Quick Copyright : fx_quick_copyright, fx_quick_copyright(0)
#@gui : Text = text{"\\251 G'MIC"}
#@gui : Size = int(27,13,128)
#@gui : Color = color(255,255,255,128)
#@gui : Outline = int(1,0,4)
#@gui : Position = choice(3,"Up-Left","Up-Right","Bottom-Left","Bottom-Right")
#@gui : Offset = int(5,0,40)
#@gui : Orientation = choice(1,"-90 deg.","0 deg.","+90 deg.","+180 deg.")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_quick_copyright :
i[0] 0 t[0] "$1",0,0,$2,1,$3,$4,$5 autocrop[0] 0 r[0] {{0,w}+2*$7},{{0,h}+2*$7},1,3,0,0,0.5,0.5
i[1] 0 t[1] "$1",0,0,$2,1,1 autocrop[1] 0 r[1] {{1,w}+2*$7},{{1,h}+2*$7},1,1,0,0,0.5,0.5 dilate[1] {1+2*$7}
rotate[0,1] {90*($10-1)}
repeat {$!-2}
if {$8==0} j. [0],$9,$9,0,0,{$6/255},[1]
elif {$8==1} j. [0],{w-1-{0,w}-$9},$9,0,0,{$6/255},[1]
elif {$8==2} j. [0],$9,{h-1-{0,h}-$9},0,0,{$6/255},[1]
else j. [0],{w-1-{0,w}-$9},{h-1-{0,h}-$9},0,0,{$6/255},[1]
fi
mv. 2 done
rm[0,1]
#@gui Rainbow : fx_rainbow, fx_rainbow
#@gui : Left Position = float(80,0,100)
#@gui : Right Position = float(80,0,100)
#@gui : Left Slope = float(175,0,400)
#@gui : Right Slope = float(175,0,400)
#@gui : Thinness = float(3,0.1,8)
#@gui : Opacity = float(80,0,199)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_rainbow :
repeat $! l[$>]
100%,100% spline. 0,$1%,100,{-$3}%,100%,$2%,100,$4%,1,1
flood. 0,0,0,0,0,1,1 flood. {w-1},0,0,0,0,1,1
distance. 0 c. 0,255 n. 0,{$5*255}
rainbow_lut +luminance. c. 0,{min(100,200-$6)}% n. 0,255 a[-2,-1] c
map.. . rm.
if {$6<100} sh. 3 *. {$6/100} rm. fi
blend alpha
endl done
#@gui Shade Bobs : fx_shadebobs, fx_shadebobs
#@gui : note = note("<small>Bobs parameters :</small>")
#@gui : Density = int(50,1,200)
#@gui : Radius = int(5,1,100)
#@gui : Duration = int(200,1,500)
#@gui : Velocity = float(1,0,10)
#@gui : sep = separator()
#@gui : note = note("<small>Curve parameters :</small>")
#@gui : Rx = float(-1,-3,3)
#@gui : Ry = float(2,-3,3)
#@gui : Rz = float(1,-3,3)
#@gui : Rt = float(0.8,-3,3)
#@gui : Rcx = float(0,-3,3)
#@gui : Colormap = choice(8,"Grayscale","Standard","HSV","Lines","Hot","Cool","Jet","Flag","Cube")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/18/04</i>.</small>")
fx_shadebobs :
channels 0 f 0
repeat $! l[$>]
t=0
repeat $3
repeat $1
r={$6+$5*cos(6*$7*$t)+(1-$5)*sin(6*$8*$t)}
a={(360*sin($7*$t)+30*$6*$>)*pi/180}
ax={2*$>*pi/$1+$t}
cx={(1+$9*cos($ax)+$r*cos($a))*w/2}
cy={(1+$9*sin($ax)+$r*sin($a))*h/2}
ellipse. $cx,$cy,$2%,$2%,0,-1,1
done
t+={$4%}
done
endl done
& 255 if $10 map {$10-1} fi
#@gui Snowflake 2 : samj_en_Flocon_De_Neige, samj_en_Flocon_De_Neige(1)
#@gui : note = note("<small>Ah! comme la neige a neig&#233;! <i>Soir d'hiver / &#278;mile Nelligan</i></small>")
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rays = int(6,3,12)
#@gui : Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Radius Middle Circle = float(40,1,100)
#@gui : Tilt = float(0,0,360)
#@gui : Contours Recursion = int(3,0,5)
#@gui : Contours = color(192,192,192)
#@gui : Opacity Contours = float(1,0,1)
#@gui : Display Contours = choice(0,"Non / No","Contours + Flocon/Snowflake","Contours")
#@gui : Snowflake Recursion = int(3,0,5)
#@gui : Snowflake = color(255,255,255)
#@gui : Opacity Snowflake = float(0.7,0,1)
#@gui : Type Snowflake = choice(0,"A","B","C","A2","B2","C2")
#@gui : Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Shadow = bool(0)
#@gui : X-Shadow = float(0.5,-5,5)
#@gui : Y-Shadow = float(0.5,-5,5)
#@gui : Smoothness Shadow = float(1.8,0,5)
#@gui : Curvature Shadow = float(0,0,1)
#@gui : Shadow Offset X = float(0,-20,20)
#@gui : Shadow Offset Y = float(0,-20,20)
#@gui : Alpha Channel = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2014/04/24</i>.</small>")
samj_en_Flocon_De_Neige :
-samj_Flocon_De_Neige $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32
#@gui Spiral : mathmap_spiral, mathmap_spiral
#@gui : Rotations = float(5,0,20)
#@gui : Time = float(0,0,1)
mathmap_spiral:
q="sin(rmath*$1*pi*2-amath+$2*2*pi)*0.5+0.5"
mathmap_grayColor $q
mathmap_xy:
e[^-1] "mathmap xy: fonction with formulas : "$1" and "$2"."
v -
repeat $! local[$>]
{w},{h},1,1 [-1] reverse
fill[0] "H=2*h/max(w,h);W=2*w/max(w,h);x0=(w-1)/2+1e-10; y0=(h-1)/2; xmath=(x-x0)*W/w;  ymath=-(y-y0)*H/h; ($1)*w/W+x0"
fill[1] "H=2*h/max(w,h);W=2*w/max(w,h);x0=(w-1)/2+1e-10; y0=(h-1)/2; xmath=(x-x0)*W/w;  ymath=-(y-y0)*H/h; -($2)*h/H+y0"
a[0,1] c
warp[-1] [0],0,1,0
k[-1]
endlocal done
v +
mathmap_ra:
e[^-1] "mathmap ra: fonction with formulas : "$1" and "$2"."
v -
repeat $! local[$>]
{w},{h},1,1 [-1] reverse
fill[0] "x0=(w-1)/2+1e-10; y0=(h-1)/2; rmath=((x-x0)^2+(y-y0)^2)^0.5*2/w; amath=(atan(-(y-y0)/(x-x0))+pi/2*(sign(x-x0)-1))%(2*pi); x0+($1)*x0*cos($2)"
fill[1] "x0=(w-1)/2+1e-10; y0=(h-1)/2; rmath=((x-x0)^2+(y-y0)^2)^0.5*2/w; amath=(atan(-(y-y0)/(x-x0))+pi/2*(sign(x-x0)-1))%(2*pi); y0-($1)*x0*sin($2)"
a[0,1] c
warp[-1] [0],0,1,0
k[-1]
endlocal done
v +
mathmap_grayColor:
e[^-1] "mathmap grayColor: fonction with formulas : "$1"."
v -
repeat $! local[$>]
resize 100%,100%,1,1
fill "H=2*h/max(w,h);W=2*w/max(w,h);x0=(w-1)/2+1e-10; y0=(h-1)/2; rmath=((x-x0)^2+(y-y0)^2)^0.5*2/w; amath=(atan(-(y-y0)/(x-x0))+pi/2*(sign(x-x0)-1))%(2*pi); ($1)"
n 0,255 to_rgba
endlocal done
v +
#@gui Spiral RGB : spiral_RGB, spiral_RGB_preview(1)
#@gui : Red Rotations = int(1,1,20)
#@gui : Green Rotations = int(3,0,20)
#@gui : Blue Rotations = int(5,0,20)
#@gui : Counter Clockwise = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small>This filter is based on a conversion of a Mathmap script originally written by Nevit Dilmen</small>")
#@gui : note = note("<small>Create fun spirals with the size and aspect ratio of the input image.</small>")
spiral_RGB_preview :
-spiral_RGB ${1--1}
spiral_RGB :
-repeat $! -l[$>]
-sh. 0
-f. "
begin(
red_rotations=$1;
green_rotations=$2;
blue_rotations=$3;
if ($4==1,direction=-1,direction=1);
);
X=(2*x/(w-1))-1;
Y=1-(2*y/(h-1));
a=atan2(Y,X);
if (a<0,a=a+(2*pi));
r=sqrt(X*X+Y*Y);
RRR=sin(r*red_rotations*pi*2+a*direction+2*pi)*0.5+0.5;
GGG=sin(r*green_rotations*pi*2+a*direction+2*pi)*0.5+0.5;
BBB=sin(r*blue_rotations*pi*2+a*direction+2*pi)*0.5+0.5;
i(#0,x,y,0,1)=GGG*255;
i(#0,x,y,0,2)=BBB*255;
RRR*255"
-rm.
-endl -done
#@cli shape_dragonfly : _size>=0
#@cli : Input a 2d dragonfly binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_dragonfly ,
shape_dragonfly : check "${1=512}>=0"
e[^-1] "Input a $1x$1 dragonfly binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBpbnQgbGl0dGxlX2VuZGlhbgoxIDEyMTcgMSAxICMxNjQyCniczZhnjFVFGIYvJVGRJgLSpfcOS28uvSiKgoKioogURSFWFMUGsTcEwW7UoAaixIogRUClCCxV2sLugkAwKLhIkXt835znhsnN8ss//tg8eb5vzjkzc2a+M3cThROJhP4KJeK/BHykQxSdL16YjKKSYmmxjFhOLC9WECuKlcXKYlWxqlhNrCZWF6uLNcWaYi1YW6wt1hHriPXEurCeWB82EBuIDcWGYqOAjcTGsInYRGxaAJuKzWBzsbnYImALsWUaW4mtxNYFsLWYAduIGbCN2LYAthXbi+3OwfZiR7FDwE5iR9hJ7CJ2DthV7CJ2E7vCbmKmeJnYXcwUe4jdA/YUe4i9xJ5ib7G32FfsI74hFhe/i6KoL15OXCHvh1cQf8JnyyuJa+T98SriOvkA3Othg/xycRbrYiP+Or5ZfgXu9bJNPlCcif8aeA1xh/xKcQa+M8134a+x3nbj08mne7b8Ksbpdb+O52bTzuMr634ofmkQXx/F493JOLLpZ1bEc4nvIe5x1rcTzyG+RWws7iWeS9zz4HWaQ3/2M0+eD6+/XMZ3kPncHsXrKpf99Ttxz09H4t5nf/B+PA9dub/jR3mPHkcm/XH8L963x+F1sysZz9PJKN73x1kve6N4HW2iHpzAc7h+I+vjVBSvu1z6kcU6+UfeS8xjnFnMx5koXrd5zPsGxW8V98kH+T3Ib8avwW9ivobwPm/ArxN/kQ8Vf5NfL66VXysekA/3+07G9/G8+r6rk/H6OBTFz12VjPt3WD7K+yEZz5vne4y4kn3leR7vdcW+8/xOFJezX4/J7xOXsc/z5ZPEpdSFv+WTxe+pN57vx/GWzONTtM9gnqbx/BX082fGs4pxr2V+1jG/6+EG3lsW3Oh1KW6Cm8WtAbd4fTJPQjQFH8J7dL+3M8/u54PsH8/3afn9+I34vbQfwfUTyY/E78JH4XfiY/Cx+BD6U5b5GE3c60oaXUT8Yq4bxXN7B/l/guv9/B2sn1TcHEG8L9eVZRyp67xuXBf6kS+fdv1w9tEA8pcQL8f1fl4268z5imnXe15dRwYy3kpp11/L/r0Sr5J2vd+b9/0gPD3veJ7yg/Fq8GLG6efuT8b7yfHqPCc1D/3JD8VrpF3veTvAvNprBe/lFHXmQLA+agfXn6I+HWLf2+uSL8M+6UL+FvL1uE8q3578beQbBNe7nnl/HWS9uX2jIJ9PvT7I+juJn2b9/Ml4PP6x5JsGedcJf0ddj8cl4jrZLMgvUPwO4s3pn+Pe9+OJp/Z/aXEJcdeLVkF715m7iWcE7VcS9zjbBO1/VnwC8bb02/HVQbxdEF9LPJ/5PEHc9WUi8Q5BfAPt/T3pSL/cn43EXQ87EXf7zUH7ztzP7bfQ/2O853zabwviXbnO7b3/XT+OEj9GfDvz5vfVjXxp9rXn3/X7srT4uCBulmKf+z0fYV0eIe79fTvvOxP6HL2bdWX3d+Ew8Wzq3WHWfxh3vTlE/BDxPXzn/J3qBUsQ977y96w3dHvXg2GJ+LvXB6bau27uI74/uL+/eznE82i/m++dzwP9iJdkvB7PTuI5xP1evJ62UBdS8fWcL1LnxT3EH6IuZuMP47vwR6mLKZ+C78Afx7fjT+Db8KnUza34tOTZ85n9aXwT/ix1NAt/Pnn2/Of5eAFfh7/EvK3FX8HX4K/iq/AZ1GGfq33+non/SH4WvoL8bHw5+bfkV4vLyL+NLyX/Lr6Y/Pt8txfhH+AL8Q9p/y0+h/w3+Mf4V/intP+C583F55Ofh39O/jP6P4/8fPJzyX9B/hPyXzJfc8h/jX9E/hvm/wPyC3h/7+ELef/v4IuS8bn4TXwx63kWvoTv9gzc5yuv/+m8/x84L7xMfjnnixfJu756nz5H3u7fX8+Q93nR9WAaebvryVTcdbib+CTtfY5znXuMvOux6+Rkxm93nZ2E+7znOv0A7jrtOn8P7nOgz5MT5Bfi/t07nrz3pb9HY3HXbf+eHh24f4ePxH1+9Pd1ROD+Xg/HXd/9/R9G/32+9HliSJD3+WZQkPd56Yog7/rbN7h/MbF70J8iYhfc/68wiyfPusdZDKZ7Me6X7hecI/5/87Cf/9XT5+W8RHz+LMK82ZN4cfxM4IVoXzQRn5ccL0Hc7fyvptPESyZjP048dOdLBV4U933yC8ify83CsEgyvk+KReHg9lH0L+17LGAxIDI1IDEgMSAjNjIKeJxzZ2Bg8AXiKAYIiAZiIyBOAWIFKF0ExIlAnA7E+UCcB8RpQJwDxJVQdcVAnAFVVwDEqUAcCzUTAKELCFQ="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d dragonfly shape]" v +
#@gui Superformula : fx_superformula, fx_superformula(1)
#@gui : Resolution = int(4096,2,8192)
#@gui : sep = separator()
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : sep = separator()
#@gui : M = int(8,1,32)
#@gui : N1 = float(1,-32,32)
#@gui : N2 = float(5,-32,32)
#@gui : N3 = float(8,-32,32)
#@gui : sep = separator()
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : sep = separator()
#@gui : Thickness = float(3,0,50)
#@gui : Color = color(128,255,128,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/18/04</i>.</small>")
fx_superformula :
repeat $! l[$>] to_rgba
{w},{h}
f3d {0.5*max(w,h)/tan($4*pi/360)}
superformula3d $1,${4-7}
r3d. 0,0,1,$10 r3d. 0,1,0,$9 r3d. 1,0,0,$8
*3d. {0.5*$2*{-2,w}},{0.5*$3*{-2,h}}
col3d. 1 j3d.. .,50%,50%,0,1,1,0,0 rm.
distance. 1 >. $11% *.. . ==. 0
r. 100%,100%,1,4
sh. 0 *. $12 rm.
sh. 1 *. $13 rm.
sh. 2 *. $14 rm.
sh. 3 *. $15 rm.
+[-2,-1]
endl done
#@gui Turbulence : fx_turbulence, fx_turbulence
#@gui : Radius = float(128,1,1024)
#@gui : Octaves = int(6,1,12)
#@gui : Damping per Octave = float(4,1,10)
#@gui : Difference Mixing = float(0,-10,10)
#@gui : Mode = choice("Turbulence","Turbulence 2","Fractal Noise","Fractured Clouds","Stardust","Pea Soup")
#@gui : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_turbulence :
remove_opacity turbulence ${^0}
fx_animate_preview : skip ${4=1},${5=0},${6=$5}
repeat $!
if $5 width=$5 else width={w} fi
if $6 height=$6 else height={h} fi
if $4 s. x,2 else . fi
-$1.. $2 -$1. $3
r[-2,-1] {max(w,{-2,w})},{max(h,{-2,h})},1,100%,3
if {!$4} columns.. 0,50% columns. 50%,100% fi
a[-2,-1] x r. $width,$height,1,100%,2 drgba.
line. 50%,0,50%,100%,1,0,0,0,255
to. "Start",3,-1,13,2,1,255 to. "End",{w-24},{h-18},13,2,1,255
mv. 0 done
#@gui Twisted Rays : Twisted_Rays_en, Twisted_Rays_en(1)
#@gui : note = note("<span foreground="orangered"><b>Resulting Image</b></span>")
#@gui : Dimensions Pixels = int(800,256,1920)
#@gui : Delete Layer Source = bool(1)
#@gui : Twirl = float(0.2,-5,5)
#@gui : Blend Rays = choice(2,"Add","And","Average","Darken","Difference","Edges","Grainextract","Grainmerge","Multiply","Negation","Or","Screen","Softburn","Softdodge","Subtract","Xor","- NO -")
#@gui : Rendu = choice(5,"Rays Colors AB","Rays Colors ABC","Rays Colors ABCD","Rays Colors ABCDE","Rays Colors ABCDEF","Rays Colors ABCDEFG")
#@gui : note = note("<span foreground="orangered"><b>Colored Rays</b></span>")
#@gui : Number Of Rays = int(21,3,360)
#@gui : Offset Angle Rays Layer 1 = float(0,-360,360)
#@gui : Offset Angle Rays Layer 2 = float(0,-360,360)
#@gui : Color A = color(0,0,255,255)
#@gui : Color B = color(0,255,255,255)
#@gui : Color C = color(0,255,0,255)
#@gui : Color D = color(255,255,0,255)
#@gui : Color E = color(255,0,0,255)
#@gui : Color F = color(255,0,255,255)
#@gui : Color G = color(255,255,255,255)
#@gui : Random Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Contours = color(0,0,0,255)
#@gui : Display = bool(0)
#@gui : Dilate = int(2,1,16)
#@gui : Blur = float(2,0,5)
#@gui : Sharpen = int(0,200,400)
#@gui : note = note("<span foreground="orangered"><b>Symmetrizoscope</b></span>")
#@gui : Activer Symmetrizoscope = bool(0)
#@gui : Iterations = int(5,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Symmetry Sides = choice("Backward","Forward","Swap")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/04/27</i>.</small>")
Twisted_Rays_en:
-Twisted_Rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49
#@gui Wiremap : gcd_wiremap, gcd_wiremap(1)
#@gui : note = note("<i>Turn an image into a wireframe map</i>"), sep = separator()
#@gui : Segments = int(100,4,400)
#@gui : Depth = int(100,4,400)
#@gui : Smoothness = float(0.5,0,2)
#@gui : Distance = float(0.5,-2,2)
#@gui : Output = choice("Black &amp; White","Color","Transparent Black &amp; White","Transparent Color")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/01/27</i>.</small>")
#@gui : note = note("<small>\n<b>Warning:</b> can be extremely slow with high segments!</small>")
#@gui : note = note("<small>Lower layer will be used for color if available.</small>")
gcd_wiremap : -skip ${1=100},${2=100},${3=0.5},${4=0.5},${5=0}
dm={$!>1" && "$5%2}
-l[${-arg\ 1+$dm,0,0-1}]
-if {$dm} op=0
-if {s==2||s==4} -split_opacity. -rv[^0] op=1 -remove_opacity[0]
-elif {0,s==2||s==4} -split_opacity[0] op=1 -endif
-else -split_opacity op={$!>1} -endif
--norm[0] -b. $3% -n. 0,$2 -*. -1 w={w/2} h={h/2}
-r. $1,{round(h/w*$1)},1,3,2 v={w*h} p={(w-1)*h+(h-1)*w} ln={h}
-sh. 0 -f. x -n. -$w,$w -rm.
-sh. 1 -f. y -n. -$h,$h -rm. -permute. cxyz -y.
(67.5;73.5;109.5;103.5;51.5;100.5)
($v;$p)
{($1-1)*2},$ln,1,1,if(x%2,-1,2) {($1-1)*2},$ln,1,1,"y*$1+round(x/2)"
-a[-2,-1] c -permute. cxyz -discard. -1
{($ln-1)*2},$1,1,1,if(x%2,-1,2) {($ln-1)*2},$1,1,1,"round(x/2)*$1+y"
-a[-2,-1] c -permute. cxyz -discard. -1 -a[-2,-1] y
-if {$5%2}
--r[{$dm?$dm+$op:0}] $1,{0,round(h/w*$1)},1,3,3 --z. 0,0,100%,{h-2}
-permute. cyxz -z.. 0,0,{-2,w-2},100% -permute.. cxyz -y[-2,-1] -a[-2,-1] y
-else 1,{$p*3},1,1,255 -endif
-if {$op}
--r[1] $1,{0,round(h/w*$1)},1,1,3 -gt. 1 --z. 0,0,100%,{h-2} -permute. cyxz
-z.. 0,0,{-2,w-2},100% -permute.. cxyz -y[-2,-1] -a[-2,-1] y -rm[1]
-else 1,$p,1,1,1 -endif
-mv[-6] -3 -a[-6--1] y
-if {$5>1}
-f[0] 0 -to_a[0] -sh[0] 100% -f. 255
-j3d[0] [-2],50%,50%,{$2*$4},1,1,1,0 -negate. -rm[-2,-1]
-else -f[0] 0 -j3d[0] [-1],50%,50%,{$2*$4},1,1,1,0 -rm. -endif
-endl
#@gui _
#@gui <b>Repair</b>
#@gui Anti Alias : gcd_anti_alias, gcd_anti_alias_preview(0)
#@gui : note = note("<i>Selectively smooth resizing pixelation</i>"), sep = separator()
#@gui : Smooth Amount = int(60,0,200)
#@gui : Edge Exponent = float(0.3,0,10)
#@gui : Lighten Edges = int(50,0,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_anti_alias : -skip ${1=10},${2=0.3},${3=10}
-repeat $! -l[$>]
-remove_opacity[-1]
--smooth[0] $1,0,1,1.6,1.1,0.8,30,0.6
--gradient_norm[0] --n[-1] 0,$3 -add[0,-1]
-pow[-1] $2 -n[-1] 0,255
--gradient_norm[-1] -pow[-1] $2 -n[-1] 0,255
-blend[-2,-1] overlay -append[-2,-1] c
-blend[0,1] alpha -c 0,255
-endl -done
gcd_anti_alias_preview :
-gui_split_preview "-gcd_anti_alias ${1--2}",$-1
gcd_srgb2jpeg :
-repeat $! -l[$>]
-if {s<3} -continue -endif
-if {s==4} -split_opacity -endif
-mix_rgb[0] 0.299,0.587,0.114,-0.1687,-0.3313,0.5,0.5,-0.4187,-0.0813
-sh[0] 1,2 -+[-1] 128 -rm[-1] -a c
-endl -done
gcd_jpeg2srgb :
-repeat $! -l[$>]
-if {s<3} -continue -endif
-if {s==4} -split_opacity -endif
-sh[0] 1,2 --[-1] 128 -rm[-1]
-mix_rgb[0] 1,0,1.402,1,-0.34414,-0.71414,1,1.772,0 -a c
-endl -done
gcd_srgb2luma :
-repeat $! -l[$>]
-remove_opacity
-if {s!=3} -continue -endif
-sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
-*[1] 0.299 -*[2] 0.587 -*[3] 0.114
-+[1-3] -rm[1] -channels[0] 0
-endl -done
gcd_srgb2luminance :
-repeat $! -l[$>]
-remove_opacity
-if {s!=3} -continue -endif
-srgb2rgb[0] -sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
-*[1] 0.2126 -*[2] 0.7152 -*[3] 0.0722
-+[1-3] -rm[1] -channels[0] 0
-endl -done
gcd_gamma : -skip ${1=1},${2=0},${3=255}
-if {$1==1} -return -endif
-repeat $! -l[$>]
-if {!$2} g={1/max($1,0.001)} -^ $g -* {$3^(1-$g)}
-else -* -1 -+ $3 -max 0 -^ $1 -* {-$3^(1-$1)} -+ $3 -endif
-endl -done
gcd_sbezier : -skip ${1=0.5},${2=255}
-repeat $! -l[-1] -/ $2 --sqr -*. {1-2*$1} -*.. {2*$1} -+ -* $2 -endl -done
gcd_ibezier : -skip ${1=0.5},${2=255}
-if {$1==0.5} -return -endif
-repeat $! -l[-1]
d={1-2*$1} e={$1/$d} -/ {$2*$d} -+ {$e*$e}
-sqrt. -* {$1>0.5?-1:1} -- $e -* $2
-endl -done
gcd_label : -skip ${1=4},${2=0.067}
-repeat $! -l[$>]
-label[-1] $1,1 nb={1+iM}
--histogram[-1] $nb,0,{$nb-1}
--map[-2] [-1] -rm[-2]
-le[-1] {$2%*w*h} -*[-1] 255
-inpaint[-2] [-1] -rm[-1]
-endl -done
gcd_shrink :
_gcd_w={0,w} _gcd_h={0,h}
-repeat $! -l[$>] -if {max(w,h)>700} -rr2d[-1] 700,700,0,1 -endif -endl -done
gcd_unshrink :
-repeat $! -l[$>] -r $_gcd_w,$_gcd_h -endl -done
gcd_fix_alpha :
-repeat $! -l[$>] -if {s==2||s==4}
-sh 0,{s-2} -sh[0] 100%,100% -max[-1] 1 --neq[-1] 1 -*[-3,-1] -k[0]
-endif -endl -done
#@cli gcd_noalpha
#@cli : Remove any gimp alpha channel and zero transparencies
gcd_noalpha :
-e[^-1] "Remove gimp alpha channel from image$?."
-v - -repeat $! -l[$>] -if {s==2||s==4}
m={s-2} -sh 0,$m -sh.. 100% -neq. 0 -*.. . -k[0] -channels 0,$m
-endif -endl -done -v +
#@cli gcd_splitalpha
#@cli : Split any gimp alpha channel and zero transparencies
gcd_splitalpha :
-e[^-1] "Split gimp alpha channel from image$?."
-v - -repeat $! -l[$>] -if {s==2||s==4}
m={s-2} -sh 0,$m -sh.. 100% [-1] -neq.. 0 -*[1,2] -k[^1] -channels.. 0,$m
-endif -endl -done -v +
#@cli gcd_force_rgb
#@cli : Force selected gimp images to be in RGB mode.
gcd_force_rgb :
-e[^-1] "Force gimp image$? to be in RGB mode."
-v - -repeat $! -l[$>]
-if {s>4} -v + -error[] "Command '-gcd_force_rgb': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {s==4} -sh 0,2 -sh.. 3 -neq. 0 -*.. . -k[0] -channels 0,2
-elif {s==2} -sh 0 -sh.. 1 -neq. 0 -*.. . -k[0] -channels 0 -r 100%,100%,100%,3
-elif {s==1} -r 100%,100%,100%,3
-endif
-endl -done -v +
#@cli gcd_force_rgba
#@cli : Force selected gimp images to be in RGBA mode.
gcd_force_rgba :
-e[^-1] "Force gimp image$? to be in RGBA mode."
-v - -repeat $! -l[$>]
-if {s>4} -v + -error[] "Command '-gcd_force_rgba': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {s==4} --channels 3 -neq. 0 -*
-elif {s==3} -channels 0,3 -sh. 3 -f. 255 -rm.
-elif {s==2} --channels 1 -neq. 0 -* -r 100%,100%,100%,4 -sh. 2 -f. .. -rm.
-elif {s==1} -r 100%,100%,100%,4 -sh. 3 -f. 255 -rm.
-endif
-endl -done -v +
#@cli gcd_force_a
#@cli : Force selected gimp images to have an alpha channel.
gcd_force_a :
-e[^-1] "Force gimp image$? to have an alpha channel."
-v - -repeat $! -l[$>]
-if {s==1||s==3} -channels 0,{s} -sh. {s-1} -f. 255 -rm.
-elif {s==2||s==4} --channels 100% -neq. 0 -* -endif
-endl -done -v +
#@cli gcd_srgb2rgb
#@cli : Convert from sRGB gamma to RGB by fast approximate.
gcd_srgb2rgb :
-e[^-1] "Convert image$? from sRGB gamma to RGB by fast approximate."
-v - -c 0,255 -* 257 -round 1 (0,255) -r. 65536,1,1,1,3 -srgb2rgb. -map[^-1] . -rm. -v +
#@cli gcd_rgb2srgb
#@cli : Convert from RGB to sRGB gamma by fast approximate.
gcd_rgb2srgb :
-e[^-1] "Convert image$? from RGB to sRGB gamma by fast approximate."
-v - -c 0,255 -* 257 -round 1 (0,255) -r. 65536,1,1,1,3 -rgb2srgb. -map[^-1] . -rm. -v +
#@cli gcd_extract_clut : _resolution_root,_smoothness,_nb_iterations>=0,_nb_randoms>=0
#@cli : Extract color LUT from selected images.
gcd_extract_clut : -skip ${1=8},${2=3},${3=5},${4=5}
-e[^-1] "Extract color LUT from image$?."
-v - -to_rgb b={int($1)^2} s={$b^1.5}
(0,1;0,1/0,1;0,1^0,0;1,1/0,0;1,1^0,0;0,0/1,1;1,1)
-*. 255 -r. $b,$b,$b,3,3 -r. $s,$s,1,3,-1
-repeat {$!-1} -l[$>,-1] nm="[CLUT: "{0,n}"]"
--matchpatch. ..,1,1,1,$3,$4 -warp[0] .,0
-rm. -r.. $b,$b,$b,3,-1 -b.. $2 -nm.. $nm
-endl -done -rm. -v +
#@cli gcd_geometric_median : size>=0,_nb_iter>=0
#@cli : Apply geometric median filter on vector-valued images.
#@cli : Default values: 'size=3' and 'nb_iter=12'.
#@cli : $ image.jpg +gcd_geometric_median 3
gcd_geometric_median : skip ${1=3},${2=12}
-e[^-1] "Apply geometric median filter of size $1, on image$?."
-v -
repeat $! l[$>]
[0] +boxfilter. {$1+1-$1%2} sh. 0
f. "*
begin(
const boundary = 1;
const N = int($1/2);
const W = N+1;
weightedSum = I(#1);
totalDist = weightedSum;
);
Y = I(#2,x,y);
for (iters = 0, iters<$2, ++iters,
weightedSum = 0;
totalDist = 0;
distSum = 0;
flag = 0;
for (j = -N, j<W, ++j,
for (k = -N, k<W, ++k,
X = J(#1,j,k);
diff = X - Y;
dist = norm2(diff);
if(dist==0, flag=1,
R = 1/dist;
weightedSum += R * X;
totalDist += R * diff;
distSum += R;
);
);
);
if(totalDist==0, break(),
bal = flag ? 1/norm2(totalDist) : 0;
Y = max(0, 1 - bal) * weightedSum / distSum + min(1, bal) * Y;1
)
);
I(#0,x,y) = Y;1" k[0]
endl done -v +
#@cli gcd_poisson_disk : _radius[%]>0,_value,_max_iters>0
#@cli : Add poisson disk sampling noise to selected images.
#@cli : Default values: 'radius=8', 'value=1' and 'max_iters=30'.
#@cli : $ 800,800 gcd_poisson_disk 8
gcd_poisson_disk : check "${1=8}>0 && ${3=30}>0" skip ${2=1}
e[^-1] "Add noise points to image$?, with specified minimum distance."
v - repeat $! l[$>]
R={${"is_percent $1"}?max(w,h,d)*$1:$1}
dim={d>1?3:h>1?2:1} cw={0.999*$R/sqrt($dim)}
({[w,h,d,1]}) y. c
{[ceil(I/$cw)]}
r[1] 1,1,1,$dim,-1
1,1,1,$dim 1,1,1,1
{vector$dim(2*ceil(sqrt($dim))+1)} r. 100%,100%,100%,2
f. "P=[x,y,z]-int([w/2,h/2,d/2]);[sum(sqr(P)),dot(P,[1,w#2,w#2*h#2])]"
r. {[whd,s,1,1,-1]} sort. +,x z. 0,1,100%,100% y. c
nm[1] dims nm[2] grid nm[3] samples nm[4] active nm[5] prox
eval ${-math_lib}"
const N = "$dim";
const radius = "$R";
const grid_cw = "$cw";
const max_sample_attempts = $3;
mag2(vec) = (sum(sqr(vec)));
prox = I#5;
lim = I#1;
dar_insert(#3,I#1,0);
dar_insert(#3,u(I#1),1);
dar_insert(#4,1,0);
I(#2,int(I[#3,1]/grid_cw)) = 1;
I(#0,I[#3,1]) = $2;
while (dar_size(#4)>0,
R = int(u(dar_size(#4)-1e-4));
P = i[#4,R];
T = I[#3,P];
for (attempts=0, attempts < max_sample_attempts, ++attempts,
do (S=4*(u(vectorN(1))-0.5); M=mag2(S), M <= 1 || M > 4);
X = T + radius * S;
if (min(X)<0 || min(lim-X)<0, continue());
G = int(X/grid_cw);
GI = dot(G,[1,w#2,w#2*h#2]);
for (K=0;rejected=0, K<size(prox), ++K,
V = i[#2,GI+prox[K]];
if (V>0 && mag2(I[#3,V]-X)<sqr(radius), rejected=1;break())
);
if (!rejected,
Q = dar_size(#3);
dar_insert(#3,X,Q);
dar_insert(#4,Q,dar_size(#4));
I(#2,G) = Q;
I(#0,X) = $2;
break();
);
);
if (attempts == max_sample_attempts, dar_remove(#4,R));
);
" k[0]
endl done v +
#@gui Banding Denoise : banding_denoise, banding_denoise_preview(0)
#@gui : V Cutoff = float(5,0,50)
#@gui : H Cutoff = float(5,0,50)
#@gui : Space = float(5,0,20)
#@gui : Value = float(10,0,100)
#@gui : Show Difference = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
banding_denoise:
-repeat 2 --bilateral[-1] $3,$4 -keep[0,-1] -done
--compose_grainextract[0,1]
-fftpolar[-1]
-polygon[-2] 4,0,{(h/2)+1},{50-$1}%,{(h/2)+1},{50-$1}%,{(h/2)-1},0,{(h/2)-1}
-polygon[-2] 4,{50+$1}%,{(h/2)+1},{w},{(h/2)+1},{w},{(h/2)-1},{50+$1}%,{(h/2)-1}
-polygon[-2] 4,{(w/2)+1},0,{(w/2)+1},{50-$2}%,{(w/2)-1},{50-$2}%,{(w/2)-1},0
-polygon[-2] 4,{(w/2)-1},{h},{(w/2)+1},{h},{(w/2)+1},{50+$2}%,{(w/2)-1},{50+$2}%
-ifftpolar[-1,-2]
-compose_grainmerge[1,2]
-keep[-1]
banding_denoise_preview:
-if {$5==0}
-banding_denoise ${1--1}
-else
--banding_denoise ${1--1}
-compose_grainextract[0,1]
--[-1] 128 -*[-1] 5 -+[-1] 128
-endif
#@gui Bayer Reconstruction : bayer2rgb, gui_no_preview
#@gui : G/M Smoothness = _float(6,0,20)
#@gui : R/B Smoothness (Principal) = _float(6,0,20)
#@gui : R/B Smoothness (Secondary) = _float(4,0,20)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Compression Blur : gcd_comp_blur, gcd_comp_blur_preview(0)
#@gui : note = note("<i>For subtle smoothing of compression artifacts</i>")
#@gui : sep = separator(), note = note("<small>1. Preview will <b>not</b> show the final result accurately.</small>")
#@gui : note = note("<small>2. Be sure to apply <b>before</b> any image resizing.</small>")
#@gui : note = note("<small>3. Reduce grid width when increasing divisions to avoid over-smoothing.</small>")
#@gui : note = note("<small>4. Set grid divisions to zero for 100% smoothing.\n</small>")
#@gui : sep = separator()
#@gui : Grid Divisions = int(2,0,3)
#@gui : Grid Width = int(3,1,3)
#@gui : Grid Smoothing = float(1,0,1)
#@gui : Preserve Edges = int(100,0,100)
#@gui : Colour Channels = bool(1)
#@gui : Boost Smooth = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/05/15</i>.</small>")
gcd_comp_blur : -skip ${1=2},${2=3},${3=1},${4=100},${5=1},${6=0}
gsz={2^(5-$1)}
-repeat $! -l[$>]
-remove_opacity[-1]
--to_gray[0] -edges[-1] 14.5% -n[-1] {100-$4}%,100%
-if {0,s>1" && "$5}
--ac[0] "-median 5",ycbcr_cbcr
-image[0] [-1],0,0,0,0,1,[-2] -rm[-1]
-endif
-if {$1==0} {w},{h},1,1,255 -mul[-2,-1] -else
{w},{h},1,1,0
-grid[-1] $gsz,$gsz,0,0,1,255
-if {$2>=2} -grid[-1] $gsz,$gsz,1,1,1,255 -endif
-if {$2==3} -grid[-1] $gsz,$gsz,-1,-1,1,255 -endif
-blur[-1] $3,0 -mul[-2,-1]
-endif
-i[-2] [0] -append[-2,-1] c
-smooth[1] {100*$6+100},0.6,0.3
-blend[0,1] alpha
-if {!$6} -sharpen[-1] 20 -endif
-endl -done
gcd_comp_blur_preview :
-gui_split_preview "-gcd_comp_blur ${1--2}",$-1
#@gui Deinterlace : deinterlace, fx_deinterlace_preview(0)
#@gui : Algorithm = choice("Standard","Motion-Compensated")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_deinterlace :
deinterlace 0 skip ${^0}
fx_deinterlace_preview :
gui_split_preview "fx_deinterlace $*",${-3--1}
#@gui Deinterlace2x : gcd_deinterlace2x, gcd_deinterlace2x_preview(0)
#@gui : note = note("<i>Blend 2x frames for 4:2:0 YUV</i>"), sep = separator()
#@gui : Balance = int(40,1,255)
#@gui : 2x Type = choice("DCCI2x","Box2x","Fast Blend","Set Aspect Only")
#@gui : Aspect = choice("None","1:1","4:3","5:4","16:9","16:10","2.35:1","1.85:1")
#@gui : Interp = choice(2,"linear","bicubic","lanczos")
#@gui : Ignore Current Aspect = bool(0)
#@gui : Fast Blend Preview = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/05/01</i>.</small>")
#@gui : note = note("\n<small><b>Note:</b> preview may be inaccurate</small>")
#@gui : note = note("<small>Interp is only used when setting aspect</small>")
gcd_deinterlace2x : -skip ${1=40},${2=0},${3=0},${4=2},${5=0},${6=1}
-if {$3}
ca={if($5,1,h/w)} na={arg($3,1,{4/3},{5/4},{16/9},{1.6},{2.35},{1.85})}
-r {$ca*$na*w},100%,1,3,{arg($4+1,3,5,6)} -c 0,255
-endif -if {$2==3} -return -endif
-repeat $! -l[$>]
w={w} h={h} d={d} hh={int($h/2)} -rgb2yuv -s c
-l[0] --shift 0,-1 -r $w,$hh,$d,1,4 -endl
-l[-2,-1] -r $w,2,$d,$hh,-1 --shift 0,0,0,-1 -r $w,2,$d,50%,4 -r $w,$hh,$d,1,-1 -endl
-a[0,2,3] c -a[^0] c -yuv2rgb
-if {$2==0} -scale_dcci2x ,,1 -r 50%,100%,1,3,4
-elif {$2==1} -gcd_scale_box2x , -r 50%,100%,1,3,4
-else
a={2/3} b={-1/12} ($b,$a,$b;$b,$a,$b;0,0,0) --convolve[^-1] [-1] -rm...
-r 100%,200%,1,3,4 -shift[-2,-1] 0,1 -+[-3,-1] -+[-3,-1]
-endif
-c 0,255 -shift. 0,1 --- --norm. a={-192^-.5/$1} ($a,$a,$a;$a,0,$a;$a,$a,$a)
-convolve.. [-1] -rm. -max. -1 -+. 1 -*[-2,-1] --[0,-1] -rm.
-endl -done
gcd_deinterlace2x_preview :
-gcd_deinterlace2x ${1},{if($6,max(2,$2),$2)},${3--1}
#@gui Descreen : fx_pahlsson_descreen, fx_pahlsson_descreen_preview(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Andreas P&#229;hlsson</i>.      Latest update: <i>2016/27/06</i>.</small>")
fx_pahlsson_descreen : -skip $*
-pahlsson_descreen
fx_pahlsson_descreen_preview :
-gui_split_preview "-fx_pahlsson_descreen 0",$-1
pahlsson_descreen :
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-rgb2cmyk
-split c
-name[-4] C
-pahlsson_descreen_channel[-4]
-name[-3] M
-pahlsson_descreen_channel[-3]
-name[-2] Y
-pahlsson_descreen_channel[-2]
-name[-1] K
-pahlsson_descreen_channel[-1]
-append c
-cmyk2rgb
-endl -a c -endl -done
pahlsson_descreen_channel :
# Keep the basename around for debugging purposes
basename={0,b}
-name[0] original
# Get original dimensions.
crop1=0,0,{original,w-1},{original,h-1},0
crop2=0,{original,h},100%,100%,0
-float2fft8[original]
-name[original] fft
# Clone the image to split in real/imaginary parts for later recombination.
-i [fft]
-name[-2] real
-name[-1] imaginary
-crop[real] $crop1
-crop[imaginary] $crop2
# Build a mask.
-i [real]
-name[-1] mask
# Peak detection with DOG. Maybe not the best way. Does work though.
# Factor of 1.6x, size relative to image. Not great for small images.
-dog[mask] 0.5%,0.8%
-normalize[mask] 0,255
-threshold[mask] 64
-normalize[mask] 0,255
-negate[mask]
# Make sure the center is not masked.
-ellipse[mask] 50%,50%,7%,7%,255,255,255,255
# Make a blur mask. Not entirely sure why this is a good thing.
-i [mask]
-name[-1] blurmask
-blur[blurmask] 1.6%
-normalize[blurmask] 0,255
# Merge mask and blurmask
-mul[mask,blurmask]
-div[mask] 256
# Apply the mask to the real part.
-mul[mask,real]
-div[real] 256
# Recombine real with mask and imaginary part.
-append[real] [imaginary],y
-name[real] fft
-remove[imaginary]
# Inverse the FFT
-fft82float[fft]
#@cli float2int8
#@cli : Convert selected float-valued images to 8bits integer representations.
float2int8 :
e[^-1] "Convert float-valued image$? to 8bits integer representations."
v - repeat $! l[$>]
s c repeat $! l[$>]
m={im} M={iM} quantize 16777216,0,1
+>> 8 &. 255 +&.. 255 >>... 16
({'$m,$M'}) a y
endl done a c
endl done v +
#@cli int82float
#@cli : Convert selected 8bits integer representations to float-valued images.
int82float :
e[^-1] "Convert 8bits integer representation$? to float-valued image$?."
v - repeat $! l[$>]
s c repeat $! l[$>]
sh. {h-1},{h-1},0,0 m={t} rm.
rows 0,{h-2} s y,3 *... 65536 *.. 256 -|
skip ${n\ $m}
endl done a c
endl done v +
#@cli float2fft8
#@cli : Convert selected float-valued images to 8bits fourier representations.
float2fft8 :
e[^-1] "Convert float-valued image$? to 8bits fourier representations."
v - repeat $! l[$>]
fftpolar +.. 1 log.. float2int8[-2,-1] a y
endl done v +
#@cli fft82float
#@cli : Convert selected 8bits fourier representations to float-valued images.
fft82float :
e[^-1] "Convert float-valued image$? to 8bits fourier representations."
v - repeat $! l[$>]
s y,2 int82float exp.. -.. 1 ifftpolar
endl done v +
#@gui Despeckle : gcd_despeckle, gcd_despeckle(3)
#@gui : note = note("<i>Remove small dots and specks</i>"), sep = separator()
#@gui : Tolerance = int(20,0,50)
#@gui : Max Area = int(10,0,100)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.   Latest update : <i>2013/02/01</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set max area to 0 for no area size limit.</small>")
gcd_despeckle : -skip ${1=15},${2=30}
-repeat $! -l[$>]
ma={if(!$2,w*h,$2)}
--label[-1] $1,1 nb={1+iM}
--histogram[-1] $nb,0,{$nb-1}
-map[-2] [-1] -rm[-1]
-le[-1] $ma -*[-1] 255
-inpaint[-2] [-1] -rm[-1]
-endl -done
#@gui Iain's Fast Denoise : iain_fast_denoise_p,iain_fast_denoise_p_preview(0)
#@gui : Luma = float(0,0,3)
#@gui : Chroma = float(0,0,3)
#@gui : Gamma = float (1,.5,3)
#@gui : Despeckle = float(0,0,1)
#@gui : Dither Output = bool(0)
#@gui : Preview Shows = choice (0,"Normal Output","Luma Noise",  "Chroma Noise")
#@gui : sep = separator ()
#@gui : Parallel Processing = choice(1,"Off","Auto")
#@gui : sep = separator()
#@gui : note = note("This noise reduction filter is designed for speed, and some quality has been sacrificed.")
#@gui : sep = separator ()
#@gui : note = note("<small>Author: Iain Fergusson</small>")
#@gui : note = note("<small>Update 28 March 2015 - increased parallel overlap to remove artefacts</small>")
#@gui : note = note("<small>Update 26 Oct 2013 - parallel processing</small>")
#@gui : note = note("<small>Released 22 Feb 2013</small>")
iain_fast_denoise_p:
-tic
-if $7
-apply_parallel_overlap "-iain_fast_denoise ${1--1}",128,0
-else
-iain_fast_denoise ${1--1}
-endif
-toc
iain_fast_denoise:
-repeat $! -l[$>] nm={0,n} -split_opacity -l[0]
fastluma1={$1*5000}
fastluma2={$fastluma1*.9}
fastluma3={$fastluma1*.65}
fastluma4={$fastluma1*.44}
fastchroma1={$2*5000}
fastchroma2=$fastchroma1
fastchroma3={$fastchroma2/2}
fastchroma4={$fastchroma3/2}
despeckle_threshold={($4/25)*100000}
-if {$3!=1}
scale={255*1000}
ex={$3}
pt1x={$scale*0.025}
pt2x={$scale*0.05}
pt3x={$scale*0.075}
pt4x={$scale*0.1}
pt5x={$scale*0.125}
pt6x={$scale*0.15}
pt7x={$scale*0.175}
pt8x={$scale*0.2}
pt9x={$scale*0.225}
pt10x={$scale*0.25}
pt11x={$scale*0.275}
pt12x={$scale*0.3}
pt13x={$scale*0.325}
pt14x={$scale*0.35}
pt15x={$scale*0.375}
pt16x={$scale*0.4}
pt17x={$scale*0.425}
pt18x={$scale*0.45}
pt19x={$scale*0.475}
pt20x={$scale*0.5}
pt21x={$scale*0.525}
pt22x={$scale*0.55}
pt23x={$scale*0.575}
pt24x={$scale*0.6}
pt25x={$scale*0.625}
pt26x={$scale*0.65}
pt27x={$scale*0.675}
pt28x={$scale*0.7}
pt29x={$scale*0.725}
pt30x={$scale*0.75}
pt31x={$scale*0.775}
pt32x={$scale*0.8}
pt33x={$scale*0.825}
pt34x={$scale*0.85}
pt35x={$scale*0.875}
pt36x={$scale*0.9}
pt37x={$scale*0.925}
pt38x={$scale*0.95}
pt39x={$scale*0.975}
pt40x={$scale*1}
pt1y={(0.025^$ex)*$scale}
pt2y={(0.05^$ex)*$scale}
pt3y={(0.075^$ex)*$scale}
pt4y={(0.1^$ex)*$scale}
pt5y={(0.125^$ex)*$scale}
pt6y={(0.15^$ex)*$scale}
pt7y={(0.175^$ex)*$scale}
pt8y={(0.2^$ex)*$scale}
pt9y={(0.225^$ex)*$scale}
pt10y={(0.25^$ex)*$scale}
pt11y={(0.275^$ex)*$scale}
pt12y={(0.3^$ex)*$scale}
pt13y={(0.325^$ex)*$scale}
pt14y={(0.35^$ex)*$scale}
pt15y={(0.375^$ex)*$scale}
pt16y={(0.4^$ex)*$scale}
pt17y={(0.425^$ex)*$scale}
pt18y={(0.45^$ex)*$scale}
pt19y={(0.475^$ex)*$scale}
pt20y={(0.5^$ex)*$scale}
pt21y={(0.525^$ex)*$scale}
pt22y={(0.55^$ex)*$scale}
pt23y={(0.575^$ex)*$scale}
pt24y={(0.6^$ex)*$scale}
pt25y={(0.625^$ex)*$scale}
pt26y={(0.65^$ex)*$scale}
pt27y={(0.675^$ex)*$scale}
pt28y={(0.7^$ex)*$scale}
pt29y={(0.725^$ex)*$scale}
pt30y={(0.75^$ex)*$scale}
pt31y={(0.775^$ex)*$scale}
pt32y={(0.8^$ex)*$scale}
pt33y={(0.825^$ex)*$scale}
pt34y={(0.85^$ex)*$scale}
pt35y={(0.875^$ex)*$scale}
pt36y={(0.9^$ex)*$scale}
pt37y={(0.925^$ex)*$scale}
pt38y={(0.95^$ex)*$scale}
pt39y={(0.975^$ex)*$scale}
pt40y={(1^$ex)*$scale}
-endif
interpolation=1
-tic
-to_rgb
-mul[0] 1000
-if {$3!=1}
-apply_curve[0] 0,0,0,$pt1x,$pt1y,$pt2x,$pt2y,$pt3x,$pt3y,$pt4x,$pt4y,$pt5x,$pt5y,$pt6x,$pt6y,$pt7x,$pt7y,$pt8x,$pt8y,$pt9x,$pt9y,$pt10x,$pt10y,$pt11x,$pt11y,$pt12x,$pt12y,$pt13x,$pt13y,$pt14x,$pt14y,$pt15x,$pt15y,$pt16x,$pt16y,$pt17x,$pt17y,$pt18x,$pt18y,$pt19x,$pt19y,$pt20x,$pt20y,$pt21x,$pt21y,$pt22x,$pt22y,$pt23x,$pt23y,$pt24x,$pt24y,$pt25x,$pt25y,$pt26x,$pt26y,$pt27x,$pt27y,$pt28x,$pt28y,$pt29x,$pt29y,$pt30x,$pt30y,$pt31x,$pt31y,$pt32x,$pt32y,$pt33x,$pt33y,$pt34x,$pt34y,$pt35x,$pt35y,$pt36x,$pt36y,$pt37x,$pt37y,$pt38x,$pt38y,$pt39x,$pt39y,$pt40x,$pt40y
-endif
redmul=.299
greenmul=.587
bluemul=.114
-to_rgb[0]
--split[0] c
-mul[1] $redmul
-mul[2] $greenmul
-mul[3] $bluemul
-add[1-3]
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[3] luma
--sub[blue] [luma]
-name[-1] cb
--sub[red] [luma]
-name[-1] cr
-keep[luma,cb,cr]
-if {$despeckle_threshold>0}
-iain_fast_despeckle[0] {1-$despeckle_threshold}
-endif
-if {$1>0}
-iain_fast_denoise_main[0] {$fastluma1},{$fastluma2},{$fastluma3},{$fastluma4},$interpolation
-endif
-if {$2>0}
-iain_fast_denoise_main[1] {$fastchroma1},{$fastchroma2},{$fastchroma3},{$fastchroma4},$interpolation
-iain_fast_denoise_main[2] {$fastchroma1},{$fastchroma2},{$fastchroma3},{$fastchroma4},$interpolation
-endif
-name[0] luma
-name[1] cb
-name[2] cr
--add[cb] [luma]
-name[-1] blueout
--add[cr] [luma]
-name[-1] redout
-remove[1,2]
--mul[redout] $redmul
--mul[blueout] $bluemul
-sub[luma] [-1]
-sub[luma] [-2]
-div[luma] $greenmul
-remove[-1,-2]
-move[2] 0
-append c
-if {$5==1}
100%,100%,1,1,0
-noise[-1] 0.7,0
--laplacian[0]
-threshold[-1] 4
-dilate[-1] 3
-mul[-1] -1
-add[-1] 1
-mul[-2] [-1]
-remove[-1]
-add
-endif
-if {$3!=1}
scale={255*1000}
ex={1/$3}
pt1y={(0.025^$ex)*$scale}
pt2y={(0.05^$ex)*$scale}
pt3y={(0.075^$ex)*$scale}
pt4y={(0.1^$ex)*$scale}
pt5y={(0.125^$ex)*$scale}
pt6y={(0.15^$ex)*$scale}
pt7y={(0.175^$ex)*$scale}
pt8y={(0.2^$ex)*$scale}
pt9y={(0.225^$ex)*$scale}
pt10y={(0.25^$ex)*$scale}
pt11y={(0.275^$ex)*$scale}
pt12y={(0.3^$ex)*$scale}
pt13y={(0.325^$ex)*$scale}
pt14y={(0.35^$ex)*$scale}
pt15y={(0.375^$ex)*$scale}
pt16y={(0.4^$ex)*$scale}
pt17y={(0.425^$ex)*$scale}
pt18y={(0.45^$ex)*$scale}
pt19y={(0.475^$ex)*$scale}
pt20y={(0.5^$ex)*$scale}
pt21y={(0.525^$ex)*$scale}
pt22y={(0.55^$ex)*$scale}
pt23y={(0.575^$ex)*$scale}
pt24y={(0.6^$ex)*$scale}
pt25y={(0.625^$ex)*$scale}
pt26y={(0.65^$ex)*$scale}
pt27y={(0.675^$ex)*$scale}
pt28y={(0.7^$ex)*$scale}
pt29y={(0.725^$ex)*$scale}
pt30y={(0.75^$ex)*$scale}
pt31y={(0.775^$ex)*$scale}
pt32y={(0.8^$ex)*$scale}
pt33y={(0.825^$ex)*$scale}
pt34y={(0.85^$ex)*$scale}
pt35y={(0.875^$ex)*$scale}
pt36y={(0.9^$ex)*$scale}
pt37y={(0.925^$ex)*$scale}
pt38y={(0.95^$ex)*$scale}
pt39y={(0.975^$ex)*$scale}
pt40y={(1^$ex)*$scale}
-apply_curve[0] 0,0,0,$pt1x,$pt1y,$pt2x,$pt2y,$pt3x,$pt3y,$pt4x,$pt4y,$pt5x,$pt5y,$pt6x,$pt6y,$pt7x,$pt7y,$pt8x,$pt8y,$pt9x,$pt9y,$pt10x,$pt10y,$pt11x,$pt11y,$pt12x,$pt12y,$pt13x,$pt13y,$pt14x,$pt14y,$pt15x,$pt15y,$pt16x,$pt16y,$pt17x,$pt17y,$pt18x,$pt18y,$pt19x,$pt19y,$pt20x,$pt20y,$pt21x,$pt21y,$pt22x,$pt22y,$pt23x,$pt23y,$pt24x,$pt24y,$pt25x,$pt25y,$pt26x,$pt26y,$pt27x,$pt27y,$pt28x,$pt28y,$pt29x,$pt29y,$pt30x,$pt30y,$pt31x,$pt31y,$pt32x,$pt32y,$pt33x,$pt33y,$pt34x,$pt34y,$pt35x,$pt35y,$pt36x,$pt36y,$pt37x,$pt37y,$pt38x,$pt38y,$pt39x,$pt39y,$pt40x,$pt40y
-endif
-mul[0] 0.001
-c 0,255
-toc
-endl -a c -nm $nm -endl -done
fastblur:
(0.0579710145,0.1304347826,0.0579710145;0.1304347826,0.2463768116,0.1304347826;0.0579710145,0.1304347826,0.0579710145)
-convolve[0] [1]
-remove[-1]
iain_fast_despeckle:
(0,0.2,0;0.2,0.2,0.2;0,0.2,0)
--convolve[0] [1]
--sub[-1] [0]
-abs[-1]
--convolve[-1] [1]
-sub[-1] [-2]
-abs[-1]
-keep[0,2,-1]
-threshold[-1] $1
-mul[-1] 255
-append[1,2] c
-blend alpha
iain_fast_denoise_main:
cropwidth={w}
cropheight={h}
-resize[0] {w+(8-w%8)},{h+(8-h%8)},1,{s},0,1
width={w}
height={h}
--resize[0] 50%,50%,{d},{s},2
--resize[1] $width,$height,{d},{s},$5
-fastblur[-1]
-sub[0] [2]
-remove[2]
--resize[1] 50%,50%,{d},{s},2
--resize[2] {$width/2},{$height/2},{d},{s},$5
-fastblur[-1]
-sub[1] [3]
-remove[3]
--resize[2] 50%,50%,{d},{s},2
--resize[3] {$width/4},{$height/4},{d},{s},$5
-fastblur[-1]
-sub[2] [4]
-remove[4]
--resize[3] 50%,50%,{d},{s},2
--resize[4] {$width/8},{$height/8},{d},{s},$5
-fastblur[-1]
-sub[3] [5]
-remove[5]
-rmsthresh[0] $1
-rmsthresh[1] $2
-rmsthresh[2] $3
-rmsthresh[3] $4
-resize[-1] {3,w},{3,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-resize[-1] {2,w},{2,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-resize[-1] {1,w},{1,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-resize[-1] {0,w},{0,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
rmsthresh:
--abs[0]
-fastblur[1]
-threshold[1] {$1}
-fastblur[1]
-mul[0] [1]
-keep[0]
iain_fast_denoise_p_preview:
-if {$-2==0}
-iain_fast_denoise ${1--3}
-endif
-if {$-2==1}
--iain_fast_denoise_p $1,0,1,$4,0,0,$7
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
-if {$-2==2}
--iain_fast_denoise_p 0,$2,1,$4,0,0,$7
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
#@gui Iain's Noise Reduction : iain_iains_nr,iain_iains_nr_preview(0)
#@gui : 1 Luma NR = float (3,0,20)
#@gui : 2 Chroma NR = float (3,0,20)
#@gui : 3 Despeckle = int (1,0,4)
#@gui : note = note("       <small>Adjust noise reduction by tone</small>")
#@gui : 4 Highlights = float (0,-50000,50000)
#@gui : 5 Shadows = float (0,-32000,32000)
#@gui : sep = separator ()
#@gui : note = note("<b>Recover Details</b>")
#@gui : 6 Recover Details = choice (0,"Do not Recover Details","Recover Details", "Recover Details as separate layer")
#@gui : 7 Recovery Amount = float(1,.1,10)
#@gui : note = note("       <small>Adjust detial recovery by size</small>")
#@gui : 8 Adjust Fine Details = float (0,-500,500)
#@gui : 9 Adjust Medium Details = float (0,-500,500)
#@gui : 10 Adjust Large Details = float (0,-500,500)
#@gui : 11 Detail Emphasis = float (1.35,1,4)
#@gui : sep = separator ()
#@gui : 12 Sharpen Edges = float (0,0,4)
#@gui : note = note("<b>Preview options</b>")
#@gui : 13 Preview Shows = choice (0,"Normal Output","Luma Noise",  "Chroma Noise","Details")
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 10 Jan 2013")
iain_iains_nr:
-repeat $! -l[$>] nm={0,n} -split_opacity -l[0]
lnr=$1
cnr=$2
despek=$3
highs=$4
shadow=$5
recovery_choice=$6
detail_recovery={5000-($7*500)}
fast=1
fine_det=$8
med_det=$9
large_det=$10
det_emphasis=$11
sharp=$12
-to_rgb
-apply_gamma {1/1.3}
-mul 900
-apply_curve 1,0,0,32000,{32000-$shadow},160000,{160000-$shadow},256000,{256000-$highs-$shadow}
-div 2000
-iain_rgb2ycbcr
-split c
-if {$lnr>0}
-if {$recovery_choice==0}
-iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
-unsharp[0] .7,$sharp,0
-endif
-if {$recovery_choice==1}
--iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
--sub[0] [-1]
-add[-1] {128}
-remove[0]
-unsharp[2] .7,$sharp,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
-rectangle[-1] 0,0,100%,48,1,128
-rectangle[-1] 0,0,48,100%,1,128
-rectangle[-1] 0,100%,100%,{h-48},1,128
-rectangle[-1] {w-48},100%,100%,0,1,128
-iains_nr_fft_tile3[-1] {$detail_recovery},48,0,$fine_det,$med_det,$large_det,1,3
-crop[-1] 48,48,{w-49},{h-49}
-sub[-1] {128}
-mul[-1] $det_emphasis
-add[2] [-1]
-remove[-1]
-move[-1] 0
-endif
-if {$recovery_choice==2}
--iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
--sub[0] [-1]
-add[-1] {128}
-remove[0]
-unsharp[2] .7,$sharp,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
-rectangle[-1] 0,0,100%,48,1,128
-rectangle[-1] 0,0,48,100%,1,128
-rectangle[-1] 0,100%,100%,{h-48},1,128
-rectangle[-1] {w-48},100%,100%,0,1,128
-iains_nr_fft_tile3[-1] {$detail_recovery},48,0,$fine_det,$med_det,$large_det,1,3
-crop[-1] 48,48,{w-49},{h-49}
-sub[-1] 128
-mul[-1] $det_emphasis
-add[-1] 128
-move[-2] 0
-endif
-endif
-if {$cnr>0}
-add[1,2] 300
-iains_nr_patchb[1] 10,$cnr,3,3,0,1,1,4,.5,.4,.2,0,1,1,2,0
-iains_nr_patchb[2] 10,$cnr,3,3,0,1,1,4,.5,.4,.2,0,1,1,2,0
-sub[1,2] 300
-endif
-append[0,1,2] c
-iain_ycbcr2rgb[0]
-mul[0] 2000
-apply_curve[0] 1,0,0,{32000-$shadow},32000,{160000-$shadow},160000,{256000-$highs-$shadow},256000
-div[0] 900
-apply_gamma[0] 1.3
-c 0,255
-endl -a c -nm $nm -endl -done
iains_nr_med3stack16:
-blend_median
iains_nr_med5stack16:
-blend_median
iains_nr_fft_tile3_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
--add[1] [-1]
-threshold[-1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-remove[0,1,2]
-keep[-1]
iains_nr_fft_tile3_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-iains_nr_fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
iains_nr_fft_tile3:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$8>2}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
-endif
-if {$8>1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$8==3}
-blend_median
-endif
-if {$8==2}
-blend_median
-endif
iains_nr_patchb_smoothing:
-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done
iains_nr_patchb_2:
--resize[0] 50%,50%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb_3:
--resize[0] 25%,25%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb_4:
--resize[0] 12.5%,12.5%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb_5:
--resize[0] 6.125%,6.125%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb:
-apply_gamma {1/$14}
-if {$8==1}
-hybrid_median[-1] 1,0,0
-endif
-if {$8==2}
-hybrid_median[-1] 3,0,0
-endif
-if {$8==3}
-median[-1] 3
-endif
-if {$8==4}
-median[-1] 3
-median[-1] 3
-median[-1] 3
-endif
-repeat $15
-if {$8<4}
-if {$13==1}
-iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
-endif
-endif
-iains_nr_patchb_2 $1,{$2*$9},$3,$4,$5,$6,$7,$8
-iains_nr_patchb_3 $1,{$2*$10},$3,$4,$5,$6,$7,$8
-iains_nr_patchb_4 $1,{$2*$11},$3,$4,$5,$6,$7,$8
-iains_nr_patchb_5 $1,{$2*$12},$3,$4,$5,$6,$7,$8
-done
-apply_gamma $14
iain_rgb2ycbcr:
redmul=.299
greenmul=.587
bluemul=.114
-to_rgb[0]
--split[0] c
-mul[1] $redmul
-mul[2] $greenmul
-mul[3] $bluemul
-add[1-3]
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[3] luma
--sub[blue] [luma]
-name[-1] cb
--sub[red] [luma]
-name[-1] cr
-keep[luma,cb,cr]
-append[luma,cb,cr] c
iain_ycbcr2rgb:
redmul=.299
greenmul=.587
bluemul=.114
-split c
-name[0] luma
-name[1] cb
-name[2] cr
--add[cb] [luma]
-name[-1] blueout
--add[cr] [luma]
-name[-1] redout
-remove[1,2]
--mul[redout] $redmul
--mul[blueout] $bluemul
-sub[luma] [-1]
-sub[luma] [-2]
-div[luma] $greenmul
-remove[-1,-2]
-move[2] 0
-append c
iain_iains_nr_preview:
-if {$-1==0}
-iain_iains_nr ${1--2}
-endif
-if {$-1==1}
--iain_iains_nr $1,0,$3,$4,$5,$6,$7,$8,$9,$10,1.3,0
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
-if {$-1==2}
--iain_iains_nr 0,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,0
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
-if {$-1==3}
-iain_iains_nr $1,$2,$3,$4,$5,2,$7,$8,$9,$10,$11,0
-keep[-1]
-sub 128
-mul 3
-add 128
-endif
#@gui Inpaint [Holes] : fx_inpaint_holes, fx_inpaint_holes(0)
#@gui : Maximal Area = float(4,1,512)
#@gui : Tolerance = float(20,0,255)
#@gui : Connectivity = choice(1,"Low","High")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/27/05</i>.</small>")
fx_inpaint_holes :
inpaint_holes {$1^1.5},$2,$3
#@gui Inpaint [Morphological] : fx_inpaint_morpho, fx_inpaint_morpho_preview(1)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> It is strongly suggested to apply this filter only on a selection around the region to inpaint, to save computation time!</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/25/11</i>.</small>")
fx_inpaint_morpho :
repeat $! l[$>]
R=$1 G=$2 B=$3 A=$4
if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi
+round select_color. 0,{round([$R,$G,$B,$A])}
if $5 dilate. {1+2*$5} fi
inpaint_morpho.. [1]
rm.
endl done
fx_inpaint_morpho_preview :
fx_inpaint_morpho ${1-4},{1+$5}
#@gui Inpaint [Multi-Scale] : fx_inpaint_matchpatch, fx_inpaint_matchpatch_preview(1)
#@gui : Number of Scales = _int(0,0,16)
#@gui : note = note{"<small>(Set <i>Number of scales</i> to <i>0</i> for automatic scale detection)</small>"}
#@gui : Patch Size = _int(9,1,64)
#@gui : Number of Iterations per Scale = _int(10,1,100)
#@gui : Blend Size = _int(5,0,32)
#@gui : Allow Outer Blending = _bool(1)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : sep = separator(), Preview Progression While Running = _bool(0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Preview and final result may strongly differ.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/25/11</i>.</small>")
fx_inpaint_matchpatch :
repeat $! l[$>]
R=$6 G=$7 B=$8 A=$9
if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi
+round select_color. 0,{round([$R,$G,$B,$A])}
if $10 dilate. {1+2*$10} fi
if $11
visu_size=${fitscreen[]" "{0,w},{0,h},1,25%,50%}
w1.. $visu_size,0,"[Preview] G'MIC: Inpaint [multi-scale]"
fi
srand 0 inpaint_matchpatch.. [1],${1-5}
rm.
endl done
fx_inpaint_matchpatch_preview :
fx_inpaint_matchpatch ${1-9},{1+$10},0
#@gui Inpaint [Patch-Based] : fx_inpaint_patch, fx_inpaint_patch_preview
#@gui : Patch Size = _int(7,1,64)
#@gui : Lookup Size = _float(16,1,32)
#@gui : Lookup Factor = _float(0.1,0,1)
#@gui : Blend Size = _float(1.2,0,5)
#@gui : Blend Threshold = _float(0,0,1)
#@gui : Blend Decay = _float(0.05,0,0.5)
#@gui : Blend Scales = _int(10,1,20)
#@gui : Allow Outer Blending = _bool(1)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : Process by Blocs of Size = _choice("100%","75%","50%","25%","10%","5%","2%","1%")
#@gui : sep = separator(), note = note("<small>A quick tutorial on how to use this filter can be found here:</small>")
#@gui : url = link("G'MIC Inpainting tutorial on Patrick David's blog.","http://blog.patdavid.net/2014/02/getting-around-in-gimp-gmic-inpainting.html")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>Maxime Daisy</i>.      Latest Update: <i>2015/25/11</i>.</small>")
_fx_inpaint_patch :
repeat $! l[$>]
R=$9 G=$10 B=$11 A=$12
if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi
+round select_color. 0,{round([$R,$G,$B,$A])}
if $13 dilate. {1+2*$13} fi
inpaint.. [1],$1,{$1*$2},$3,1,{$4*$1},${5-8}
rm.
endl done
fx_inpaint_patch :
repeat $! l[$>]
if $14
bs={max(16,min(w,h)*arg(1+$14,100,75,50,25,10,5,2,1)%)}
at "_fx_inpaint_patch $*",$bs,$bs,1,25%,25%,0,2
else _fx_inpaint_patch $*
fi
endl done
fx_inpaint_patch_preview :
fx_inpaint_patch ${1-12},{1+$13},100
#@gui Inpaint [Transport-Diffusion] : fx_inpaint_diffusion, fx_inpaint_diffusion_preview(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-Oriented","Edge-Oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/10/04</i>.</small>")
fx_inpaint_diffusion :
repeat $! l[$>]
R=$4 G=$5 B=$6 A=$7
if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi
+select_color 0,$R,$G,$B,$A
if {$8} dilate. {1+2*$8} fi
inpaint_diffusion.. [1],$1%,$2,$3
rm.
endl done c 0,255
fx_inpaint_diffusion_preview :
fx_inpaint_diffusion ${1-7},{1+$8}
#@gui JPEG Smooth : gcd_jpeg_smooth, gcd_jpeg_smooth_preview(0)
#@gui : note = note("<i>Quick JPEG cleanup for moderate compression glitches</i>")
#@gui : sep = separator()
#@gui : Compression Filter = bool(1)
#@gui : Anti Alias = bool(1)
#@gui : Quick Enlarge = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_jpeg_smooth : -skip ${1=1},${2=1},${3=0}
-repeat $! -l[$>]
-if $1 -gcd_comp_blur[-1] 2,3,1,100,1 -endif
-if $3 -r[-1] 140%,140%,1,3,5 -c[-1] 0,255 -endif
-if $2 -gcd_anti_alias[-1] 10,0.3,10 -endif
-endl -done
gcd_jpeg_smooth_preview :
-gui_split_preview "-gcd_jpeg_smooth ${1--2}",$-1
#@gui Local Similarity Mask : local_similarity_mask, local_similarity_mask(1)
#@gui : note = note("Select pixels at")
#@gui : Center (%) = point(50,50,0,1)
#@gui : note = note("With similarity")
#@gui : Keep = int (50,0,255)
#@gui : Reject = int (128,0,255)
#@gui : note = note("On these channels")
#@gui : Channel(s) = choice(4,"RGB","Red","Green","Blue","Luminance","a-component","b-component","Hue","Saturation","Value","Lightness","[Cyan]MYK","C[Magenta]YK","CM[Yellow]K","CMY[Key]")
#@gui : Steps = int (10,2,100)
#@gui : sep = separator()
#@gui : note = note("This filter creates a mask based on pixels that are close to, and similar to, the selected pixel.")
#@gui : sep = separator()
#@gui : note = note("Author : <i>Iain Fergusson</i>. Update 12 September 2018: Added interactive point and <b>Steps</b> control")
local_similarity_mask:
-repeat $! -l[$>]
nm=${-gui_layer_name}
x_location=$1
y_location=$2
keep=$3
reject=$4
colour_channel=$5
-if {$6==0}
steps=100
-elif {$6==1}
steps=25
-elif {$6>1}
steps={min($6,($reject-$keep))}
-endif
-to_rgb
-if {$colour_channel!=0}
-if {$colour_channel==1}  -channels 0 -endif
-if {$colour_channel==2}  -channels 1 -endif
-if {$colour_channel==3}  -channels 2 -endif
-if {$colour_channel==4} -luminance -endif
-if {$colour_channel==5} -rgb2lab[0] -channels 1 -endif
-if {$colour_channel==6} -rgb2lab[0] -channels 2 -endif
-if {$colour_channel==7} -rgb2hsv[0] -channels 0 -endif
-if {$colour_channel==8} -rgb2hsv[0] -channels 1 -endif
-if {$colour_channel==9} -rgb2hsv[0] -channels 2 -endif
-if {$colour_channel==10} -rgb2hsl[0] -channels 2 -endif
-if {$colour_channel==11} -rgb2cmyk[0] -channels 0 -endif
-if {$colour_channel==12} -rgb2cmyk[0] -channels 1 -endif
-if {$colour_channel==13} -rgb2cmyk[0] -channels 2 -endif
-if {$colour_channel==14} -rgb2cmyk[0] -channels 3 -endif
-endif
-n 0,255
-mul[0] 0.9
{w},{h},1,1,0
step_size={($reject-$keep)/$steps}
-repeat {$steps}
--flood[0] $x_location%,$y_location%,0,{$keep+($>*$step_size)},0,1,255 -threshold[-1] 99%
-add[-1,-2]
-done
-keep[-1]
-n 0,255
nm name($nm)
-endl -done
#@gui Moire Removal : iain_moire_removal, iain_moire_removal(0)
#@gui : Smoothing = float (5,0,20)
#@gui : Smart Threshold = float (5,0,10)
#@gui : Moire Removal Method = choice(0,"Smart","Aggresive","Smooth only")
#@gui : sep = separator()
#@gui : note = note("Moire removal consists of two parts, first, an edge-protected smoothing and second a frequency analyisis of the difference between the smoothed and original image. The image is broken into tiles, and each tile processed. A tile that is a solid colour is skipped." )
#@gui : note = note("Smoothing must be high enough to remove the moire. The <b>Smart Threshold</b> sets the detection of moire for each frequency on each colour channel. If a frequency in one colour channel is determined to be moire it is replaced by the colour channel least likely to have moire." )
#@gui : note = note("The <b>Agressive</b> setting skips the thresolding step and uses the lowest frequency level from the colour channels." )
#@gui : note = note("The filter will reduce chroma details/noise" )
iain_moire_removal:
tile_size=256
overlap=16
cropwidth={w}
cropheight={h}
-if {$cropwidth%$tile_size>0}
-resize[0] {w+($tile_size-w%$tile_size)},100%,1,{s},0,1
-endif
-if {$cropheight%$tile_size>0}
-resize[0] 100%,{h+($tile_size-h%$tile_size)},1,{s},0,1
-endif
h_tiles={w/$tile_size}
v_tiles={h/$tile_size}
-repeat $v_tiles,v_count
-repeat $h_tiles,h_count
--crop[0] {($h_count*$tile_size)-$overlap},{($v_count*$tile_size)-$overlap},{($h_count*$tile_size)+($tile_size+$overlap-1)},{($v_count*$tile_size)+($tile_size+$overlap-1)},1
-done
-done
-rm[0]
-repeat $! -l[$>]
-if {iM!=im}
[0]
-apply_parallel_channels[1] "
-l[0]
-repeat 3
-l[-1]
-repeat 2
-denoise[0] 10,{$1/($>+1)},5,5,0,{min($>,1)}
-done
--resize[0] 50%,50%,{d},{s},2
--resize[-1] 200%,200%,{d},{s},3
-sub[0,-1]
-endl
-done
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-done
-endl
"
-if {$3<2}
-sub[0] [1]
-l[0]
-fftpolar[0]
-if {$3==1}
-append[0,1] x
-split[0] c
-min
-split[0] x,2
-elif {$3==0}
-fill[1] if(max(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))-min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))<$2,min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2)),(i(x,y,z,c)))
-endif
-ifftpolar[0,1]
-keep[0]
-endl
-to_rgb
-add
-else
-keep[1]
-endif
-c 0,255
-endif
-endl
-progress {($>/$!)*100}
-done
-repeat $! -l[$>]
-crop $overlap,$overlap,{$tile_size+$overlap-1},{$tile_size+$overlap-1}
-endl
-done
-append_tiles $h_tiles,$v_tiles
-crop 0,0,{$cropwidth-1},{$cropheight-1}
#@gui Pixel Denoise : iain_pixel_denoise_p, iain_pixel_denoise_p_preview(0)
#@gui : Method = choice(2,"Old Method - slowest","Hybrid Median - medium speed softest output","Morphological - fastest sharpest output")
#@gui : sep = separator()
#@gui : Iterations = int(1,1,10)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator()
#@gui : Preview Shows = choice(0,"Output","Difference")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(1,"Off","Auto")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. </small>")
#@gui : note = note("<small>Update - 1 July 2014 - Added much faster Morphological method. Note: The iteration setting is ignored for this method. There is no change to the output for iterations greater than one.</small>")
#@gui : note = note("<small>Update - 1 December 2013 - Fixed some bugs.</small>")
#@gui : note = note("<small>Update - 20 October 2013 - Parallel Processing</small>")
#@gui : note = note("<small>Update - 8 March 2013 - Incorperated Hybrid Median into this filter and added a choice between the old method and hybrid median</small>")
createbc:
(0.5,0.5,0;0,0,0;0,0,0)
(0.5,0,0.5;0,0,0;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbd:
(0.5,0,0;0,0,0.5;0,0,0)
(0.5,0,0;0,0,0;0,0,0.5)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbe:
(0.5,0,0;0,0,0;0,0.5,0)
(0.5,0,0;0,0,0;0.5,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbf:
(0.5,0,0;0.5,0,0;0,0,0)
(0,0.5,0.5;0,0,0;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbg:
(0,0.5,0;0,0,0.5;0,0,0)
(0,0.5,0;0,0,0;0,0,0.5)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbh:
(0,0.5,0;0,0,0;0,0.5,0)
(0,0.5,0;0,0,0;0.5,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbi:
(0,0.5,0;0.5,0,0;0,0,0)
(0,0,0.5;0,0,0.5;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbj:
(0,0,0.5;0,0,0;0,0,0.5)
(0,0,0.5;0,0,0;0,0.5,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbk:
(0,0,0.5;0,0,0;0.5,0,0)
(0,0,0.5;0.5,0,0;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbl:
(0,0,0;0,0,0.5;0,0,0.5)
(0,0,0;0,0,0.5;0,0.5,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbm:
(0,0,0;0,0,0.5;0.5,0,0)
(0,0,0;0.5,0,0.5;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbn:
(0,0,0;0,0,0;0,0.5,0.5)
(0,0,0;0,0,0;0.5,0,0.5)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbo:
(0,0,0;0.5,0,0;0,0,0.5)
(0,0,0;0,0,0;0.5,0.5,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbp:
(0,0,0;0.5,0,0;0,0.5,0)
(0,0,0;0.5,0,0;0.5,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbq:
--createbc[0]
--createbd[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbr:
--createbe[0]
--createbf[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbs:
--createbg[0]
--createbh[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbt:
--createbi[0]
--createbj[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbu:
--createbk[0]
--createbl[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbv:
--createbm[0]
--createbn[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbw:
--createbo[0]
--createbp[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbx:
--createbq[0]
--createbr[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createby:
--createbs[0]
--createbt[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbz:
--createbu[0]
--createbv[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createca:
--createbx[0]
--createby[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createcb:
--createbz[0]
--createbw[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
megaclean:
--createca[0]
--createcb[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
cross:
--shift[0] 0,1,0,0,2
--shift[0] 0,-1,0,0,2
--shift[0] 1,0,0,0,2
--shift[0] -1,0,0,0,2
-iain_median_5_stack
ex:
--shift[0] 1,1,0,0,2
--shift[0] 1,-1,0,0,2
--shift[0] -1,-1,0,0,2
--shift[0] -1,1,0,0,2
-iain_median_5_stack
hybrid_median:
-ac "
-repeat $1
--cross[0]
--ex[0]
-iain_median_3_stack[0,1,2]
-done
",$2
iain_hybrid_median:
-repeat $1
--cross[0]
--ex[0]
-iain_median_3_stack[0,1,2]
-done
iain_pixel_denoise:
-if {$1==0}
-ac "
-repeat $2
-megaclean
-done
",$3
-elif {$1==1}
-hybrid_median[0] $2,$3
-elif {$2==1}
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
-endif
iain_pixel_denoise_p:
-if $5
-if {$1==0}
-ac "
-repeat $2
-apply_parallel_overlap \"-megaclean \",4,0
-done
",$3
-elif {$1==1}
-ac "
-apply_parallel_overlap \"-iain_hybrid_median[0] $2\",4,0
",$3
-elif {$1==2}
-ac "
-apply_parallel_overlap \"
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
\",4,0
",$3
-endif
-else
-if {$1==0}
-ac "
-repeat $2
-megaclean
-done
",$3
-elif {$1==1}
-ac "
-iain_hybrid_median_p[0] $2
",$3
-elif {$1==2}
-ac "
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
",$3
-endif
-endif
time=$|
iain_pixel_denoise_p_preview:
-if {$4==0}
-iain_pixel_denoise_p ${1--1}
-endif
-if {$4==1}
--iain_pixel_denoise_p ${1--1}
-sub[0] [1]
-keep[0]
-n 0,255
-endif
#@gui Recursive Median : iain_recursive_median_p, iain_recursive_median_p_preview(0)
#@gui : Median Radius = int(3,1,20)
#@gui : Repeats = int(1,1,20)
#@gui : Channel(s) = choice(0,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator()
#@gui : Preview Shows = choice("Output","Difference")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(1,"Off","Auto")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
#@gui : note = note("<small>Update - 25 October 2013 - Parallel Processing was not working properly, fixed now.
#@gui : note = note("<small>Update - 20 October 2013 - Parallel Processing and Control Layout</small>")
iain_recursive_median_p:
-if $5
-ac "
-apply_parallel_overlap \"
-repeat $2 -median $1 -done
\",{$1*2},0
",$3,0
-else
-ac "
-repeat $2 -median $1 -done
",$3,0
-endif
recursive_median:
-ac "-repeat $3 -median $1 -done",$2,0
iain_recursive_median_p_preview:
-if {$-2==0}
-iain_recursive_median_p $1,$2,$3,$4,$5
-endif
-if {$-2==1}
-remove_opacity
--iain_recursive_median_p $1,$2,$3,$4,$5
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
#@gui Red-Eye Attenuation : red_eye, red_eye
#@gui : Threshold = float(75,0,100)
#@gui : Smoothness = float(3.5,0,20)
#@gui : Factor = float(0.1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
#@gui Remove Hot Pixels : fx_remove_hotpixels, fx_remove_hotpixels_preview(0)
#@gui : Mask Size = int(3,3,20)
#@gui : Threshold = float(10,0,200)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_remove_hotpixels :
remove_hotpixels $1,$2
fx_remove_hotpixels_preview :
gui_split_preview "fx_remove_hotpixels $*",${-3--1}
#@gui Repair Scanned Document : jeje_scandoc, jeje_scandoc_preview(0)
#@gui : note = note(Use filter is useful to post process document you scan with a digital camera. It peforms smoothing, background correction and white balance adjustement)
#@gui : Smoothness = int(3,1,7)
#@gui : Background = float(1,10,100)
#@gui : White Level = float(90,0,100)
#@gui : Black Level = float(5,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/11/03</i>.</small>")
jeje_scandoc :
-scandoc $1,$2%,$3%,$4%
jeje_scandoc_preview :
-gui_split_preview "-jeje_scandoc $1,$2,$3,$4",$-1
#@gui Smooth [Anisotropic] : fx_smooth_anisotropic, fx_smooth_anisotropic_preview(0)
#@gui : Amplitude = float(60,0,1000)
#@gui : Sharpness = float(0.7,0,2)
#@gui : Anisotropy = float(0.3,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(1.1,0,10)
#@gui : Spatial Precision = float(0.8,0.1,2)
#@gui : Angular Precision = float(30,1,180)
#@gui : Value Precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest Neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/08/27</i>.</small>")
fx_smooth_anisotropic :
repeat $! l[$>]
ac "repeat $11 smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 done",$12
endl done c 0,255
fx_smooth_anisotropic_preview :
gui_split_preview "fx_smooth_anisotropic $*",${-3--1}
#@gui Smooth [Antialias] : fx_smooth_antialias, fx_smooth_antialias_preview(0)
#@gui : Amplitude = float(5,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/11/13</i>.</small>")
fx_smooth_antialias :
repeat $! l[$>]
+diffusiontensors 0,1,1,$3,$3
+gradient_norm.. >=. $2% *[-2,-1]
smooth.. .,{$1^1/3},0.5,120,2,1 rm.
endl done
fx_smooth_antialias_preview :
gui_split_preview "fx_smooth_antialias $*",${-3--1}
#@gui Smooth [Bilateral] : fx_smooth_bilateral, fx_smooth_bilateral_preview(0)
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_bilateral : skip ${5=0},${6=0}
ac "repeat $3 bilateral $1,$2 done",$4
fx_smooth_bilateral_preview :
gui_split_preview "fx_smooth_bilateral $*",${-3--1}
#@gui Smooth [Block PCA] : jeje_denoise_patch_dict, jeje_denoise_patch_dict_preview(0)
#@gui : Patch = choice(1,4,8,16,32)
#@gui : Cycles = int(8,1,32)
#@gui : Components = float(1.1,1,9)
#@gui : Coefficients = float(1.1,0,9)
#@gui : Remix = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter is quite time consuming.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
jeje_denoise_patch_dict:
--denoise_patch_dict {2^($1+2)},$2,$3,$4
-*[0] $5 -*[1] {1-$5} -+ -c 0,255
jeje_denoise_patch_dict_preview :
-gui_split_preview "-jeje_denoise_patch_dict ${1--2}",$-1
#@gui Smooth [Diffusion] : fx_smooth_diffusion, fx_smooth_diffusion_preview(0)
#@gui : Sharpness = float(0.7,0,2)
#@gui : Anisotropy = float(0.3,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(1.1,0,10)
#@gui : Time Step = float(15,5,50)
#@gui : Iterations = int(8,1,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_diffusion :
ac "gui_parallel_overlap \"smooth $6,$1,$2,$3,$4,$5,0 c 0,255\",$8,$9",$7
fx_smooth_diffusion_preview :
gui_split_preview "fx_smooth_diffusion $*",${-3--1}
#@gui Smooth [Geometric-Median] : fx_gcd_geometric_median, fx_gcd_geometric_median_preview(0)
#@gui : note = note("<i>Smooth using windowed geometric median of vectors</i>"), sep = separator()
#@gui : Radius = int(3,1,9)
#@gui : Iters = int(12,1,20)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/07/18</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>This prototype filter can be extremely slow to compute!</small>")
#@gui : note = note("<small>Only odd window sizes are currently supported.</small>")
fx_gcd_geometric_median :
ac "gcd_geometric_median $1,$2",$3
fx_gcd_geometric_median_preview :
gui_split_preview "fx_gcd_geometric_median $*",${-3--1}
#@gui Smooth [Guided] : fx_smooth_guided, fx_smooth_guided_preview(0)
#@gui : Radius = int(5,1,100)
#@gui : Smoothness = float(30,0,512)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/29/10</i>.</small>")
fx_smooth_guided : skip ${5=0},${6=0}
ac "repeat $3 guided $1,$2 done",$4
fx_smooth_guided_preview :
gui_split_preview "fx_smooth_guided $*",${-3--1}
#@gui Smooth [IUWT] : jeje_denoise_iuwt,jeje_denoise_iuwt_preview(0)
#@gui : Threshold = float(3,0,10)
#@gui : Number of Scales = int(4,2,6)
#@gui : Wavelet = choice(2,"Spline B1","Spline B2","Spline B3","Spline B4","Spline B5","Spline B6")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small><b>Note:</b>Denoise the image by thresholding the coefficient of the Isotropic Undecimated Wavelet Transform.</small>")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/17/12</i>.</small>")
jeje_denoise_iuwt :
-denoise_iuwt $1,$2,{$3+1}
jeje_denoise_iuwt_preview:
-gui_split_preview "-jeje_denoise_iuwt $1,$2,$3",$-1
#@gui Smooth [Mean-Curvature] : fx_smooth_meancurvature, fx_smooth_meancurvature_preview(0)
#@gui : Time Step = float(30,5,50)
#@gui : Iterations = int(4,1,30)
#@gui : Keep Iterations as Different Layers = bool(false)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_meancurvature :
ac "gui_parallel_overlap \"meancurvature_flow $2,$1,$3 c 0,255\",$5,$6",$4
fx_smooth_meancurvature_preview :
gui_split_preview "fx_smooth_meancurvature $*",${-3--1}
#@gui Smooth [Median] : fx_smooth_median, fx_smooth_median_preview(0)
#@gui : Radius = int(3,1,20)
#@gui : Threshold = float(255,0,255)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_smooth_median :
ac "median $1,$2",$3
fx_smooth_median_preview :
gui_split_preview "fx_smooth_median $*",${-3--1}
#@gui Smooth [NL-Means] : fx_smooth_nlmeans, fx_smooth_nlmeans_preview(0)
#@gui : Patch Size = float(4,0.5,10)
#@gui : Spatial Bandwidth = int(4,3,13)
#@gui : Tonal Bandwidth = float(10,1,50)
#@gui : Patch Measure = choice(3,"Linf-Norm","L1-Norm","L2-Norm","Luminance","Lightness","RGB")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;r&#244;me Boulanger</i>.      Latest Update: <i>2015/01/07</i>.</small>")
fx_smooth_nlmeans:
repeat $! l[$>]
if {s==1} nlmeans $1,$2,$3,-_fx_smooth_nlmeans$4
else ac "gui_parallel_overlap \"nlmeans $1,$2,$3,-_fx_smooth_nlmeans$4\",$6,$7",$5
fi
endl done
_fx_smooth_nlmeans0 : s c abs max
_fx_smooth_nlmeans1 : s c abs +
_fx_smooth_nlmeans2 : norm
_fx_smooth_nlmeans3 : if {s>=3} channels 0,2 luminance else norm fi
_fx_smooth_nlmeans4 : if {s>=3} channels 0,2 srgb2rgb rgb2lab channels 0 else norm fi
_fx_smooth_nlmeans5 :
fx_smooth_nlmeans_preview:
gui_split_preview "fx_smooth_nlmeans $*",${-3--1}
#@gui Smooth [Patch-Based] : fx_smooth_patch, fx_smooth_patch_preview(0)
#@gui : Spatial Variance = float(10,0.1,200)
#@gui : Patch Variance = float(10,0.1,200)
#@gui : Patch Size = int(3,2,21)
#@gui : Lookup Size = int(5,2,21)
#@gui : Patch Smoothness = float(0,0,4)
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_patch :
ac "gui_parallel_overlap \"repeat $7 denoise $1,$2,$3,$4,$5,$6 done c 0,255\",$9,$10",$8
fx_smooth_patch_preview :
gui_split_preview "fx_smooth_patch $*",${-3--1}
#@gui Smooth [Patch-PCA] : fx_smooth_patchpca, fx_smooth_patchpca_preview(0)
#@gui : Strength = float(4,0,16)
#@gui : Patch Size = int(7,2,21)
#@gui : Lookup Size = int(11,2,21)
#@gui : Spatial Sampling = int(7,1,16)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Beware, this filter uses a very computationally intensive algorithm to denoise images. So, do not complain too much if you have less than 8 cores
#@gui : available for the computation :)
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i> and <i>J&#233;rome Boulanger</i>.      Latest Update: <i>2016/24/03</i>.</small>")
fx_smooth_patchpca :
ac "denoise_patchpca ${1-4} c 0,255",$5
fx_smooth_patchpca_preview :
gui_split_preview "fx_smooth_patchpca $*",${-3--1}
#@gui Smooth [Perona-Malik] : fx_smooth_peronamalik, fx_smooth_peronamalik_preview(0)
#@gui : K-Factor = float(20,0,255)
#@gui : Time Step = float(5,5,50)
#@gui : Iterations = int(5,1,30)
#@gui : Keep Iterations as Different Layers = bool(false)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/26/11</i>.</small>")
fx_smooth_peronamalik :
ac "gui_parallel_overlap \"peronamalik_flow $1,$3,$2,$4 c 0,255\",$6,$7",$5
fx_smooth_peronamalik_preview :
gui_split_preview "fx_smooth_peronamalik $*",${-3--1}
#@gui Smooth [Selective Gaussian] : fx_smooth_selective, fx_smooth_selective_preview(0)
#@gui : Amplitude = float(5,0,20)
#@gui : Edges = float(0.5,0,2)
#@gui : Scales = int(5,1,10)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_selective :
ac "gui_parallel_overlap \"repeat $4 blur_selective $1,$2,$3 done c 0,255\",$6,$7",$5
fx_smooth_selective_preview :
gui_split_preview "fx_smooth_selective $*",${-3--1}
#@gui Smooth [Skin] : fx_smooth_skin, fx_smooth_skin_preview(1)
#@gui : note = note("<small><b>Step 1:</b> Skin detection</small>")
#@gui : Skin Estimation = choice(2,"None","Manual","Automatic")
#@gui : Tolerance = float(0.5,0,1)
#@gui : Smoothness = float(1,0,5)
#@gui : Threshold = float(1,0,10)
#@gui : Pre-Normalize Image = bool(1)
#@gui : X-Coordinate [Manual] = float(50,0,100)
#@gui : Y-Coordinate [Manual] = float(50,0,100)
#@gui : Radius [Manual] = float(5,0,25)
#@gui : sep = separator()
#@gui : note = note("<small><b>Step 2:</b> Medium scale smoothing</small>")
#@gui : Base Scale = float(2,0,10)
#@gui : Fine Scale = float(0.2,0,0.8)
#@gui : Smoothness = float(3,0,10)
#@gui : Smoothness Type = choice(1,"Gaussian","Bilateral")
#@gui : sep = separator()
#@gui : note = note("<small><b>Step 3:</b> Details enhancement</small>")
#@gui : Gain = float(0.05,0,0.5)
#@gui : sep = separator()
#@gui : Preview Data = choice{5,"Skin Mask","Base Scale","Medium Scale (Original)","Medium Scale (Smoothed)","Fine Scale","Result Image"}
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=H8pQfq-ybCc")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/20/12</i>.</small>")
fx_smooth_skin :
repeat $! l[$>] split_opacity l[0] to_rgb
if $5 +balance_gamma 128,128,128 else [0] fi
if {$1==0} channels. 0 f. 1 elif {$1==2} detect_skin. $2 else detect_skin. $2,$6%,$7%,$8% fi
M={iM} b. $3% *. {$M/iM} *. $4 c. 0,1
split_details[0] 4,$9%,$10%
+_fx_smooth_skin[2] $12,$11
j[2] .,0,0,0,0,1,.. rm[-2,-1]
*. {10^$13} + c 0,255
endl a c endl done
_fx_smooth_skin :
if {$1==0} b {$2/8}%
else
if {$2>0}
m={im} M={iM} n 0,255
repeat {int($2/5)} bilateral 3%,{5*3} done
bilateral 3%,{($2%5)*3}
* {($M-$m)/255} + $m
fi
fi
fx_smooth_skin_preview :
if {$-2==0}
gui_split_preview "if $5 balance_gamma 128,128,128 fi if {$1==0} f 1 elif {$1==2} detect_skin $2 else detect_skin $2,$6%,$7%,$8% fi M={iM} b $3% * {255*$M/iM} * $4 c 0,255",${-3--1}
elif {$-2==1}
gui_split_preview "b $9%",${-3--1}
elif {$-2==2}
gui_split_preview "split_details 4,$9%,$10% k.. n 0,255",${-3--1}
elif {$-2==3}
gui_split_preview "split_details 4,$9%,$10% k.. _fx_smooth_skin $12,$11 n 0,255",${-3--1}
elif {$-2==4}
gui_split_preview "split_details 4,$9%,$10% k. n 0,255",${-3--1}
else
gui_split_preview "fx_smooth_skin $*",${-3--1}
fi
if {$1==1}
to_rgb
circle $6%,$7%,$8%,0.2,0,255,0
circle $6%,$7%,$8%,0.4,0xFFFFFFFF,0,255,0
line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
fi
#@gui Smooth [Thin Brush] : fx_smooth_anisotropic, fx_smooth_anisotropic(0)
#@gui : Amplitude = float(60,0,1000)
#@gui : Sharpness = float(0.9,0,2)
#@gui : Anisotropy = float(0.64,0,1)
#@gui : Gradient Smoothness = float(3.1,0,10)
#@gui : Tensor Smoothness = float(1.10,0,10)
#@gui : Spatial Precision = float(0.8,0.1,2)
#@gui : Angular Precision = float(30,1,180)
#@gui : Value Precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest Neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : Channel(s) = choice("RGB","Luminance","Blue &amp; Red chrominances","Blue chrominance","Red chrominance")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : note = note{"\n<small><b>Note: </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest Update: <i>2010/26/12</i>.</small>")
#@gui Smooth [Total Variation] : fx_smooth_tv, fx_smooth_tv_preview(0)
#@gui : Time Step = float(30,5,100)
#@gui : Iterations = int(10,1,40)
#@gui : Keep Iterations as Different Layers = bool(false)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_tv :
ac "gui_parallel_overlap \"tv_flow $2,$1,$3 c 0,255\",$5,$6",$4
fx_smooth_tv_preview :
gui_split_preview "fx_smooth_tv $*",${-3--1}
#@gui Smooth [Wavelets] : fx_smooth_haar, fx_smooth_haar_preview(0)
#@gui : Threshold = float(1,0,10)
#@gui : Iterations = int(10,1,32)
#@gui : Scales = int(10,2,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger and David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_haar :
remove_opacity
ac "gui_parallel_overlap \"denoise_haar $1,$3,$2 c 0,255\",$5,$6",$4
fx_smooth_haar_preview :
gui_split_preview "fx_smooth_haar $*",${-3--1}
#@gui Smooth [Wiener] : jeje_local_wiener, jeje_local_wiener_preview(0)
#@gui : Scale = float(2,.5,10)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_local_wiener :
-ac "-local_wiener $1",$2,$3
jeje_local_wiener_preview:
-gui_split_preview "-jeje_local_wiener $*",$-1
#@gui Solidify : fx_solidify_td, fx_solidify_td_preview(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-Oriented","Edge-Oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Dilation / Erosion = int(0,-20,20)
#@gui : Colorspace = choice(1,"sRGB","Linear RGB")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter reconstructs transparent regions of an image using a transport-diffusion algorithm. Useful only for images having an alpha-channel.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/07/04</i>.</small>")
fx_solidify_td :
repeat $! l[$>]
to_rgba sh 0,{s-2} if $5 srgb2rgb. fi rm.
if $4
. sh. 100% if {$4>0} erode. {1+2*$4} else dilate. {1-2*$4} fi rm.
solidify. $1%,$2,$3
rv blend alpha
else
solidify $1%,$2,$3
fi
if $5 rgb2srgb. fi
endl done
fx_solidify_td_preview :
gui_split_preview "fx_solidify_td $*",${-3--1}
#@gui Unquantize [JPEG Smooth] : gcd_unquantize, gcd_unquantize(0)
#@gui : note = note("<u>Remove quantization artifacts</u>")
#@gui : note = note("<small>1. Preview will <b>not</b> show the final result accurately.</small>")
#@gui : note = note("<small>2. Be sure to apply <b>before</b> any image resizing.</small>")
#@gui : note = note("\n<i>Block Smoothing Options</i>"), sep = separator()
#@gui : Iterations = int(6,0,8)
#@gui : Preserve Edges = float(1,0,1)
#@gui : Color Channels = bool(1)
#@gui : note = note("\n<i>Anti-Aliasing Options</i>"), sep = separator()
#@gui : Iterations = int(5,0,30)
#@gui : Threshold = int(15,1,200)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/04/29</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Useful for removal of common compression and rescaling artifacts.</small>")
#@gui : note = note("<small>* If a specific glitch remains, try reducing edge preservation.</small>")
#@gui : note = note("<small>* For AA only set Block Iterations to 0.</small>")
gcd_unquantize : -skip ${1=6},${2=1},${3=1},${4=5},${5=15}
-repeat $! -l[$>]
-gcd_srgb2jpeg -s c
-if {$1>0}
--edges[0] 14.5% -n[-1] {1-$2},1
-if {$3" && "$!>2}
-a[1,2] c --apply_parallel_overlap[1] "-median 5",3
-j[1] [-1],0,0,0,0,1,[-2] -rm[-1]
-endif
{w},{h},1,1,0 -grid[-1] 8,8,0,0,1,1 -grid[-1] 8,8,-1,-1,1,1
-b[-1] 1,0 -*[-2,-1] -n[-1] 0,1 --pde_flow[0] $1,30,iee,0
-j[0] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-endif
-if {$4>0}
--median[0] 3 -sub[-1] [0]
-abs[-1] -ge[-1] $5
-dilate[-1] 3 -n[-1] 0,1
--apply_parallel_overlap[0] "-pde_flow "$4",7,iee,0",8
-j[0] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-endif
-a c -gcd_jpeg2srgb -c 0,255
-endl -done
#@gui Unstrip : jeje_unstrip, jeje_unstrip_preview(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Size = float(20,1,50)
#@gui : Sensitivity = float(4,1,10)
#@gui : Normalize = bool(true)
#@gui : FFT Preview = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/10</i>.</small>")
jeje_unstrip :
-unstrip $1,$2,$3
-if $5 -tape -powerspectrum -else
-if -$4 -n 0,255 -else -c 0,255 -endif
-endif
jeje_unstrip_preview :
-gui_split_preview "-jeje_unstrip $1,$2,$3,$4,$5",$-1
#@gui Upscale [DCCI2x] : fx_scale_dcci2x, fx_scale_dcci2x_preview(0)
#@gui : note = note("<i>Directional Cubic Convolution Interpolation</i>"), sep = separator()
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Garagecoder</i>.      Latest   Latest Update: <i>2015/11/07</i>.</small>")
#@gui : note = note{"\n<small><b>Note: </b>
#@gui : This filter re-implements the scaling algorithm described at :
#@gui : </small>"}
#@gui : url = link("wikipedia.org","https://en.wikipedia.org/wiki/Directional_Cubic_Convolution_Interpolation")
#@gui : note = note("<small>The algorithm is intended for enlarging images while avoiding</small>")
#@gui : note = note("<small>artifacts, e.g. staircase artifacts.</small>")
#@gui : note = note("\n<small>Threshold controls edge[lower] to texture[higher] balance.</small>")
#@gui : note = note("<small>Exponent controls texture edge sharpness[higher].</small>")
#@gui : note = note("<small>Warning: highly experimental...</small>")
fx_scale_dcci2x : skip ${1=1.15},${2=5},${3=0}
repeat $! l[$>]
split_opacity scale_dcci2x ${1-3} a c c 0,255
endl done
fx_scale_dcci2x_preview :
z 25%,25%,75%,75% fx_scale_dcci2x $*
fx_render3d : skip ${14=1}
width={(1+$14)*$1} height={(1+$14)*$2}
n3d c3d m3d {round($13)} f3d={0.5*max($width,$height)/tan($7*pi/360)}
f3d $f3d l3d {$8*$f3d},{$9*$f3d},{$10*$f3d} sl3d $11 ss3d $12
repeat $! l[$>]
*3d {$3*max($width,$height)} r3d 0,0,1,{-$6} r3d 0,1,0,{-$5} r3d 1,0,0,{-$4}
$width,$height,1,3,-1
j3d. ..,50%,50% rm..
to_rgba replace_color 0,0,-1,-1,-1,255,0,0,0,0
if $14
r $1,$2,1,100%,2 s c,-3 +. 1e-5 /[0] [1] *[0] 255 a c
fi
endl done
#@gui Upscale [Diffusion] : fx_upscale_smart, fx_upscale_smart_preview(0)
#@gui : Width = text("200%")
#@gui : Height = text("200%")
#@gui : Smoothness = float(2,0,20)
#@gui : Anisotropy = float(0.4,0,1)
#@gui : Sharpness = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_upscale_smart :
to_rgb upscale_smart $1,$2,1,$3,$4,$5 c 0,255
fx_upscale_smart_preview :
repeat $!
+r. $1,$2,1,1,0
if {w<{-2,w}||h<{-2,h}}
rm. /. 4
0 t. "Downscaling is\nnot allowed!",5,5,20,1,255 r. ..,..,1,1,0,0,0.5,0.5
-|[-2,-1]
else
z.. {50-50*{-2,w}/w}%,{50-50*{-2,h}/h}%,{50+50*{-2,w}/w}%,{50+50*{-2,h}/h}%
rm. fx_upscale_smart. $1,$2,$3,$4,$5 c. 0,255
fi
mv. 0 done
#@gui Upscale [Scale2x] : fx_scalenx, fx_scalenx_preview(0)
#@gui : Scaling Factor = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gui : Colorbase = choice(0,"RGB","YCbCr","Lab")
#@gui : note = note{"\n<small><b>Note: </b>
#@gui : This filter re-implements the scaling algorithm described at :
#@gui : </small>"}
#@gui : url = link("http://scale2x.sourceforge.net")
#@gui : note = note{"<small>
#@gui : This filter is useful for resizing images that have very few colors
#@gui : (e.g. indexed images). It is generally useless for true colors images.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_scalenx :
repeat $! l[$>] split_opacity
if {$2==1} rgb2ycbcr[0] round[0]
elif {$2==2} rgb2lab8[0] round[0]
fi
if {$1==0} scale2x
elif {$1==1} scale3x
elif {$1==2} scale2x scale2x
elif {$1==3} scale3x scale2x
elif {$1==4} scale2x scale2x scale2x
elif {$1==5} scale3x scale3x
elif {$1==6} scale3x scale2x scale2x
elif {$1==7} scale2x scale2x scale2x scale2x
elif {$1==8} scale3x scale3x scale2x
elif {$1==9} scale3x scale3x scale3x
fi
if {$2==1} ycbcr2rgb[0]
elif {$2==2} lab82rgb[0]
fi
a c endl done
fx_scalenx_preview :
z 40%,40%,60%,60%
fx_scalenx $1,$2
#@gui _
#@gui <b>Sequences</b>
#@gui 3D Elevation [Animated] : fx_animate_elevation3d, fx_animate_elevation3d_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global parameters :</b>"}
#@gui : Factor = float(100,-1000,1000)
#@gui : Smoothness = float(1,0,10)
#@gui : Width = _int(1024,8,4096)
#@gui : Height = _int(1024,8,4096)
#@gui : Rendering = choice(2,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,1440)
#@gui : Y-Angle = float(0,0,1440)
#@gui : Z-Angle = float(360,0,1440)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_elevation3d : skip "${4=}"
if $3 filename="$4/gmic_elevation3d.png" else filename="" fi
_fx_elevation3d ${5-6}
animate fx_render3d,"${7-8},${10-19},$9",\
"${7-8},${20-29},$9",$1,$2,{``$filename}
fx_animate_elevation3d_preview : skip "${4=}"
w={w} h={h}
_fx_elevation3d ${5-6}
fx_animate_preview fx_render3d,$w","$h",${10-19},$9",\
$w","$h",${20-29},$9",0,$w,$h
#@gui 3D Extrusion [Animated] : fx_animate_extrude3d, fx_animate_extrude3d_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global parameters :</b>"}
#@gui : Depth = float(10,1,256)
#@gui : Resolution = int(512,1,1024)
#@gui : Smoothness = float(0.6,0,3)
#@gui : Width = _int(1024,8,4096)
#@gui : Height = _int(1024,8,4096)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,1440)
#@gui : Y-Angle = float(360,0,1440)
#@gui : Z-Angle = float(0,0,1440)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_extrude3d : skip "${4=}"
if $3 filename="$4/gmic_extrude3d.png" else filename="" fi
_fx_extrude3d ${5-7}
animate fx_render3d,"${8-9},${11-20},$10",\
"${8-9},${21-30},$10",$1,$2,{``$filename}
fx_animate_extrude3d_preview : skip "${4=}"
w={w} h={h}
_fx_extrude3d ${5-7}
fx_animate_preview fx_render3d,$w","$h",${11-20},$10",\
$w","$h",${21-30},$10",0,$w,$h
#@gui 3D Image Object [Animated] : fx_animate_imageobject3d, fx_animate_imageobject3d_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global parameters :</b>"}
#@gui : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,1440)
#@gui : Y-Angle = float(401,0,1440)
#@gui : Z-Angle = float(21,0,1440)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_imageobject3d : skip "${4=}"
if $3 filename="$4/gmic_imageobject3d.png" else filename="" fi
_fx_imageobject3d "_",$5
animate fx_render3d,"${6-7},${9-18},$8",\
"${6-7},${19-28},$8",$1,$2,{``$filename}
fx_animate_imageobject3d_preview : skip "${4=}"
w={w} h={h}
_fx_imageobject3d "_preview_",$5
fx_animate_preview fx_render3d,$w","$h",${9-18},$8",\
$w","$h",${19-28},$8",0,$w,$h
#@gui 3D Text Pointcloud : fx_text_pointcloud3d, fx_text_pointcloud3d_preview
#@gui : Frames = _int(64,1,256)
#@gui : 1st Text = text("G'MIC")
#@gui : 2nd Text = text("Rocks!")
#@gui : Smoothness = float(1,0,5)
#@gui : Color = color(200,220,255)
#@gui : Background = color(255,255,255,255)
#@gui : X-Shadow = float(2,0,10)
#@gui : Y-Shadow = float(2,0,10)
#@gui : Shadow Smoothness = float(1,0,5)
#@gui : Stationary Frames = _int(19,1,32)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/01/09</i>.</small>")
fx_text_pointcloud3d :
W={w} H={h} M={round(1.5*max(w,h))} rm
text_pointcloud3d "$2","$3",$4
col3d. ${5-7} *3d. {0.7*$M}
f3d 4000 db3d 0 m3d
repeat $1
rprogress {60*$>/$1}
angle={$>*360/$1}
+r3d[0] 1,0,1,$angle
$M,$M,1,3,-1 j3d. ..,50%,50%,0,1 rm..
done
rm[0] a z autocrop -1 to_rgba s z replace_color 0,0,-1,-1,-1,255,0,0,0,0
if $11 N=$! repeat $! l[$>] rprogress {60+40*$>/$N}
i[0] 100%,100%,1,4 fc[0] ${8-11} +channels. 3,3 +negate. b[-2,-1] $14% to_rgba.
j[0] .,$12%,$13%,0,0,1,..,255 rm[-2,-1] blend alpha
endl done fi
if {$W>$H} r2dx $W else r2dy $H fi
if {$15>1}
i[{int($1/2)}] [{int($1/2)}]x{$15-1}
i[0] [0]x{$15-1}
fi
fx_text_pointcloud3d_preview :
fx_text_pointcloud3d 4,"$2","$3",$4,${5-7},${8-11},${12-14},1 drgba
frame 1,1,0 append_tiles 2,2
#@gui 3D Tiles : fx_transition3d, fx_transition3d_preview(0)
#@gui : Inter-Frames = _int(10,3,100)
#@gui : X-Tiles = int(8,1,64)
#@gui : Y-Tiles = int(8,1,64)
#@gui : X-Rotation = text("1")
#@gui : Y-Rotation = text("1")
#@gui : Z-Rotation = text("0")
#@gui : Focale = float(800,100,2000)
#@gui : Enable Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2012/13/08</i>.</small>")
fx_transition3d :
f3d $7
transition3d $1,$2,$3,"$4","$5","$6",$8
fx_transition3d_preview :
if {$!==1} gui_warning_preview "Missing input layer" return fi
f3d $7
k[0,1] transition3d 4,$2,$3,"$4","$5","$6",$8
k[1,2]
r[0] 50%,100%,1,100%,0
r[1] 50%,100%,1,100%,0,0,1
a x
line 50%,0,50%,100%,1,0,0,0,255
#@gui B&amp;W Pencil [Animated] : fx_animate_pencilbw, fx_animate_pencilbw_preview(0)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Pencil Type = float(2.3,0,5)
#@gui : Amplitude = float(100,0,200)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Pencil Type = float(0.3,0,5)
#@gui : Amplitude = float(60,0,200)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_pencilbw : skip "${4=}"
if $3 filename="$4/gmic_pencilbw.png" else filename="" fi
animate pencilbw,"${5-6}",\
"${7-8}",$1,$2,{``$filename}
fx_animate_pencilbw_preview : skip "${4=}"
fx_animate_preview pencilbw,"${5-6}",\
"${7-8}"
#@gui B&amp;W Stencil [Animated] : fx_animate_stencilbw, fx_animate_stencilbw_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Edge Threshold = float(10,0,30)
#@gui : Smoothness = float(10,0,30)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Edge Threshold = float(10,0,30)
#@gui : Smoothness = float(20,0,30)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_stencilbw : skip "${4=}"
if $3 filename="$4/gmic_stencilbw.png" else filename="" fi
animate stencilbw,"${5-6}",\
"${7-8}",$1,$2,{``$filename}
fx_animate_stencilbw_preview : skip "${4=}"
fx_animate_preview stencilbw,"${5-6}",\
"${7-8}"
#@gui Cartoon [Animated] : fx_animate_cartoon, fx_animate_cartoon_preview(0)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global Parameters :</b>"}
#@gui : Color Quantization = int(4,2,256)
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Smoothness = float(0.5,0,2)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge Threshold = float(10,1,30)
#@gui : Edge Thickness = float(0.1,0,1)
#@gui : Color Strength = float(1.5,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Smoothness = float(3,0,2)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge Threshold = float(10,1,30)
#@gui : Edge Thickness = float(0.1,0,1)
#@gui : Color Strength = float(1.5,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_cartoon : skip "${4=}"
if $3 filename="$4/gmic_cartoon.png" else filename="" fi
animate cartoon,"${6-10},$5",\
"${11-15},$5",$1,$2,{``$filename}
fx_animate_cartoon_preview : skip "${4=}"
fx_animate_preview cartoon,"${6-10},$5",\
"${11-15},$5"
#@gui Edges [Animated] : fx_animate_edges, fx_animate_edges_preview(0)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global Parameters :</b>"}
#@gui : Negative Colors = bool(0)
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Smoothness = float(0,0,10)
#@gui : Edge Threshold = float(10,0,30)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Smoothness = float(0,0,10)
#@gui : Edge Threshold = float(30,0,30)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_edges : skip "${4=}"
if $3 filename="$4/gmic_edges.png" else filename="" fi
animate fx_edges,"${6-7},$5",\
"${8-9},$5",$1,$2,{``$filename}
fx_animate_edges_preview : skip "${4=}"
fx_animate_preview fx_edges,"${6-7},$5",\
"${8-9},$5"
#@gui Edges on Fire : fx_fire_edges, fx_fire_edges_preview(0)
#@gui : Edges = float(0.7,0,3)
#@gui : Attenuation = float(0.25,0,1)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Threshold = float(25,0,100)
#@gui : sep = separator()
#@gui : Number of Frames = _int(20,1,999)
#@gui : Starting Frame = int(20,0,199)
#@gui : Frame Skip = _int(0,0,20)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/06/07</i>.</small>")
fx_fire_edges :
fire_edges ${1-7} rv
fx_fire_edges_preview :
gui_split_preview "fire_edges $1,$2,$3,$4,1,$6,0",${-3--1}
#@gui Lava Lamp : fx_lavalampbw, fx_lavalampbw_preview(0)
#@gui : Number of Key-Frames = _int(3,2,50)
#@gui : Number of Inter-Frames = _int(30,2,100)
#@gui : Smooth Looping = _bool(1)
#@gui : sep = separator()
#@gui : Resolution = float(20,1,100)
#@gui : Size = float(2,0,30)
#@gui : Smoothness = _float(0.01,0,1)
#@gui : Transparent Background = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/06/07</i>.</small>")
fx_lavalampbw :
if {!$!} (255;100^64;16^128;0) r. 512,512,1,3,3 fi
repeat $! l[$<] remove_opacity
w={w} h={h}
+r $4%,$4%,1,1,0 [-1]x{$1-1} rand[^0] 0,1 stencil[^0] $5,0
if $3 [1] fi
morph[^0] $2,$6,0
stencil[^0] $5,0
r[^0] $w,$h,1,1,3 b[^0] 10 >=[^0] 50% *[^0] 255
r[^0] 100%,100%,1,4 j[^0] [0] rm[0]
if $3 rm. fi
endl done
if {!$7} repeat $! l[$>] split_opacity n. 0,1 *[^-1] . rm. endl done fi
fx_lavalampbw_preview :
fx_lavalampbw 2,2,1,$4,$5,$6,$7 k[0]
#@gui Lissajous [Animated] : fx_animate_lissajous, fx_animate_lissajous_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : sep = separator()
#@gui : note = note{"<b>Starting parameters :</b>"}
#@gui : Resolution = int(4096,2,8192)
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : Z-Size = float(3,1,10)
#@gui : X-Multiplier = float(8,0,32)
#@gui : Y-Multiplier = float(7,0,32)
#@gui : Z-Multiplier = float(0,0,32)
#@gui : X-Offset = float(0,0,1)
#@gui : Y-Offset = float(0,0,1)
#@gui : Z-Offset = float(0,0,1)
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : Thickness = float(0,0,50)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator()
#@gui : note = note{"<b>Ending parameters :</b>"}
#@gui : Resolution = int(4096,2,8192)
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : Z-Size = float(3,1,10)
#@gui : X-Multiplier = float(8,0,32)
#@gui : Y-Multiplier = float(7,0,32)
#@gui : Z-Multiplier = float(0,0,32)
#@gui : X-Offset = float(0,0,1)
#@gui : Y-Offset = float(0,0,1)
#@gui : Z-Offset = float(0,0,1)
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : Thickness = float(0,0,50)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/18/04</i>.</small>")
fx_animate_lissajous : skip "${4=}"
if $3 filename="$4/gmic_lissajous.png" else filename="" fi
animate fx_lissajous,"${5-22}",\
"${23-40}",$1,$2,{``$filename}
fx_animate_lissajous_preview : skip "${4=}"
fx_animate_preview fx_lissajous,"${5-22}",\
"${23-40}",0
#@gui Object Animation : fx_tk_animateobject, fx_tk_animateobject_preview(1)
#@gui : sep = separator()
#@gui : note = note("Object motion:")
#@gui : X-Motion = float(0,-100,100)
#@gui : Y-Motion = float(0,-100,100)
#@gui : Z-Motion = float(0,-10,50)
#@gui : sep = separator()
#@gui : note = note("Camera position:")
#@gui : Camera X = float(0.5,0,1)
#@gui : Camera Y = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("Frame settings:")
#@gui : Frame Size = int(400,50,1920)
#@gui : Frames = int(2,2,100)
#@gui : Reverse Motion = bool(0)
#@gui : note = note("<small>Your mask must be placed below your image. Switch input layers to <i><b>Active and below</b></i>.</small>")
#@gui : sep = separator()
#@gui : Work on Frameset = bool(0)
#@gui : note = note("<small>To use this option your mask must be placed below your frames. Switch input layers to <i><b>All</b></i>.</small>")
#@gui : sep = separator()
#@gui : note = note("Advanced settings:")
#@gui : Sharpen Object = float(0,0,10)
#@gui : Expand Background Reconstruction = float(0,0,50)
#@gui : Smoothen Background Reconstruction = float(0,0,1)
#@gui : Adjust Background Reonstruction = float(1,1,256)
#@gui : sep = separator()
#@gui : Blue Screen Mode = bool(0)
#@gui : note = note("<small>Layer stack for images: Object image top, background image below, mask bottom. Layer stack for framesets: Frameset top, object image below, mask bottom. Switch input layers to <i><b>All</b></i>.</small>")
#@gui : sep = separator()
#@gui : Camera Motion Only = bool(0)
#@gui : Closeup = float(1,1,10)
#@gui : note = note("<small>Use this option without mask layer. Switch input layers to <i><b>Active</b></i> or <i><b>All</b></i></small>")
#@gui : sep = separator(), note = note("<small>Author : <i>Tom Keil</i>.      Latest update: <i>2012/08/04</i>.</small>")
fx_tk_animateobject :
-if {$!<=1} -return -endif
-if {$15==0}
-to_rgb -if {$9==0}
-r {w*{$6/max(w,h)}},{h*{$6/max(w,h)}},1,{s},6 -c 0,255
-if {$14==0}
[-1,-2] [0] -rv[0,1]
-blur_xy[0] $11 -ir[0] $13,256 -n[0] 0,255
-tk_fx_replace_color[0] 1,0,0,0,0,255,0,0,0,0
-blur_xy[0] $12 -inpaint[1] [0]
-rm[0] -rv[-1,-2]
-else [0] -rv[0,1] -rv[-1,-2]
[0] [0]
[-3] [-1]
-to_gray[-1,-2] -ir[-1,-2] 128,256 -n[-1,-2] 0,255
-s[1] c -a[1,2,3,-1] c
-s[2] c -a[2,3,4,-1] c
-rv[1,-1] -compose_rgba[1,-1]
-rv[2,-1] -compose_rgba[2,-1]
-to_rgb[1,2]
-endif
dx={$1/$7} dy={$2/$7} dz=1 -repeat $7
-shift[-1,-2] $dx%,$dy%
-if {$3>=0} dz={$dz+{{$3}/$7}}
-else dz={$dz-{{{1-{10.01+$3}/10}}/$7}} -endif
--fx_zoom[-1,-2] $dz,$4,$5,0
-to_gray[-1] -ir[-1] 128,256 -n[-1] 0,255 -to_rgb[-2]
-s[-2] c -a[-4,-3,-2,-1] c
-if {$10!=0} -unsharp[-1] {$10/5},{$10/2},0 -cut[-1] 0,255  -endif
-mv[-1] -3 -done -rm[-1,-2] -rv -rv[-1,-2]
index={-3} -repeat $7
[-2] -rv[-1,-2] index={$index-1}
-rv[-3,$index] -compose_rgba[-3,$index]
-done -rm[-2] -if {$8==1} -rv -endif
-else
-if {$14==0} frames={$!-1} counter={-5}
[-1,-2]
--blur_xy[-1] $11 -ir[-1] $13,256 -n[-1] 0,255
-tk_fx_replace_color[-1] 1,0,0,0,0,255,0,0,0,0
-blur_xy[-1] $12
-repeat $frames -inpaint[$counter] [-1]
counter={$counter-1} -done -rm[-1,-4]
[-1,-2]
-else frames={$!-2} --to_gray[-1]
-s[-3] c -a[-5,-4,-3,-1] c
--to_gray[-1] --fc[-1] 0,0,0
-rv[-1,-4] -compose_rgba[-1,-4] -mv[-1] -3
-endif
counter={-6} dx=0 dy=0 dz=1 -repeat {$frames}
[-1,-2]
-shift[-1,-2] $dx%,$dy%
-if {$3>=0} dz={$dz+{{$3}/$frames}}
-else dz={$dz-{{{1-{10.01+$3}/10}}/$frames}} -endif
--fx_zoom[-1,-2] $dz,$4,$5,0
-to_gray[-1] -ir[-1] 128,256 -n[-1] 0,255 -to_rgb[-2]
-s[-2] c -a[-4,-3,-2,-1] c
-if {$10!=0} -unsharp[-1] {$10/5},{$10/2},0 -cut[-1] 0,255 -endif
-mv[-1] $counter
-compose_rgba[$counter,{$counter-1}]
dx={$dx+{$1/$frames}} dy={$dy+{$2/$frames}}
counter={$counter-1}
-rm[-1,-2]
-done  -rm[-1,-2,-3,0]
-endif
#camera motion only
-else
-to_rgb -if {$9==0}
-r {w*{$6/max(w,h)}},{h*{$6/max(w,h)}},1,{s},6 -c 0,255 -endif
dx=0 dy=0 dz=1 -if {$9==0} counter=$7 -else counter={$!-1} -endif
index={-2} -repeat $counter
-if {$9==0} [-1] -mv[-1] $index -endif
dx={$dx+{$1/$7}} dy={$dy+{$2/$7}}
-shift[$index] $dx%,$dy%
-if {$3>=0} dz={$dz+{{$3}/$7}}
-else dz={$dz-{{{1-{10.01+$3}/10}}/$7}} -endif
-fx_zoom[$index] $16,$4,$5,0
-fx_zoom[$index] $dz,$4,$5,0
-if {$10!=0} -unsharp[$index] {$10/5},{$10/2},0 -cut[$index] 0,255 -endif
index={$index-1} -done
-if {$16!=1} -rm[-1] -endif -endif
#preview function
fx_tk_animateobject_preview:
-if {$15==0} start_x={{xM/w}*100} start_y={{yM/h}*100} -else start_x=50 start_y=50 -endif
-fx_tk_animateobject ${1-6},1,${8--1} -k[0]
-line[0] {$1+$start_x}%,{$2+$start_y-10}%,{$1+$start_x}%,{$2+$start_y+10}%,1,255,0,0
-line[0] {$1+$start_x-10}%,{$2+$start_y}%,{$1+$start_x+10}%,{$2+$start_y}%,1,255,0,0
-line[0] {$4*100}%,0%,{$4*100}%,{{$5*100}-5}%,1,255,255,0
-line[0] {$4*100}%,{{$5*100}+5}%,{$4*100}%,100%,1,255,255,0
-line[0] 0%,{$5*100}%,{{$4*100}-5}%,{$5*100}%,1,255,255,0
-line[0] {{$4*100}+5}%,{$5*100}%,100%,{$5*100}%,1,255,255,0
#@gui Rodilius [Animated] : fx_animate_rodilius, fx_animate_rodilius_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : Color Mode = choice(1,"Darker","Lighter")
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(5,2,20)
#@gui : Offset = float(0,0,180)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(5,2,20)
#@gui : Offset = float(180,0,180)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_rodilius : skip "${4=}"
if $3 filename="$4/gmic_rodilius.png" else filename="" fi
animate rodilius,"${6-10},$5",\
"${11-15},$5",$1,$2,{``$filename}
fx_animate_rodilius_preview : skip "${4=}"
fx_animate_preview rodilius,"${6-10},$5",\
"${11-15},$5"
#@gui Soft Glow [Animated] : fx_animate_glow, fx_animate_glow_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Amplitude = float(0,0,8)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Amplitude = float(3,0,8)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_glow : skip "${4=}"
if $3 filename="$4/gmic_glow.png" else filename="" fi
animate glow,"$5",\
"$6",$1,$2,{``$filename}
fx_animate_glow_preview : skip "${4=}"
fx_animate_preview glow,"$5",\
"$6"
#@gui Spatial Transition : fx_spatial_transition, fx_spatial_transition_preview(1)
#@gui : Number of Added Frames = _int(10,1,256)
#@gui : Shading (%) = float(0,0,100)
#@gui : Transition Shape = choice(7,"Bottom Layer","Top Layer","Custom Formula","Horizontal","Vertical","Angular","Radial","Plasma")
#@gui : Custom Formula = text{"cos(x*y/(16+32*A))"}
#@gui : A-Value = float(0,0,1)
#@gui : sep = separator()
#@gui : Preview Type = choice(1,"Transition Map","Timed Image","Sequence x4","Sequence x6","Sequence x8")
#@gui : Preview Time = float(0.5,0,1)
#@gui : Preview = value(0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/10/04</i>.</small>")
fx_spatial_transition :
to_rgba r ${-max_wh},1,100%,0,0,0.5,0.5
shape=-1 formula=
if {$3==0}
elif {$3==1} shape=0
elif {$3==2} formula="$4"
elif {$3==3} formula="sin(x*0.5*pi/w*(1+100*A))"
elif {$3==4} formula="sin(y*0.5*pi/h*(1+100*A))"
elif {$3==5} formula="atan2(y-h/2,x-w/2)%((1-A)*2*pi+0.001)"
elif {$3==6} formula="R=0.5*sqrt(w*w+h*h);sqrt((y-h/2)^2+(x-w/2)^2)%(0.001+R*(1-A))"
elif {$3==7} 100%,100% plasma. 1,1,{8/(1+$5)} equalize. 1024
fi
if {narg($formula)}
{w},{h},1,1,"A=$5;"$formula fi
if $-1
if {$6==0} k[$shape] norm n 0,255
elif {$6==1" && "$7==0} rm[$shape] rm.
elif {$6==1" && "$7==1} rm[$shape] rm[0]
elif {$6==1}
transition[^$shape] [$shape],$1,$2,$7*($1-1) rm[$shape] rm[0--1:2]
else
transition[^$shape] [$shape],{$6*2},$2 rm[$shape] to_rgba
fi
if {$!>1} to_rgba frame 2%,2%,0,0,0,0 append_tiles , fi
else
transition[^$shape] [$shape],$1,$2
rm.
fi
nm name(transition),pos(0,0)
if {narg($formula)} u "{$1}{$2}{$3}{\""$formula"\"}{$5}{$6}{$7}{0}" fi
fx_spatial_transition_preview :
if {($3<=1" && "$!<3)" || "($3>1" && "$!<2)} gui_print_preview "Warning:",,"This filter requires more input layers to work properly." return fi
fx_spatial_transition ${1-3},"$4",${5-7},1
#@gui _
#@gui <b>Silhouettes</b>
#@gui <i>Animals</i>
#@gui Dragonfly : mc_dragonfly, mc_dragonfly_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_dragonfly :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_dragonfly {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Dragonfly"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_dragonfly_preview :
mc_dragonfly $* blend[^0] [0],alpha rm[0]
#@cli shape_kookaburra : _size>=0
#@cli : Input a 2d kookaburra binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_kookaburra ,
shape_kookaburra : check "${1=512}>=0"
e[^-1] "Input a $1x$1 kookaburra binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgOTU5IDEgMSAjMTEwNwp4nI2VeWyVRRTFz3TfH6Eo7qLFSDSKgFBKSyGARSgICCggdYni0gaDiSHRhESjiYZocMEqFCioiNWispQlRNPUQsUCLbZQS21tKd33je7net+88nwvmugfv5z55r2Z755778wHH/gYGEDpTXVgHO/DJE7BNEZjOVdgHQ36JAnJTMEGvoKN3IjX+Do2cRPe4Jt4i2/jHb6LzdyM9/g+tnALPuCH+Jhb8QlT8Rm3YTu3I82Shh3cgZ2WnZZdll1IZzp2cw/2KJ/zC3zJvdirfMV92MevkcEM5Rt8y0xkcj/28zt8zwM4wIM4xEPKYRweIYtZyhEcsRzFMR5TjuMET+BH/oRsZiOHOcjlSeQxD6d5GvnMxzkW4jcW4QIv4neWooxlqGAFKlmJy7yMGtaino1oZiva2YFu9qCXfRjgIEgCYoyv+Bp/8TeBEmRCJMSESbhxiMOMktEmUpZgQLJxvSSiS/UGSUCz1XjUSA4i5X6UqYbLTTgnP2uMuTbGXJ7CKY0zT+P8VePM51mNtQAFPG/jLeIFG3OJxlzKSxp3Oco17gqNu5JVGns1qllj469lvXpoQAOb0MRm9dKCFrahje3WUwe70MVu662HvdZfH/st/epzkEMY4jCG1S8pFqExRnyMj3r3FT/jp/79JdAEKM48BEmwCdZchEioCZUwmxMn4RKheI4jTIRbHR5j77n/r97rw+17wkfeH+bW0JG4nOqKMdTWLtgS7NYg9eLy41SnvwD1GTCi/urbz9bfx+bCR3NiDARGbJ6oORvW3A1ZBjWXAxzQnDpz26d57sVVzXm35r5La9DJTkuH1qTd0q41akOrrZVLW7UPWywtto7NWs8mS5NbGy2NWu8GW/d6rX+dpU57oW5Ea21v1GiPXLFcsVRbqm3/VGkflWtflfEPey4uaZ85z0gJS3BRe69Ye7CYxdqLRTivfVloKdQeLcBZ7dczPKN968CwHNfzFoZ+OaoagquShV8YrOfhoPZ3INrlB5ykH5okU/veF/WSYe+CdO7WeyLd4rw30vQOcd4n2/gqKOPxKTdgUKKQypd17ztV16NX7tD59eiRcaop6JTb9T5K0XfcppqMVrlV1yfrGbxF9SU0ys16V72IOrlRn1/QMzlW//c8quU61XWokjG6z3P4U0br/s+iXBzYymdQKmFWSyQYH/FpPMUnkcQkrOVaPME1WKOs5mqs4io8zsewkiuxQu/W5XwUy7gMS7kUS/gIFnMxFnEREpmIhVyIBVygPIz5nI8EJuAhZR7nYS7nYo5lDmZzNmZZZiGe8ZipuHSme+w97/otjnGIVVwaa8feGosZbp2BGMWlMXbs0hhMd+v0/xx7rru2n+feLmK9xrHuZ++x99y/6z89xXn87unfqa6c/K3X1nh6jUa0Mo1TMdXyIKbot9LJZE62TOIDmMiJuJf3YAIn4G7ehfGMQhTHQiRIv69jEMlRiGAossr/As3XmqgxIDI2IDEgMSAjNTMKeJxzZ/BliGJgYIhmMGJIYVBgyGbIB8JshkSGJIZShiIgTASKFjNkAOkChlSGWKBaAORKCL8="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d kookaburra shape]" v +
#@gui Kookaburra : mc_kookaburra, mc_kookaburra_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_kookaburra :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_kookaburra {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Kookaburra"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_kookaburra_preview :
mc_kookaburra $* blend[^0] [0],alpha rm[0]
#@cli shape_rooster : _size>=0
#@cli : Input a 2d rooster binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_rooster ,
shape_rooster : check "${1=512}>=0"
e[^-1] "Input a $1x$1 rooster binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTkyOSAxIDEgIzIzODEKeJyFl3l0lsUZxe9k+bInJAJhlUWBIJvSqGjV4gYiaEUxIKvIYgC1Lsj2IftioaKIIjsIiKAUq2VRrFBbq4IisgkIBBISEpZEZAsEmOud+T4CnJ6e/jHn99yZeWeemXlmeRGBCAMDKLU7Y1BMg0o2AiWMQOVyRuIXRiK9nFE4zihUKWc0fhXTxROM9jrEAE4xgCZqp5iX7Ci1EYPTSmXqK9N/e0lH4GYbg5OMxRmvI8M65godq3ZiUep1lHScymJxVsnpTOlSxuFcuY5X2WXd2o8pXjoe55Xv8i7Ij3bejwTpBOk4lQVwUf600xhOMlE6QdqVXcp3fiTKTgI9Y3x+W+9Pw3L9oPovZQas+r8o/9vaBPnTXDpKZYnqr7m+j0Ybm6Ty28Q2eMA+4FNr29qnVvZBfK72ptu2+A8rYY5tJ9bCStsZ/2YdrLVd8U/xX7Yn1rEuvrF9sJ7XY6O4jvXwvfgF62Oz7Yt/sAG2eGZgm31a7TbETzYba8Wd4me8AbvFT8WfbT+xEfbZ/lgj5oir2RgH7ADPPPsMVooHrZvDXvg7m2CvfQqfsKm+cWyG/eLHYq7thb+J+fLlI7FQfa8QD6uvv/JGFKvt5eIvans5b8Kvanu55uaUfc7ztPghf4ez9nkxE2X2Bc8L9iWV3wIrfshbAQ6UbgHDl9Xu7YgUV/BOBDhY/bdErPgJ70MCh2IVWyOJQY2lDVI82yKNr2is7VCRIzT2P6Ky5yOowlFie1QT14g1xNV8DLU4RuyAOhyr/MdxHSeoXhbqcaJnA07SnGYhg5M1x53QiFM0553QmK+LT6App2ptOqMZ3xS7oDnf0pp1QyZHKh4qah274xb1dZ5pWuMeaKH+zrECvmRP3K4+S5mCr9gbd3C84i5JcdEXd8mHU4rVr5mNlnxVdjy+5QDcw9f8XtnAZ3G/+nd7biOfQyu+oRiPxnd8Hm04TXs3Epv4EtrKly80fw9zuucjnCl/BuMxzpYvQ5HFufJjGDpxvhhEFy5UPMYptl9Edy6WHZDfL+JJLpGP0fL7JfTiMvkYJXsg+vBD+Rip/TAI2VyBb7RfStV+f34k28jXwXiGn8hfozEMxp+4MmwPwQtcpRgeioH8VByCQVzr9RB+rnkdiiDXeT2c68VhGMkvlT8MY/iV1+P4tdcT+a0YxCRu1PoMw2R+JwYxhZu0bkFM5Y9eT+NWr6dzu9Y1iJncofUejjncqfUPYh53i8PxLvcoroZjMfdpbwSxhDmKtyCWcr84XDGaq/0QVGzmaR8EFZP5sodp7xSozMXkIXwgvYaF0kH1uU3nQ0XF9Aj5vV0xkSZ7pGJkp+wU1Rmtud+t/Zeo78ZozvfoTImTPU5zm6N5jsYyxcYG9TtPMfk9D2K+YuIH9bdAsblF/Thu4xEs5F/wE49hkeJkF0s0htexh8c99/EE3lOsHuApzzye0dimoYBnPQtZhvf5No7yomcJYZbyHRdL4gx3XnueZ6JZxmXmA37wf9Iy1V96VXqfS8yScHqP7yktNou4yCzku2YBF5j5nG/mca6ZwzlKs80szjIzOdPM4DtmOt82b/EtM41vmqmcat7g62YKXzOTOdlM4p/Nq5xoJnC8GcexZgxHm9EcZUZyhHmFw80wDjVDONgM4stmoOL1Ip81A9jfZDPb9GFv8xR7mh7sbrqws+nILNOBHUx7PmIeYjvThg+YVrzf3Md7zb28J5zuNnezpWnJP5i7eKe5g7eb29jC3MpbzM3MNJlsbm7ijaYZm5ombGwas5G5gQ1NQ2aYBqxv6vF6cx3rmjqsY2qzlqnJGqY6q5mqrGIqs5KpyGtMGlNNBSabJM13PONMrOY/wCgTyQhjSJ2XF3DenkOpPY0SW4xj9giO2MMosoU4ZPN1Th/U+Z6rsz5HZ/lenes/Y5fdqbtiB7bbbdhqt+g++UF3S4zWdD3W23XhZDQ/a3UnfaZkdBaswmq9G8iPscqXOXs5Ppbt7l3LpVjmyxdhsV2ERfZdLLQLsMDOwzw7W3fdbMy2s5ScPcfrEK9Oc+3cq9I8fX9Zh+rM9m09qj5bY5ZNlS+/lw/ubq6JmTZZ47hNe6eB8mtihu7pc7pHylR+gTXwtnw8pXvmrMrLWB0TbKa/18tYDeOt7ifln2VV2TeqXkbYbqr4z1C9KrIb632RoTPN2Y30bsrQN+kYZzP0HsrQN+kYa+vpnZShs7gyxti6OCb7hOzRtrb2VYa+d3ZNHFZfx2WPstVQpHxnj7CVccjb6XjFpiBXdUqUH9R7JEf5xbLbq69j4qO2AY7oHeFYpLOlg/ILxcelC3iNZ76YJeYx1TNX7GjrY7/YSczRHdRR/u4TO4l7dRaF6PT1Ojcc62K38jvaOjpPHGt7Ztla2Ol5rc4bxxrYofpZtjq2Sz+ucW3zrCq6/KrY6pmOH339dGz2rKxzzLGS7ivHijrfXD8hZtlrdKddyTTdd8leh5imczE5nO++u6xDTNW9mRzOd+UhfTnf0eVX0H3lxp8aptMVyvmEZ+oVTBHT0Fn6W/FKvUHr0Fl6g9bHcZPiqIu4hdd67tD7rotidZfec12l9+jd1lV6r95njjl6g3VT/gG9rbpJ58qfs4rR7srL05vglGLX2fl6E/zq7WTZMYqP6uih/ALtz8OK/yd9W+6tHLIPKL9EPjypd2qu7u9i2T2Vf1D3S7Heoj19O86uLTtJ7QRk18FTyi+UfVR+91J+kfo6qjm5qOT0YZUd0bvFvWl6q+5RlR/RXXZGfvdW+THpIvl6UvPt9C96vxR6nYI+0sd11zl9IqxPSB/yY6uAvnpfn5Rd4HUqslV+RnPgxl6i+tkqL5U+KH1M7fdTeZl8cfqo6MrP04033vvUz7/Rk70+rO+yFbcHZBfJ7id7v/fF2dW97fy4ZDsf+oftfKWQHev7GhC282Q/q/29X3Pi2n1e+8TZ7psX7HUqj9Z+i8NA7dcCrcEeffOybSJfIvGz7EE6h9z/207N2WDbQmOPCNsBjethjSFG/bbX2B0f09zFyD/HgNhBc+T4kOoFNLY7/L+OW99s7bcicbP6ydbeWqF2n1asL/esoDeIY4reHBGa8yS9N4zWIlFvHscEJCjF6xyKK0+xiNG9ESPGhlNIh1LgCjukA1flhXTgv+r9r3SpfpT+UyL1/xdxRbqs9Res1PL0b3UXFlsxIDE1IDEgMSAjMzMKeJxzZ/BliGJgYChhyAdjPYZkhkyGXIZ0hiqgKABOuAT9"
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d rooster shape]" v +
#@gui Paw : mc_paw, mc_paw_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_paw :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_paw {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Paw"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_paw_preview :
mc_paw $* blend[^0] [0],alpha rm[0]
#@cli shape_mapleleaf : _size>=0
#@cli : Input a 2d maple_leaf binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_mapleleaf ,
shape_mapleleaf : check "${1=512}>=0"
e[^-1] "Input a $1x$1 maple leaf binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTczNyAxIDEgIzE4ODkKeJyVl3lwldUZh383yb1JCIssCdBCKiVEQRGwWgLD4gaYUIpCkipLKyFkIQGxLe3UWurCUhEFREXEaWVsKzJBnWmt49qqrZVKHUQsLbYqRRBZpEDYcnPP2+eceyUk0mH6xzvv83u/s77nfOd8n9KUFlFEwrrsisgsTRkuppjLVKbLUpbLVrZrp3bBcpTj2qt9sA7qcNo6quNp60QbEXV2XdQlZV1dN3VrZbnKbWV5ymtj3V13rId6pCypz27JOq3b7OXS1Wy56u2iSgSfKWfd8L3x6err8hlnBr5ABf+HFbpC9XP9zmlN5HFg8On4AsYSDT5hmboEb5aNH6RBwQZrMPZ1F1HcvE+n3BAVsQ4W/DANa2PD3fCzWvJ5EXWKqJuuEW4ENlIjT9sojcLO5LH0e8pGaZzLoP9RupZcJWy0il3xWaxEJSlrYp2vxzfTj/fOYip1pSkrU1mwcpWnrK1O2reCn8qcnXk/TdPOalO/EJtK7EyrZjzH3BR8WvA+999ljRvdjcwrQ99nfI2uQvNZg0Y3Uz+0rOB/bO21lGc3W4Vusw5wlm6xmVpgHeEcYnX6KXw3zxbAt1sn/czO0x3wXfgl1gVfp4XWWYvhhfAieBH7bbHVh+cL4SXw3fiFlke7c3UPfJf10DJ4BWN27NM7rafutTlaib8duw++H78AWw4/YF/WT+xLlI1oFe09iL7NvoKv00PWS7fa+fjZWm299SPro4fhNZbPXL+qR+Bf0E8CPd/6aq3V6jHzec/X99AJ2nyM2DorIG99w3uyzmr0uPXTPLtQG6jbhP4lei66wfw7VaNfWaHmWH89ZbfoCbtA9TaA/ZShF9DrKVdvF1EvppfQT6LrbCB7JkuvoDegZ9sl9N0u7Nc/EmugrRpijty+gd6IrrIr9Gf4Oco0oSvRb9o8dJS2+qvCrmSNI9pC7Hnz+3cAsavw6cRuZixZtDdANxFzjO0dYi/Z5fq2Fetd8v+KDdU0G6+/wb+Hp8Db4VdtGPwNuD7wDfDf4dfgcvgf8OtwKbyDNdhk/twp0iS7Th+Q778wPmfD0RPRtXrLrknxXG21sZpMuQ8ZyzYbR3uTQ/w9uxYu00fwdsZXaqWUmYOlM0ev/bM5WAZ9ldCG1/XaSY4dehLv0UeM5d82SdfBO+GPaWNi4NnaDU+A95KrPfB46p+i7aPk9xN0MTrOuI/y/FPKFWP+3GpknF6P43mC8+t40GUagxnvyQn0Pp5fYzPgudoPXwWfZKyex1gVXK8D8NXwqcBllKlmTet1EL6S/dTEGA8wjtFwHD4IjyJ3cbTnESFeoyNhL5ennlUz3gzGMZU2aslLFXqGrghlK+EK2McrmUdFqNOMb+Q9HxnKzNAxnvm2m+2mwMNpM27fYZ6zYF9meogXhfj0EB8aeBrznaXL4Wb6P0Hfl2FxmxLil8LNdmOIFzHPuN0Q4kPJSzN8MtT18XK4Cvbx8hC/LMWn4K+R02bmf5IxDAnxUuKVGhzik+GZGhR4UuCBga+HK3RxipuIXwQn2Hc+3j+0M5F4ZeBE4BrKe54A11K+PrBfC9+OO4MTvCdx9tfFrL0LPFsDQpnxtFtHm56LQ5kLYYN9vJD2Hfu8mfIFsLH/fd2+9OXZx/sEHhv4fOqYjQmcb8/ga9XLnqb/WvW0BnSN8mwDukbd7El8tXKDrlZ324ivwj9Fn7OIez2Lcg1Bdw2+Gr0BXxvqOfrJpR2j3zz8mbqbrU/5J4LvbOdFOlmnSEfrEMmx7EimxSIxi2IZkXSL8FHllHDNanIndcId5246zr3zuT+qw+6wDrlDOugOYAf1GXbA7dd+t0+fuk+0x+3Wx26XdroP9YF7Xzvcdr3ntmqLe1ub3Sa94V7TH9zLetE9r+fcs/qNe0ZPu43a4Nbr1+5xrXM/16NujR5yq/QZd9Gzbjn7Pl+/c0vZSxfgF7HOA/F3kpdL9Vv3ul512/RO6GML48lj329mnP6OeEunmIefD5NnaonAcdcUOI35ZlhaJMrcY6ctGrSPR0yRNCxq6cE+z1OGLQ1nis9z1JaF+yHO2kTtPsaWyV6doZitwGfx7kxXJnyc+DHeMc/H4CO8JzHzc8vUId4Bz0c4Ew/YN5VlK3UY3sv+a28P6j/wbrtaObaasjHOyhFqZw+Tnxhn8BD6XcNZE+NML2Sej9BGjHO5jyLwPngrd22areX8i+mv3Oee98Jv8m0Qgfdwfr7o1tJHTC+7R1N+rXYRf8Gtpr8o67Q8nNkNbjHndYx1upW+o1rpavUv9P2uRv/Er8K/j3+A+A6er3ITSH1P7h7/rIS89eBOimmFG0POunOHRbXMjSZXeYw5qiV8l8e5s0/wfbGNcj9gHRv59ng3cB9y1JX7MAr3JhdduS+jms83936+Yd6mzHzXlXuhkzbD8/gP2MV30CbKlMB/Cj7G3ej/GZIW5Zs76lp0MtZa+/+LtjrznLGkbom16GSstU7+v2R9QbfEWnQy1lr7f5+2OvucsaRuif1vnd2mbiZz6rfrv+okDzMxIDE1IDEgMSAjMzMKeJxzZ/BliGJgYChhyAdjPYZkhkyGXIZ0hiqgKABOuAT9"
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d maple leaf shape]" v +
#@gui Rooster : mc_rooster, mc_rooster_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_rooster :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_rooster {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Rooster"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_rooster_preview :
mc_rooster $* blend[^0] [0],alpha rm[0]
#@cli shape_paw : _size>=0
#@cli : Input a 2d paw binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_paw ,
shape_paw : check "${1=512}>=0"
e[^-1] "Input a $1x$1 paw binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMjAyNyAxIDEgIzIzNTcKeJyNl3d8V0UWxU8SCKQRFNBFEFFxQaXIhiQ0IbFQlC6gIl1IAkiRdXEtuytiYV1dWURUWBZEioiU0MsCClIMBBJaooAgnYCVppS5ft/7PX6CZssf8zlnkt97b+6Ze8/cUaQiIxQhMRqfjVSUK6GSLlqlXGnFuBh/xLpYRpziXbw/ElyCxliUngXftJL6k4/R+osro7FWWs/5GKPhV2CsRrhEvWXxeuEKTNCLAb7kY6JeLhbLamQYvff9Eq/SX/11/IwjWfMY8GVieIPfvehKaTQ4wkVpFFjWlVUiz5bxRwKxxRFnjEoT//OnouEJ/KacKrhrVdFdp8quisaxztGuqibw3rHuZk2yCnrH3aLJ9hv901XXVKukie42TbcqmuxqaoZV1RRXWzPtJk1zd2iWVdP7ri54iz5wSZpj1fWhS1a23arZLkXz7HbNdfU132pqnmuohVZbC1wjLbI7tNA11mKrq8XuTi2xJC11TbXMkrXcpYEpWuHStdxSwbv0b6uvVe5urbCG+tjdq5XWSKvBVXanPnHNwCZa51roY0vTBtcSTNen4Gq7Sznufq2xu7XRx3uU61rpE2umLa6N1lpz5YHrrIXyXVuwpba5duB92u7aa4O10k7X4TJsrUL3gD61tvrcdVKOtdOuAHe7ztpoHbTHxwe01z0Y4EPKtU760j0Mdtb+AA+4LtpsD+mgjw/rsOuqLWHsoqOum/Ksq44FWOS6g910PMATrofyrYe+CvBr10tbrae+8bGXvg3wO9db2+xRfR/gSfco2EenrsC+Og1utwydcX3ATJ0NY1/tsCz96DKKwX46B+60/jrvMsEBunAFPqaLv0DnssCBxBitFAvxPOosFV5gg4glVvV9Pph1xatBwLdbGTUM80Q18vkQ1vAz30keNw7zq9WE9RXY44zLeTk1LZaXV5rPh6rw/+IVlO7z3+uzYnihPXEFL+Rbaf+BN2XNhfYHfh/iBf6z3ppDvJC4mpinn8fLqi8+tSc8T1QGvrQ3mBdQ0xkWp33heTzzeP6f4c93om8GWu4L5jusFO9LDM+3WaQe5XtfBvN6Pvdy4Akls6Z95IzHU1jr/+Kp6LWXnNuBLik+93JwKH+vcAX/gjwtnvckh4eSD9cQb49f8Mf93+wyrz6G/Ip/Ts143FvPZ/YI+TaEZ6KUybyQ+tpCHhUQ90BiKjCvBgfxTHkNQt8d5tXsIO3GBwfzm9B8IN+txDye93TWJuZ77QbmMXynE7X+GDrdxLc74gcDtB9PTKX+PX4AX0y19vhGfx202+Dt8JJ+OoQ/puIl6+GHrRa8Nd6TBa8Db4U/Zeqo/Q5+H56VAU8inhb4WF94MrwZXtdHx/DJFLztI7Q+hlcm43er0LcIv0zGC1eiaRGemYRPrkDTInwzyRrjr93hTeEN8dzuOo5/1uVdS9DuOM/V4XuL0O4476uNZy/An47znZqsdZ49CG+m2/H6uehRBB+OFtnEPQsNiljni2iXbTdyXnRg3lIj2Zd5Vlnvo0WR3a9X0Hcu+znV2rDuVnoVfWeRvxPhx9DiNc6dNGI/yv9f5+xJw6+PoNcodE6ze+Ht9A++l47PH+Ybb6BzOvEcQvcxrCudGA+wlrHonG4N2JNOnLm1eLYeOdoZXpt6q8O+dtbbxNeEvdnFXo/jXGrM2VZIvOPRoCFr3k6OjOe5VOohF00mcEadxqsnoNdZPPpf6O7hRLT8EU+ehN7nXU+9i9YXAryIJ09mfYbXvofWYr+moHMEeziFGCLBqehbgv31sCT7P404o8Hp6FuK3JiOBjHky/voG8KWiiPHPkDP+AATyMWZ6FcmwERydSYaXkVOf4h+IWynctTEbPYihB1UgZqag3Yh7KhrqbdL6O1xRer4Emaz/9dR49noVSnAyjaMs76Lrg+wij0JPqIbAqxqfySHugbYTTcGeJM9dRl2183gQmq8mj0N9tQtxWIvVbdnisHeqnEZLkLjW+3ZAL2/9yGvotE/xN+0isQe4u+QV/N93pf9vI3+JMQnkSPLAj6ZHFgR8CleX+LzDPapEbX4NOvPYE+aUqMhPoN9XRvwmezlOp9nkufNqfsQn02Ob0CL+fA55P6nAZ/LnuX4PIvRHo+5xDvgP09SS1k83xE+zOcL2ZtczpFs+CL2Y7PP+1HPnt+F+FLz+gtvH/v5NZ8Hn8Pvl6NrHvs+O8yHsMYseq/enMkhvgKN8v3c6UfcGfigl1chnu/nWj88KAven7iz0KM/v/Fy1OMD4F4eZ9GXPRbma3jfVj/fM+GD4V5NZOJ3Q3hPL/YpE/2G+r3N5IDns+5JfHMdeZdPPBPh69Egn3qdEPA88nM87/V09fx5nM+fIvb21H0fNH4afdriDX3Q+Fl4KzwjxDdRU6NZx0b7M7wZfhPiOezla6xpoz3H8030N58P570N9DLr22TPs6Z6GkHu5toLrLWOngv4aquhZ8jxXHsJvapqGOv2+GL/DOrK90dSd13420iVJ47N9gr4UIAPgq+CncHXwI7g36nbB8DXwfbgKF1NTW+x0dR3a+ajVZaYttgY8D7mY/CBFuBYfOFevvMWeA/zt/GNdObvgE3BcYrFNzfZePylPvFNUGnOmhwwmrMoxybiT7WI/11F4bHrbTL+dTOxvkdvdz1xTqEnLMeZM407wnTuBzO4G8zUTPehZrnZ3AvmcCfIVrabp/luAfeARVrkFmuJW8odYBn9/wqtdKvo9z+i119Nn7+GHn8t/f16rXcb6Otz6OU3aZPL1Wa3hf49n959K337du1wO+nTC+jRP6M/30Vvvpt+fI++cHvpw/fRg++n7z5Iz31Qh9xheu0j9NlH6bGL6K+P01OfYHxFL/0N/fO3jO/om79nnKRPPsU4TX98Fp8/qx/cD/j8OWI9h89fwOMv4O8ODRz+bgxFRFiEPyItkhEVUcJK+KOklWRER5SyUuFR2kr7I8ZiwiPWYn814izuv4xf/z6W91x6d2hc+mZ0sA5vlIiIYn1R/jojWTMXaH8Y8VwkrovEd544zxHzD8R/Bh1Oo8dJtPmOO8a33Du+5i5ygvtJEXoeQdtD6LwfzYdy1rZmD7riDWnsSxvOqCT2qTk1+Vv2Lo0+4Br2tJEacGesx32yNnfOGq6abnAVtfLMTxH5r/cxIDE1IDEgMSAjMzMKeJxzZ/BliGJgYChhyAdjPYZkhkyGXIZ0hiqgKABOuAT9"
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d paw shape]" v +
#@gui _
#@gui <i>Icons</i>
#@gui Flip : mc_flip, mc_flip_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>5th of September 2018</i>.</small>")
mc_flip :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_flip {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Flip"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_flip_preview :
mc_flip $* blend[^0] [0],alpha rm[0]
#@gui Information : mc_information, mc_information_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>5th of September 2018</i>.</small>")
mc_information :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_information {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Information"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_information_preview :
mc_information $* blend[^0] [0],alpha rm[0]
#@cli shape_flip : _size>=0
#@cli : Input a 2d flip binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_flip ,
shape_flip : check "${1=512}>=0"
e[^-1] "Input a $1x$1 flip binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTM3NSAxIDEgIzE3NzgKeJxdlnl0VdUVxr8bKWEqMgoOCIQkICQMFnPfe8l7CSGkSlAxGMQAUWODVFLKAkqRwYYGWUKtVsWpdaFVsOhCRERFREWlCghI0VIZa0WpUgeotra2nt3fOSqL+sdZv+z7Xu67dw/f/pSlrEiRxOm8Ik8DXUKlrlJVbrRqXK3qXL2ucVM01U3XT9x1mu+a1OwWabG7Sbe427TU3al73L1a5u7Xg+4hrXSPaJVbrTVurda5p7TebdBG97w2uZe02b2iLW6btrudet3t0m73pva4t7TP7dcBd0hvu3d02L2rI+59feCO6kP3sT5xx/R396k+c//U5+5f+sL9V186J3OKsuyUqIW1jLKtVdTa2kRtrV3U3jpEHa1T1Nm6RF3ttKibdY9Ot8X6ty3RmTZPB22+zrafaqfNUi+boc02XTn2Y22wqcq1Rq21Kcq3a7WKc45do+WcAdagZfYDFdjVutvqVWhXaSmn0CbqZrsC1mqJ1cGxWmgT4Bg12Xg4WvP4rNAu1Gy7HI7UTBsHv69pdhmsUKPVcN9hmmyXwowaAktUzz0KLKk6q4axJgQO1TjuOcCGqCZwkKrtYlio0YH9Ncougv00kt/sb3mqtFGwjyoCe6vcqnivs1UaeJZKeKZz7AylArsrYReon52mosDO+l5gRw2x89XXTtVAnr2vfZdn8WzLPSvJV2u+45nNGaE8+w659DyF3HpG5LpCw50/w1XOOfnvcleuYeEMUxnnG5a5Mnqx7ARLXakynG+YcZkTTLs0Oc7Sq/w9x1rAtOZaS/otQw2yYVrzrVW4/jNrE+ImawdLtMDaayvxz3m/rcTN1iHEN1inEC+yLrAYdtU24hutGyzWYvLluYT8ed5EPl8L7AFT+qX1pNeLdYv1CvyV5cCUbrVc7SC+jfrsIL7d+monXErddrik7qCOPr7LCpgTz0KYpPcGaRfxr21wiH9j5xIndS998YfA8wKX0S+74X2WCLzfUjCh39JXbxA/YGm9CR+k397g+nIrI05ohZXrj/AharWHz39H7fYQr6S2ng/TA3+Cj9ArbwVWBa6i1/bCR+k9z9X05j74GD27z8VwjPbDNfT6Aa6vZU48n2AWDnB9HTNyMHC8DsEnmas/w6eYKc+n7Uq0IdZ6Zs/zGebwL3ADc/kOfNYmBW60yehHrOeY3XcDp+g9+Lz9CE2J9QIz/p4r0iabRlykF5n9vwbO0PvwJZsJYzRhFvoT6/c2W0fhKzZHfwuciybFehUd8dxi1+sjuNWa9HHgAvQq1jZr1jH4mi0M3G6LdBwupy7H0c7t8JhbyOeezXw/5v8W8P8x92kK/Mhdz/1jfmcev+c5l9+PeY45gUfdbJ4v5jln8bwxzz1TLwfO4H2KeK/pgUfcNN63iPeeyvsXkZdG8hETTyE/MfG1gYfdZPIXk8dJ5NOzgfzG5Plq8h2T93qYgFdSj5i61FEfz4nUK6Zu46lfTB1rAw+4cdQ3AcdSb88aPQ73uzH0Q0xfVAfuZc+s5vpedxH943kh/ZSgr6ror5h+GwkT8Hz6L0EfVtKPniPozwT9WgGTsJz+TdDHZeQ5QV9n6O8kcZp+TxKX0P9+HlLMQzLMw32BMfOSZG7OY348hwbucucyX0nmbDDzliIexPz5uJB5TMGCwJ2uv+6EO1w/5tfHfZlnH+cx38Uwl3lPMfc5zH8KXeiFHhQT90QffNwDvSiGZwVuc2egJ57d0RfPbuhNCeyK/hSjQ11gCeyEPpWgXx3QKx+fin6lYXv0zF9vh76lYRv0Lo3utUL/fJyNHvq4Jfro2QK9zMAsXWdeRzPf0tbSk3T3//W47Ft6PexrHS8/ofHDT/r7K/2voG7+jKCO/vRDs3uiL/3R7F7slAI023MgWu05hB3Tmx00lJ3jWYRGeybYSTnoUIod5VmCNuegR2Voch92XTma7FmBJntWsvP6oFMj2YG56NQodmIuO3O05QdWo72eNTaAfXUJe7YQVrN3BwfWobV56Fg9GpvHjm6gNz0nU8N89KyRXOaz06ehpfno2kwbDi9nJ/m9WEvOL4DjqckoOAGfcDGso9Zj4BX4iLHQ+4pa9qr3GROh9x1XQe9DGqD3JT/ke96nNPL7X/mW3uiY9zE90S3va3rgcQ5xzrRf6D/4ntPxQN3wQl3xRJ3xRh3xSO3xSm3xTK3xTtl4qBaWFUWmyPBWX+KxvsBrfY7n+gfe6zge7BO82Id4sg/wZkfwaIfxam/j2Q7i3fbi4fbg5Xbj6V7H223H423B623G823C+23EA67HC67DE67BG67CI650K/QAnnEZ3vEePORSd6tuxlMuRh+b0cB5eM1ZaNhU9GkS2lOHrtSgFVX0TobZHchcdVrxPzrt8oExIDE1IDEgMSAjMzMKeJxzZ/BliGJgYChhyAdjPYZkhkyGXIZ0hiqgKABOuAT9"
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d flip shape]" v +
#@gui Mail : mc_mail, mc_mail_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>5th of September 2018</i>.</small>")
mc_mail :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_mail {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Mail"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_mail_preview :
mc_mail $* blend[^0] [0],alpha rm[0]
#@cli shape_information : _size>=0
#@cli : Input a 2d information binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_information ,
shape_information : check "${1=512}>=0"
e[^-1] "Input a $1x$1 information binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTYzOSAxIDEgIzE5MDMKeJxtl3lY1lUWx7+3yXEac0pnbDInH80Ze5pqZlrGabWy0txTJEIy19xN0ywXXFhcEcEFFRAVF0RUEFGUANnk5VVEQVFDRQXXtGemnGrKns6Z7+++P5DMP87zOef78v7ee8/v3HMPuAt3GRiA9usrjdBUWqClPIw20g7t5TE8Lk/iH/I0npUOeE5ewIvyMl6R1/C6vInO0gVdpTt6SE/0lj7oK37wlwC8K4HoL0EYIAMxSAZjiAzFMBmOETISo2UMxso4fCjjMUEmYpJ8jMnyCT6VKZgq0zBdgjFDZmKWzEaIhCJMwjFH5mKezMcCWYgIWYRIWYwoicYSWYqlsgzLJQYrZCVWSSziJB6rJQFrZC3WyjokSiLWywZslE1Iks3YLMnYIinYKtuwXVKRJmm0HUiXnciQXdgtmciUPdgre5ElnyFbcpAjudgneciXfBRIIQqlCPulGB7x0ErglQM4KKU4JGUoox2WIyiXClTIURyTY6iU4zguJ3BSPkeVVNFO4bScQbVU087inJxHjdTQanFBLuKiXMJluYwrchVX5Qtck3m4of64zlxcVz98KSG4pH3wb+aoRnuTs3BWe+Er5u2U9sQNmYGT2oMMxnHyG/Kodse3Mh3l2g3fkYfJ78lD5A/Meyl5kzxA/ihTUUL+xNijXSFkMWMl95NGp6GQutGpKGD8K8b5jO8m8xg3suyOxjod+xg3ZpzL+B7GuVzPb8kcxk3IbMb3umyqwWRP3Kcz8Bl5v8tmOpPsheaMs7jfPzC+xbfxgM5qwD54UGc3YF88pKH8vh9aufyThpH90FrD+Xv+Lt9BG53LdQWgrctHdB7XG4h2Op/7CMSfdQHZH38h8zQI7TWC+34Pj5IF+j4e00jmxcciHYTHNYr58rFYh+BJXcK8DiWXwqvD8HddjoP6ARnD9zACT+kKlOkoPK0rcURH4xmNRYWOxbMaj0odh39qAk7oeHTQNajSj/AvTcQZnYTndD3O6WQ8r0m4qFPwgibjKnP+om7Df5iTlzQdP3CPL2tH05H2ir5qXrX2mumknWivmzf0DdqbprN2pnUxb+lbtK6mm3ajdTc9tAetp+lJ66W9TW/a29rH9KH1VT/jR+un/sbf2jsmQANo75pADaT1N0Ea5Np7ZoAOoL1vBmoJ/svcDdQcrncRBmsmapm7wZqG07oYQ7iPSnKobmTdRmMY932Q/EDjmE+HMcz7Ugynn0OO4Hf36jKM5PvKIEfpHOzg34xmHWy1DMZmcgxzs4k5Hsu6SyLHUU/SVfjQfh5LRrMe4jCBz8i1XM73HoeP+N08XY2J9VzB95+Aj/mMAq6tjpP5rAJdi0/IQl3nMhFT+Gwfnc99LNQNmGb1Om5EMH+rSDfdxiTMZB3s180ukzHL5WyupVi3uExBiMtQcr/LYtZCONd6i9sxh/RoKuZyzbeYhnlW34H5Nq5jOha4XMi9lehOlxmIsHoGFtl4l8vdiHS52DLT5R5EuYxmburo1SwssXoWllrdR69mY5nL5Vb30au5iHG5wup13IeVVs/DKubYR0fPR6zVCxBndYeO7qNXixDvcrX93KHz+X4kWL0Ya6zu0NF99LKG17pcZ3UfvXoAiS7XW/3n9GopNtj9lmKj1R068SGXZazJdS6d+PBtPIJk0uOyRMsb0HkfFUix8dEGdHQfS/QYz4SjV2Kb1RvSef/Hsd3GdTyBVKufrGea1R068ecuq3jm6ujUXRXSbXyqAR3dR4+e4VlNcOnoPnq0ugHjqVdjl/38LHZb/Rzp6D+nR8+TTn84j0yr++jRGtLRa7HnF4wlL7B3xN1GR794R3r0Eu8WJ67jZd4pjn6FXMX4TlxJXq1nttUdOvEXd+AKnl8fi/VaA8ZQ/yVzyKI7cjl53WV7KGva57fDj6zzHPa5Qm2Lm1Z3/Da8L+r81viefjb7a4E+jP/V+63wHc+Az38I39b7Lel76C9hb/wjvuF58PkP0Pdy79H0W7Dv1/m/52xzgH4Ue2pz62dZvxn9g65/P/1S5n0x/fvwtfUj2ZOb4iueF59/L/0y129i/UzeKbl6D/3Drt+Y9+ER6+doI/rlrJUI9vwKy2QyQxdiC8+IwxSekZ2867eS6eQ2no0dvFu280w4TCVTOSOk8WxsJ9N5FhzuJLdyhtjF2k/hHbSb3MJ4D2s+mfFeMon3cZae5j0UzrWcYS8I4/qq2RvCuMdq9pAw5rKaPSaU7+kce1CorfF40suajtUQzmo17G0hnB1q2ftCONPVsjeGcGa4wN4ZgmNkFO++E6zZSManWKsRZDVrdT5Zw5qcy+ddYg2G8/eusVZCuL6v9UveLTNNsE43U3WK+VQnm0k60UzQ8WacjjGjdKQZrsPMUB1iBvEeD+IdH8B730/7ciboZbpzbujCWaITZ4yO+pJ5XjuYZ/Qp8zd9wvxVHzXttK1pra3Mg9rCNNPfmSb6G3O3GvOT3ORseoPz7DXOvxdwlrNypZSjlHN2vmRzLk9HimxEAmf9KM7EM/l/w1gZgn78P+QJaY6WV/4PhbIE3DEgMTUgMSAxICMzMwp4nHNn8GWIYmBgKGHIB2M9hmSGTIZchnSGKqAoAE64BP0="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d information shape]" v +
#@gui Phone : mc_phone, mc_phone_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>5th of September 2018</i>.</small>")
mc_phone :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_phone {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Phone"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_phone_preview :
mc_phone $* blend[^0] [0],alpha rm[0]
#@cli shape_shopping_cart : _size>=0
#@cli : Input a 2d shopping_cart binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_shopping_cart ,
shape_shopping_cart : check "${1=512}>=0"
e[^-1] "Input a $1x$1 shopping_cart binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTM0NSAxIDEgIzEzNDIKeJytlWlQlXUUxp9jWippabmmuEI5jjlFkFcREC/34kbCVYlAQYGATAkHF1RwQZFFzS1TUzNX3PdtmpxmaiZrpj6UzdQH/aRT5mRZpq3/03Pf+/JyL5Cf+vDM7z3/dz/nOeePVmglEICadj0Ro00qUo0PPmqSzQcd+0xa0PF/XZcWcn2aEz/4OM3E4p62w0QzDMNMDGJMtKVoWzH2WmPc8rnm1zU9F4M8zZW9ulcu6AXqvJy3dU7PUWflrKMzciZEp+W0o1NyKkQn5aStE3qCOi7HHR2TYyE6KkcdHZEjQTqsh+SQo4NyMET1Uh+iA3LA1n7dJ/sceXBD3RYvajf+qwdr9Bb8zNFLFl/Q9dhDttNXLX5n3KQXN02STTd2kz8wfo/nG+nGLvIW4+b04kfy3SDeNp4mTMJO8ifGDdzB+38mtzv04o7NX4zXpgfvkL8yDqUH28i7jBuZjHsm2aYXW7jewPtcD9CLt8nfGQfzDzPGZjI28/4/bf7F9WD+TW7idQ38x4y1OQYbeV4ZBxM6zuZYbAiicD3AsVhPtmK8jnzIZmsdb3Mc3iTbMG6JD5Nr+Yy2FifhCZ1AZuEpxmtY40jGq3U2hlpcAJfF5XCTdVqHCRY3I0NTyF3IZVyrh1HMuFbPoszih1hh8TO+MwXVeoU59vMaPeXnTZwgV+ldvG9R8Ym+RLaXLy12katcr9I+8j3jKh0sdy1WSZWulBW6wlalVIZouSx3tEyW6tIgLZEljiqkXMtlvs6XEi2Rmfqa5Gu+ZGu2ZGiG+DRNxut48ahHEjReXOqSKI2SITpEIjVC+vC7emgP6aydJEzDpI22EWMMvXGffrxDj9/CDXMdV801fGO+xVfmCj43X+Cy+RQfmY/xgbmEC+YiTpszOGaOo94cxB6zBzvMTmwxW7HRbMJasxbVpgaVphLlpgJlZiFKTSlmm2IUmSLkmXxkm2xkmalIN+mYYFKQTA8m0edu9l6iSUSCGUUlIM7EYaSlkZZiOUNHWBphabgZbsllM3DsakGN51uWKyRueL7/fX4F3h+g/5viTbylBKrKVNGTbaVOa6XWUY3UOKp2WO1olayyPBHwxUpLwd5o9MIyxwMVUsHal1taLIt1kSzShbJQy6SMfpiv82SezpW5WiqlOkfm0B8lWizFOktm6Ux6pUiKtEAKNE/yNEdyNFMyNVzC9TIKbwvCTBekaUd8bXojU7vTAwMwQ/viuhmEQo3kvByC13Uw59tzeEOHcl5Fo1SjOHdcWKAx9NAILNLhnB9xqNBYGNZwqcaz70ejUhPZ70lYqW72s5d94sEjOgY17Ot27Ps69nUY+3ENe7kD+8Xfe49pKufFRHRSH+dKGvt9MuePD0+Sb1FdNZ1zbAq6aQa26svobjEDPTWTc/MVm5nopVM5f7NsTkW4ZnNOT7OZjb46nXM/x+Z09Ndc7g8zmjAXAzUf+zSvCfMRQe235k8BDjRjAZ4OYr0WBrEQB6lntOh/ZcNzm7+v+ff4vzOCCjDwHxFB/+XnQP77Xv7vgCD689GfudrN/PQLoj9/fZnTXcxnHzu/4cz5Tua7t53/XqzJdtajJ2vkr09P1mwbj7uznltYx25WXdNZ38nch6aw3j7WfRI60w8b6INOli9S8Th9so7+6GjtAyl4lD5aTf+0p69qrX3Cy3nt3zeSOH899N8o+tBNP8bTl6O4b42kT+PoVxd9G8v98EX6eBh+M1H0dTT9PRQl+jz9Phiz9Fn6P5J9MIjzsR/3joG4ZnogS8PZLx3h067oYFoj7sa//BfTxjEgMTUgMSAxICMzMwp4nHNn8GWIYmBgKGHIB2M9hmSGTIZchnSGKqAoAE64BP0="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d shopping_cart shape]" v +
#@gui Shopping Cart : mc_shopping_cart, mc_shopping_cart_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>5th of September 2018</i>.</small>")
mc_shopping_cart :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_shopping_cart {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Shopping Cart"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_shopping_cart_preview :
mc_shopping_cart $* blend[^0] [0],alpha rm[0]
#@cli shape_mail : _size>=0
#@cli : Input a 2d mail binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_mail ,
shape_mail : check "${1=512}>=0"
e[^-1] "Input a $1x$1 mail binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBpbnQgbGl0dGxlX2VuZGlhbgoxIDE5MzkgMSAxICMyMDIyCnic7ZlpjBVVGoaPxBA1REfHuiHqOC5xQhwNcYkaxyUagriM24i7McZoXGJc47jNqLgjgigCgmyyL80utIA2IrIJooOACAjYgi2INKuIWHe+d85T3Sffvf/0j8n8IC/f+1Sdc6rqVp33nA4tQgj2b58Q/wV0xynlcoP9p6H86/Wf1l5LVPUjpvuhqh81PQBV/ZhpK1T146YHmT5BLT3Y9F/U/zY9FFX9pGkJVf2UaWtU9dOmh5t2opb+yfQZaumfTZ+llh5t+hy19FjT56mlx5m+QC1tY/oStfSvpp2ppSeavkwtbWvahVp6kukr1FJ7HOWu1NLTTF+l7mZ6hml3avlnmr5GLf8s09eppeea9qCWnm/ak/oN03amvajltzftTS2/g+mb1PIvMu1DLf8S077U8i8z7Uct/wrT/tTyrzIdQC3/atOB1PKvNR1ELf8G08HU8m8yHUL9tunNpkOpddwtpsOoddytpsOpddxtpiOoddwdpqOo5d9tOpp6pOk9pmOoddy9pjXUOu5+07HUOu4h0/HU7Uy3md5g+rDpNaabTS9I+Fb4I/DvHW+EPwbf5PgW+BPwjY5vhj8J/87x7+Gd4N86vgn+LHyD4xvhz8PXO/4d/EX4N443wDvD6x1Xf9ebdjG92nSd4+vh3Th/rePfwLvD1zheT/894F85/jW8J3y14+vgvRnfSsfX0H9fzv/S8a/g/eArHF8NHwD/wvFV8EHw5Y6vhA9mfEsd/xI+FP654+rvOtMRtL/E8eWcPxr+H8eXwWvgnzm+FD6O/hc7/jl8AvwTx5fAJ9P+Isc/Y/xT4Asd/xReC//Y8cXwafQ/3/FP4DPg8xxfxPjq4HMdXwifRf9zHF9A+7PhHzk+Hz6H9j90fB58HnyW43PhC+AfOD4HvhA+0/GP4IsZX53jGs+1PAed/57js+BL4DMc/4D2l8GnOz4T/gV8muN18JWM713H34ev5vypjs9gfGvgUxyfDl8Hf8fxafB6+GTH34Wvh09yvBbeAJ/g+FTGvwk+3vF3OH8zfJzjk+Fb4GMdnwTfCq9xfCJ8B3y04xPgu+CjHB8P3w0f6fhYntse+AjHi+/KXvhwx8fQvkm5Y4jfuZRrvJq3hzhf49R8P9j5Gp9ywtvOV7/KF4OcP6wcc8oA52scA037O1/jUC7q53yN4y3Tt5yvcSh39XX+wHLMc286X+NQDuztfI1DObKX8zUO5cyeztc4lE/fcL7GoZz7uvP7lGM+fs35GodydXfnaxzK4686X+NQju/mfI1D64BXnK95XeuHLs7X+LTeeNn5GofWK52dr3E8bPqS8zWOB01fcH5X0/tDzEWpr/Hda/qc8zW+e0LMWamvcdxl+ozzNe47TZ+u0o78p6r0e1cVvyv9dqpyvfdV6Vf354Eq49RzfajKdfXgfvr7o+eldd+LVZ5vZpqb3lblfveC632/vcrz0++9ZPqT6d9Nf+F4//z74Ou7dLHpz9T+99MXX9+3C2k3477590H+NvwfGYf//fbHb6Teznn+9z8AX9/t80P8/mZV3p+B+Mrh54b4Hc+qvH+D8FWfHWLuz6q8v4PxNR/9jXazKu//EHzNa2eEuG7IQuX3Yyi+5sfTaLcUKr9Lw/HXmJ4aYu7OeE7pcSPwNZ+fFGLez0Ll928kvvJ02xBzdhYqv5+j8JVjT6DdUqj8Lo/BV149PsS8kYXK73oNvnJwmxBzS8Zz8vOafOXPv4SYc7NQOX+Mw1eOPJZ2S6FyXpqAr/x6VIi5NAuV89pEfOXBI0PMdVmonBcn4Sv/HRFiPlQ9zB03GV/59LAQ82QWKufpKfjKc61DzI1ZqJzvp+Irlx0aYj7MQmVuqMVXPjskxBxY4jn5/FVC/xBi/sxCZY6Zjq/+D0xqn4dm4CtXtQoxv2WhMlcV/eg+7s/1l0JlfqvDVw5qmdz3ie64mcm496Wdon2fl+Ur17RIfj8+dxb3tSPqc+1s/CuT++Jzv/zL0VrH5+Bfmtx/vy6RfzHH+Vw/H79D8pz9ukh+e9SvKz7Gb0c/dY4vwj+P4/y6pnh/zkl+t35dKP8s1K+rPsU/k35mO168x6dznF/XLcE/NXkP/bpY/smoX1cuxW+L+nXrcvwT0AWOF9+341G/Ll6B34br8Ovu4jt6HMf5dfsq/GNQv+5fjX9Uufk7mfLie34k/fh9h7X4h3Oc37dYh98a9fsexfxTQv2+ST3+H8vN80fKi3nuYLjft9mAf2C5eZ5KeTGftqIdv6/UAN8fXeV4MW+3RP2+1Sb8fVG/71Xkgxb07/fVfsAv583ze8qLHLIX/rXjjfA9eXOOSHmRd3bnsR+/r7id/ndyvt+X3MH52+B+X3MnvDFvzkUp3wXfnDfnq5Tvhm+E+33ZIic2wP2+7h74Bq7vB8f3cn31nL/F8SLXroU3Op4XzxW+1fFy8buh/+0J137CCs7bkfhaZy/D35n4/9s3xN+V+B31XtL+7sS/Su87x/+U+FeaLsTfk/hXmC7A/znxLzedi/9L4l9qOhs/T3ytB2bhlxP/EtOZ5t9IrfXAe3ncl1Ot3D8tj/dFdQfT2rx5X0btTMnj/VHd3nRSHq+/uN/j83jdTbnO6n8kdU0er7Mpb+bx+op6tNWXJfWoPF5nUy7O43U05ek8XkdRD7P6oqQemsfrasr9uVsH/L/+3da/1d9zq6n+XvxfihVCRzEgMTUgMSAxICMzOAp4nHNnYGDwBeIoBggoAeJ8JFoPiJOBOBOIc4E4HYiroGoBnXAE/Q=="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d mail shape]" v +
#@gui _
#@gui <i>Misc</i>
#@gui Barbed Wire : mc_barbed_wire, mc_barbed_wire_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_barbed_wire :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_barbedwire {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Barbed Wire"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_barbed_wire_preview :
mc_barbed_wire $* blend[^0] [0],alpha rm[0]
#@cli shape_crosshair : _size>=0
#@cli : Input a 2d crosshair binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_crosshair ,
shape_crosshair : check "${1=512}>=0"
e[^-1] "Input a $1x$1 crosshair binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMjg5OSAxIDEgIzIyNDMKeJyVmGt0VcUZhj/2hJBAAiQhHBVBFCwolirWglisl4p4AS14oSAEBOQiJCigEQxIFEQuVoF6ARFEUUQF1CjFe0ELCFakSGmlbWxptaVClz9cq13tnj4z+8yZySGB+ONd37MnJ8k5++yZ73tfiSRqIk1EUMGhE6RzfLb0ii+Sy+P+MjAeLMPiUvmXTskRXSpj42L5Ev5CF0lF3Eo+h2t1K6mMW8oB+DNdKDPjFrIP3qcLZC68B/5EN5eFcXP5NfwRvCTOlw/hD+HH4W3wr3S+rIzzZCu8RefJGvg9+F3dTJ6Pm8nb8FvwBvgNeDNcE+fKJvh1nSubWX8NrmH9HdZfgV9mfUvcVDbAG+BtrL8Ev6ibyk7W18HrWN8Nr4XXwnvhZ+E1vGY//Az8NHwAXg0/BdfCq+CV8EH4SXgF/CX8BLxc58gheBn8OHw4zpHH4Efhr+FH4J/D38BL4SXwf+DF8GL4v/DD8EOwoJ/BD2olEVoEL2ItFy2EF1DzWZ8PP0AtQPPgeay3RvfDc1krRnPgOayVwvfB91JPQNVwNevt4NnwPdQOaBY8i9oRzYSrqJ1QFXw39TtoBjyD2hVNh++idkN3wZXU7uhO+E7q2egOeBr1XDQNnko9T0cyBZ4C90K3w7ex1hu+DZ4M/xCeDFdQf4Qq4HLqxfxsEjwJvhSeCE+E+6Jb4Qms9YMnwOPhK+Hx8Dj4angcPJZ6Dde3wLfAP4HHwGPgQfBoeDR8PTwKHgXfCN8M3wz/FB4Jj4SHwiPgEfAwuAwug8vg4fBweCQ8DB4Gj4Jvgm+Cx8BD4aHwWHgIPMS+34j/kbL/x3yewfBg+1mVZfNeyu17SskNcAW6ATbv19zH6+Hr7D2OqCn7maahQZbN9xPJQHig/d4iPn/K3oPp9l6k5Fp4BroWNvepCl0DD6DOQgMsm2cnkv5wf2o114avhu+19zolV1HnoKvgK6n32+8jZb+TB+Ar4Cuo87k23A9eYL+/lFxOXYT66rawYk9Echncl+r4MurD6MecVeZZWIIuTfNSfucS3QZF7L2I56aNfXYeRRdZVuxVBZfwfEVwRC2RC6nLUR9dDCv2ubLch7UV9rkskguoK9EFaV7Fa3rr1ijivIjkfPh86tOoVx1uJT2pa1BPy0qeQz/QLVEER+yNlnZ/PI++X4cL2UORvIDOtaw425T04NztwdpL6BzLirNPwS3YfxEcUVvI96gvo+6cwSF3p76KvluH8+Us6mvorIC7cU53o25CZ1pW8os0n0ndjM6wrDizEz6D+ibqallxpifclfo26mJZyTtp7kJ9l2vPEeeOYSW/tGdQHorgSE63rOghyvLprG1FnS0r+QAZ7szaB6iTZUXvSbgTdZs94xxHcpplJTuQ4dNY24FOtazoYZ53IsOnsrYTdbSs6HnKckfWPCv6YSSnpPljZPgU1j5GHSwreqc6ijvw809Qe8tKfoMMt2fNs5K9XJ+c5k9RNp9M3Rfwb1G7LG7H3/CsZD/XJ6X5d8jwSax5VvL7gD9DJ2bxibzes2J2iOhDCf/B9qS6bHrUHwP+E0odg1PU2oA/p7d5VtI2i9tS/9wA/wWVHoNNLz3YAP/V9lrHStocxTnytzS3oYb8BT+rn5WUWM5hFjs2l1D/znXjOUf+oc2s0Dg2M8UhrhvPOfLPRrGSouPwV+jbcdPM3/9KT6Dn5aHxcDmzTD79bRI8hb5VgKbIYV3JDNUSVcJVzF+tURU8m75SjGbDc+kTJcx2c+HDTY6t8LXV9KNiVJ31t8P/OZW+WYCmwhX03HzeZ3nWex/DrJSHRn/r+9GYe9y476o+bvhZCJ+dxj1r4bN5/Gc5fPaPtz8Srn+fNbQvHYd7N3uvN3Qe1MfZ50pD51B9nH2ehWdefZx9XoZnan2cfTYf0OGZfTQnZ38UcH09IarTQ/brsLcczUmPigKur3dFdXrdXh32QN8b9wQ9c492vTTkSHYHvXe39j057NV12ff2XUHP36X9LOBmhJCT2cHPFNuDWWO79jNIOJs4TmYWP8u8H8w472s/+2wJZqIt2s9K76VnqIT9bBXOXI6TWUxlZjQ3r5nZ7c1gpnPznZn1NgczoJsHzWy4KZgZX8/MksrOkm7GrAlmz1eCmdSxmVU3BjPsRu1n2/XBzLte+1n4xWBGfiGYndcFM/Va7WfttdrP4M9qP5ubOd3N7M9oP8uv1n7GX6397L9KO0+grD9wXuFJ7T3EE9p7C+MzLrQcyTKd+A/jRR7T3qMYv+K8yyPae5ql2nudxdp7IOOHnDd6SHvP9KD2Xsr4KuexFmrvveZr78nmae/VjG9zHs74Oeft7kuz8XzV2nnBxBcOSPtC4xedd5zJz5ynvFsn/tJ4zenae9BK7b2p8amDLCf+1XlZ42udx72d1znvO1l7T1yObkx75YnaeWiTEThvnfhs57mN/3Ze3Phy59GNX3fe3fj44ZYj6+/LrL+P7PUI6/sjmwe4bMD4d5cZmPfhsgTzXl3GYD6Pyx7M53eZhLlHY9NZRX/tMgzFfffZRj/tMw+Tf5gs5Fb7XPiM5GJ7L5LsxOQoLlPpo13Wouzz6jKYntpnM+dpn9mYveSynHN0kvHcYfeu+c6S7MfseZcJmfPCZEXT7XmTk8mQzHnnsiVzbrrMqb32WZTpByajmm37TE4muzJ91GVaJUHW1Ur7DKwQuWzM5GQL0plZrk6yNPO8q0zGZvI2xT5Jsrf/BZncv4Os7psgw/s6yPaOBJnfIdaXa5MFmlwwR1boJCM8CK/USXZYCz+lk0zxQJA17g8yyL3pbPI5eHeQWe7KZJm5sh02Ged6XrM1bpbJPk0OWgO/Cr/BustKa4IMdSP8lk6y1XWZzDXJX10WuyrOp98kGe2yuLnNbnfAJsf9SCeZ7qJM1tvC5r4mA/4UnhUX4vVS9P9CmxPX6iQznhwXMW+lmKGKZFxcKkfgw5xZZfEQuS4eIP3iS6R33EO6xO2k8Mj/Ae4IPV8xIDE1IDEgMSAjMzMKeJxzZ/BliGJgYChhyAdjPYZkhkyGXIZ0hiqgKABOuAT9"
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d crosshair shape]" v +
#@gui Crosshair : mc_crosshair, mc_crosshair_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_crosshair :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_crosshair {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Crosshair"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_crosshair_preview :
mc_crosshair $* blend[^0] [0],alpha rm[0]
#@cli shape_phone : _size>=0
#@cli : Input a 2d phone binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_phone ,
shape_phone : check "${1=512}>=0"
e[^-1] "Input a $1x$1 phone binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTU2OSAxIDEgIzEzMzEKeJytl2tQVVUYhj80R9IkTTLUFBUGJURB7sjtYDlZWWlmgefA4S5qkvcbXiC72G0q07KypKvTWDaWZXkp85aXQGH60dTUTDP96ddm/P/t3u8954gcjjPW+GPNs58FrL332mut90P6Sb8oiRJBm3l5sMToMInVERKno+ROHSPxOl4SNFGSdKIka7Kk6GSZolMlXdMlU7MkR3MkT/OlQAukSIvFox60UilFC+dcjRLH9cg8vUm63VKZrwPoj+lAeplG08t1EN2rg+k+HUKv1Bi6X4fSq0DzajyzA6/V4eyv01h6A96jO0jzRo2jL9KR9CU6mm40X4r3NW/SsRy3SePpy3QcfblOoK8AzVdiXsxXgearNYm+BjRfq5Po6zFvIdp9mjWFbjTfpKl0o/kWzG93kOYtmkZvxZzbuK06jb5VM+hbNZP+NGj+jGbTnwXNn9Nc+jbQfJvm0V/AdzMPsFRe1Onsfwnf0vxlLaQbzV/B9+0O0vxVLaEbzbfjG3cHaeNu1xn0HXo3fYfeQ98Jmu/UmfQ3QPM39V76LtB8l86ivxXk23of7/OO3k83mu/WB+hG83d1Nv09fZC+Rx+iG23cPfowvQ00b9M59PdB8w/0EXiA5h/qPLrRcUvAR+G96bjF4Hx4gI5bJB/p4/AAHbcQLIMH6LgFYDl8On6/HJ4PLoAH6Li5uL8XHqDjZuP5fPAsPK8PnglWwDPwPhXwdLxvJTwN718Jn4L5ME7GvPnRn4J59MMnYZ6r4EmY/yp4gryu1fDx8hrouGPxfWvgo7EOauBxWB+18BFYN7Xw4VhXdfBhWG918Bh5Suvht2Cd1sNvls3aAB8oG0HH7Y91vxAehf2wUBZqI/ZhqC3CXuxpjfx5A/ZrvdSz1WEv12JfW6uRGrZq7PsqND/OgVCrxNnQ0yowP76IzSsLMLfhrRzzH97K8I0CLVJfT39kv/pvQtehe11939C1F2ed9wq9eNYQfbwOPX/FFVbwOsBAq+zDwFyE5sV/hX5e96Yfc9qbkfp6WMXr6+N/+d1rj1Edxhs55o0aqxpZFGCbGy1nsV4/dofKBfheN1ba4fvckdIB7nfHyCWs6wPuOPIg9mEn1vsh7EvjYTdZurAHjmHfdoLHsZ+7sDdOYp8bz2Dfd2G/nHdzyHY3D1wknThXjL/g3OnSJfIrzi3jbzjfunSp/E42yR/kMvmTXCF/kWvkb3KD/EO28vzrBO187NSW/+ktPIeN1n9Jt1yXG6/tHrkY9Iu6OaJ3gJG8Qzf1cWO7buR9wt0YyX/W5gjuwfdupl/APEby86D5eV0f0c+B5ud0XdDX8T5G6z+ra+lG85/w3SK50fyMrqYbzU/rKo57OsxPgeandCX9JGh+EuvD/ARofkKX93Hjj1hPTpDmx/VJutH8B6w7J0jz77EenSDNj+kTHPcoaH4U69b8CGh+RBfTD4Pmh7HOzb8DLZ+/RaaYH2LeeOQb5k+JfM1cKpGDzKkS+Yq5VSxfMseK5QBzrUi+YO4VyX7mYKF8zlwslM+YkwWyj7lZIJ8yV/NlL/M2Xz5h/uYit3298rqN+Z2NXC5nXu9m3mcgh60emIb6xuqDdOSw1Q1TUS9ZHZGK/LV6YzLqLqs/kuV5nQufiNy1+iQReWv1ywTkrNU38bKB9c4Y5KvVP6NQl1p9dAfq11nwWFnMuuo25KrVWbciQ60OG4KzfwZ8EHLIA49GPW513QCZw7qvv8xGPZiLmjELdWQGas001J+pqFGT9S5J1AT8f3C7VF3+F5FZ+PIxIDE1IDEgMSAjMzMKeJxzZ/BliGJgYChhyAdjPYZkhkyGXIZ0hiqgKABOuAT9"
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d phone shape]" v +
#@gui Cupid : fx_cupid, fx_cupid_preview
#@gui : Size (%) = float(75,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/01/08</i>.</small>")
fx_cupid :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_cupid {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Heart"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
fx_cupid_preview :
fx_cupid $* blend[^0] [0],alpha rm[0]
#@gui Gear : fx_gear, fx_gear_preview
#@gui : Size (%) = float(75,0,100)
#@gui : Number of Teeth = int(12,1,96)
#@gui : Elevation (%) = float(15,0,100)
#@gui : Angle (%) = float(0,0,100)
#@gui : Inner Radius (%) = float(40,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/01/08</i>.</small>")
fx_gear :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_gear {($11?2:1)*min($w,$h)},${2-5}
if $11 r2dx 50% fi
frame {2.5*$6}%,{2.5*$6}%,0 b $6% * $10 round c 0,255 autocrop
100%,100%,1,3 fc. ${7-9} rv[-2,-1] a c
gui_set_layer_name "Gear"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
fx_gear_preview :
fx_gear $* blend[^0] [0],alpha rm[0]
#@gui Heart : fx_heart, fx_heart_preview
#@gui : Size (%) = float(75,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2018/01/08</i>.</small>")
fx_heart :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_heart {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Heart"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
fx_heart_preview :
fx_heart $* blend[^0] [0],alpha rm[0]
#@gui Paint Splat : mc_paint_splat, mc_paint_splat_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>5th of September 2018</i>.</small>")
mc_paint_splat :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_paint_splat {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Paint Splat"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_paint_splat_preview :
mc_paint_splat $* blend[^0] [0],alpha rm[0]
#@cli shape_barbedwire : _size>=0
#@cli : Input a 2d barbed wire binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_barbedwire ,
shape_barbedwire : check "${1=512}>=0"
e[^-1] "Input a $1x$1 barbed wire binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBpbnQgbGl0dGxlX2VuZGlhbgoxIDY5MSAxIDEgIzk3Mwp4nI2WSWyNURTHP1qvqvpqnh4RNSwIQWtKDAlaNbQUbdASG0QsEGJhQSIRK0OCDZFgIRYskEhEQsJWYowhhmpLa54aauh71//k+33ezUuFxcsv95xz7z3n3P+93ws6BkGgX4cg/AUwWZtyWWJWyv1htpgNbdxJ7CTGxJiYA2MeG5xztt4w/C9duF4JbMTe5MJ1S2Fkb2Zc4tk7i69cuP8c2ED8a88ey7DbuMyz2zpviC+DdeTdxn6fsc9lXh3rJf/hTzH+kuF/xvqZ/nkunPc//jh288+HT2TPz7Bb/FPZu5Kn2Rdgz4yP7I+Jb8+eJ34in7/Zy7E/kr3Lf9grXHgOzejqJ7oQXK74kbgqaHab/9o7pzhxtv5ysYedK+dg8d09f43YW3wrf1/xPfZasY/4TvYB4gfqXyn2t3GG/ZwL5zcyr9XhV1yCcTb5WfwN8v4qDqP+GejYrmBCHCN+d2n9GG+K3dDbaPpTgp5t/RHiJPEH/XL0846417sPI8XprGP9uSfu9/xjxRrxgXjAuy9n4AFxtZ2feJB7Y/bzYk/xuVho+hTXmi7EI9RpdVwUB6LDyfRxg+lTPEFfLO9L4lDqLxN/iVuD8B05zdjiLovvyXMQ9tFwGXVaP66Ih1lvFfsPRN+FjJd48Vep385vdxC+SwWc80LO0+Ku0b8WcZd4QZxI/3t6cdfFQ9S3Qzwrjucc4+RrcXdd+E620DfTwXbxNP1KUncUf5++Wp7HsW8TT6Krn8Q1efO6oJNT5LlFPCZO9eKb0bvlP4q8Z8Ey5pWLR5kX6c7OIUGfh7NOMdwnHhGnUZfFv2W+1TFEfEgfD7UTZ/reJW4U91CP5THY03Mr8e/Yd7u4Rtzp0u9KIki/a9/oh93/ceJmcYW4ibh6/J/xr6fudfTH9J5Hn+x8VotzPH+dOFOsFvsR15V87b1Yi910PVtc7MJ3yfz5GXG59DWffs4VK8VexMXxx+mL6WINbCPPJs5vkafPuLdu9N5Uu/T32I9PuvR72g3avCov3uqv4Dwy41PUX0X/X3rx0fcu15uX5N5F86K8bF5pEH7fOqKTLPQdzYvD9uZNYb9f5N/GOVd5cTH0Xkx8jnc/WhkvJc7e2SJv3e/os4S42+gnWieaH/lvsc80xt9Yp5R1XojVQfp72+LS/5NsbO/SMvpo4wmefTnnZ+NiF77z9ei80rNnodcadGj7F4i11JnDeDDnmeCexb2+FaDnVvTfwH5R/+27av4ixvb97eONX6VCnRVRd1Mq/G5H/kb+90T+ev5HjCH/vMqU+w2wUyNRMSAxNSAxIDEgIzM4Cnicc2dgYPAF4igGCCgB4nwkWg+Ik4E4E4hzgTgdiKugagGdcAT9"
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d barbed wire shape]" v +
#@gui Sierpinski Triangle : fx_sierpinski, fx_sierpinski(1)
#@gui : Recursions = int(6,0,10)
#@gui : 1st X-Coord = float(50,0,100)
#@gui : 1st Y-Coord = float(0,0,100)
#@gui : 2nd X-Coord = float(0,0,100)
#@gui : 2nd Y-Coord = float(100,0,100)
#@gui : 3rd X-Coord = float(100,0,100)
#@gui : 3rd Y-Coord = float(100,0,100)
#@gui : Color = color(255,255,255)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sierpinski :
repeat $! l[$>] split_opacity l[0]
100%,100% sierpinski. ${1-7}
+fc.. $8,$9,$10 j[0] .,0,0,0,0,$11,..,255 rm[-2,-1]
endl a c endl done
#@gui _
#@gui <i>Nature</i>
#@gui Australia : mc_australia, mc_australia_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_australia :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_australia {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Australia"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_australia_preview :
mc_australia $* blend[^0] [0],alpha rm[0]
#@cli shape_paint_splat : _size>=0
#@cli : Input a 2d paint_splat binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_paint_splat ,
shape_paint_splat : check "${1=512}>=0"
e[^-1] "Input a $1x$1 paint_splat binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTYxNyAxIDEgIzIwNDEKeJx1lnlw1dUVx8/Nvry8bJCNQERKFEIxLAHZBASUFtl3AwQElE5bbGs3hNKRjqV1VxZlrVOnnY4dZ9qqdUpZDUteQgKEBGJEQAJkIXsAGwr39PO7eThMp/3jzPd77j333HPPuZuESIgRI4JEBSIkwkZLjPWJz8ZJXFB8TvdJrI2lL0aisYmyUdiGS5gNk7raMAm3EbKA9k80QvKtX/4BLrIJskcjZYlNkn86TJa9YIHtLvscpoAR92Cq7HeYJgeCuF/DGJcOhjrcp0YW2wzJCEp6EPdht9T1h8syZx8pTzmMcnhQY2S5w1gw7Ws8pHGygvZP1e+wUONlJf6OaCLYQ45pkjxte8kl/LRpN2nC/3qbLc3YX9fu0sI8621/uUnfvzRV2jUafYrc0Qz6Y+Gr5CtsPezE93s2RM7pd+hPkgZ8HbCh6L+QRsYdIp9fwJsZ9yn59Hgr8RXaSGzWMr+f9ig5r+ukQxNoj3b8Br4KqcsF+FfEUUidLsI7NQXuky/xc1vT5DB1qdHtYLxc1h1y1CbKVd0px2w3qdfdUkRdGvVdCZCXVn1PSlj/df2DHLdZ8m99X0ptmZTZE3LCnpSTTk45OWXLpdyeltNOKqTCViJn5IytkipbLdX2nJyzF+SCvSgX7SW5ZC/LN6nXHr0iueRvr9bKYPK7T+tkCHnYrw2SBx7QRocHtVmG0X9QW9DDwTZptx2yjDzt0g5ZTq1+rzdkJfX4o94EU+V97ZRnqMEHegvMpI5R1OaOrNJeUkLubqnCs6RUU8wqvU9OahrYW8o1A7xfKrUH2EfOgM+gn9VMsI9UgU+Dn4ErwWpwBf3V2tPh5+Byh5nmKfx5uMxhD7OUeTwsYN5q5lmsPR3mE1+1ppsFmu70+dStCn02dT1LXDOo+xlwCmuo0FSTCk9DUh3v0tOxT2dsD/xnMmdP7WWyNMvcr31MX+1rsjUbecA8qA8GpZ/pp/1Nf80xOTrADNCBZqA+ZB7SXJOrg8wgHWwG6xAnQ+6RoTo0KHlmmA4zw3W4eVgfNiN1pBmjY8x4HW8m6kQzWScT7xQzTaeZmTqTtcw283S+WagLWW++WaSLzRItIBcFQVxqzrK+N8Bz7PnXdIm5QJ1exa5Gk+UlXWRqqe9GfdI0UN8X8dPEnt6Az2by9oLOMy3gL3UOmOGwFVwPtoHrmL8dXKuz0NPledDTuzBd1oAd4M+JtR2/PwM7mOcnDlPkx+B18DmH3eVH2N/grP0A3Tt/39cZYKJ8F7zJOV+l00E/e89Dn6wgDzdY3zJw2j0ynX5PZjBuFj5nI3OIea7OJV9zHXqymvvvmsMw7o055lnOQQNrWv01cg8zdhbxeL48mY7/qTrVPKFPOPHq8W39lqvN4/q4eUwfM5N0EjLRTNAJ5lF9lPqNM2P1EfMIMkZHm1HUdaSTEQ5HORllRtM3xskY7Me6cV7tJ+CjSyawDzzx+HjXPw6fY7EfzfiRyAh8DmfvDGMP5bGX8thTdeR8OdjEOV0Jtuk35E+s8Qj9HdqP8xzh+HUdKH8jn0cdz+MuiQ7yEZzhSO6tGPSh1HI0Zy6Ru9nTB7NXRnE3pnA3evogcw37Gure6cbnsseGyxXO4y18H+E81OhQqSWWTzgf5zWXezJL/s55qdIc+H3wHHOKGBs44x9zngKM9fhHnK+97OM6+Iect7ex/StncCv4F87jFnx+wNnczB3wZ+1tNmkP2c1dtIlYtms3MEW2arJ5i72/SZPMm+yl18HXietlMFETkSSTFJQuPdEkaIKJ13jjV7/xqc/EaIyJ0igTqZEmQsNNmIaZUA0xIWqMcAeqvSO3bad02nbu1BZpsc3SbBulEblmG5BrQWmQBif192C91Ns6qbO1UstbdFs/k6u8YTf1jFTyFpS798F7M0p5O0qk2AZ4Wzwpwi6UPBcxLpw36BgY4bDOYRH3XJikU0ePV4KZyBX6K1h/L/hleCX3f2/0K87GJ33glx2Pk77wGsf9ko19jQYcfwB+CV4B7wf/0vF46c++uoh9Oe05jgfkFHwAcZyHn8RnjobwJgekjHkjuPvv8EaWso8i2BM3eTePM2c49W/jLS1mXCj3SKPu4l1NJMYdst1ul212m7xj35G37VbZimyxW5DNstlulF/bDbKBP9BtXc5/wftPFMhaxnZovqzhzW7V+fJT3vBmnSPP8a436kz5Ie9+nU6VZ8n/VZ0iq62Xg8nyPeutcxJxh8ku661nHPs1DImU3/Fn+4IzYTUb20julWh5l3/J56yxkzutEr2Rda3Bt3enVbDeJvTnmaMdm9NIM/lex1yt9JU7PY6Yo7CLcnlrcbrnO1xOkF9Pf4Hx9eSwzOl++RX+P+aOb0V/kT+Lx732Lp7o2jeyTo977b/hL/qRs4mX3zre1f4SOeni8fIyefLsvf/ZK/w/Pftm2l8N8ib4a/APwUbvTJHfgPsbxBOrX97gr1rCmjrc2Y2TN53uQ/eR3zjqlEyd45x+BdzidD96DPmOo67J7IkE9Gj2Vhy17tLb2FMXsNtBXUuJr5i+Hfy3TvB2FNO+0/Fk5oqnXv/Nu8H9spt/8v/n3V0cd3kJ/v8XLybuLp4Cj3W8jPYA8e4K8iLycZcfpX474aXMdZi/9zbi8fgi1nE8iCXEehfzWW8xa8onb4EgFrHeJ8nzMdazkNwfBRdQs8PEO586FhLTPOp8iHjmWu//Fy2zuBf2kLOZgf8A3He64TEgMTUgMSAxICMzMwp4nHNn8GWIYmBgKGHIB2M9hmSGTIZchnSGKqAoAE64BP0="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d paint_splat shape]" v +
#@gui Barnsley Fern : fx_barnsley_fern, fx_barnsley_fern_preview(1)
#@gui : Type = choice("Asplenium Adiantum-Nigrum","Thelypteridaceae")
#@gui : Density (%) = float(100,0,300)
#@gui : Angle = float(30,-180,180)
#@gui : Opacity (%) = float(40,0,100)
#@gui : Color = color(10,178,0,255)
#@gui : Add as a New Layer = _bool(1)
#@gui : sep = separator()
#@gui : note = note("This filter renders the Barnsley fern fractal, described here:")
#@gui : url = link("https://en.wikipedia.org/wiki/Barnsley_fern")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/18/10</i>.</small>")
fx_barnsley_fern :
repeat $! l[$<]
shape_fern {min(w,h)},$2%,$3,{$4%},$1 *. 255
100%,100%,1,3,[${5-7}]
rv[-2,-1] a[-2,-1] c
if {!$9} blend alpha,{$8/255}
else nm. "name(Barnsley Fern),opacity("{round($8*100/255)})")" rv[-2,-1]
fi
endl done
fx_barnsley_fern_preview :
fx_barnsley_fern ${1-8},0
#@gui Gum Leaf : mc_gum_leaf, mc_gum_leaf_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_gum_leaf :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_gumleaf {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Gum Leaf"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_gum_leaf_preview :
mc_gum_leaf $* blend[^0] [0],alpha rm[0]
#@cli shape_australia : _size>=0
#@cli : Input a 2d australia binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_australia ,
shape_australia : check "${1=512}>=0"
e[^-1] "Input a $1x$1 australia binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTUxMSAxIDEgIzE5MTQKeJx1Vnlw1tUVPTcJJEBCCBTZF8MyCooga0AQBKt1LFgRpAUBywyDiEV2EJCKYoGmQEcKUgIhbAYISwoiSysYBNl3CVuEIG0KoiJlyZflnZ7fyxeMnekfZ8657/2+t9z7vnsvIhBhMEB4Z0cEIl0UlroIhBiNScI6F4kCcWBPZgwyXALypaewIja6qrjHWEz3OgE/aDzQm6Rv6tt3va6C76RnsJJ0PL4VFzICc71dGTdY1etM7XmXhuusjg+05hxXCws910eKeK5rqG+jsJVxWOEM37Ox1onS/uXwiR+LRRFb6mwx2Ml4rHI9NF8Bf2cC1rpnNVcB/9BeGa6vxgLu43mde0nfV8V6P14NG8Q7+TPdpw926CyZsreLt7h+ZfgBfOxexjbPwXxNjb+Aj1lL3BObWVvjJbzV9fK83f0KfxPvcC/+D/eWb6Owi3WwU2cJ6T67y+jPWBdfKwYX+JLiUN7bV1055DCYL7Ur4Gv29THaw3qyK+FffFl2DD73dizyNB/4Zo++v+6q4d/so3gZsjR/w1WX3/sgU/o7V1O6NzZ5XUv6xbCuLf0CNrI+bjqtwZ7YIH3XNVZcSnSIkYhgM8W+xC7U+aLYSnEN7IelZ+v3D6Mck7VmM8+ZbC7+k3z0KKI5B1vYAjGcpzg/hljOV2xbIo5/ka9boTIXyNePI54LFaPWqMYlimlrVOcy+a8NanCFfFeW07HX81rsZ1vxOhwQP8D1OOx5I456zsTxMJ9gO323Gd/oLtelHxSHuEXvLVpj7ZDI3fJbjO7cXnO7ccuPBzoLtxXHa+yAZvJrPvcpRh3QXG89nweQyyQ8orXyeUixSsKjim2g/8lOaCF9TzqPT+AxrXePB71uqX2C8Wvsgsf1X8ovowt5TPt2RRsG7/64ztMVbVkZxTypsz6Fdl6f1vm6oz3zdLan0YHXtMYz4iRL8uhoHcNICo91YIcw2lv7MAI7+LYTn7DO7Gxd2MWe5JPWlV3voxu73cdT7G7d2cN68Gn7OZ+xZ/kLe47P2y/Z03qxj/VlX+vHX1t/9rcBHGADOciGcIgN5Ws2mmNtHMfbBE60icIkTrW3Oc3e4wybyVk222O2RzKTbYH8W8C5tpgptoRLLJXLLI1ptpwrbCVX2iqustX8yNKZbmu4xmMt11kGM2w919sGbrBN3GSZzLTN3GxbuMW2cqt9wm22TSjS+vuEQm6XjtQ7igzrKL2lQGfZQc977JC4iHvtiOaKuM+OKq7F/MKO8bgdF07whMfxsH2Mx/TN0f+DY/rmRPg3J+0kT9kp4TSzLZvn7BzP2wVetIseOZZTBhfLIIdfhZFj+bpHnnTwP82TXaBzlnCk3mGOFYqviovFV3jFcnnZLvGCbEPA57XnFf+2z4mDd31WHHmfQ+JcBvUi4Cj5JFu/D3yRbV9p31LkMtcu+7UvebvkzCV3ueD3OWdntUa2v2u2neEZ+5JfCme8PhMeK0Uwd5qnPQIfnZS/yvq6rJ+P8Igd5mHF6qDidtAOcL/tF75QvPZ57LW9wueK5x6PLMvy+Mx2c7ewy3YJn/JTYafiS+WgrbjDItWPj+THkHJTmv7791Q/luI874pTkM07yl2LcEr+KOYN5bMFekvXxfOVo64pz/1Zv8tV3pujscuqJckau6R8OEu4pPw4CSuZo3w5AWm8IB6HVJ5XPh2DpZ5HqU6ew3qOxGLl2GJmIINvYNF9PUL19CHFYi3WcTjms4niFOhhmMdG0muwlkORzIaKYzrWcAhmsoHG05HO3+IPyueBXs1X8b7qwY+6rv9+NQfjPdWtkHywyuvaeherdebB6gNqKo+txHLp6aqtd6TTOAi/V20OdCoHYhqreL2Ur+Bt1e/byuFLOEB9RpzXKeyv/iMW/+Fy3e83eEs9wy35+a/spj0rYJS3l+m+nTFA9g9MxYfKs/2UQ2+qDhXL3x+qFvSWHfQpxaopC1VTemkumC/kB9rD5J9W6PmTsbZ4XjH7XnaBYrRYazyn777VfzsUttt5PU9naYNOys2BXqQ61VHnyOdc7dtSOTgmrB9Ba+0f6IWqfY0U7wXixuL5WrdYcQnG5jDR8x8Vg0TxLPk5qCsh/W6m+owWWi/k884MxaC66kaczvyu/J6g2hKn806Xf6O0bqzO+g5SXUXVi2lIUZ91lVMx1U3BFDcZk4W33CRMchMx0U3ABDce44VxbizGeozBmDACPdqNDmMU3nRveox0Iz1+597ACDfC43X3Ooa74cJrGOaGYagbilfdYAxyA/GKG4D+6huKVbv7qZcr1Lspkr96qfco1H07qh8p0H3bqo8Maa6Vi9P7qY0W6nNu6y01V/9zU+/oIf32G903Xn1knHqcSi4a5XW/WrfU1KpnilIv+1NEqr+NxFn5McLrkvEfuWQ+Qus2LVJX7O1yWjMGMfJfRe1xTXmvifYL+oGm6m1DerdNXVOhCRrrTqVo5BrdR6JLFB5EQ/WwARq4BkJ91Peoh3rqp+p61EGdMGqr96ol1JRParoaqKFeO0H7VRHi1UeX3jlW56ogv0S78kg+9F/vDNGsMSAxNSAxIDEgIzMzCnicc2fwZYhiYGAoYcgHYz2GZIZMhlyGdIYqoCgATrgE/Q=="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d australia shape]" v +
#@gui Japanese Maple Leaf : mc_maple_leaf, mc_maple_leaf_preview(1)
#@gui : Size (%) = float(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Mathew Callaghan</i>. Last update: <i>4th of September 2018</i>.</small>")
mc_maple_leaf :
max_wh={$!>0?[${-max_wh}]:[512,512]}
w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
l[]
shape_mapleleaf {($7?2:1)*min($w,$h)}
if $7 r2dx 50% fi
frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
gui_set_layer_name "Maple Leaf"
gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
endl
mv. 0
mc_maple_leaf_preview :
mc_maple_leaf $* blend[^0] [0],alpha rm[0]
#@cli shape_gumleaf : _size>=0
#@cli : Input a 2d gum leaf binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_gumleaf ,
shape_gumleaf : check "${1=512}>=0"
e[^-1] "Input a $1x$1 gum leaf binary shape." v -
ir={round($1)}
if {!$ir} 0
else
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgOTY5IDEgMSAjNTk2CnichdXnVuMwEAXgiUMNvXdC76GFQICE3kkoSahPuu+xr7HPcM/OjGxFArP74zszNgdbVqQrCihIUIKIdf7mCiOBgEXVCJAM1fukrQ3au7UBjczURjQxU5tUs63NaKEW1UqtzNQUpdBGbWindtVBHaqTOtHFTO1S3dSNHupRvdSr+lSf6qd+DNCAGqRBDNGQGlbDaoRGMEqjaozGME7jzNQJmlCTNKnSlGZRTWOKptR0WE0/bc3QjDVLs9YczVnzNG8teP2CWqRFa4mWPMu07FmhlVirtIa1/8hQxrGO9R9s0EZoE5sxtmgrtI3tGFnKsh3sxMjRLna/2cNerDzynn3sf3OAg28OcRgqUIEVUfQc4chzjGPrBCfWKU6tM5xZ5zi3LnBhXeJSXeGKXdM1u8GN5xa3se5w96N73LOv993/c5914/X1d/9rLPFj88fwdTxGCSVVtrWsHvBgPXr9o+cJT+rZ1mergoqqosrc3lzX+yrVUFMveFGveA3V+ze8We94tz7wYX16/WfI7b9e+33ccz7sO6J3umOIxhSNsT5u8y3ud9XC76x6c1KxcxXN3VM4r4/O3Jftb1TS381dU9EauOZ1K2tY1rOsb1nvsv5lP0R7RPZMUfdVQfdYtO9kP+Z530b7Okc53fNZzgTJC8kOyRXJmAznkeSWZJrknGSfZKHkpeSn5KlkrWSw5LNktWS3ZLnk+yCT7JfzoIvPCDk/UnymtPD5ImdPA59HST6fjCSfa4Z77fdJPft+vh+Ez3BrwOdoEPN39370jF9//gJSgJz1MSAxNSAxIDEgIzMzCnicc2fwZYhiYGAoYcgHYz2GZIZMhlyGdIYqoCgATrgE/Q=="
decompress_rle. r. $ir,$ir,1,1,5 if {$ir>512} b. 0.2% fi >=. 40%
fi
nm "[2d gum leaf shape]" v +
#@gui Snowflake : fx_snowflake, fx_snowflake(1)
#@gui : Recursions = int(5,0,6)
#@gui : Opacity = float(1,0,1)
#@gui : Color = color(255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_snowflake :
repeat $! l[$>] to_color split_opacity l[0]
shape_snowflake {min(w,h)},$1 100%,100%,1,3,[${3-5}]
j[0] .,{([w#0,h#0]-[w#1,h#1])/2},0,0,$2,.. k[0]
endl a c endl done
#@gui __
#@gui <b>Stereoscopic 3D</b>
#@gui 3D Conversion : fx_tk_make3D, fx_tk_make3D_preview(1)
#@gui : sep = separator()
#@gui : note = note("Stereoscopic settings:")
#@gui : Scene Selector = choice("automatic depth estimation","daylight scene","optimized lateral inhibition","light motive","dark motive","landscape","center foreground","center background","left foreground","left diagonal foreground","right foreground","right diagonal foreground","left and right foreground","left and right background","bottom and top foreground","bottom and left foreground","bottom and right foreground","central perspective outdoor","central perspective indoor","portrait","human 1","human 2","studio","underwater","flat")
#@gui : Far Point Deviation = float(20,-100,100)
#@gui : Stereoscopic Window Position = float(0,-100,100)
#@gui : Depth Field Control = float(20,0,100)
#@gui : Feature Analyzer Threshold = float(0,0,5)
#@gui : Feature Analyzer Smoothness = float(0,0,5)
#@gui : Local Detail Enhancer = float(0,0,5)
#@gui : DOF Analyzer = float(0,0,5)
#@gui : Frequency Analyzer = float(0,0,5)
#@gui : Flip Left / Right = bool(0)
#@gui : Use Individual Depth Map = bool(0)
#@gui : note = note("<small>To use this option your depth map must be placed below your image. Switch input layers to <i><b>Active and below</b></i>.</small>")
#@gui : sep = separator()
#@gui : note = note("Image settings:")
#@gui : Black & White = bool (0)
#@gui : Output Format = choice("Anaglyph red/cyan","Anaglyph red/cyan optimized","Anaglyph blue/yellow","Anaglyph blue/yellow optimized","Anaglyph green/magenta","Anaglyph green/magenta optimized","Full side by side keep width","Full side by side keep uncompressed","Full bottom/top","Half side  by side","Half bottom/top","Interlace horizontal","Interlace vertical","Full HD frame packing","Unaligned images","Depth map only")
#@gui : Gamma Compensation = float(1.2,0,4)
#@gui : Anti-Ghosting = float(25,0,255)
#@gui : Color Boost = float(1,0,4)
#@gui : Anaglyph Glasses Adjustment = float(0,-100,100)
#@gui : Autocrop = bool (1)
#@gui : Bidirectional Rendering = bool (0)
#@gui : sep = separator()
#@gui : note = note("Frame settings:")
#@gui : Render Multiple Frames = bool (0)
#@gui : Render Routine for Wiggle Animations = bool (0)
#@gui : Frames = int(2,2,100)
#@gui : Frame Size = int(200,50,1920)
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2012/20/09</i>.</small>")
fx_tk_make3D :
# prepare image
sh={-$2} sw={-$sh-$3} size1={w} size2={h} -to_rgb[0] -r[0] $size1,$size2 [0]
# create depth map
-if {$11==0}
--fx_tk_depthmap[-1] $1,$4,$5,$6,$7,$8,$9,0,0,0 -r[-1] $size1,$size2
-fx_gaussian_blur[-1] 0,{{w+h}/700},{{w+h}/350},1,0,0,0
# individual depth map
-else -if {{$!}!=3}
-error[] "For individual depth map select input mode ACTIVE AND BELOW" -endif
-rv[1,-1] -to_rgb[-1] -luminance[-1]
# analyze image features to enrich individual maps
-if {$11==1}
-if {$9!=0}
--fc[0] 128,128,128 --channels[0] 2 -negate[-1] -c[-1] 0,90
-n[-1] 0,128 -rv[-1,-2] -compose_darken[-1,-2]
--channels[0] 0 -negate[-1] -c[-1] 165,255 -n[-1] 128,255 -rv[-1,-2]
-compose_hardlight[-1,-2] -rv[-1,-2]
-if {$11==0} -if {$1!=20} -fx_compose_average[-1,-2] {$9/5}
-else -fx_compose_value[-1,-2] {$9/5},0
-tk_fx_channel_processing[-1] 1,{$4/25},0,0,0,0,100,256,0,0,0,2,0,0
-endif
-else -fx_compose_value[-1,-2] {$9/5},0 -endif -endif
-if {$8!=0} --fx_highpass[0] 2,2,0,0,0
-tk_fx_replace_color[-1] 5,0,128,128,128,255,0,0,0,255
-fx_morpho[-1] 3,70,0,0,0,1,0   -to_gray[-1] av={ia}
-ir[-1] $av,255 -n[-1] 0,255 -blur_xy[-1] 25
-rv[-1,-2] -fx_compose_overlay[-1,-2] {$8/5} -endif
-if {$5!=0} --fx_isophotes[0] {{$5*3}+2},0,0,0
-fx_morpho[-1] 3,{5-{$5/2}},0,0,0,1,0
-tk_fx_channel_processing[-1] 1,1,255,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -fx_compose_overlay[-1,-2] {$5/10}
--fx_gradient_norm[0] {$6*2},{1.5-{0.1+{$5/3.6}}},0,100,0,0
-rv[-1,-2] -compose_lighten[-1,-2] -fx_segment_watershed[-1] $5,$6,0,0
-endif
-if {$7!=0} --luminance[0] -fx_map_tones[-1] 1,{0.25-{$7/20}},0,30,3,0
-rv[-1,-2] -fx_compose_overlay[-1,-2] {$7/10} -endif
-n[-1] 0,255
-endif -endif
#frame size for multiple frames
-if {$20==1} -r {w*{$23/max(w,h)}},{h*{$23/max(w,h)}},1,3,6 -c 0,255 -endif
#create second view
-if {$20==0}
-if {$13!=15} -if {$19==0}
-if {$sw<=0} -negate[-1] -endif
-r[-1] $size1,$size2,1,2 -s[-1] c -f[-1] 0 -n[-2] 0,$sw -a[-1,-2] c
-warp[-2] [-1],1 -shift[-2] $sh,0 -rm[-1]
-else
[-1] -r[-1,-2] 100%,100%,1,2
-s[-1] c -f[-1] 0 -n[-2] 0,{abs($sw/2)} -a[-1,-2] c
-negate[-2] -s[-2] c -f[-2] 0 -n[-3] 0,{-abs($sw/2)} -a[-2,-3] c
-warp[-4] [-2],1 -warp[-3] [-1],1
-shift[-3] $sh,0 -rm[-1,-2]
-endif -endif
-else
#create multiple frames
-if {$19==0}
count={$22} dev=0 -repeat $count dev={$dev+{$sw/$22}}
[0] -rv[-1,-2]
-if {$sw<=0} -negate[-1] -endif
-r[-1] 100%,100%,1,2 -s[-1] c -f[-1] 0
-if {$21==0} -n[-2] 0,$dev -else -n[-2] {-$dev},$dev -endif
-a[-1,-2] c -warp[-2] [-1],1 -to_gray[-1] -n[-1] 0,255
-if {$sw<=0} -negate[-1] -endif
-done -rm[-1,0] -rv
-else
count={abs($22/2)} dev=0
-repeat $count dev={$dev+{$sw/$count}}
[-2] -rv[-1,-2]
[-2] -rv[-1,-2]
[-1] -r[-1,-2] 100%,100%,1,2
-s[-1] c -f[-1] 0
-if {$21==0} -n[-2] 0,{abs($dev/2)}
-else -n[-2] {-abs($dev/2)},{abs($dev/2)} -endif
-a[-1,-2] c
-negate[-2] -s[-2] c -f[-2] 0
-if {$21==0} -n[-3] 0,{-abs($dev/2)}
-else -n[-3] {-abs($dev/2)},{abs($dev/2)} -endif
-a[-2,-3] c
-warp[-4] [-2],1 -warp[-3] [-1],1 -rm[-2] -to_gray[-1] -n[-1] 0,255
-mv[-4] -1 -done -rm[-1,-2] -mv[0--1:2] -1 -rv[0-50%] -mv[0] 50%
-endif -endif
#crop images
-if {$20==0} -if {$18==1} -if {$13!=15}
-if {$sh>=0} -crop[-1,-2] $sh,0,{w},{h} -else -crop[-1,-2] 0,0,{w+$sh},{h} -endif
-if {$19==0}
-if {$sw>=0} -crop[-1,-2] $sw,0,{w},{h} -else -crop[-1,-2] 0,0,{w+$sw},{h} -endif
-else -crop[-1,-2] {abs($sw/2)},0,{w-abs($sw/2)},{h}
-endif -endif -endif -endif
#align stereoscopic image
-if {$12==1} -fx_blackandwhite 0.299,0,0.587,0,0.114,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0 -endif
-if {$20==0}
-if {{$13!=14}&&{$13!=15}}
-fx_tk_stereoimage[0,1] $13,$10,$14,$15,$16,$17
-elif {$13==14} -k[0,1]
-elif {$13==15} -k[-1]
-endif
-endif
-if {$13==14} -apply_gamma $14 -tk_fx_channel_processing 1,1,$15,0,0,0,100,256,0,0,1,10,7,0
-fx_mix_lab 1,0,0,$16,0,0,$16,0,0,0,2,0 -endif
fx_tk_make3D_preview :
-if {$20==0} shpre={$2/3} swpre={$3/3} -else shpre={$2*{400/$23}} swpre={$3*{400/$23}} -endif
-if {{$11==1}&&{{$!}!=2}} -fc[0] 255,0,128,255 -k[0] -text "For individual depth map",10,80%,20,1,0,0,0,255
-text "select input mode ACTIVE AND BELOW.",10,90%,20,1,0,0,0,255
-else
-fx_tk_make3D $1,$shpre,$swpre,${4-12},{if({$20==1},14,$13)},${14-19},0,${21-23} -if {{$13==14}||{$20==1}} -k[1] -endif
-endif
#@gui 3D Video Conversion : fx_tk_video3D, fx_tk_video3D_preview(1)
#@gui : sep = separator()
#@gui : note = note("<b>Stereoscopic settings:</b>")
#@gui : Scene Selector = choice("automatic depth estimation","daylight scene","optimized lateral inhibition","light motive","dark  motive","landscape","center foreground","center background","left  foreground","left diagonal foreground","right foreground","right diagonal  foreground","left and right foreground","left and right background","bottom and top foreground","bottom and left foreground","bottom and right foreground","central  perspective outdoor","central perspective indoor","portrait","human 1","human  2","studio","underwater","flat")
#@gui : Far Point Deviation = float(10,-100,100)
#@gui : Stereo Window Position = float(-10,-100,100)
#@gui : Depth Field Control = float(20,0,100)
#@gui : Feature Analyzer Threshold = float(0,0,5)
#@gui : Feature Analyzer Smoothness = float(0,0,5)
#@gui : Local Detail Enhancer = float(0,0,5)
#@gui : DOF Analyzer = float(0,0,5)
#@gui : Frequency Analyzer = float(0,0,5)
#@gui : Motion Analyzer = float(0,-5,5)
#@gui : Flip Left / Right = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Frames settings:</b>")
#@gui : Black & White = bool (0)
#@gui : Output Format = choice("Anaglyph red/cyan","Anaglyph red/cyan optimized","Anaglyph blue/yellow","Anaglyph blue/yellow optimized","Anaglyph green/magenta","Anaglyph green/magenta optimized","Full side by side keep width","Full side by uncompressed","Full bottom/top","Half side  by side","Half bottom/top","Interlace horizontal","Interlace vertical","Full HD frame packing","Left and right image streams","Depth maps only")
#@gui : Output to Folder = bool(0)
#@gui : Folder Name = folder()
#@gui : Gamma Compensation = float(1.2,0,4)
#@gui : Anti-Ghosting = float(25,0,255)
#@gui : Color Boost = float(1,0,4)
#@gui : Anaglyph Glasses Adjustment = float(0,-100,100)
#@gui : Autocrop = bool (1)
#@gui : Set Frame Format = bool (1)
#@gui : Frame Width = int(1280,128,4096)
#@gui : Frame Format = choice(1,"4:3","16:9","3:2","2:1","21:9","Keep aspect ratio")
#@gui : Frames Offset = int(0,-5,5)
#@gui : Reverse Frame Stack = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Input settings:</b>")
#@gui : Processing Mode = choice("Layer processing","Batch processing")
#@gui : Input Folder = folder()
#@gui : Input Frame Files Name = text("frame_")
#@gui : Start Frame Number = int(0,0,99998)
#@gui : End Frame Number = int(1,1,99999)
#@gui : Frame Files Format = choice(".png",".bmp")
#@gui : sep = separator()
#@gui : note = note("<b>Advanced editing:</b>")
#@gui : Activate Custom Filter = choice("off","on","left stream only", "right stream only")
#@gui : Custom Filter Code = text(1,"# old movie #\n#-luminance -fx_stripes_y 10,3,0 -sepia \n\n#simple vintage#\n#--fc 0,15,125 -rv -fx_compose_exclusion 0.3 \n\n# HDR popout #\n#-fx_map_tones_fast 2,0.3,3,2 -fx_unsharp_octave 4,5,3,0,0,0\n\n")
#@gui : Depth Fade in Frames = int(0,0,120)
#@gui : Depth Fade Out Frames = int(0,0,120)
#@gui : sep = separator()
#@gui : note = note("<b>Advanced quality control:</b>")
#@gui : Key Frame Rate = int(1,1,100)
#@gui : Stabilizer = float(5,0,100)
#@gui : Preprocessor Radius = float(0,0,5)
#@gui : Preprocessor Power = float(0,0,5)
#@gui : Custom Depth Correction = choice("None","Custom correction map","Single custom depth map","Custom depth maps stream")
#@gui : Rendering Mode = choice(1,"Right eye view","Bidirectional rendering","Align image streams","Anaglyph reconstruction")
#@gui : sep = separator()
#@gui : note = note("<b>Preview:</b>")
#@gui : Preview Type = Choice("first frame","last frame","selected frame","full layer stack -slow!-")
#@gui : Preview Frame Selection = int(0,0,99999)
#@gui : sep = separator(), note = note("<small><b>Switch input layers to All.</b></small>")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.       Latest update: <i>2012/07/10</i>.</small>")
fx_tk_video3D :
sh={-$2} sw={-$sh-$3} size1={w} size2={h}
-if {narg($_previewflag)==0} _previewflag=0 -endif
-if {$_previewflag!=0} sh={$sh*{400/$22}} sw={$sw*{400/$22}} -endif
-if {$26==0}
####layer based conversion####
-if {{$34!=0}||{$35!=0}}
-if {{$34>={{$!}-$35}}||{$35>={{$!}-$34}}} -error[] "Fade out of frame range."
-endif -endif
-if {$13!=14} -channels 0,2 -endif
-if {$_previewflag!=2}  frames={$!} -else frames=1  -endif
counter={$!} index=0
-if {$_previewflag!=0} -r 400,328 -endif
# image stream alignment and 2D filtering only modes
#-if {{$41==3}&&{$_previewflag==0}} -error[] "Anaglyph video reconstruction in batch processing mode only" -endif
flag3d=0 -if {$41!=2}
-if {!{{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}}} flag3d=1
# start 3D conversion per frame
-repeat {$frames}
# prepare images
[$index]
# create depth maps
-if {{$40==0}||{$40==1}}
--fx_tk_depthmap[$index] $1,$4,$5,$6,$7,$8,$9,$38,$39,{w*{$37/1000}}
-r[-1] $size1,$size2 -endif
-if {$40==1}
infilec="correction.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-to_rgba[-1,-2] -compose_rgba[-1,-2] -to_rgb[-1]
-elif {$40==2}
infilec="depthmap.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-elif {$40==3}
-if {$_previewflag==2}
infilec="depthmap_"$_mapin".png" inpathc="$27/depthmaps/"$infilec""
-else
infilec="depthmap_"{$frames-$index}".png" inpathc="$27/depthmaps/"$infilec""
-endif
-input[-1] $inpathc
-rv[$index,-2]
-endif
-if {$_previewflag!=0} -r 400,328 -endif
# motion analysis
-if {$10!=0}
-if {$_previewflag==2} [0] -mv[-4] -1
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,{{$37/2}+1} -negate[-1] -n[-1] 0,255
-else
[$index] [{$index+1}]
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,{{$37/2}+1}
-negate[-1] -n[-1] 0,255
-if {$index<={$frames-2}} --negate[-1] -endif
-endif
-endif
index={$index+1} -done
-if {$10!=0}
-if {$_previewflag==2}
-if {$42==0}  infile={$29} -elif {$42==1} infile={$30} -elif {$42==2} infile={$43} -endif
-if {$infile==2} -rv[-1,-2] -else -if {$infile>={$29+2}}
-compose_difference[-4,-5] -luminance[-4] -n[-4] 0,255
-ir[-4] 0,1 -negate[-4] -n[-4] 0,255
-negate[-4] -compose_darken[-1,-4]
-mv[-3] -1 -endif -endif
-blur_xy[-2] {w*{$37/1000}}
-if {$infile!=$29} -if {$10>=0} -fx_compose_lighten[-1,-2] {abs($10)/5}
-else -negate[-2] -fx_compose_darken[-1,-2] {abs($10)/5} -endif -endif
-else
-rm[-1] -rm[{$counter+3}]
-repeat {$frames-2}
-mv[{$counter+6}] {$counter+2}
-compose_darken[{$counter+2},{$counter+3}]
-rv[{$counter+1},{$counter+2}]
-blur_xy[{$counter+1}] {w*{$37/1000}}
-if {$10>=0}
-fx_compose_lighten[{$counter+1},{$counter+2}] {abs($10)/5}
-else -negate[{$counter+1}]
-fx_compose_darken[{$counter+1},{$counter+2}] {abs($10)/5}
-endif
counter={$counter+2} -done
-rv[-3,-4] -blur_xy[-4] {w*{$37/1000}}
-if {$10>=0} -fx_compose_lighten[-3,-4] {abs($10)/5}
-else -negate[-4] -fx_compose_darken[-3,-4] {abs($10)/5} -endif
-endif
-endif
# create second view frameset
-if {$_previewflag==2} -if {$24!=0} -rm[-2] -endif -endif
index={-1} -repeat $frames
-if {$13!=15}
-if {$41==0} -if {$sw<=0} -negate[$index] -endif -endif
-if {$_previewflag!=2}
-if {$34!=0} -if {{-$index}<=$34} sw={{{-$index}/$34}*$sw} sh={{{-$index}/$34}*$sh}
-endif -endif
-if {$35!=0} -if {-{$index+1}>={$frames-$35}} sw={$sw*{{$frames-{-{$index+1}}}/$35}}
sh={$sh*{{$frames-{-{$index+1}}}/$35}} -endif -endif -endif
-if {$41==0}
-r[$index] 100%,100%,1,2 -s[$index] c -f[$index] 0 -n[{$index-1}] 0,$sw
-a[$index,{$index-1}] c -warp[{$index-1}] [$index],1
-shift[{$index-1}] $sh,0 -rm[$index]
-else
[$index]
-mv[-1] {$frames+{$index+1}}
-r[$index,{$frames+{$index+1}}] 100%,100%,1,2
-s[$index] c -f[$index] 0 -n[{$index-1}] 0,{abs($sw/2)} -a[$index,{$index-1}] c
-negate[{$frames+{$index+1}}] -s[{$frames+{$index+1}}] c
-f[{$frames+{$index+2}}] 0 -n[{$frames+{$index+1}}] 0,{-abs($sw/2)}
-a[{$frames+{$index+1}},{$frames+{$index+2}}] c
-warp[{$frames+{$index+0}}] [{$frames+{$index+1}}],1
-warp[{$index-1}] [$index],1
-shift[{$index-1}] $sh,0
-rm[$index,{$frames+{$index+1}}]
-endif
-endif
sh={-$2} sw={-$sh-$3}
-if {$_previewflag!=0} sh={$sh*{400/$22}} sw={$sw*{400/$22}} -endif
index={$index-1} -done
# frames offset
-if {$13!=15} -if {$_previewflag!=2}
-if {$24>=0} -repeat $24 -rm[-1] [$frames]
-mv[-1] $frames -done
-else counter={1} -repeat {abs($24)} -rm[$frames]
[{-$counter}] -mv[-1] {-$counter-1} counter={$counter+1} -done -endif
-endif -endif
# autocrop frames
-if {$20==1} -if {$13!=15}
-if {$sh>=0} -crop $sh,0,{w},{h} -else -crop 0,0,{w+$sh},{h} -endif
-if {$sw>=0} -crop $sw,0,{w},{h} -else -crop 0,0,{w+$sw},{h} -endif
-endif -endif
#end image stream alignment and 2D mode bypass
-endif -endif
# apply custom filter
-if {$_previewflag!=2}
-if {$32!=0} -if {$13!=15} -repeat $! -l[$>] -fx_custom_code "$33",0,0,0 -endl -done -endif -endif
-else
-if {$32==1} -if {$13!=15} -fx_custom_code[0,1] "$33",0,0,0 -endif
-elif {$32==2} -if {$13!=15} -l[0] -fx_custom_code "$33",0,0,0 -endl -endif
-elif {$32==3} -if {$13!=15} -l[1] -fx_custom_code "$33",0,0,0 -endl -endif
-endif -endif
# align stereoscopic images
-if {$41==2} -if {{$13==14}||{$13==15}} -error[] "Output format not allowed for image stream alignment" -endif -endif
-if {$12==1} -ac "-fx_blackandwhite 0.3,0,0.6,0,0.1,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0",rgb -endif
counter={$frames-1} index={-2}
-repeat $frames
-if {{$13!=14}&&{$13!=15}}
-fx_tk_stereoimage[-1,$counter] $13,$11,$16,$17,$18,$19
-elif {$13==15} -rm[0,$index]
-endif counter={$counter-1} index={$index-1} -done
# adjust output image streams
-if {$13==14} -apply_gamma $16 -tk_fx_channel_processing 1,1,$17,0,0,0,100,256,0,0,1,10,7,0
-fx_mix_lab 1,0,0,$18,0,0,$18,0,0,0,2,0 -endif
# resize frames to output format
-if {$21==1} -if {$13!=13}
-if {$23==0} -r $22,{$22*0.75},1,{s},6
-elif {$23==1} -r $22,{{$22*9}/16},1,{s},6
-elif {$23==2} -r $22,{{$22*2}/3},1,{s},6
-elif {$23==3} -r $22,{$22*0.5},1,{s},6
-elif {$23==4} -r $22,{{$22*9}/21},1,{s},6
-elif {$23==5} -r $22,{$22*{h/w}},1,{s},6 -endif
-endif -endif  -c 0,255
-if {$25==1} -rv -endif
# save frames to folder
-if {$14==1}
-if {{$31==0}||{$13==15}} end=".png" -else end=".bmp" -endif
-rv
index={0} name=0
-if {{$13==14}&&{$flag3d==1}}
fileleft="$15/frame_left_"{$name+1}$end fileright="$15/frame_right_"{$name+1}$end
-else  -if {$13!=15} filename="$15/frame_"{$index+1}$end
-else  filename="$15/depthmap_"{$index+1}$end -endif -endif
-repeat $frames
-if {{$13==14}&&{$flag3d==1}}
-output[$index] $fileright
-output[{$index+$frames}] $fileleft
index={$index+1} name={$name+1}
fileleft="$15/frame_left_"{$name+1}$end fileright="$15/frame_right_"{$name+1}$end
-else
-output[$index] $filename
index={$index+1} -if {$13!=15} filename="$15/frame_"{$index+1}$end -else filename="$15/depthmap_"{$index+1}$end -endif
-endif
-done -rv
-endif
####batch based conversion####
-else
# load images in batch mode
-if {$31==0} end=".png" -else end=".bmp" -endif
infile={$29} inpath="$27/$28"$infile""$end"" outfile={$29}
frames={{$30-$29}+1} counter=1
-if {{$34!=0}||{$35!=0}}
-if {{$34>={$frames-$35}}||{$35>={$frames-$34}}} -error[] "Fade out of frame range"
-endif -endif
-if {$41==2}
inpathleft="$27/$28""left_"$infile$end inpathright="$27/$28""right_"$infile$end
-endif
av=1 var=1 avprev=1 varprev=1
-repeat $frames
-if {$41!=2}
-rm -input[0] $inpath
-if {{$24==0}} [0]
-else infile2={$infile+$24}
-if {$infile2<=$29} infile2={$29} -endif
-if {$infile2>=$30} infile2={$30} -endif
inpath2="$27/$28"$infile2""$end""
-input[1] $inpath2 -endif
-else
-rm -input[0] $inpathleft
-input[1] $inpathright
-endif
size1={w} size2={h}
# image stream alignment and 2D filtering only modes
flag3d=0 -if {$41==3} flag3d=1 -endif -if {{$41!=2}&&{$41!=3}}
-if {!{{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}}} flag3d=1
# prepare images
-if {$13!=14} -channels[0,1] 0,2 -endif
# create depth map
-if {{$40==0}||{$40==1}}
av={0,ia} var={0,iv} diffav={{$av-$avprev}/$avprev*100} diffvar={{$var-$varprev}/$varprev*100}
-if {{abs($diffav)>=10}||{abs($diffvar)>=10}} scenechange=1 -else scenechange=0 -endif
-if {{$counter==1}||{$scenechange==1}||{{$counter/$36}=={round($counter/$36,1)}}}
--fx_tk_depthmap[0] $1,$4,$5,$6,$7,$8,$9,$38,$39,{w*{$37/1000}} -r[-1] $size1,$size2
-if {$av!=0} avprev=$av -endif -if {$var!=0} varprev=$var -endif
-if {$36!=1} filename="$15/depthmap_temp.png"
-output[-1] $filename -endif
-else
filename="$15/depthmap_temp.png"
-input[-1] $filename
-endif
-endif
-if {$40==1}
infilec="correction.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-compose_rgba[-1,-2]
-elif {$40==2}
infilec="depthmap.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-elif {$40==3}
infilec="depthmap_"$infile".png" inpathc="$27/depthmaps/"$infilec""
-input[-1] $inpathc
-endif
# motion analysis
-if {$10!=0} -if {$infile!=$29}
[0]
infilemov={$infile-1} inpathmov="$27/$28"$infilemov""$end""
-input[-1] $inpathmov
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,{{$37/2}+1} -negate[-1] -n[-1] 0,255
-if {$infile>={$29+2}}
infilemov2={$infile-2} inpathmov2="$27/$28"$infilemov2""$end""
-input[-1] $inpathmov2
infilemov3={$infile-1} inpathmov3="$27/$28"$infilemov3""$end""
-input[-1] $inpathmov3
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,1 -n[-1] 0,255 -compose_darken[-1,-2]
-endif -blur_xy[-1] {w*{$37/1000}} -rv[-1,-2]
-if {$10>=0}
-fx_compose_lighten[-1,-2] {abs($10)/5}
-else
-negate[-2]
-fx_compose_darken[-1,-2] {abs($10)/5}
-endif
-endif -endif
# create second view
-if {$13!=15}
-if {$41==0}
-if {$sw<=0} -negate[2] -endif
-if {$34!=0} -if {$counter<=$34} sw={{$counter/$34}*$sw} sh={{$counter/$34}*$sh} -endif -endif
-if {$35!=0} -if {$counter>={$frames-$35}} sw={$sw*{{{$frames-$counter}+1}/$35}}
sh={$sh*{{{$frames-$counter}+1}/$35}} -endif -endif
-r[-1] 100%,100%,1,2 -s[-1] c -f[-1] 0 -n[-2] 0,$sw -a[-1,-2] c
-warp[-2] [-1],1 -shift[-2] $sh,0 -rm[-1]
-else
[-1] -r[-1,-2] 100%,100%,1,2
-s[-1] c -f[-1] 0 -n[-2] 0,{abs($sw/2)} -a[-1,-2] c
-negate[-2] -s[-2] c -f[-2] 0 -n[-3] 0,{-abs($sw/2)} -a[-2,-3] c
-warp[-4] [-2],1 -warp[-3] [-1],1
-shift[-3] $sh,0 -rm[-1,-2]
-endif
-endif
sh={-$2} sw={-$sh-$3}
# autocrop frames
-if {$20==1} -if {$13!=15}
-if {$sh>=0} -crop $sh,0,{w},{h} -else -crop 0,0,{w+$sh},{h} -endif
-if {$sw>=0} -crop $sw,0,{w},{h} -else -crop 0,0,{w+$sw},{h} -endif
-endif -endif
#end image stream alignment and 2D mode bypass
-endif  -endif
-if {$41==3} -fx_tk_deana[0] $37,{{$38*2}+0.1} -to_rgb -endif
# apply custom filter
-if {$32==1} -if {$13!=15} -fx_custom_code[0,1] "$33",0,0,0 -endif
-elif {$32==2} -if {$13!=15} -l[0] -fx_custom_code "$33",0,0,0 -endl -endif
-elif {$32==3} -if {$13!=15} -l[1] -fx_custom_code "$33",0,0,0 -endl -endif
-endif
# align stereoscopic image
-if {$12==1} -ac[0,1] "-fx_blackandwhite 0.3,0,0.6,0,0.1,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0",rgb -endif
-if {{$41==2}&&{$13==14}} -error[] "Output format not allowed for image stream alignment"
-elif {{$41==3}&&{$13==15}} -error[] "Output format not allowed for anaglyph video reconstruction"
-elif {{$41==2}&&{$13==15}} --fx_tk_depth_obtain[0,1] $11,{$37/100},{100-{$38*20}},{$39*20}
-if {$32!=0} -fx_custom_code[0,1,-1] "$33",0,0,0 -endif -k[-1]
-elif {{$41!=2}&&{$13==15}} -k[-1]
-elif {{$41==3}&&{$13==14}} -k[0,1]
-else -fx_tk_stereoimage[0,1] $13,$11,$16,$17,$18,$19 -endif
# adjust output image streams
-if {$13==14} -apply_gamma $16 -tk_fx_channel_processing 1,1,$17,0,0,0,100,256,0,0,1,10,7,0
-fx_mix_lab 1,0,0,$18,0,0,$18,0,0,0,2,0 -endif
# resize frame to output format
-if {$21==1} -if {$13!=13}
-if {$23==0}   -r $22,{$22*0.75},1,{s},6
-elif {$23==1} -r $22,{{$22*9}/16},1,{s},6
-elif {$23==2} -r $22,{{$22*2}/3},1,{s},6
-elif {$23==3} -r $22,{$22*0.5},1,{s},6
-elif {$23==4} -r $22,{{$22*9}/21},1,{s},6
-elif {$23==5} -r $22,{$22*{h/w}},1,{s},6
-endif -endif -endif -c 0,255
# save frame to folder
-if {{$13==14}&&{$flag3d==1}}
fileleft="$15/frame_left_"$outfile$end fileright="$15/frame_right_"$outfile$end
-else  -if {$13!=15} filename="$15/frame_"$outfile$end
-else  filename="$15/depthmap_"$outfile$end -endif -endif
-if {{$13==14}&&{$flag3d==1}}
-output[0] $fileleft -output[1] $fileright
-else -output[0] $filename
-endif
outfile={$outfile+1}
# end batch processing loops and delete temporary file
infile={$infile+1} inpath="$27/$28"$infile""$end""
-if {$41==2} inpathleft="$27/$28""left_"$infile$end inpathright="$27/$28""right_"$infile$end -endif
counter={$counter+1} -done -endif
-if {{$_previewflag==0}&&{$26==1}} -if {$36!=1}
-if ${-is_windows} path="$15" path=${path}{`92`}
-x "cd \""$path"\" && del depthmap_temp.png"
-else file="$15/depthmap_temp.png" -x "rm -f \"$file\"" -endif
-endif -endif
#####preview function####
fx_tk_video3D_preview :
shpre={$2*{400/$22}} swpre={$3*{400/$22}}
-if {$26==0}
#####preview layer mode###
-if {{$!}==1} -fc[0] 255,0,128,255 -k[0] -text "Select multiple layer",10,80%,24,1,0,0,0,255
-text "input mode ALL.",10,90%,24,1,0,0,0,255
-elif {$41==2} -fc[0] 255,0,128,255 -k[0] -text "Alignment of image streams",10,80%,24,1,0,0,0,255
-text "in BATCH processing mode only!",10,90%,24,1,0,0,0,255
-elif {$41==3} -fc[0] 255,0,128,255 -k[0] -text "Anaglyph video reconstruction",10,80%,24,1,0,0,0,255
-text "in BATCH processing mode only!",10,90%,24,1,0,0,0,255
-else
_previewflag=1
-if {$40==3} -if {$42==0} _mapin=1 -elif {$42==1} _mapin={$!} -elif {$42==2}  _mapin=$43 -endif -endif
-if {$42==0} nr=1 pv={-1} -elif {$42==1} nr={$!} pv={-$!} -elif {{$42==2}||{$42==3}} nr=$43 pv={-$43} -endif
-if {{$42==2}||{$42==3}} -if {$43>={$!}} nr={$!} pv={-$!} _mapin={$!} -endif -endif
-if {$42!=3}
-fx_tk_video3D[$pv] $1,$shpre,$swpre,${4-9},0,${11-13},0,"$15",${16-23},0,${25-26},"$27","$28",${29-32},"$33",0,0,${36-39},0,${41-43} -k[$pv]
-text[0] "layer "{``$nr},20,75%,{h*0.1},1,255,{if({{$13==2}||{$13==3}||{$13==15}},0,255)},0,255
-if {$24!=0} -text "For preview with frames offset ",20,70%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255 -endif
-if {{$34!=0}||{$35!=0}} -text "For fade in/out effect preview",20,65%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255  -endif
-if {$40!=0} -text "For preview with custom depth correction ",20,60%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255 -endif
-if {$10!=0} -text "For preview with motion analyzer ",20,55%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255 -endif
-if {{$32==2}||{$32==3}} -text[0] "Separate stream filtering ignored in layer mode",20,50%,{h*0.05},1,255,255,0,255 -endif
-else
-fx_tk_video3D $1,$shpre,$swpre,${4-13},0,"$15",${16-26},"$27","$28",${29-32},"$33",${34-43} -k[$pv]
-endif
-text[0] "layer "{``$nr},20,75%,{h*0.1},1,255,{if({{$13==2}||{$13==3}||{$13==15}},0,255)},0,255
-if {{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}} -text[0] "2D filter mode on!",50%,75%,{h*0.075},1,255,255,0,255 -endif
-if {$36!=1} -text "Key frame settings ignored in layer processing mode. ",20,50%,{h*0.05},1,255,255,0,255 -endif
_previewflag=0
-endif
-else
####preview batch mode####
_previewflag=2
-if {$42==3}
--fc[0] 255,0,128,255 -k[-1]
-text "No preview available",20,50,28,1,0,0,0,255
-text "for batch input stack!",20,80,28,1,0,0,0,255
-text "Please select frame to adjust settings.",20,150,16,1,0,0,0,255
-elif {{$42==2}&&{{$43<={$29-1}}||{$43>={$30+1}}}} -fc[0] 255,0,128,255 -k[0]
-text[0] "Selected frame out of range! ",10,80%,24,1,0,0,0,255
-elif {{$41==2}&&{$13==14}} -fc[0] 255,0,128,255 -k[0]
-text[0] "Output format not allowed!",10,80%,24,1,0,0,0,255
-elif {{$41==3}&&{$13==15}} -fc[0] 255,0,128,255 -k[0]
-text[0] "Output format not allowed!",10,80%,24,1,0,0,0,255
-else
-rm
-if {$31==0} end=".png" -else end=".bmp" -endif
-if {$42==0}  infile={$29}
-if {$34!=0} swpre={{1/$34}*$swpre} shpre={{1/$34}*$shpre} -endif
-elif {$42==1} infile={$30}
-if {$35!=0} swpre={{1-{1/$35}}*$swpre} shpre={{1-{1/$35}}*$shpre} -endif
-elif {$42==2} infile={$43}
-if {{$34!=0}||{$35!=0}}
-if {$43<={$29+$34}} swpre={{$43/$34}*$swpre} shpre={{$43/$34}*$shpre} -endif
-if {$43>={$30-$35}} swpre={{$30-$43}*{$swpre/$35}} shpre={{$30-$43}*{$shpre/$35}} -endif
-endif
-endif
-if {$41!=2}
inpath1="$27/$28"$infile""$end""
-input[0] $inpath1
-if {$24!=0} infileoff={$infile+$24}
-if {$infileoff<=$29} infileoff={$29} -endif
-if {$infileoff>=$30} infileoff={$30} -endif
inpathoff="$27/$28"$infileoff""$end""
-input[1] $inpathoff
-endif
-if {$infile!=$29} -if {$10!=0}
infilemov={$infile-1} inpathmov="$27/$28"$infilemov""$end""
-input[-1] $inpathmov
-if {$infile>={$29+2}}
infilemov2={$infile-2} inpathmov2="$27/$28"$infilemov2""$end""
-input[-1] $inpathmov2
infilemov3={$infile-1} inpathmov3="$27/$28"$infilemov3""$end""
-input[-1] $inpathmov3
-endif -endif -endif
-else
inpathleft="$27/$28""left_"$infile$end inpathright="$27/$28""right_"$infile$end
-rm -input[0] $inpathleft
-input[1] $inpathright
-endif
-if {$42==0} _mapin=$29 -elif {$42==1} _mapin=$30 -elif {$42==2} _mapin=$43 -endif
framesn={{$30-$29}+1}
-if {{{$34!=0}||{$35!=0}}&&{{$34>={$framesn-$35}}||{$35>={$framesn-$34}}}} -fc[0] 255,0,128,255 -k[0]
-text "Fade out of frame range! ",10,80%,{h*0.1},1,0,0,0,255
-else
-if {{$41==2}&&{$13==15}} --fx_tk_depth_obtain[0,1] $11,{$37/100},{100-{$38*20}},{$39*20}
-if {$32!=0} -fx_custom_code[0,1,-1] "$33",0,0,0  -endif -k[-1]
-else
-fx_tk_video3D $1,$shpre,$swpre,${4-9},{if({$infile==$29},0,$10)},${11-13},0,"$15",${16-25},0,"$27","$28",${29-31},{if({{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}},2,$32)},"$33",0,0,1,${37-43}
-endif -to_rgb -if {$13==14} -k[-1] -endif
-text[0] "frame "{``$infile},20,75%,{h*0.1},1,255,{if({{$13==2}||{$13==3}||{$13==15}},0,255)},0,255
-if {$41!=2} -if {$36!=1} -if {{$40==0}||{$40==1}} -text[0] "Preview always forced to key frame. ",20,50%,{h*0.05},1,255,255,0,255 -else
-text[0] "No keyframe computation for individual maps. ",20,64%,{h*0.05},1,255,255,0,255 -endif -endif -endif
-if {{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}} -text[0] "2D filter mode on!",50%,75%,{h*0.075},1,255,255,0,255 -endif
-endif -endif -endif
_previewflag=0
#@gui Automatic Depth Estimation : fx_tk_autodepth, fx_tk_autodepth(1)
#@gui : sep = separator()
#@gui : note = note("This filter estimates a depth map from a 2D image by analyzing various monoscopic image properties.")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>       Latest update: <i>2012/30/07</i>.</small>")
fx_tk_autodepth :
-repeat $! -l[$>] -to_rgb size1={w} -resize2dx 400,2
#coefficient settings
whpos=128 blpos=128 rpos=255 gpos=200 blupos=200 crga=1.5 crmix1=0.5 crmix2=0.5 geocomp1=75 geocomp2=30
geostr=0.3 focstr=0.3 featsize=60 featpos=128 feattr=35 tr=30 rtr=90 gtr=90 blutr=90 contstr=0.9
featinfl=1 foctol=5 focmorph=70 focavt=85 focavt2=140 focvart=2000 latinhib=0.5
#depth from gravity
--fx_map_tones_fast[-1] 10,0.5,0,0 -luminance[-1]
-fx_segment_watershed[-1] 0.5,1,0  -label[-1] 5,0
--fx_gradient_norm[0] 0,0.5,0,100,0,0 -compose_lighten[-1,-2]
-fx_segment_watershed[-1] 0.5,1,0 -label[-1] 5,0 -n[-1] 0,255
#depth from luminance and compensate over/underexposed areas
--luminance[0]
--channels[0] 1 -ir[-1] $gtr%,100%
-fx_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$gpos
-tk_fx_replace_color[-1] 1,0,0,0,0,255,0,0,0,0  -blend[-1,-2] alpha
--channels[0] 0 -ir[-1] $rtr%,100%
-fx_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$rpos
-tk_fx_replace_color[-1] 1,0,0,0,0,255,0,0,0,0 -blend[-1,-2] alpha
--channels[0] 2 -ir[-1] $blutr%,100%  -n[-1] 0,$blupos
-fx_morpho[-1] 2,2,0,0,0,1,0
-tk_fx_replace_color[-1] 1,0,0,0,0,255,0,0,0,0
-to_rgba[-1] --fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,100
-s[-2] c -rv[-1,-2] -compose_multiply[-1,-2] -to_gray[-1] -a[-4,-3,-2,-1] c
-blend[-1,-2] alpha
--channels[0] 0 --luminance[0] -compose_average[-1,-2] -ir[-1] 80%,95%
-fx_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$whpos
-tk_fx_replace_color[-1] 1,0,0,0,0,255,0,0,0,0 -blend[-1,-2] alpha
--channels[0] 0 --luminance[0] -compose_average[-1,-2] -ir[-1] 5%,20%
-fx_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$blpos
-tk_fx_replace_color[-1] 1,0,0,0,0,255,0,0,0,0 -blend[-1,-2] alpha
#depth from lateral inhibition
--fx_gradient_norm[0] 0,0.5,0,50,0,0
[-1]
-fx_morpho[-1] 2,$featsize,0,0,0,1,0
-ir[-1] $feattr%,100%
-n[-1] 0,$featpos
-blur_xy[-1] 2
-fx_compose_lighten[-1,-2] $contstr
-blur_xy[-1] 2
#depth from color
-to_rgb[0] -rgb2ycbcr[0] --channels[0] 2 -ycbcr2rgb[0]
-n[-1] 0,255 -c[-1] 25%,100%  -apply_gamma[-1] $crga
--channels[0] 2 -negate[-1] -c[-1] 0,128
-to_rgba[-1] --fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,270,0,100
-s[-2] c -rv[-1,-2] -compose_multiply[-1,-2] -to_gray[-1]
-a[-4,-3,-2,-1] c -rv[-1,-2] -fx_compose_darken[-1,-2] $crmix1
#depth from geometry
--luminance[0] -fx_houghsketchbw[-1] 10,5,15,$tr,1,1,0 complex={ia}
-if {$complex>=$geocomp1}
-do tr={$tr+10} -rm[-1] --luminance[0] -fx_houghsketchbw[-1] 10,5,15,$tr,1,1,0 complex={ia}
-while {{$complex>=$geocomp2}&&{$tr<=90}} -endif
-fx_morpho[-1] 3,5,0,0,0,1,0 -blur_xy[-1] 1 -fx_distance[-1] 255,0,1,1,0
complex={ia}
#depth from focus
--fx_highpass[0] 2,2,0,0,0
-tk_fx_replace_color[-1] $foctol,0,128,128,128,255,0,0,0,255
-fx_morpho[-1] 3,$focmorph,0,0,0,1,0   -to_gray[-1]
av={ia} var={iv}
-if {{$av<=$focavt}||{{$av>=$focavt}&&{$av<=$focavt2}&&{$var<=$focvart}}}
-ir[-1] $av,255 -n[-1] 0,255 -blur_xy[-1] 10 -else -fc[-1] 128,128,128 -endif
#lateral inhibition emphaziser
--fx_gradient_norm[0] 0,0.5,0,50,0,0
#composing depth representations
-rm[0]
-fx_compose_overlay[-7,-6] 0.5
-fx_compose_overlay[-6,-5] $featinfl
-fx_compose_value[-5,-4] $crmix2
-rv[-4,-3]
-if {$complex!=0} -fx_compose_overlay[-4,-3] $geostr -else -rm[-3] -endif
-rv[-3,-2]
-fx_compose_overlay[-3,-2] $focstr
-rv[-2,-1]
-fx_compose_lighten[-1,-2] $latinhib
#final segmentation and smoothing
-blur_xy[-1] 2  -fx_morpho[-1] 3,20,0,0,0,1,0
-fx_segment_watershed[-1] 15,0,0 -n[-1] 0,255
-blur_y[-1] 2 -blur_x[-1] 1
-resize2dx $size1,2
-endl -done
#@gui De-Anaglyph : fx_tk_deana, fx_tk_deana(1)
#@gui : sep = separator()
#@gui : note = note("This filter reconstructs strereoscopic full colour views from anaglyphs")
#@gui : sep = separator()
#@gui : Colour Smoothing = float(20,0,100)
#@gui : Gamma Equalizer = float(2,0.1,10)
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>     Latest update: <i>2012/20/09</i>.</small>")
fx_tk_deana :
-repeat $! -l[$>] -to_rgb --s c -rm[-1]
-to_rgb[-1,-2] -rgb2lab[-1,-2] -channels[-1,-2] 0
-rgb2lab[0] -s[0] c -blur_x[1,2] $1
-c[-1,-2] {0,im},{0,iM}
-apply_gamma[-1] {($2^({0,ia}/ia)-$2)*$2+1}
-apply_gamma[-2] {($2^({0,ia}/{-2,ia})-$2)*$2+1}
[1,2] -rm[0] -mv[2] 0
-a[0,1,2] c -a[1,2,3] c -lab2rgb[0,1]
-endl -done
#@gui Depth Map Construction : fx_tk_depthmap, fx_tk_depthmap(1)
#@gui : sep = separator()
#@gui : note = note("This filter estimates and constructs a depth map for a 2D image ")
#@gui : Scene Selector = choice("automatic depth estimation","daylight scene","optimized lateral inhibition","light motive","dark  motive","landscape","center foreground","center background","left  foreground","left diagonal foreground","right foreground","right diagonal  foreground","left and right foreground","left and right background","bottom and top foreground","bottom and left foreground","bottom and right foreground","central  perspective outdoor","central perspective indoor","portrait","human 1","human  2","studio","underwater","flat")
#@gui : Depth Field Control = float(20,0,100)
#@gui : Feature Analyzer Threshold = float(0,0,5)
#@gui : Feature Analyzer Smoothness = float(0,0,5)
#@gui : Local Detail Enhancer = float(0,0,5)
#@gui : DOF Analyzer = float(0,0,5)
#@gui : Frequency Analyzer = float(0,0,5)
#@gui : Preprocessor Radius = float(0,0,5)
#@gui : Preprocessor Power = float(0,0,5)
#@gui : Smoothing = float(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>       Latest update: <i>2012/30/07</i>.</small>")
fx_tk_depthmap :
-repeat $! -l[$>] -to_rgb size1={w} -resize2dx 400,2
-if {{$8!=0}||{$8!=0}} -fx_map_tones_fast {$8*4},{$9/5},3,0 -endif
-if {$1==0} --fx_tk_autodepth[-1]
--luminance[0] -fx_map_tones[-1] 1,0.25,0,30,3,0
-rv[-1,-2] -fx_compose_value[-1,-2] 0.15
-tk_fx_channel_processing[-1] 1,{$2/20},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==1} --channels[0] 2
-tk_fx_channel_processing[-1] 1,{{$2/25}+0.1},0,0,0,0,100,256,0,1,0,2,0,0
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/1.5}}
-rv[-1,-2] -fx_compose_lighten[-1,-2] {0.5+{$2/200}}
-elif {$1==2} --s[-1] c -fx_dog[-1] 0.4,0,0,0,0
-negate[-2]  -fx_dog[-3] 0.4,0,0,0,0
-fx_compose_alpha[-1,-2] 0.44,0
-fx_compose_alpha[-1,-2] 0.44,0
-tk_fx_channel_processing[-1] 1,{$2/20},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==3} --luminance[-1]
-tk_fx_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==4} --luminance[-1] -negate[-1]
-tk_fx_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==5}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-$2}
-elif {$1==6}
--fx_radial_gradient[-1] 0,0,0,255,255,255,255,255,1,$2,100,50,50
-elif {$1==7}
--fx_radial_gradient[-1] 0,0,0,255,255,255,255,255,0,0,{100-$2},50,50
-elif {$1==8}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,0,$2,100
-elif {$1==9}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,315,$2,100
-elif {$1==10}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,0,{100-$2}
-elif {$1==11}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,45,0,{100-$2}
-elif {$1==12}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/2}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==13}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,180,100,{50+{$2/2}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,{50-{$2/2}},0
-compose_darken[-1,-2]
-elif {$1==14}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,50,{100-{$2/2}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,270,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==15}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/2}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==16}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/2}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==17}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/4}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/4}}
-compose_lighten[-1,-2]
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==18}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/4}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/4}}
-compose_lighten[-1,-2]
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/4}}
-compose_lighten[-1,-2]
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,270,50,{100-{$2/4}}
-compose_lighten[-1,-2]
-elif {$1==19} --channels[-1] 0
-tk_fx_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
--fx_radial_gradient[-1] 0,0,0,255,255,255,255,255,1,$2,100,50,50
-rv[-1,-2] -compose_multiply[-1,-2]
-elif {$1==20}
--fx_gaussian_blur[-1] $6,0,0,1,0,0,0
-fx_edges[-1] {$4/2},{50-{$2/2}},1,0
--fx_gradient_norm[0] {$4/2},{1.5-{$2/67}},0,{100-$2},0,0
-rv[-1,-2] -compose_lighten[-1,-2] --channels[0] 0
-tk_fx_channel_processing[-1] 1,{{$2/25}+1},0,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -compose_lighten[-1,-2]
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/4}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/4}}
-compose_lighten[-1,-2]
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/2}}
-compose_lighten[-1,-2] -rv[-1,-2] -compose_lighten[-1,-2]
-elif {$1==21} --fx_gaussian_blur[-1] $4,0,0,1,0,0,0
-fx_edges[-1] {$4/2},{50-{$2/2}},1,0
--fx_gradient_norm[0] {$4/2},{1.5-{$2/67}},0,{100-$2},0,0
-rv[-1,-2] -compose_lighten[-1,-2] --channels[0] 0
-tk_fx_channel_processing[-1] 1,{{$2/25}+0.5},0,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -compose_lighten[-1,-2]
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,0,{100-$2}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,0,{100-$2}
-compose_darken[-1,-2] -rv[-1,-2] -compose_darken[-1,-2]
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,75,{100-{$2/4}}
-rv[-1,-2] -fx_compose_lighten[-1,-2] 0.5
-elif {$1==22} --fx_gaussian_blur[-1] $4,0,0,1,0,0,0
-fx_edges[-1] {$4/2},{50-{$2/2}},1,0
--fx_gradient_norm[0] {$4/2},{1.5-{$2/67}},0,{100-$2},0,0
-rv[-1,-2] -compose_lighten[-1,-2] --channels[0] 0
-tk_fx_channel_processing[-1] 1,{{$2/25}+0.5},0,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -compose_lighten[-1,-2]
-elif {$1==23} --channels[-1] 0
-tk_fx_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==24} --fc[-1] 0,0,0
-endif
# analyze image features
-if {$7!=0}
--fc[0] 128,128,128 --channels[0] 2 -negate[-1] -c[-1] 0,90
-n[-1] 0,128 -rv[-1,-2] -compose_darken[-1,-2]
--channels[0] 0 -negate[-1] -c[-1] 165,255 -n[-1] 128,255 -rv[-1,-2]
-compose_hardlight[-1,-2] -rv[-1,-2]
-if {$1!=19} -fx_compose_average[-1,-2] {$7/5}
-else -fx_compose_value[-1,-2] {$7/5},0
-tk_fx_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-endif -endif
-if {$6!=0} --fx_highpass[0] 2,2,0,0,0
-tk_fx_replace_color[-1] 5,0,128,128,128,255,0,0,0,255
-fx_morpho[-1] 3,70,0,0,0,1,0   -to_gray[-1] av={ia}
-ir[-1] $av,255 -n[-1] 0,255 -blur_xy[-1] 25
-rv[-1,-2] -fx_compose_overlay[-1,-2] {$6/5} -endif
-if {$3!=0} --fx_isophotes[0] {{$3*3}+2},0,0,0
-fx_morpho[-1] 3,{5-{$3/2}},0,0,0,1,0
-tk_fx_channel_processing[-1] 1,1,255,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -fx_compose_overlay[-1,-2] {$3/10}
--fx_gradient_norm[0] {$4*2},{1.5-{0.1+{$3/3.6}}},0,100,0,0
-rv[-1,-2] -compose_lighten[-1,-2] -fx_segment_watershed[-1] $3,$4,0,0
-endif
-blur_y[-1] $10 -blur_x[-1] {$10/2}
-if {$5!=0} --luminance[0] -fx_map_tones[-1] 1,{0.25-{$5/20}},0,30,3,0
-rv[-1,-2] -fx_compose_overlay[-1,-2] {$5/10} -endif
-n[-1] 0,255 -rm[0] -resize2dx $size1,2 -endl -done
#@gui Depth Map Reconstruction : fx_tk_depth_obtain, fx_tk_depth_obtain(1)
#@gui : note = note("This filter estimates a depth map from the left and the right view of a stereoscopic image. Images must be aligned correct to compute correct depth information.")
#@gui : Flip Left/Right = bool(0)
#@gui : Smoothness = float(0.1,0,1)
#@gui : Center Size = float(100,0,100)
#@gui : Center Smoothness = float(0,0,50)
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>       Latest update: <i>2012/04/09</i>.</small>")
fx_tk_depth_obtain :
-if {$!<=1} -return -endif
-l
-to_rgb size1={w} size2={h} -resize2dx 400,2
-if {$1==1} -rv -endif
-if {$3!=100}
-fx_frame_round 10,{100-$3},$4,0,255,255,255,255,0,0.1,3
-endif
-displacement[0] [1],$2
-rm[1]
-channels 0
-n 0,255
-r $size1,$size2 -endl
#@gui Lenticular Print : fx_tk_lenticular, fx_tk_lenticular(1)
#@gui : sep = separator()
#@gui : Lenticular Density Lpi = float(30,5,200)
#@gui : Lenticular Orientation = choice("vertical","horizontal")
#@gui : Print Size Width = float(5,1,50)
#@gui : Print Size Unit = choice("inch","centimeter")
#@gui : Print Adjustment Marks = bool(1)
#@gui : Automatic Upscale for Optimum Results = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2011/10/06</i>.</small>")
fx_tk_lenticular :
-if {$!<=1} -return -endif
frames={$!} index=0 -if {$4==0} length=$3 -else length={$3/2.54} -endif
lenses={$length*$1} lensewidth={w/$lenses}
picstripe={$lensewidth/$frames} x=0 y=0 end={$picstripe}
step={$lensewidth-$picstripe}
#automatic upscale
-if {$6==1}
-if {$picstripe!={int($picstripe)}} scale={{int($picstripe)+1}/$picstripe}
-r {w*$scale},{h*$scale} lensewidth={w/$lenses} picstripe={$lensewidth/$frames}
end={$picstripe} step={$lensewidth-$picstripe} -endif -endif
-to_rgb --fc[-1] 255,255,255 -repeat $lenses
-if {$2==0}
-fill[-1] if(x>=$end,0,i) x={$x+$step} end={$end+$step}
-fill[-1] if(x>=$end,255,i) x={$x+$picstripe} end={$end+$picstripe}
-else
-fill[-1] if(y>=$end,0,i) y={$y+$step} end={$end+$step}
-fill[-1] if(y>=$end,255,i) y={$y+$picstripe} end={$end+$picstripe}
-endif -done
-repeat {$frames-1} --to_gray[-1] -ir[-1] 128,256 -n[-1] 0,255
-if {$2==0} -shift[-1] {{$picstripe}*{$frames-{$index+1}}}
-else -shift[-1] 0,{{$picstripe}*{$frames-{$index+1}}} -endif
-s[$index] c -a[$index,{$index+1},{$index+2},-1] c
index={$index+1} -done
-repeat {$frames-1} -rv[0,-2] -compose_rgba[0,-2] -rv[0,-2] -done
-if {$5==1} -to_rgba[0]
-if {$2==0} -shift[0] 0,5 -else -shift[0] 5,0 -endif
-negate[-1] -rv -compose_rgba -else -rm[-1] -endif
#@gui Single Image Stereogram : fx_tk_stereogram, fx_tk_stereogram_preview(1)
#@gui : sep = separator()
#@gui : Deviation = float(50,0,200)
#@gui : sep = separator(), note = note("Pattern generator")
#@gui : Pattern Variation 1 = float(0.5,0,1)
#@gui : Pattern Variation 2 = float(10,0,20)
#@gui : Pattern Variation 3 = float(0,0,1)
#@gui : Tiles = int(40,10,100)
#@gui : Color 1 = color(255,255,0)
#@gui : Color 2 = color(255,0,0)
#@gui : Color 3 = color(0,255,0)
#@gui : Color 4 = color(0,0,255)
#@gui : Color Strength = float(0.5,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2012/25/02</i>.</small>")
#@gui : note = note("Input image should be a <b>depth map</b> which is turned into an autostereogram, also known as magic eye image")
#@gui : note = link("Background explained here","http://en.wikipedia.org/wiki/Autostereogram")
fx_tk_stereogram :
-repeat $! -l[$>] -to_gray --fc[-1] 255,255,255
-fx_plasma[-1] $2,$3,8,0,0,128,128,128
-fx_array[-1] 10,10,0,0,0,0
-fx_array_fade[-1] {$5/10},{$5/10},0,0,80,90,3,0
-r[-1] [0],[0]
-fx_noise[-1] {w/30},0,3,0,0
--fx_rorschach[-1] $4,1,0 -rv[-1,-2] -fx_compose_multiply[-1,-2] 0.5
--fx_corner_gradient[-1] $6,$7,$8,255,$9,$10,$11,255,$12,$13,$14,255,$15,$16,$17,255
-rv[-1,-2] -fx_compose_hardlight[-1,-2] $18
-rv[-1,-2]
-r[-1] 100%,100%,1,2
-s[-1] c -f[-1] 0 -n[-2] 0,$1 -a[-1,-2] c
-warp[-2] [-1],1
-rm[-1] -endl -done
fx_tk_stereogram_preview :
-gui_split_preview "-fx_tk_stereogram ${1--2}",$-1
#@gui Stereoscopic Image Alignment : fx_tk_stereoimage, fx_tk_stereoimage(1)
#@gui : sep = separator()
#@gui : Mode = choice("Anaglyph red/cyan","Anaglyph red/cyan optimized","Anaglyph blue/yellow","Anaglyph blue/yellow optimized","Anaglyph green/magenta","Anaglypgh green/magenta optimized","Full side by side keep width","Full side by side keep uncompressed","Full bottom/top","Half side  by side","Half bottom/top","Interlace horizontal","Interlace vertical","Full HD frame packing")
#@gui : Flip Left / Right = bool(0)
#@gui : Gamma Compensation = float(1,0,4)
#@gui : Anti-Ghosting = float(0,0,255)
#@gui : Color Boost = float(1,0,4)
#@gui : Anaglyph Glasses Adjustment = float(0,-100,100)
#@gui : sep = separator()  note = note("This filter needs two aligned input images.")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>     Latest update: <i>2012/04/08</i>.</small>")
fx_tk_stereoimage :
-if {$!<=1} -return -endif
-local -to_rgb
-if {$4!=0} -tk_fx_channel_processing 1,1,$4,0,0,0,100,256,0,0,1,10,7,0 -endif
-if {{$1==0}||{$1==1}||{$1==2}||{$1==3}||{$1==4}||{$1==5}} -apply_gamma $3 -endif
-if {$1==0} -if {$2==0} -rv[-1,-2] -endif -s c
-rm[-3,-4,-5] -a[-1,-2,-3] c
-elif {$1==1} -if {$2==1} -rv[-1,-2] -endif
-apply_gamma[-1] 1.15 -apply_gamma[-2] 1.0 -s c
rlr=456 rlg=500 rlb=176 rrr={-43} rrg={-88} rrb={-2}
glr={-40} glg={-38} glb={-16} grr=378 grg=734 grb={-18}
blr={-15} blg={-21} blb={-5} brr={-72} brg={-113} brb=1226
[0-5]
-*[-3] $rlr -*[-2] $rlg -*[-1] $rlb -*[-6] $rrr -*[-5] $rrg -*[-4] $rrb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $glr -*[-2] $glg -*[-1] $glb -*[-6] $grr -*[-5] $grg -*[-4] $grb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $blr -*[-2] $blg -*[-1] $blb -*[-6] $brr -*[-5] $brg -*[-4] $brb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
-k[-1--3] -a[-1,-2,-3] c
-elif {$1==2} -if {$2==0} -rv[-1,-2] -endif -s c
-rm[-6,-5,-1] -mv[0] 3  -a[-1,-2,-3] c
-elif {$1==3} -if {$2==1} -rv[-1,-2] -endif
-apply_gamma[-1] 0.9 -apply_gamma[-2] 1.25 -s c
rrr=1062 rrg={-205} rrb=299 rlr={-16} rlg={-123} rlb={-17}
grr={-26} grg=908 grb=68 glr=6 glg=62 glb={-17}
brr={-38} brg={-173} brb=22 blr=94 blg=185 blb=911
[0-5]
-*[-3] $rlr -*[-2] $rlg -*[-1] $rlb -*[-6] $rrr -*[-5] $rrg -*[-4] $rrb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $glr -*[-2] $glg -*[-1] $glb -*[-6] $grr -*[-5] $grg -*[-4] $grb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $blr -*[-2] $blg -*[-1] $blb -*[-6] $brr -*[-5] $brg -*[-4] $brb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
-k[-1--3] -a[-3,-2,-1] c
-elif {$1==4} -if {$2==0} -rv[-1,-2] -endif  -s c
-rm[-1,-3,-5] -mv[-1] -2 -a[-3,-2,-1] c
-elif {$1==5} -if {$2==1} -rv[-1,-2] -endif  -s c
-apply_gamma[-1] 1 -apply_gamma[-2] 1.15 -s c
rrr={-62} rrg={-158} rrb={-39} rlr={529} rlg={705} rlb={24}
grr={284} grg=668 grb=143 glr={-16} glg={-15} glb={-65}
brr={-15} brg={-27} brb=21 blr=9 blg=75 blb=937
[0-5]
-*[-3] $rlr -*[-2] $rlg -*[-1] $rlb -*[-6] $rrr -*[-5] $rrg -*[-4] $rrb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $glr -*[-2] $glg -*[-1] $glb -*[-6] $grr -*[-5] $grg -*[-4] $grb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $blr -*[-2] $blg -*[-1] $blb -*[-6] $brr -*[-5] $brg -*[-4] $brb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
-k[-1--3] -a[-3,-2,-1] c
-elif {$1==6} -if {$2==1} -rv[-1,-2] -endif
-r[-1,-2] 50%,50%,1,3,6 -a[-1,-2] x
-elif {$1==7} -if {$2==1} -rv[-1,-2] -endif -a[-1,-2] x
-elif {$1==8} -if {$2==1} -rv[-1,-2] -endif -a[-1,-2] y
-elif {$1==9} -if {$2==1} -rv[0,1] -endif
-r[0,1] 50%,100%,1,3,6 -a[0,1] x
-elif {$1==10} -if {$2==1} -rv[0,1] -endif
-r[0,1] 100%,50%,1,3,6 -a[0,1] y
-elif {$1==11} -to_rgba[0,1]
-if {$2==1} -rv[0,1] -endif
-fill[0] if(y%2==0,0,i) -rv[0,1] -compose_rgba[0,1] -to_rgb
-elif {$1==12} -to_rgba[0,1]
-if {$2==1} -rv[0,1] -endif
-fill[0] if(x%2==0,0,i) -rv[0,1] -compose_rgba[0,1] -to_rgb
-elif {$1==13}
-if {$2==1} -rv[0,1] -endif
-r[0,1] 1920,1080,1,3,6 --fc[-1] 0,0,0 -r[-1] 1920,45
-rv[-1,-2] -a[-1,-2] y -a[-1,-2] y
-endif -c 0,255
-if {{$1==6}||{$1==7}||{$1==8}||{$1==9}||{$1==10}||{$1==11}||{$1==12}||{$1==13}}
-apply_gamma $3 -endif
-fx_mix_lab 1,0,0,$5,0,0,$5,0,0,0,2,0
-if {{$1==0}||{$1==1}} -fx_mix_rgb 1,$6,0,1,0,0,1,0,0,0,2,0 -endif
-if {{$1==2}||{$1==3}} -fx_mix_rgb 1,0,0,1,0,0,1,$6,0,0,2,0 -endif
-if {$1==4} -fx_mix_rgb 1,0,0,1,$6,0,1,0,0,0,2,0 -endif
-if {$1==5} -fx_mix_rgb 1,0,0,1,$6,0,1,{if({$6>=0},$6,0)},0,0,2,0 -endif
-endl
#@gui Stereo Image : gcd_stereo_img, gcd_stereo_img(1)
#@gui : note = note("<u>Create a 3D image from a flat one</u>")
#@gui : note = note("\n<i>3D Options</i>"), sep = separator()
#@gui : 3D Image Type = choice("Anaglyph: Red/Cyan","Side by Side","Depth Map","Inverse Depth Map")
#@gui : Balance Color = float(0.5,0,1)
#@gui : Depth = float(1.2,0,3)
#@gui : Distance = float(1,-2,2)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Despeckle = bool(1)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Auto Crop = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/07/02</i>.</small>")
gcd_stereo_img : -skip ${1=0},${2=2},${3=1.2},${4=1},${5=0.25},${6=2},${7=4},${8=1},${9=0}
-repeat $! -l[$>]
-to_rgb[0] b={abs($3%*w*$4)}
--gcd_depth[0] $5,$6,$7,$8
-gcd_stereo[0,1] $1,$2,$3%,$4
-if {!$1" && "$9} -z[-1] $b,{w-1-$b} -endif
-endl -done
gcd_depth : -skip ${1=0.25},${2=2},${3=4},${4=1}
-repeat $! -l[$>]
-if {w>h} -if {w>700} --r[-1] 700,{h*700/w} -else [0] -endif
-elif {0,h>700} --r[-1] {0,w*700/h},700 -else [0] -endif
-median[-1] 7 -gcd_segment_ch0[-1] 1
-if $4 -gcd_label[-1] $3 -else -label[-1] $3,1 -endif
-c[-1] 0,255 -b[-1] 0.45% -n[-1] 0,$2 -r[-1] [0],[0]
-norm[0] -n[0] 0,1 -+[-2,-1] -b[-1] $1% -n[-1] 0,255
-endl -done
gcd_segment_ch0 : -check "${1=1}>=0"
-repeat $! -l[$>]
min={im} -+ {1+$min} --gradient_norm -channels[0] 0
--f[-1] "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
-*[0,-1] -*[-1] -1 -watershed[-2] [-1] -rm[-1] -- {1+$min}
-endl -done
gcd_stereo : -skip ${1=0},${2=1},${3=1.2%},${4=1}
-l[-2,-1]
-if {$1==2} -keep[-1] -return
-elif {$1==3} -keep[-1] -negate -return -endif
wfac={if(${"-is_percent $3"},$3*w,$3)} -n[-1] 0,$wfac
-if {$1<2" && "$2>0} -gcd_balance_anaglyph[0] {2-$2} -endif
-i[1] [0] -warp[0] [-1],1 -mul[-1] -1 -warp[1] [-1],1 -rm[-1]
-if $1 -rv[0,1] -append[0,1] x -else -shift[0] {round(-$wfac*$4)} -shift[1] {round($wfac*$4)}
-channels[0] 0 -channels[1] 1,2 -append[0,1] c
-endif
-endl
gcd_balance_anaglyph : -skip ${1=1},${2=0.43},${3=0.45}
-l[-1] -sh 0,0 -sh[0] 1,1 -sh[0] 2,2 ---[2] [1] inv={255^(1-$1)*$2}
-if {$1>1} --sign[-1] -abs[-2] -^[-2] $1 -*[-2] $inv -*[-2,-1] -else -*[-1] $2 -endif
--[2,3] [-1] -*[-1] {1/$2-1} -+[1,-1] --*[3] 0.65 --[-1] [1] -max[-1] 0 -*[-1] $3
--[3] [-1] -*[-1] {1/$3-1} -+[1,-1] -apply_gamma[1] 1.15 -rm[1-3] -c 0,255
-endl
#@gui Undo Anaglyph : gcd_unstereo, gcd_unstereo_preview(1)
#@gui : note = note("<u>Attempt to revert red/cyan anaglyph to 2D</u>")
#@gui : note = note("<b>Warning: with high precision or large image this can be VERY slow!</b>")
#@gui : note = note("\n<i>Displacement Settings</i>"), sep = separator()
#@gui : Precision = float(5,1,6)
#@gui : Smoothness = float(0.1,0,1)
#@gui : Horizontal Warp Only = bool(1)
#@gui : Fast (Low Precision) Preview = bool(1)
#@gui : note = note("\n<i>Tile Settings</i>"), sep = separator()
#@gui : Horizontal Tiles = int(1,1,8)
#@gui : Vertical Tiles = int(1,1,8)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/10/26</i>.</small>")
gcd_unstereo : -skip ${1=5},${2=0.1},${3=0},${4=1},${5=1},${6=1},${7=0},${8=0}
-repeat $! -l[$>]
-if {$4" && "$8} pr=1 -else pr=$1 -endif
-to_rgb[0] -split_tiles[0] $5,$6
-repeat $! -l[$>]
-s[0] c --equalize[0,1] 256
--displacement[-2] [-1],$2,$pr
-if $3 -sh[-1] 1,1 -f[-1] 0 -rm[-1] -endif
-/[-1] 2 -warp[1,2] [-1],1 -*[-1] -1 -warp[0] [-1],1
-keep[0-2] -a c -c[0] 0,255
-endl -done
-append_tiles $5,$6
-endl -done
gcd_unstereo_preview :
-gui_split_preview "-gcd_unstereo ${1--1},1",$-1
#@gui _
#@gui <b>Testing</b>
#@gui <i>Afre</i>
#@gui Gamify : fx_gamify, fx_gamify_preview(1)
#@gui : Lightness = int(50,50,60)
#@gui : Chroma = float(2,1.1,5)
#@gui : sep = separator(), Normalize = bool(1)
#@gui : Contrast = float(1,1,1.5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("Filter by <i>afre</i>. Latest update: <i>2017-01-05</i>.")
fx_gamify :
-if $3 -n 0,255 -endif
-rgb2lab -lab2lch
-s c -n... $1,100 -*.. $2 -a c
-lch2lab -lab2rgb
-split_details 2
-l.. -adjust_colors 0,{-$4/1.5*20} -endl
-*. $4
-+ -c 0,255
fx_gamify_preview :
-gui_split_preview "-fx_gamify $*",$-1
#@gui Hessian Norm : fx_hnorm, fx_hnorm_preview(0)
#@gui : Strength = float(1,.5,1.5)
#@gui : Contrast = int(50,1,99)
#@gui : Invert = bool(0)
#@gui : sep = separator(), note = note("Filter by <i><a href="https://discuss.pixls.us/u/afre">afre</a></i>. Latest update: <i>2018-05-09</i>.")
fx_hnorm :
af_hnorm ^ $1
c 0,$2%
if $3 negate fi
n 0,255
af_hnorm:
repeat $! l[$>]
+hessian[0] xx +hessian[0] xy +hessian[0] xz +hessian[0] yy +hessian[0] yz hessian[0] zz
sqr + s c + sqrt
endl done
fx_hnorm_preview :
fx_hnorm $*
#@gui Vigrect : fx_vigrect, fx_vigrect_preview(1)
#@gui : Size(%) = int(10,1,25)
#@gui : Blur(%) = int(10,5,20)
#@gui : Opacity = float(.75,.5,1)
#@gui : sep = separator(), note = note("Filter by <i>afre</i>. Latest update: <i>2017-01-05</i>.")
fx_vigrect :
p={min(w,h)*$1/100}
--to_gray -rectangle. {[$p,$p,w-$p,h-$p]}
-f. i==0?0:ia#0 -b. {min(w,h)*$2/100} -*. $3 -- -c 0,255
fx_vigrect_preview :
-fx_vigrect $*
#@gui _
#@gui <i>Chris from Pixls.Us</i>
#@gui Remove Scratches : fx_remove_scratches, fx_remove_scratches_preview(0)
#@gui : note = note("<small><b>Note:</b> Scratch removal for scanned film images</small>")
#@gui : sep = separator()
#@gui : Threshold = float(72,0,100)
#@gui : Erosion = int(2,0,5)
#@gui : Dilation = int(4,0,7)
#@gui : Show Preview After = choice(3,"Threshold","Erosion","Dilation","Final image")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Chris/Pixls.us</i>.      Latest update: <i>2017/04/01</i>.</small>")
_fx_remove_scratches :
repeat $! l[$>] to_rgba
sh 0,2
sh.. 3
<. {$1*255%}
if {$4>=1} erode. $2 fi
if {$4>=2} dilate. $3 fi
if {$4<3} k... channels 3 * 255
else inpaint_matchpatch.. . k... channels 0,2
fi
endl done
fx_remove_scratches :
_fx_remove_scratches ${1-3},3
fx_remove_scratches_preview :
gui_split_preview "_fx_remove_scratches $*",$-1
#@gui _
#@gui <i>Corvo</i>
#@gui Corvo's Painting 5 : fx_corvo_painting_5, fx_corvo_painting_5(0)
#@gui : note = note("Polygonize settings")
#@gui : Amplitude = int(35,0,2000)
#@gui : Smoothness = float(10,0,100)
#@gui : Minimal Area = float(10,0,100)
#@gui : Alpha Polygonize = float(0.5,0,1)
#@gui : sep = separator()
#@gui : Texture = float(50,0,100)
#@gui : Plasma = float(0.3,0,1)
#@gui : sep = separator()
#@gui : note = note("Smooth settings")
#@gui : Amplitude = float(50,0,1000)
#@gui : Gradient Smoothness = float(2,0,10)
#@gui : Tensor Smoothness = float(5,0,10)
#@gui : Alpha Filter = float(1,0,1)
fx_corvo_painting_5 :
--polygonize $1,$2,$3,10,10
--blend[0,1] alpha,$4
-texturize_canvas[2] $5,0.5,0.6
-smooth[2] $7,0.4,0.7,$8,$9
--plasma[2] 0.7,100,8 n 0,255
-blend[3,2] grainmerge,$6
-bilateral[0,2] 10,7
-blend[0,2] alpha,$10
rm.
#@gui _
#@gui <i>Deprecated</i>
#@gui Morphological Filter (Deprecated) : fx_morpho, fx_morpho_preview(0)
#@gui : Action = choice("Erosion","Dilation","Opening","Closing",
#@gui : "Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gui : Size = int(5,2,60)
#@gui : Negative = bool()
#@gui : Shape = choice(0,"Square","Octagonal","Circular")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Stretch")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2014/06/08</i>.</small>")
fx_morpho :
ac "-__fx_morpho ${^0}",$5,$6
fx_morpho_preview :
gui_split_preview "fx_morpho ${^0}",$-1
__fx_morpho :
if {$4==1} suf="_oct" elif {$4==0} suf="" else suf="_circ" fi
if {$1==0} erode$suf $2
elif {$1==1} dilate$suf $2
elif {$1==2} erode$suf $2 dilate$suf $2
elif {$1==3} dilate$suf $2 erode$suf $2
elif {$1==4} repeat $! +erode$suf $2 -[-2,-1] mv. 0 done
elif {$1==5} repeat $! +dilate$suf $2 rv[-2,-1] -[-2,-1] mv. 0 done
elif {$1==6} repeat $! +erode$suf $2 dilate$suf. $2 -[-2,-1] mv. 0 done
else repeat $! +dilate$suf $2 erode$suf. $2 rv[-2,-1] -[-2,-1] mv. 0 done
fi
if $3 repeat $! l[$>] split_opacity negate[0] a c endl done fi
#@gui _
#@gui <i>Garagecoder</i>
#@gui Blend [Feather] : gcd_blend_feather, gcd_blend_feather(1)
#@gui : note = note("<u>Overlay layers seamlessly by feathering edges</u>")
#@gui : note = note("<small>1. Set Input layers to <b>Active &amp; below</b> for two layers</small>")
#@gui : note = note("<small>2. For best results ensure layers are the same size</small>")
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Max Delta = int(100,0,200)
#@gui : Color Transfer = float(0.5,0,1)
#@gui : Hue Extent = float(2,0,6)
#@gui : Remove BG = int(0,0,20)
#@gui : Keep Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/05/05</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Remove BG can help mask off unwanted areas, which works</small>")
#@gui : note = note("<small>best on objects surrounded by simple backgrounds.</small>")
#@gui : note = note("<small>Overlaying a larger area can sometimes improve the output.</small>")
gcd_blend_feather : -skip ${1=100},${2=0.5},${3=2},${4=0},${5=0}
-r[^-1] [-1],[-1],1,100%,0,0,0.5,0.5
-if $5
--gcd_blend_maxdelta ${1-4}
-to_a[0] -split_opacity[0] -rv[1,-1] -a[1,-1] c -rm[0]
-else -gcd_blend_maxdelta ${1-4} -endif
gcd_blend_maxdelta : -skip ${1=100},${2=0.5},${3=2},${4=0}
-if {$!>1} -repeat {$!-1} -l[0,1]
-to_a -split_opacity -/[1,3] 255
-nm[0] upper -nm[1] alpha -nm[2] lower -nm[3] mask
--r[lower] 1,1,1,100%,2
--+[upper] 0.1 -*[-1] [alpha]
-s[-1] c -discard[-3--1] 0 -a[-3--1] c
-r[-1] 1,1,1,100%,2 -r[-2,-1] [upper]
-*[-2,-1] $2 -sub[upper,-1] -add[upper,-1] -c[upper] 0,255
--distance[alpha] 0 -nm[-1] dist
-eq[mask] 0 -*[mask] {dist,iM} -max[dist] [mask]
-if {$4>0}
[upper] [alpha] -a[-2,-1] c
-gcd_fgmask[-1] {20-$4} -b[-1] 3 -*[alpha,-1]
-endif
--n[dist] 0,$3 -c[-1] 0,1 -*[-1] [alpha]
-gcd_srgb2jpeg[upper,lower] -sh[upper,lower] 1,2
-j[-1] [-2],0,0,0,0,1,[-3] -rm[-3--1]
-gcd_jpeg2srgb[upper,lower]
-n[dist] 0,{255*$1%}
--sub[upper] [lower] -*[-1] [alpha]
--sign[-1] -abs[-2] -min[dist,-2] -*[dist,-1]
-+[lower] [dist] -k[lower] -c 0,255
-endl -done -endif
gcd_fgmask : -skip ${1=0}
-repeat $! -l[$>]
-to_a -expand_xy 20,0 -split_opacity -gt[-1] 0
--distance[-1] 0 -max_patch[-1] 3 -*[-1] 2
--erode[1] 20 -*[-2,-1] -dilate[-1] $1
--gradient_norm[-2] -gt[-1] 0
-gradient_norm[0] --eq[-1] 0 -*[0,-1]
-max[-2,-1] -*[0,1] -*[0] -1
-watershed[-1] [-2] -rm[-2]
-shrink_xy 20 -- 1
-endl -done
#@gui CRMT Tiles : fx_gcd_crmt_tile, fx_gcd_crmt_tile(1)
#@gui : note = note("<i>Tiling by Clone, Rotate, Mirror, Translate method.</i>"), sep = separator()
#@gui : Constants = text{"t_w=[w] t_h=[round(1/2*sqrt(3)*$t_w)]"}
#@gui : Image Size = text("[3*$t_w,2*$t_h]")
#@gui : Command List = text{1,"C0 T0 C0 Fo R-60 T[-1/2*$t_w,0]"}
#@gui : Inpaint = bool(0)
#@gui : sep = separator(), note = note("<small>Implementation : <i>Garagecoder</i>.     Latest update : <i>2018/12/06</i>.</small>")
#@gui : note = note("<small>Author: <i>G. Bachelier</i></small>")
#@gui : note = note("\n<b>Warning</b>: alpha version, don't expect perfection!")
fx_gcd_crmt_tile :
m "_crmt_tile_C : [$""1]"
m "_crmt_tile_R : rotate. $""1 autocrop."
m "_crmt_tile_Fo : mirror. x"
m "_crmt_tile_Fi : mirror. y"
({'"_crmt_tiling_command : $1 {``$2},1,4 $3"'})
replace_str. "C","_crmt_tile_C "
replace_str. "Fo","_crmt_tile_Fo "
replace_str. "Fi","_crmt_tile_Fi "
replace_str. "R","_crmt_tile_R "
replace_str. "T","_crmt_tile_T "
replace_str. "[","{["
replace_str. "]","]}"
m {t}
rm.
repeat $! l[$>]
_crmt_tiling_command k[1]
if $4
+channels[0] 100% negate. dilate. 3
inpaint[0] .,0,0 rm.
fi
endl done
uncommand _crmt_tiling_command
_crmt_tile_T : skip ${1=0},${2=0}
f. ':i3>0?I(#1,$1+x,$2+y)=I;i' rm.
#@gui Cumulative Math : fx_gcd_cumul_math, fx_gcd_cumul_math_preview(1)
#@gui : note = note("<i>Cumulative Math glitch filter</i>"), sep = separator()
#@gui : Operation = choice(0,"Add","Or","Xor","And","Mod")
#@gui : Amount = int(1,1,512)
#@gui : Step = int(1,1,256)
#@gui : Horizontal = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/18</i>.</small>")
fx_gcd_cumul_math : skip ${1=0},${2=1},${3=1},${4=0}
op=${arg\ 1+$1,"add","or","xor","and","mod"}
ac "gcd_cumul_math $2,$3,"$op",$4",rgb replace_nan 255
gcd_cumul_math : skip ${1=1},${2=1},${3="add"},${4=0}
repeat $! l[$>]
100%,100%,100%,1,1 (0,$2) if $4 z. 1,1 fi
+mul. $1 shift[1] {^} rm. m={^} rm. [0]
repeat $1 +shift. $m +mul. [1] $3[0,-1] rm.. done k[0] mod 256
endl done
fx_gcd_cumul_math_preview :
gui_split_preview "fx_gcd_cumul_math ${1--2}",$-1
#@gui Deblur Texture : fx_gcd_blur_deblur_texture, fx_gcd_blur_deblur_texture_preview(0)
#@gui : note = note("<i>Variance-based edge preserving deblur or smooth</i>"), sep = separator()
#@gui : Iters = int(4,1,20)
#@gui : Sigma = float(1,0,4)
#@gui : Edges = float(0.5,0,1)
#@gui : Action = choice("Deblur","Smooth")
#@gui : Channels = choice(2,"RGB","Linear RGB","Luma","Chroma")
#@gui : Percentage Sigma = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/09/02</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Iters: overall amount, increases computation time.</small>")
#@gui : note = note("<small>Sigma: detail scale.</small>")
#@gui : note = note("<small>Edges: amount of edge preservation.</small>")
#@gui : note = note("<small>Percentage sigma: make detail scale relative to image size.</small>")
fx_gcd_blur_deblur_texture : skip ${1=4},${2=1},${3=0.5},${4=0},${5=2},${6=0}
v - repeat $! l[$>]
mode=${-arg\ 1+$5,rgb,lrgb,ycbcr_y,ycbcr_cbcr}
if $6 r=$2% else r=$2 fi
if $4 ac "repeat $1 gcd_blur_texture "$r",$3 done",$mode,1
else ac "repeat $1 +l +gcd_blur_texture "$r",$3 norm sub endl add done",$mode,1 fi
endl done v +
fx_gcd_blur_deblur_texture_preview :
gui_split_preview "fx_gcd_blur_deblur_texture $*",${-3--1}
#@cli gcd_blur_texture : std_deviation>=0[%],0<=edge_exponent<=1
#@cli : Edge preserving smooth.
#@cli : Default values: 'std_deviation=1' and 'edge_exponent=1'.
#@cli : $ image.jpg gcd_blur_texture 1
gcd_blur_texture : skip ${1=1},${2=1}
e[^-1] "Apply blur texture filter of size $1, on image$?."
v - repeat $! l[$>]
[0] +sqr. b[-2,-1] $1 +sqr.. sub[-2,-1]
max. 0 +eq. 0 add[-2,-1] sqrt. pow. -$2
j[0] ..,0,0,0,0,1,. k[0]
endl done v +
#@gui Depth Blur : gcd_depth_blur, gcd_depth_blur(1)
#@gui : note = note("<u>Selectively blur based on estimated depth</u>")
#@gui : note = note("<small>Amount of blur applied is relative to luminance of the depth map</small>")
#@gui : note = note("\n<i>Focus Options</i>"), sep = separator()
#@gui : Distance Threshold = int(0,0,100)
#@gui : Blur Amount = int(15,0,100)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Create/View Depth Map = bool(0)
#@gui : Reverse Map = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/24</i>.</small>")
gcd_depth_blur : -skip ${1=0},${2=15},${3=0.25},${4=2},${5=4},${6=0},${7=1}
-repeat $! -l[$>]
sa={$2*max(w,h)/1000}
-to_rgb[0]
--gcd_depth[0] $3,$4,$5
-if $7 -negate[-1] -endif
-threshold[-1] $1%,1 -n[-1] 0,255
-if $6 -keep[-1] -else
{w},{h},1,1,0 [-2] -a[-3--1] c
-smooth[-2] [-1],$sa,30,0 -rm[-1]
-c[-1] 0,255
-endif
-endl -done
#@gui Image InfoMap : gcd_infomap, gcd_infomap(1)
#@gui : note = note("<i>View images in various informational ways</i>"), sep = separator()
#@gui : Output = choice("Spectral tones","Detail map","JPEG CbCr detail","Local equality","Standard score")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/09/26</i>.</small>")
gcd_infomap :
-repeat $! -l[$>] -to_rgb
-if {$1>3} gcd_std_score_patch 3 n 0,255
-elif {$1>2}
--dilate 3 --erode.. 3 -eq[-2,-1] -compose_channels. min
-orientation.. -* -n 0,255
-elif {$1>1} -gcd_srgb2jpeg -channels 1,2 -equalize 256 -gcd_detail
-elif {$1} -gcd_detail -else -gcd_spectral -endif
-endl -done
gcd_detail :
-repeat $! -l[$>] --bilateral 2%,30 -norm -- -n 0,255 -endl -done
gcd_spectral :
-repeat $! -l[$>]
-to_rgb -gcd_srgb2luma -- 128
--max 0 --min[0] 0 -abs[^-2] -negate[0] -a c -n 0,255
-endl -done
gcd_std_score_patch : skip ${1=3}
repeat $! l[$>]
+gcd_variance_patch $1 sqrt.
+boxfilter.. $1 sub[0,-1] +eq. 0 add[-2,-1] div
endl done
gcd_variance_patch : skip ${1=3}
repeat $! l[$>] +sqr boxfilter $1 sqr.. rv sub max 0 endl done
#@gui Inverse Bezier Warp : gcd_ebwarp, gcd_ebwarp(1)
#@gui : note = note("<i>Horizontal inverse conformal bezier warp</i>"), sep = separator()
#@gui : Mid = float(0.5,0,1)
#@gui : End = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/02/06</i>.</small>")
#@gui : note = link("http://benpaulthurstonblog.blogspot.co.uk/2015/12/ebezier.html")
gcd_ebwarp : -skip ${1=0.5},${2=1}
-repeat $! -l[$>]
b={w*$1*$2} c={w*$2} d={2*$c-4*$b}
e={(4*$b-$c)/(2*$d)} se={sqr($e)}
{w},{h},1,1,x
-if {$1==0.5} -*. {1/$c} -else
-/. $d -+. $se
-if {$1>1} -abs. -endif
-sqrt.
-if {$1>0.5} -*. -1 -endif
--. $e
-endif
-*. {w} {w},{h},1,1,y -a[^0] c
-warp[0] [-1],0,2,0 -rm. -c 0,255
-endl -done
#@gui Layer Manipulation : gcd_layers, gcd_layers_preview(1)
#@gui : note = note("\n<i>Transform</i>"), sep = separator()
#@gui : Scale = float(100,1,200)
#@gui : Angle = int(0,-90,90)
#@gui : Reduce Only (Requires Two Layers) = bool(1)
#@gui : note = note("\n<i>Position</i>"), sep = separator()
#@gui : CentreX = float(0,-50,50)
#@gui : CentreY = float(0,-50,50)
#@gui : note = note("\n<i>Edges</i>"), sep = separator()
#@gui : Erode = float(0,0,50)
#@gui : Smooth = int(0,0,25)
#@gui : Curvature (Instead of Gaussian) = bool(0)
#@gui : note = note("\n<i>Layer</i>"), sep = separator()
#@gui : Opacity = float(1,0,1)
#@gui : Mode = choice{"Normal","Add","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Grain Extract","Grain Merge","Hard Light","Hue","Lighten",
#@gui : "Multiply","Overlay","Saturation","Soft Light","Screen","Subtract","Value"}
#@gui : Flip = choice("None","Horizontal","Vertical","Both")
#@gui : Match Lower Layer Size = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/06/05</i>.</small>")
#@gui : note = note("\n<small><b>Note:</b> preview is low quality for speed</small>")
gcd_layers : -skip ${1=100},${2=0},${3=1},${4=50},${5=50},${6=0},${7=0},${8=0},${9=1},${10=1},${11=0},${12=0},${13=0}
one={$!<2}
-l[${-arg\ 1+$one,0-1,0}]
-if {$3" && "!$one" && "$1>100} -r2dx. {w/$1%},{if($-1,2,6)} -c. 0,255 -endif
w={w} h={h} -gcd_force_a[0]
-l[0]
-if {$11} -mirror ${-arg\ $11,x,y,xy} -endif
-if {!$3" || "$one" || "$1<100} -r2dx {w*$1%},{if($-1,2,6)} -c 0,255 -endif
-if {$2} -split_opacity -rotate. $2,{2-($-1)} -rotate.. $2,{2-($-1)},1 -a c -c 0,255 -endif
-if {$6" || "$7}
-sh 100% --gt. 1 -expand_xy. 1,0 -distance. 0 -gt. {1+$6}% -shrink_xy. 1
-*. .. -if {$8" && "$7} -pde_flow. $7,30,iee,0 -max. 0 -endif -min[-2,-1] -rm.
-endif
-if {!$8" && "$7} -sh 100% -b. {$7/10}%,1,{!$-1} -rm. -endif
-endl
pos={round(($w-w#0)/2+$w*$4%)},{round(($h-h#0)/2-$h*$5%)}
-if {$-1" || "$12} -i[0] $w,$h,1,{0,s} -j[0] [1],$pos -rm[1] pos=""
-else pos=,pos($pos) -endif
mode=${-arg\ 1+$10,alpha,add,burn,darken,difference,\
divide,dodge,grainextract,grainmerge,hardlight,hue,lighten,\
multiply,overlay,saturation,softlight,screen,subtract,value}
-if {$-1} -if {$!>1} -rv -blend $mode,$9 -else -sh 100% -*. $9 -rm. -endif
-else -nm[0] mode($mode),opacity({$9*100})$pos -endif
-endl
gcd_layers_preview :
-gcd_layers $*,1
#@gui LMS Adjustment : gcd_balance_lms, gcd_balance_lms(1)
#@gui : note = note("<i>Chromatically adapt to a new illuminant</i>"), sep = separator()
#@gui : Long = float(1,0.5,1.5)
#@gui : Medium = float(1,0.5,1.5)
#@gui : Short = float(1,0.5,1.5)
#@gui : sep = separator()
#@gui : Adapt Luminance = bool(0)
#@gui : Pre Normalize = bool(0)
#@gui : Auto Balance = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/09/08</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>sRGB D65 input is assumed.</small>")
#@gui : note = note("<small>LMS sliders: control illuminant ratios.</small>")
#@gui : note = note("<small>Adapt Luminance: adjust luminance as well, may cause clipping.</small>")
#@gui : note = note("<small>Pre Normalize: stretch input RGB ranges to maximum.</small>")
#@gui : note = note("<small>Auto Balance: attempt to set neutral grey lighting.</small>")
gcd_balance_lms : skip ${1=1},${2=1},${3=1},${4=0},${5=0},${6=0}
repeat $! l[$>]
if $5 s c n 0,255 a c fi srgb2rgb rgb2xyz 1
mix_channels (0.7328,0.4296,-0.1624;-0.7036,1.6975,0.0061;0.0030,0.0136,0.9834)
if $6
m={[im,iM]} +r 1,1,1,100%,2 +n.. 0.002,0.998 log. gm={ia} +r. 1,1,1,100%,2
repeat {s#2} sh[2] $> *. {$gm/i[#3,$>]} rm. done
rm. exp. n. $m r. 1,1,1,100%,2 div[-2,-1]
else (1^1^1) fi
($1^$2^$3) n={L=$4?[0.454369,0.473533,0.072098]:[1,1,1];dot(L,I#1)/dot(L,I#2)}
repeat {s#1} sh[0] $> *. {$n*i[#2,$>]/i[#1,$>]} rm. done k[0]
mix_channels (1.096124,-0.278869,0.182745;0.454369,0.473533,0.072098;-0.009628,-0.005698,1.015326)
xyz2rgb 1 rgb2srgb
endl done
#@gui Multi Thresholds : tran_multi_threshold, tran_multi_threshold(1)
#@gui : note = note("<i>Apply color to selectable tones</i>"), sep = separator()
#@gui : Threshold 1 = int(50,0,255)
#@gui : Threshold 2 = int(100,0,255)
#@gui : Threshold 3 = int(150,0,255)
#@gui : Threshold 4 = int(200,0,255)
#@gui : 1st Color = color(9,0,1)
#@gui : 2nd Color = color(175,42,27)
#@gui : 3rd Color = color(101,101,101)
#@gui : 4th Color = color(174,165,131)
#@gui : 5th Color = color(247,228,160)
#@gui : sep = separator(), note = note("<small>Author : <i>trandoductin</i>.      Latest update : <i>2016/08/25</i>.</small>")
tran_multi_threshold : -skip ${1=50},${2=100},${3=150},${4=200}
-repeat $! -l[$>]
-split_opacity --rgb2ycbcr[0] -channels. 0 -fc[0] ${5-7}
--fc[0] ${8-10} --ge[-2] $1 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
--fc[0] ${11-13} --ge[-2] $2 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
--fc[0] ${14-16} --ge[-2] $3 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
--fc[0] ${17-19} --ge[-2] $4 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
-rm. -a c
-endl -done
#@gui PQCT Example : gcd_pqct, gcd_pqct(1)
#@gui : note = note("<i>Parameterized Quadratic Conformal transformation</i>")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/02/07</i>.</small>")
#@gui : note = note("\nBased on example code from:")
#@gui : note = link("http://benpaulthurstonblog.blogspot.co.uk/2015/12/parameterized-quadratic-conformal.html")
gcd_pqct :
-repeat $! -l[$>]
({w*.1},{h*.2};{w*.2},{h*.6};{w*.2},{h*.9};{w*.5},{h*.1};\
{w*.6},{h*.8};{w*.9},0;{w*.85},{h*.4};{w},{h*.75})
-transpose. 9,2,1,1
-repeat 2
-sh[2] $>,$>,0,0 -sh[1] $>,$>,0,0
k={"k=(i[1]+i[3]+i[4]+i[6])/4; i(#-2,0)=k;
i(#-2,1)=(i[6]-i[1])/2; i(#-2,2)=(i[3]-i[4])/2;
i(#-2,3)=(i[6]+i[1])/2-k; i(#-2,4)=(i[3]+i[4])/2-k;
i(#-2,5)=(i[2]+i[5]-i[0]-i[7])/4;
i(#-2,6)=(i[0]+i[5]-i[2]-i[7])/4+(i[4]-i[3])/2;
i(#-2,7)=(i[5]+i[7]-i[0]-i[2])/4+(i[1]-i[6])/2;
i(#-2,8)=(i[0]+i[2]+i[5]+i[7])/4-k;0"}
-rm[-2,-1]
-done
--f[0] 0 -r. 100%,100%,1,2,-1 -sh[0] 0
-f. "begin(cx0=i(#2,0);cx1=i(#2,1);cx2=i(#2,2);cx3=i(#2,3);
cx4=i(#2,4);cx5=i(#2,5);cx6=i(#2,6);cx7=i(#2,7);cx8=i(#2,8);
cy0=i(#2,0,1);cy1=i(#2,1,1);cy2=i(#2,2,1);cy3=i(#2,3,1);
cy4=i(#2,4,1);cy5=i(#2,5,1);cy6=i(#2,6,1);cy7=i(#2,7,1);cy8=i(#2,8,1));
s=(2*x/w-1); t=-(2*y/h-1); s2=s*s; t2=t*t;
i(#3,x,y,0,0)=cx8*s2*t2+cx7*s*t2+cx6*s2*t+cx5*s*t+cx4*t2+cx3*s2+cx2*t+cx1*s+cx0;
i(#3,x,y,0,1)=cy8*s2*t2+cy7*s*t2+cy6*s2*t+cy5*s*t+cy4*t2+cy3*s2+cy2*t+cy1*s+cy0; i"
-rm[-4,-3,-1] -round. [0],[0],[0],[0] -sh[0] 0 px=""
-repeat {0,s} px=$px;i(#2,a,b,0,$>)=i$>#0 -done
-f. 'a=i#1;b=i1#1$px' -rm. -j[0] [-1] -k[0]
-endl -done
#@gui Quick Tonemap : fx_gcd_quicktone, fx_gcd_quicktone(1)
#@gui : note = note("<i>Simple tone and detail control</i>"), sep = separator()
#@gui : Power = float(1,0.5,2.5)
#@gui : Radius = float(4,0,10)
#@gui : Range = float(20,0,20)
#@gui : Smooth = float(0,0,4)
#@gui : Channels = choice(3,"HSI","HSV","Lab","YCbCr")
#@gui : Values = choice(1,"cut","normalize")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/06/26</i>.</small>")
fx_gcd_quicktone : skip ${1=1},${2=4},${3=20},${4=0},${5=3},${6=1}
mode=${-arg\ 1+$5,hsi_i,hsv_v,lab_l,ycbcr_y}
if {$4>0} r={[im,iM]} bilateral 1%,$4 -c $r fi
ac "+gcd_tonemap_gamma $2% +bilateral. $2%,{(iM#0-im#0)*$3/100} -[-2,-1] *. $1 +",$mode,{$6+1}
#@cli gcd_tonemap_gamma
#@cli : Map tones by local adjustment of geometric mean.
gcd_tonemap_gamma : skip ${1=100}
-v - repeat $! l[$>] m={[im,iM]} n 0.002,0.998 log +b $1 *.. {0,is/whds} / exp n $m endl done -v +
#@gui Recolor : gcd_recol, gcd_recol(1)
#@gui : note = note("<i>Apply colors to a black and white image</i>"), sep = separator()
#@gui : Min Hue Drift = int(-14,-45,0)
#@gui : Max Hue Drift = int(14,0,45)
#@gui : sep = separator(), note = note("<b>Note :</b> This filter needs two layers to work properly.")
#@gui : note = note("<small>Original Author : <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i></small>")
#@gui : note = note("<small>Adapted by : <i>Garagecoder</i>.   Latest update: <i>2013/01/16</i>.</small>")
gcd_recol :
-repeat {int($!/2)} -l[$>,{$>+1}]
-rv[-2,-1]
-channels[-2] 0 -to_rgb[-2]
-to_rgba[-1] -split_opacity[-1] -neq[-1] 0
-srgb2rgb[-3,-2] -rgb2lab8[-3,-2] -channels[-3] 0 -channels[-2] 1,2
-+[-2] 1 -*[-2] [-1]
--meancurvature_flow[-3] 3 -median[-1] 3
-gradient_norm[-1] -*[-1] -1 -watershed[-3] [-1] -rm[-1] --[-2] 1
-rm[-1] -a[-2,-1] c -lab82rgb[-1] -rgb2srgb[-1]
-rgb2hsv[-1] -s c --equalize[2] 512 -n[-1] $1,$2 -+[0,-1] -%[0] 360 -a c -hsv2rgb[-1]
-endl -done
#@gui Smart Rotate : gcd_srotate, gcd_srotate(1)
#@gui : note = note("<u>Rotate an image and extrapolate the corners</u>")
#@gui : note = note("\n<i>Rotation Options</i>"), sep = separator()
#@gui : Angle = int(0,-90,90)
#@gui : Centrex = int(50,0,100)
#@gui : Centrey = int(50,0,100)
#@gui : note = note("\n<i>Quality Options</i>"), sep = separator()
#@gui : Interpolation = choice(1,"Linear","Bicubic")
#@gui : Inpainting = choice(1,"Low","Normal","High","Ultra")
#@gui : Lookup Scale = int(6,1,16)
#@gui : Lookup Factor = float(0.6,0.2,2)
#@gui : Seamless = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/12/05</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>* Dimensions are not altered</small>")
#@gui : note = note("<small>* Quality settings affect speed!</small>")
#@gui : note = note("<small>The preview is a rough guide only.  Images with simple edges tend to work best.</small>")
#@gui : note = note("<small>Results can be improved by selecting a higher inpainting quality, but processing will take longer.</small>")
#@gui : note = note("<small>Select seamless to reduce visible seams at the corners.</small>")
gcd_srotate : -skip ${1=0},${2=50},${3=50},${4=1},${5=1},${6=6},${7=0.6},${8=0}
-repeat $! -l[$>]
-rotate $1,{$4+1},1,$2%,$3% -c 0,255 -split_opacity
-l[0]
{w},{h},1,1,1 -rotate[-1] $1,0,0,$2%,$3%
-eq[-1] 0 --area[-1] 0 -*[-1] [-2]
ps={max(round(iM^0.5/6),4)} -rm[-1]
-if $8
--inpaint[0] [-1],$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08
-rv[-2,-1] -a[-2,-1] c -blend_seamless 0,0,25%
-else
-inpaint[0] [-1],$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08 -rm[-1]
-endif
-endl -a c
-endl -done
#@gui Split Objects : gcd_splitobj, gcd_splitobj_preview(1)
#@gui : note = note("<u>Extract objects from an image to a new layer</u>")
#@gui : note = note("<small>1. Create a new transparent layer, mark background red and objects green</small>")
#@gui : note = note("<small>2. Set Input layers to <b>Active &amp; below</b>, objects will be split to two layers</small>")
#@gui : note = note("\n<i>Edge Detection Options</i>"), sep = separator()
#@gui : Alpha Min = int(50,0,100)
#@gui : Edge Flow = int(3,0,20)
#@gui : Median = int(3,0,7)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Swap Layers = bool(0)
#@gui : Grow Alpha = int(0,-20,20)
#@gui : Blur Alpha = int(0,0,20)
#@gui : Opacity = int(40,0,100)
#@gui : Inpainting = choice(0,"Off","Low","Normal","High","Ultra")
#@gui : Is Preview = value(0)
#@gui : sep = separator(), note = note("<b>Note :</b> This filter needs two layers to work properly.")
#@gui : note = note("<small>Author : <i>Garagecoder</i>.   Latest update: <i>2016/01/22</i>.</small>")
gcd_splitobj : -skip ${1=50},${2=3},${3=3},${4=0},${5=0},${6=0},${7=40},${8=0},${9=0}
-if {$!<2} -return -endif
-repeat {int($!/2)} -l[$>,{$>+1}]
-if {w!={0,w}" || "h!={0,h}} -continue -endif
-to_rgba [-1] -s[1] c,-3 -ge[2] $1% -luminance[1]
-meancurvature_flow[1] $2 -median[1] $3 -*[1,2]
-channels[0] 0,1 -s[0] c -gt[0,1] 50% -*[{$4!=0}] 2 -+[0,1]
-gradient_norm[1] -*[1] -1 -watershed[0] [1] --[0] 1 -rm[1]
-if {$5>0} -erode[0] $5 -elif {$5<0} -dilate[0] {abs($5)} -endif
-if $6 -b[0] $6,1,1 -c[0] 0,1 -endif
[1] -sh[-1] 3,3 -*[-1] [0] -rm[-1] -oneminus[0]
-if {$8>0}
-le[0] 80% --area[0] 0 -*[-1] [0]
ps={max(round(iM^0.5/6),4)} -rm[-1] -n[0] 0,255
-inpaint[1] [0],$ps,{$ps*6},1,{9-$8*2},{$ps*1.2},0,0.08,10,1
-else -sh[1] 3,3 -*[-1] [0] -rm[-1] -endif
-rm[0] -gcd_fix_alpha -nm[1] opacity($7)
-if {$9} -blend alpha,{$7/100} -endif
-endl -done
gcd_splitobj_preview :
-gcd_splitobj ${1--2},1
#@gui Stereo Video : gcd_stereo_vid, gcd_stereo_vid_preview(1)
#@gui : note = note("<u>Convert a series of image files to 3D</u>")
#@gui : note = note("\n<i>File Options</i>"), sep = separator()
#@gui : Start Image = file()
#@gui : End Image = file()
#@gui : Output Folder = _folder()
#@gui : note = note("\n<i>3D Options</i>"), sep = separator()
#@gui : 3D Image Type = choice("Anaglyph: Red/Cyan","Side by Side","Depth Map","Inverse Depth Map")
#@gui : Balance Color = float(0.5,0,1)
#@gui : Depth = float(1.2,0,2)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Despeckle = bool(1)
#@gui : note = note("\n<i>Video Options</i>"), sep = separator()
#@gui : Frame Buffer = _int(5,1,10)
#@gui : Scene Detection = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/07/02</i>.</small>")
gcd_stereo_vid :
1 -l[-1]
-i "$1" st_folder={f} st_file={b} st_ext={x} ({'$st_file'}) cpx={w}
-do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} -while {($isnum)&&($cpx>0)}
-if {$cpx>0} --z[-1] 0,$cpx fsname={t} -rm[-1] -else fsname="" -endif
-z[-1] {$cpx+{!$isnum}},100% dgts={w} fsnum={{t}} -rm[-1]
1 -nm[-1] "$2" en_file={b} ({'$en_file'}) cpx={w}
-do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} -while {($isnum)&&($cpx>0)}
-z[-1] {$cpx+{!$isnum}},100% fenum={{t}} -rm[-2,-1]
bufsz=$11 ttlbuf={$bufsz*2} ttlimg={$fenum-$fsnum+1}
scene=1 scframe=0 ov={iv} oa={ia}
-repeat {$ttlimg}
-if {$scene" && "$>==$scframe}
-k[-1] scene=0
-repeat {min($ttlbuf,$ttlimg-$scframe-1)}
curnum={$fsnum+$scframe+$>+1} curnum=${-gcd_add0\ $curnum,$dgts}
-i ""${st_folder}${fsname}${curnum}.${st_ext}""
vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
ov=$vr oa=$av
-if {$12&&($pvr>0.1" || "$pav>0.1)} scene=1 scframe={$scframe+$>+1} -break
-endif
-done
--l[0--{1+$scene}] -ap "-gcd_depth $7,$8,$9,$10" --add[0--1] -a[0--2] z -endl
-mv[-1] 0 -mv[-1] 1 -a[2--{1+$scene}] z
-endif
--slices[2] 0 --div[0] {1,d} -gcd_stereo[-2,-1] $4,$5,$6%
curnum={$fsnum+$>} curnum=${-gcd_add0\ $curnum,$dgts}
-if ${-is_windows} -o[-1] "$3"""{`92`}${fsname}${curnum}.${st_ext}""
-else -o[-1] "$3"""{`47`}${fsname}${curnum}.${st_ext}"" -endif
-progress {($>+1)/$ttlimg*100}
-rm[-1] -slices[2] 1,100%
-if {!$scene" && "($>>=($scframe+$bufsz))" && "($><($ttlimg-$bufsz-1))}
curnum={$fsnum+$>+$bufsz+1} curnum=${-gcd_add0\ $curnum,$dgts}
-i ""${st_folder}${fsname}${curnum}.${st_ext}""
vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
ov=$vr oa=$av
-if {$12&&($pvr>0.1" || "$pav>0.1)} scene=1 scframe={$>+$bufsz+1}
-else
--gcd_depth[-1] $7,$8,$9,$10 -add[0] [-1] -a[1,-1] z -a[2,-1] z
--slices[1] 0 -sub[0,-1] -slices[1] 1,100%
-endif
-endif
-done
-rm
-endl
gcd_stereo_vid_preview : -skip "${1=}","${2=}"
-l -i "$1" -onfail 100,100,1,3,0 -text[-1] "Select\nStart\nImage   ",0,0,32,1,255 -endl
-l -i "$2" -onfail 100,100,1,3,0 -text[-1] "Select\nEnd\nImage   ",0,0,32,1,255 -endl
-k[-2,-1] -a[0,1] x -to_rgb[0] --gcd_depth[-1] $7,$8,$9,$10 -gcd_stereo $4,$5,$6%
gcd_add0 :
({'"$1"'}) -if {w<$2} {$2-w},1,1,1,48 -rv[-2,-1] -a[-2,-1] x -endif -u {t} -rm[-1]
#@gui Upscale [Box] : gcd_upscale_box, gcd_upscale_box_preview(0)
#@gui : note = note("<i>Box average upscale</i>"), sep = separator()
#@gui : Upscale Factor = choice("2x","4x"), sep = separator()
#@gui : CbCr Median = bool(0)
#@gui : Sharpen = bool(0), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/09/27</i>.</small>")
#@gui : note = note("\n<small>Soft upscale with sharpening, may cause edge artifacts.</small>")
gcd_upscale_box : -skip ${1=0},${2=0},${3=0}
-if $2 -ac "-median 5,20",ycbcr_cbcr -endif
-gcd_scale_box2x $1,$3 -c 0,255
gcd_upscale_box_preview :
-if $1 -z 37.5%,37.5%,62.5%,62.5% -else -z 25%,25%,75%,75% -endif
-gcd_upscale_box $*
gcd_scale_box2x : -skip ${1=0},${2=0}
-repeat $! -l[$>]
-if {$1>0} (400,5,7,49,33) -else (200,3,3,9,5) -endif
--r.. {@0}%,{@0}% -median. {1,@1} -boxfilter. {1,@1}
--r. [0],2 --[0,-1] -r[0] .
-if $2
[0] -boxfilter[0] {1,@2} -*[0] {1,@3}
--[0,-1] -/[0] {1,@4} -rm.. -+
-else -boxfilter[0] {1,@2} -rm.. -+ -endif
-endl -done
#@gui Upscale [Noise] : gcd_upscale_noise, gcd_upscale_noise_preview(0)
#@gui : note = note("<i>Upscale 2x using randomized estimation of original</i>"), sep = separator()
#@gui : Noise = int(16,0,32)
#@gui : Iters = int(2,1,3), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/08</i>.</small>")
#@gui : note = note("\n<small>Note: reduce iters and increase noise for poor images.</small>")
gcd_upscale_noise : skip ${1=16},${2=2}
gcd_scale_noise $1,$2 c 0,255
gcd_upscale_noise_preview :
z 25%,25%,75%,75% gcd_upscale_noise $*
gcd_scale_noise : skip ${1=16},${2=2}
-v - repeat $! l[$>]
200%,200%,100%,100% gcd_random. $1
repeat $2 +r. ..,2 -. [0] r. .. boxfilter. 3 -[1,2] done rm..
endl done -v +
gcd_random : skip ${1=1},"${2=?}"
f "begin(a=int(255*u);b=int(64000*u+999);q=int(255*u+255));
n=xor(a,a<<13);a=b;b=q;q=xor(xor(q,q>>15),xor(n,n>>10))"
if {isval("$2")} n $1,$2 else n 0,$1 fi
#@gui Warp Map : gcd_warpmap, gcd_warpmap(1)
#@gui : note = note("<i>Warp an image using another as a surface</i>"), sep = separator()
#@gui : Depth = float(5,0,20)
#@gui : Detail = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Blend Mode = choice("Warp","Multiply","Softlight","None")
#@gui : Swap Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>The top layer will be warped using the bottom layer as a surface.</small>")
#@gui : note = note("<small>\nDepth: Set the apparent depth of the surface.</small>")
#@gui : note = note("<small>Detail: Perform second warp with no smooth for fine detail.</small>")
#@gui : note = note("<small>Smooth: Set low for emboss, high to wrap around large objects.</small>")
gcd_warpmap : -skip ${1=5},${2=0},${3=0},${4=0},${5=0}
-repeat {int($!/2)} -l[$>,{$>+1}]
-if $5 -rv -endif
-if {$4==3} bm=0 -i[0] [-1] -else bm=$4 -endif
-if $2 --gcd_warp[-2,-1] $1,$3 -rm[-3] -rv[-2,-1] -gcd_warp[-2,-1] $2,0,$bm
-else -gcd_warp[-2,-1] $1,$3,$bm -endif
-if {$4==3} -rv -endif
-endl -done
gcd_warp : -skip ${1=5},${2=0},${3=0}
-repeat {int($!/2)} -l[$>,{$>+1}]
wfac={$1%*w} -to_rgba[-2,-1] --norm[-1]
-blur_xy[-1] $2%,$2% -n[-1] 0,255 -g[-1] xy -a[-2,-1] c
-*[-1] -1 -n[-1] -$wfac,$wfac -warp[0] [-1],1 -rm[-1]
-if {$3==0} -rm[-1] -break -endif
-if {$3==1} -blend multiply,1,1 -else -blend softlight,1,1 -endif
-endl -done
#@gui Xbr2x : gcd_xbr2x, gcd_xbr2x(1)
#@gui : note = note("Implementation of the xBR 2x [noblend] algorithm by Hyllian.")
#@gui : note = link("http://code.google.com/p/2dimagefilter/wiki/ImageResizer")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.  Latest update : <i>2013/05/29</i>.</small>")
#@gui : note = note("<small>Disclaimer : This is a near complete recode based on C# source from ImageResizer</small>")
#@gui : note = note("<small>The results may not fully represent the original routine!</small>")
gcd_xbr2x :
-repeat $! -l[$>] -to_rgb[0]
(-1,-1;0,-1;1,-1;-1,0;0,0;1,0;-1,1;0,1;1,1;\
-1,-2;0,-2;1,-2;-2,-1;-2,0;-2,1;2,-1;2,0;2,1;-1,2;0,2;1,2)
pa_=0 pb_=1 pc_=2  pd_=3 pe_=4 pf_=5  pg_=6 ph_=7 pi_=8
a1_=9 b1_=10 c1_=11  a0_=12 d0_=13 g0_=14
c4_=15 f4_=16 i4_=17  g5_=18 h5_=19 i5_=20
e0=21 e1=22 e2=23 e3=24
($pe_,$pi_,$ph_,$pf_,$pg_,$pc_,$pd_,$pb_,$f4_,$i4_,$h5_,$i5_,$e1,$e2,$e3;\
$pe_,$pc_,$pf_,$pb_,$pi_,$pa_,$ph_,$pd_,$b1_,$c1_,$f4_,$c4_,$e0,$e3,$e1;\
$pe_,$pa_,$pb_,$pd_,$pc_,$pg_,$pf_,$ph_,$d0_,$a0_,$b1_,$a1_,$e2,$e1,$e0;\
$pe_,$pg_,$pd_,$ph_,$pa_,$pi_,$pb_,$pf_,$h5_,$g5_,$d0_,$g0_,$e3,$e0,$e2)
-*[1] -1
-repeat 21 --shift[0] {1,round(i(0,$>))},{1,round(i(1,$>))},0,0,1 -done
[0] [0] [0] [0]
-nm[0] orig -mv[0] $! -rm[0] -nm[0] kern -mv[0] $!
-repeat 4
pe={kern,i(0,$>)}  pi={kern,i(1,$>)}  ph={kern,i(2,$>)}
pf={kern,i(3,$>)}  pg={kern,i(4,$>)}  pc={kern,i(5,$>)}
pd={kern,i(6,$>)}  pb={kern,i(7,$>)}  f4={kern,i(8,$>)}
i4={kern,i(9,$>)}  h5={kern,i(10,$>)} i5={kern,i(11,$>)}
n1={kern,i(12,$>)} n2={kern,i(13,$>)} n3={kern,i(14,$>)}
--gcd_eq[$pe,$pf] --gcd_eq[$pe,$ph] -or[-2,-1] -eq[-1] 0 -nm[-1] lvl1
--gcd_yuv[$pe,$pc] --gcd_yuv[$pe,$pg] -+[-2,-1]
--gcd_yuv[$pi,$h5] -+[-2,-1] --gcd_yuv[$pi,$f4] -+[-2,-1]
--gcd_yuv[$ph,$pf] -*[-1] 4 -+[-2,-1]
-nm[-1] red
--gcd_yuv[$ph,$pd] --gcd_yuv[$ph,$i5] -+[-2,-1]
--gcd_yuv[$pf,$i4] -+[-2,-1] --gcd_yuv[$pf,$pb] -+[-2,-1]
--gcd_yuv[$pe,$pi] -*[-1] 4 -+[-2,-1]
-nm[-1] blue
--gcd_yuv[$pe,$pf] --gcd_yuv[$pe,$ph] -le[-2,-1]
--image[$ph] [$pf],0,0,0,0,1,[-1] -nm[-1] px -rm[-2]
--lt[red,blue]
--gcd_neq[$pf,$i4] --gcd_neq[$ph,$i5] -and[-2,-1] --gcd_eq[$pe,$pi] -and[-2,-1]
--gcd_neq[$pf,$pb] --gcd_neq[$ph,$pd] -and[-2,-1] -or[-2,-1]
--gcd_eq[$pe,$pg] -or[-2,-1] --gcd_eq[$pe,$pc] -or[-2,-1]
-and[-2,-1] -nm[-1] lvl2
--gcd_yuv[$pf,$pg] -nm[-1] lver
--gcd_yuv[$ph,$pc] -nm[-1] uver
--*[lver] 2 -le[-1] [uver]
--gcd_neq[$pg,$pe] --gcd_neq[$pg,$pd] -and[-2,-1]
-and[-2,-1] -and[-1] [lvl2] -image[$n3] [px],0,0,0,0,1,[-1]
--*[uver] 2 -lt[-1] [lver]
--gcd_neq[$pc,$pe] --gcd_neq[$pc,$pb] -and[-2,-1]
-and[-2,-1] -and[-1] [lvl2] -image[$n3] [px],0,0,0,0,1,[-1]
-rm[-2,-1,lver,uver]
-rm[red,blue,lvl1,lvl2,px]
-done
{orig,w},{orig,h},1,1,1 -r2dx[-1] {orig,w*2},4 -nm[-1] msk
-r2dx[orig,$e0,$e1,$e2,$e3] {orig,w*2},1
-image[orig] [$e0],0,0,0,0,1,[msk] -shift[msk] 1
-image[orig] [$e1],0,0,0,0,1,[msk] -shift[msk] -1,1
-image[orig] [$e2],0,0,0,0,1,[msk] -shift[msk] 1
-image[orig] [$e3],0,0,0,0,1,[msk]
-k[orig]
-endl -done
gcd_eq : -l[-2,-1] --[-2,-1] -norm[-1] -eq[-1] 0 -endl
gcd_neq : -l[-2,-1] --[-2,-1] -norm[-1] -neq[-1] 0 -endl
gcd_yuv : -l[-2,-1] --[-2,-1] -abs[-1] -rgb2yuv[-1] -abs[-1] -s[-1] c -*[-3] 48 -*[-2] 7 -*[-1] 6 -+[-3--1] -endl
#@gui _
#@gui <i>Gentlemanbeggar</i>
#@gui 60's Cinema : fx_gb_cfx, fx_gb_cfx_preview(0)
#@gui : Grain = float(10,0,25)
#@gui : Noon for Midnight = bool(0)
#@gui : GeneKelly = bool()
#@gui : RayHarryhausen = bool()
#@gui : CaryGrant = bool()
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : note = note{"\nUsage Notes:  Set Output mode to 'New Layer'.  After running filter, I recommend setting the newly created layer blend mode to 'hard light' when using 'noon for midnight' and 'soft light' for other images.  This filter looks best on well lit scenes."}
fx_gb_cfx :
-if {$5==1}
-noise[0] {$1/1},4
--fx_bwrecolorize 1,1,0,0,0,1,0,5,0,0,0,255,47,106,121,255,209,136,49,255,228,207,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0
-fx_compose_edges 0.9,0.5
-else
-if {$4==1}
-fx_bwrecolorize 1,1,0,0,0,1,0,6,0,0,0,255,27,25,55,255,137,152,189,255,191,217,228,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0
--noise[0] {$1/1},4
-compose_interpolation
-else
-if {$3==1}
-sepia
--fc[0] 0,65,00 -to_rgba[0]
-compose_interpolation
-noise[0] {$1/1},4
-compose_grainmerge
-else
-if {$2==0}
-sepia
--noise[0] $1,4
-compose_grainmerge
-else
-sepia
--fc[0] 0,0,255 -to_rgba[0]
-compose_interpolation
-noise[0] {$1/2},4
-compose_grainmerge -endif
-endif
-endif
-endif
fx_gb_cfx_preview :
-gui_split_preview "-fx_gb_cfx ${1--2}",$-1
#@gui About : _none_, gui_gb_about
#@gui : note = note{"
#@gui : <span foreground="purple">( <b>G</b>entlemanbeggar?s <b>F</b>ilter <b>S</b>et for <b>G'MIC</b>)</span>\n\nis proposed to you by"}
#@gui : note = note("Gentlemanbeggar")
#@gui : note = note{"\n"}
#@gui : sep = separator()
#@gui : note = note{"
#@gui : The source code of this filter is available at :"}
#@gui : note = link("http://gentlemanbeggar.wordpress.com")
#@gui : sep = separator()
#@gui : note = note{"\nThe filters in this folder are still under development and may be subject to changes."}
gui_gb_about :
-fx_logo "GB"'"s Filters"
#@gui Lens Blur : fx_gb_lb, fx_gb_lb_preview(0)
#@gui : note = note{"\nUsage Notes:  Set Output mode to 'New image' or 'in place' to simply reverse the frames in this image.  Set mode to 'New layers' to add the reversing effect to your current image."}
#@gui : Amplitude = float(10,5,20)
#@gui : Bokeh = float(7,0,20)
#@gui : sep = separator()
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
fx_gb_lb :
-spread 3
-heat_flow $1
-dilate_circ $2
-compose_lighten
fx_gb_lb_preview :
-gui_split_preview "-fx_gb_lb ${1--2}",$-1
#@gui Maxfield Parrish : fx_gb_mp, fx_gb_mp_preview(0)
#@gui : Lithograph = float(2,.5,3)
#@gui : Warm = bool()
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
fx_gb_mp :
-equalize 255
-if {$2==1}
--fx_corner_gradient 255,246,219,255,255,144,100,255,54,164,54,255,0,0,255,255
-else
--fx_corner_gradient 255,250,237,255,255,200,178,255,2,104,2,255,0,0,143,255
-endif
-rv
-fx_transfer_colors [-2,-1]1
-compose_value
-equalize 255
-fx_glow {$1},0,0
fx_gb_mp_preview :
-gui_split_preview "-fx_gb_mp ${1--2}",$-1
#@gui Modern Cinema : fx_gb_mcfx, fx_gb_mcfx_preview(0)
#@gui : Genre = choice("Blockbuster","Feel the heat","Cyberpunk-o-rama","Procedural police drama")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : note = note{"Usage Notes: When using 'auto apply' the adjustment layer is automatically applied to the image using the 'Hard light' mode.  For more control and tweaking, set Output mode to 'New Layer'.  After running filter, I suggest setting the newly created layer blend mode to 'hard light' for most images."}
fx_gb_mcfx :
-if {$1==0}
--fx_corner_gradient 255,255,255,255,0,93,131,255,248,121,2,255,0,0,0,255
-elif {$1==1}
--fx_corner_gradient 219,247,251,255,255,145,115,255,238,222,151,255,0,0,0,255
-elif {$1==2}
--fx_corner_gradient 238,251,228,255,0,117,7,255,28,73,63,255,0,0,0,255
-elif {$1==3}
--fx_corner_gradient 228,251,250,255,0,78,117,255,28,28,73,255,0,0,0,255
-endif
-fx_transfer_colors 0 -rm.
fx_gb_mcfx_preview :
-gui_split_preview "-fx_gb_mcfx ${1--2}",$-1
#@gui Ping Pong : fx_gb_pp, gui_no_preview
#@gui : note = note{"\nUsage Notes:  Set Output mode to 'New image' or 'in place' to simply reverse the frames in this image.  Set mode to 'New layers' to add the reversing effect to your current image."}
fx_gb_pp :
-rv
#@gui Urban Blight : fx_gb_ub,fx_gb_ub_preview(0)
#@gui : Colour = float(-1,-1,.03)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
fx_gb_ub :
-fx_normalize_local 2,8,5,20,1,3,0
--fx_gb_mp 3,0,0
-rv
-fx_mix_hsv 1,0,0,1,{$1},.5,1,0,0,0,2,0
-compose_overlay
fx_gb_ub_preview :
-gui_split_preview "-fx_gb_ub ${1--2}",$-1
#@gui _
#@gui <i>Gmic Tutorials</i>
#@gui Blur by Color : gtutor_blur_img, gtutor_blur_img_preview
#@gui : Range = choice(3,"XL","VL","L","N","M","VM","XM")
#@gui : Amplitude = float(0.5,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Garry R. Osgood.</i> Latest update: <i>2014/08/30</i>.</small>")
#@gui : note = link("Blur by color instructions and tutorial.","http://gmic.eu/tutorial/blur-by-color-filter.shtml")
gtutor_blur_img :
-local[-2,-1]
-if {s>3}
-remove_opacity[-1]
-endif
range={700*$1+700}
-rgb2hsl[-1]
-split[-1] c
-mul[-1] $2
-reverse[-2,-1]
-negate[-1]
-mul[-1] [-2]
-reverse[-3,-1]
-div[-1] 360
-mul[-1] {2*pi}
--sin[-1]
-cos[-2]
-append[-4,-3] c
-append[-2,-1] c
-eigen2tensor[-2,-1]
-repeat 3
-smooth[-2] [-1],$range
-done
-rm[-1]
-endlocal
gtutor_blur_img_preview :
-gtutor_blur_img ${^0}
#@cli
#@cli colorwheel : _size>0,_cclock={ 0 | 1 },_angle
#@cli : Generates a square colorwheel in clockface orientation, with zero
#@cli : degrees on top, corresponding to red, and colors transitioning
#@cli : clockwise through green (120 degrees) and blue (240 degrees). size:
#@cli : colorwheel edges, in pixels.  cclock, boolean, if true generates a
#@cli : counterclockwise colorwheel, and angle, degrees, rotates the wheel
#@cli : clockwise (negative: counterclockwise) from its reference orientation.
#@cli : Default values: _size=512, _cclock=0, _angle=0
colorwheel : -check ${1=512}>=1 -skip ${2=0},${3=0}
-e[^-1] "Input colorwheel $1 pixels square; cclockwise=$2; oriented $3 degrees"
-v -
$1,$1,1,1,'x=x-w/2;y=y-h/2;((1-2*!!$2)*(atan2(y,x)*180/pi+90-$3))%360'
100%,100%,1,2,1 -a[-2,-1] c -hsv2rgb[-1] -nm[-1] [colorwheel]
-v +
#@gui _
#@gui <i>Iain Fergusson</i>
#@gui Automixer : automixer,automixer(0)
#@gui : Output Colour Difference = bool (0)
#@gui : Use Partial Image for Noise Calulation = bool (0)
#@gui : sep = separator ()
#@gui : note = note{"This filter creates a black and white mage with the most pleasant noise characteristics (IMHO). It measures the noise in each colour channel and scales each channel so that the noise levels are even and produces a greyscale output and optionally an extra image with the colour information."}
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 2012/10/26")
automixer:
-to_rgb
--split[-1] c
-if {$2==1}
-crop[-1,-2,-3] 40%,40%,60%,60%
-endif
bluenoise=${-variance_noise}
-remove[-1]
greennoise=${-variance_noise}
-remove[-1]
rednoise=${-variance_noise}
-remove[-1]
greennoise={$greennoise*0.5}
redadjust={$greennoise/$rednoise}
blueadjust={$greennoise/$bluenoise}
-to_rgb
--split[0] c
-mul[1] {$redadjust/($redadjust+1+$blueadjust)}
-mul[2] {1/($redadjust+1+$blueadjust)}
-mul[3] {$blueadjust/($redadjust+1+$blueadjust)}
-add[1-3]
-if {$1==0}
-keep[-1]
-else
--compose_grainextract
-remove[0]
-endif
#@gui Brown Spot Clean : iain_brown_spot_clean,iain_brown_spot_clean(0)
#@gui : Red/Green Radius = int (1,1,7)
#@gui : Blue Radius = int (2,1,7)
iain_brown_spot_clean:
red_radius={($1*2)+1}
green_radius={($1*2)+1}
blue_radius={($2*2)+1}
-to_rgb
--l
-split c
-l[0]
-median $red_radius
-median $red_radius
-median $red_radius
-endl
-l[1]
-median $green_radius
-median $green_radius
-median $green_radius
-endl
-l[2]
-median $blue_radius
-median $blue_radius
-median $blue_radius
-endl
-append c
-endl
-sub[0] [1]
-add[0] 128
--l[0]
-rgb2hsv8
-split c
-keep[0]
-apply_curve 0,0,0,11,0,13,255,65,255,67,0,255,0
-lt 1
-endl
-sub[0] 128
-mul[0,2]
-add
-c 0,255
nozip:
-remove_opacity
--l[0]
(1;-1)
-convolve[0] [1]
-rm[1]
-abs
-split c
-max
-endl
--l[1]
(1,-1)
-convolve[0] [1]
-rm[1]
-abs
-split c
-max
-endl
--l[0]
--l
-split c
-add
-div 3
-endl
-sub
-abs
-split c
-max
-endl
--l[1]
--l
-split c
-add
-div 3
-endl
-sub
-abs
-split c
-max
-endl
-mul[-1,-2] $1
-add[2,4]
-add[3,4]
-l[-1,-2]
-blur 2
-sub
-gt 0
-mul 255
-endl
-append[1,2] c
-blend alpha,1,0
#@gui CA Correction : iain_CA_correction, iain_CA_correction_pr(0)
#@gui : Blue Adjustment = float(0,-5,5)
#@gui : Red Adjustment = float(0,-5,5)
#@gui : Interpolation Quality = choice (2,"Low","Med","high")
#@gui : sep = separator()
#@gui : Preview Shows = choice ("Output","colours only")
#@gui : Preview Corner = choice (3,"North-West","North-East","South-East","South-West")
#@gui : note = note("The preview is only accurate for the corners. Make sure you navigate to the same corner as selected above. ")
iain_CA_correction:
-to_rgb
longest_side={max(w,h)}
-split c
-l[0]
$longest_side,$longest_side
50%,1
-fill[-1] 1-(x/w)
--mirror[-1] x
-mul[-2] -1
-append[-1,-2] x
-resize[-1] {1,w},{1,h},1,1,1
[-1]
-rotate[-1] 90
-append[-1,-2] c
-rm[1]
-resize[1] {0,w},{0,h},{d},{s},0,0,0.5,0.5
-mul[-1] $2
-warp[0] [1],1,$3,1
-keep[0]
-endl
-l[2]
$longest_side,$longest_side
50%,1
-fill[-1] 1-(x/w)
--mirror[-1] x
-mul[-2] -1
-append[-1,-2] x
-resize[-1] {1,w},{1,h},1,1,1
[-1]
-rotate[-1] 90
-append[-1,-2] c
-rm[1]
-resize[1] {0,w},{0,h},{d},{s},0,0,0.5,0.5
-mul[-1] $1
-warp[0] [1],1,$3,1
-keep[0]
-endl
-append c
-c 0,255
iain_CA_correction_pr:
-to_rgb
x_mul={w/max(w,h)}
y_mul={h/max(w,h)}
-if {$-1==0}
rx_shift={$2*-1*$x_mul}
ry_shift={$2*-1*$y_mul}
bx_shift={$1*-1*$x_mul}
by_shift={$1*-1*$y_mul}
-elif {$-1==1}
rx_shift={$2*$x_mul}
ry_shift={$2*-1*$y_mul}
bx_shift={$1*$x_mul}
by_shift={$1*-1*$y_mul}
-elif {$-1==2}
rx_shift={$2*$x_mul}
ry_shift={$2*$y_mul}
bx_shift={$1*$x_mul}
by_shift={$1*$y_mul}
-elif  {$-1==3}
rx_shift={$2*-1*$x_mul}
ry_shift={$2*$y_mul}
bx_shift={$1*-1*$x_mul}
by_shift={$1*$y_mul}
-endif
-split c
-l[0]
[0]
[0]
-fill[1] $rx_shift
-fill[2] $ry_shift
-append[1,2] c
-warp[0] [1],1,$3,1
-keep[0]
-endl
-l[2]
[0]
[0]
-fill[1] $bx_shift
-fill[2] $by_shift
-append[1,2] c
-warp[0] [1],1,$3,1
-keep[0]
-endl
-append c
-if {$-2}
-rgb2hsv
-split c
-fill[-1] .5
-append c
-hsv2rgb
-sub 128
-mul 2
-add 128
-c 0,255
-endif
#@gui Detect Moire : iain_detect_moire,iain_detect_moire_preview(0)
#@gui : Threshold = float(50,0,100)
#@gui : Mask Size = float(5,0,100)
#@gui : Expand/Contract = int (9,-50,50)
#@gui : sep = separator ()
#@gui : Preview Saturation = float (30,0,100)
#@gui : sep = separator ()
#@gui : note = note("Detect Moire on bayer patterns. Requires RGB bayer image as input. Output is a black and white mask.")
#@gui : note = note("Preview shows mask boundary on top of a fast demosaic that will show more moire than a good demosaicing algorithm.")
iain_detect_moire_preview:
--moire_2018_2[0] $1,$2,$3
-laplacian[-1]
-abs[-1]
-l[0]
-split c
-l[1]
(0,1)
-resize[-1] [0],0,2
--mul[0] [1]
-eq[1] 0
--mul[0] [1]
-k[2,3]
-endl
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
-convolve[0,1,2,3] [-1]
-rm[-1]
-add[1,2]
-mul[1] 0.5
-append c
-adjust_colors 0,0,0,0,$4,0,255
-endl
-remove_opacity
-add
-c 0,255
iain_detect_moire:
-skip $1,$2,$3
-channels 1
--l[0]
(1,0,1;0,-4,0;1,0,1)
-convolve[0] [1]
-rm[1]
-abs
-endl
--l[0]
(1,0,-2,0,1)
-convolve[0] [1]
-rm[1]
-abs
-endl
--l[0]
(1;0;-2;0;1)
-convolve[0] [1]
-rm[1]
-abs
-endl
-add[-1,-2]
-rm[0]
-sub[0] [1]
-k[0]
-c 0,255
-l[0]
--l[0]
(1,0,1;1,0,1;1,0,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,0,1;1,0,1;1,0,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
-endl
-mul 10
-c 0,255
thickness=5
-linethick 0%,0%,100%,0%,$thickness,1,0
-linethick 0%,0%,0%,100%,$thickness,1,0
-linethick 100%,0%,100%,100%,$thickness,1,0
-linethick 0%,100%,100%,100%,$thickness,1,0
-blur $2
-gt $1
-mul 255
-if {$3>0}
-dilate $3
-endif
-if {$3<0}
-erode {$3*-1}
-endif
#@gui Exfuse : exfuse, exfuse
#@gui : Exposure = float (1,0,2)
#@gui : Contrast Bias = float(0.6,0,1)
#@gui : Saturation Bias = float(0,0,1)
#@gui : Exposure Sigma = float(0.5,0,1)
#@gui : Exposure Bias = float(1,0,1)
#@gui : Blur = float(5,0,50)
exfuse:
cropwidth={w}
cropheight={h}
--mul[0] {2*$1}
--mul[0] {4*$1}
-c 0,255
--fx_ExposureWeightMap[0] $2,$3,$4,$5,0
--fx_ExposureWeightMap[1] $2,$3,$4,$5,0
--fx_ExposureWeightMap[2] $2,$3,$4,$5,0
-parallel "
-freq_pyramid[0]","
-freq_pyramid[1]","
-freq_pyramid[2]","
-dumb_pyramid[3]","
-dumb_pyramid[4]","
-dumb_pyramid[5]"
-parallel "-blur[-1] $6","-blur[-2] $6","-blur[-3] $6"
-replace[-1,-2,-3] 0,0.000000001
--add[-1,-2,-3]
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-rm[-1]
-parallel "
-mul[0] [3]","
-mul[1] [4]","
-mul[2] [5]"
-add[0,1,2]
-keep[0]
-ifreq_pyramid[0]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-c 0,255
dumb_pyramid:
cropwidth={w}
cropheight={h}
-resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
newwidth={w}
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
-append x
-resize {$newwidth*2},100%,1,3,0,0
ifreq_pyramid:
-split x,2
-split[1] x,2
-split[2] x,2
-split[3] x,2
-split[4] x,2
-crop[1] 0,0,100%,{0,h/2-1}
-crop[2] 0,0,100%,{0,h/4-1}
-crop[3] 0,0,100%,{0,h/8-1}
-crop[4] 0,0,100%,{0,h/16-1}
-crop[5] 0,0,{4,w/2-1},{0,h/32-1}
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
freq_pyramid:
cropwidth={w}
cropheight={h}
-resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
newwidth={w}
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
-append x
-resize {$newwidth*2},100%,1,3,0,0
#@gui Exfusion : exfusion, exfusion
#@gui : Width = float (20,0,50)
exfusion:
cropwidth={w}
cropheight={h}
-resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
-repeat 10
-l[-1--4]
--l[0,1,2,3]
--resize[0] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[0,-1]
--resize[1] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[1,-1]
--resize[2] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[2,-1]
--resize[3] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[3,-1]
-endl
--iain_weightmap[0] 1,$1
--iain_weightmap[1] 1,$1
--iain_weightmap[2] 1,$1
--iain_weightmap[3] 1,$1
--add[-1,-2,-3,-4]
-replace[-1,-2,-3,-4,-5] 0,0.0000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-div[-5] [-1]
-rm[-1]
-mul[4,12]
-mul[5,12]
-mul[6,12]
-mul[7,12]
-add[4,5,6,7]
-rm[0,1,2,3]
-endl
-done
-l[-1,-2,-3,-4]
-parallel "
--iain_weightmap[0] 4,$1","
--iain_weightmap[1] 4,$1","
--iain_weightmap[2] 4,$1","
--iain_weightmap[3] 4,$1"
--add[-1,-2,-3,-4]
-replace[-1,-2,-3,-4,-5] 0,0.00000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-div[-5] [-1]
-rm[-1]
-mul[0,4]
-mul[1,4]
-mul[2,4]
-mul[3,4]
-add
-endl
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},1,3,3
-add[-1,-2]
-done
-crop 0,0,{$cropwidth-1},{$cropheight-1}
--l[0]
-resize 5%,5%,1,3,2
-endl
min={1,im}
max={1,iM}
-c[0] $min,$max
-keep[0]
-n 0,255
#@gui Exfusion3 : exfusion3, exfusion3
#@gui : Contrast Bias = float(0.3,0,1)
#@gui : Saturation Bias = float(0.3,0,1)
#@gui : Exposure Sigma = float(0.2,0,1)
#@gui : Exposure Bias = float(0.3,0,1)
#@gui : sep = separator()
#@gui : Maxlevels Adjust = int(-1,-5,0)
#@gui : Base Level Median Stack = bool(0)
#@gui : sep = separator()
#@gui : note = note("Pyramid levels are calculated automatically, but you can reduce the number of pyramid levels to save memory. You can choose how the base level is fused, by using weight maps like normal, or by using a median of the image stack")
exfusion3:
cropwidth={w}
cropheight={h}
maxlevels={round(log2(min(w,h))+0.5)+$5}
size={2^$maxlevels}
-resize {w+($size-w%$size)},{h+($size-h%$size)},1,3,0,1
-repeat $maxlevels
-l[-1--3]
--l[0,1,2]
--resize[0] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,5
-sub[0,-1]
--resize[1] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,5
-sub[1,-1]
--resize[2] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,5
-sub[2,-1]
-endl
[0]
-fx_ExposureWeightMap[-1] $1,$2,$3,$4,0
[1]
-fx_ExposureWeightMap[-1] $1,$2,$3,$4,0
[2]
-fx_ExposureWeightMap[-1] $1,$2,$3,$4,0
-rm[0,1,2]
--add[-1,-2,-3]
-replace[-1,-2,-3,-4] 0,0.0000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-rm[-1]
-mul[0,6]
-mul[1,6]
-mul[2,6]
-add[0,1,2]
-endl
-done
-l[-1,-2,-3]
-if $6
-iain_fast_median_stack
-else
[0]
[1]
[2]
-parallel "
-fx_ExposureWeightMap[-1] $1,$2,$3,$4,0","
-fx_ExposureWeightMap[-2] $1,$2,$3,$4,0","
-fx_ExposureWeightMap[-3] $1,$2,$3,$4,0"
--add[-1,-2,-3]
-replace[-1,-2,-3,-4] 0,0.0000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-rm[-1]
-mul[0,3]
-mul[1,3]
-mul[2,3]
-add
-endif
-endl
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},1,3,5
-add[-1,-2]
-done
-crop 0,0,{$cropwidth-1},{$cropheight-1}
--l[0]
-resize 5%,5%,1,3,2
-endl
min={1,im}
max={1,iM}
-c[0] $min,$max
-keep[0]
-n 0,255
#@gui Exfusion5 : exfusion5, exfusion5
#@gui : Contrast Bias = float(0,0,1)
#@gui : Saturation Bias = float(.2,0,1)
#@gui : Exposure Sigma = float(0.2,0,1)
#@gui : Exposure Bias = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("Post Fusion Options")
#@gui : Local Contrast = float (0,0,3)
#@gui : Curve = float (0,-127,127)
exfusion5:
images=$!
cropwidth={w}
cropheight={h}
maxlevels={round(log2(min(w,h))+0.5)+0}
size={2^$maxlevels}
-remove_opacity
-resize {w+($size-w%$size)},{h+($size-h%$size)},1,3,0,1,0.5,0.5
--l[0-{$images-1}]
-repeat $! -local[$>]
-fx_ExposureWeightMap[0] $1,$2,$3,$4,0
-endlocal -done
-endl
-l[-1--$images]
--add
-replace 0,0.0000000000001
-repeat {$!-1}
-div[$<] [-1]
-done
-rm[-1]
-endl
-repeat $maxlevels
-l[-1--{$images*2}]
--l[0-{$images-1}]
-repeat $! -local[$>]
--resize[0] 50%,50%,1,3,2
-resize[-1] 200%,200%,1,3,5,0
-sub[0,-1]
-endlocal -done
-endl
-l[-1--{$images*2}]
-repeat $images -local[$>,{$>+$images}]
-mul[-1] [-2]
-endlocal -done
-endl
-l[-1--$images]
-add
-endl
-move[-1] 0
-l[-1--{$images*2}]
-repeat $! -local[$>]
-resize[0] 50%,50%,1,3,2
-endlocal -done
-endl
-endl
-done
-l[-1--{$images*2}]
-if 1
-repeat $images -local[$>,{$>+$images}]
-mul[-1] [-2]
-endlocal -done
-keep[-1--$images]
-add
-else
-keep[0--{$images-1}]
-add
-div $images
-endif
-endl
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},1,3,5,0
-add[-1,-2]
-done
-resize $cropwidth,$cropheight,1,3,0,1,0.5,0.5
-n 0,255
-mul 1000
-apply_curve 1,0,0,128000,{($6*1000)+128000},255000,255000
-mul 0.001
--iain_fast_denoise $5,$5,1,{$5/100},0
-sub[1] [0]
-mul[1] -1
--add
-c 0,255
-rm[1]
-reverse
-rgb2lch
-split c
-keep[0,4,5]
-append c
-lch2rgb
#@gui Fast Formula : iain_fast_formula, iain_fast_formula
#@gui : Apply Formula = text("-apply_gamma 2.2")
iain_fast_formula:
256,1
-fill[-1] x
-local[1]
$1
-endlocal
crv0={1,[0]}
crv1={1,[1]}
crv2={1,[2]}
crv3={1,[3]}
crv4={1,[4]}
crv5={1,[5]}
crv6={1,[6]}
crv7={1,[7]}
crv8={1,[8]}
crv9={1,[9]}
crv10={1,[10]}
crv11={1,[11]}
crv12={1,[12]}
crv13={1,[13]}
crv14={1,[14]}
crv15={1,[15]}
crv16={1,[16]}
crv17={1,[17]}
crv18={1,[18]}
crv19={1,[19]}
crv20={1,[20]}
crv21={1,[21]}
crv22={1,[22]}
crv23={1,[23]}
crv24={1,[24]}
crv25={1,[25]}
crv26={1,[26]}
crv27={1,[27]}
crv28={1,[28]}
crv29={1,[29]}
crv30={1,[30]}
crv31={1,[31]}
crv32={1,[32]}
crv33={1,[33]}
crv34={1,[34]}
crv35={1,[35]}
crv36={1,[36]}
crv37={1,[37]}
crv38={1,[38]}
crv39={1,[39]}
crv40={1,[40]}
crv41={1,[41]}
crv42={1,[42]}
crv43={1,[43]}
crv44={1,[44]}
crv45={1,[45]}
crv46={1,[46]}
crv47={1,[47]}
crv48={1,[48]}
crv49={1,[49]}
crv50={1,[50]}
crv51={1,[51]}
crv52={1,[52]}
crv53={1,[53]}
crv54={1,[54]}
crv55={1,[55]}
crv56={1,[56]}
crv57={1,[57]}
crv58={1,[58]}
crv59={1,[59]}
crv60={1,[60]}
crv61={1,[61]}
crv62={1,[62]}
crv63={1,[63]}
crv64={1,[64]}
crv65={1,[65]}
crv66={1,[66]}
crv67={1,[67]}
crv68={1,[68]}
crv69={1,[69]}
crv70={1,[70]}
crv71={1,[71]}
crv72={1,[72]}
crv73={1,[73]}
crv74={1,[74]}
crv75={1,[75]}
crv76={1,[76]}
crv77={1,[77]}
crv78={1,[78]}
crv79={1,[79]}
crv80={1,[80]}
crv81={1,[81]}
crv82={1,[82]}
crv83={1,[83]}
crv84={1,[84]}
crv85={1,[85]}
crv86={1,[86]}
crv87={1,[87]}
crv88={1,[88]}
crv89={1,[89]}
crv90={1,[90]}
crv91={1,[91]}
crv92={1,[92]}
crv93={1,[93]}
crv94={1,[94]}
crv95={1,[95]}
crv96={1,[96]}
crv97={1,[97]}
crv98={1,[98]}
crv99={1,[99]}
crv100={1,[100]}
crv101={1,[101]}
crv102={1,[102]}
crv103={1,[103]}
crv104={1,[104]}
crv105={1,[105]}
crv106={1,[106]}
crv107={1,[107]}
crv108={1,[108]}
crv109={1,[109]}
crv110={1,[110]}
crv111={1,[111]}
crv112={1,[112]}
crv113={1,[113]}
crv114={1,[114]}
crv115={1,[115]}
crv116={1,[116]}
crv117={1,[117]}
crv118={1,[118]}
crv119={1,[119]}
crv120={1,[120]}
crv121={1,[121]}
crv122={1,[122]}
crv123={1,[123]}
crv124={1,[124]}
crv125={1,[125]}
crv126={1,[126]}
crv127={1,[127]}
crv128={1,[128]}
crv129={1,[129]}
crv130={1,[130]}
crv131={1,[131]}
crv132={1,[132]}
crv133={1,[133]}
crv134={1,[134]}
crv135={1,[135]}
crv136={1,[136]}
crv137={1,[137]}
crv138={1,[138]}
crv139={1,[139]}
crv140={1,[140]}
crv141={1,[141]}
crv142={1,[142]}
crv143={1,[143]}
crv144={1,[144]}
crv145={1,[145]}
crv146={1,[146]}
crv147={1,[147]}
crv148={1,[148]}
crv149={1,[149]}
crv150={1,[150]}
crv151={1,[151]}
crv152={1,[152]}
crv153={1,[153]}
crv154={1,[154]}
crv155={1,[155]}
crv156={1,[156]}
crv157={1,[157]}
crv158={1,[158]}
crv159={1,[159]}
crv160={1,[160]}
crv161={1,[161]}
crv162={1,[162]}
crv163={1,[163]}
crv164={1,[164]}
crv165={1,[165]}
crv166={1,[166]}
crv167={1,[167]}
crv168={1,[168]}
crv169={1,[169]}
crv170={1,[170]}
crv171={1,[171]}
crv172={1,[172]}
crv173={1,[173]}
crv174={1,[174]}
crv175={1,[175]}
crv176={1,[176]}
crv177={1,[177]}
crv178={1,[178]}
crv179={1,[179]}
crv180={1,[180]}
crv181={1,[181]}
crv182={1,[182]}
crv183={1,[183]}
crv184={1,[184]}
crv185={1,[185]}
crv186={1,[186]}
crv187={1,[187]}
crv188={1,[188]}
crv189={1,[189]}
crv190={1,[190]}
crv191={1,[191]}
crv192={1,[192]}
crv193={1,[193]}
crv194={1,[194]}
crv195={1,[195]}
crv196={1,[196]}
crv197={1,[197]}
crv198={1,[198]}
crv199={1,[199]}
crv200={1,[200]}
crv201={1,[201]}
crv202={1,[202]}
crv203={1,[203]}
crv204={1,[204]}
crv205={1,[205]}
crv206={1,[206]}
crv207={1,[207]}
crv208={1,[208]}
crv209={1,[209]}
crv210={1,[210]}
crv211={1,[211]}
crv212={1,[212]}
crv213={1,[213]}
crv214={1,[214]}
crv215={1,[215]}
crv216={1,[216]}
crv217={1,[217]}
crv218={1,[218]}
crv219={1,[219]}
crv220={1,[220]}
crv221={1,[221]}
crv222={1,[222]}
crv223={1,[223]}
crv224={1,[224]}
crv225={1,[225]}
crv226={1,[226]}
crv227={1,[227]}
crv228={1,[228]}
crv229={1,[229]}
crv230={1,[230]}
crv231={1,[231]}
crv232={1,[232]}
crv233={1,[233]}
crv234={1,[234]}
crv235={1,[235]}
crv236={1,[236]}
crv237={1,[237]}
crv238={1,[238]}
crv239={1,[239]}
crv240={1,[240]}
crv241={1,[241]}
crv242={1,[242]}
crv243={1,[243]}
crv244={1,[244]}
crv245={1,[245]}
crv246={1,[246]}
crv247={1,[247]}
crv248={1,[248]}
crv249={1,[249]}
crv250={1,[250]}
crv251={1,[251]}
crv252={1,[252]}
crv253={1,[253]}
crv254={1,[254]}
crv255={1,[255]}
-apply_curve[0] 0,0,$crv0,1,$crv1,2,$crv2,3,$crv3,4,$crv4,5,$crv5,6,$crv6,7,$crv7,8,$crv8,9,$crv9,10,$crv10,11,$crv11,12,$crv12,13,$crv13,14,$crv14,15,$crv15,16,$crv16,17,$crv17,18,$crv18,19,$crv19,20,$crv20,21,$crv21,22,$crv22,23,$crv23,24,$crv24,25,$crv25,26,$crv26,27,$crv27,28,$crv28,29,$crv29,30,$crv30,31,$crv31,32,$crv32,33,$crv33,34,$crv34,35,$crv35,36,$crv36,37,$crv37,38,$crv38,39,$crv39,40,$crv40,41,$crv41,42,$crv42,43,$crv43,44,$crv44,45,$crv45,46,$crv46,47,$crv47,48,$crv48,49,$crv49,50,$crv50,51,$crv51,52,$crv52,53,$crv53,54,$crv54,55,$crv55,56,$crv56,57,$crv57,58,$crv58,59,$crv59,60,$crv60,61,$crv61,62,$crv62,63,$crv63,64,$crv64,65,$crv65,66,$crv66,67,$crv67,68,$crv68,69,$crv69,70,$crv70,71,$crv71,72,$crv72,73,$crv73,74,$crv74,75,$crv75,76,$crv76,77,$crv77,78,$crv78,79,$crv79,80,$crv80,81,$crv81,82,$crv82,83,$crv83,84,$crv84,85,$crv85,86,$crv86,87,$crv87,88,$crv88,89,$crv89,90,$crv90,91,$crv91,92,$crv92,93,$crv93,94,$crv94,95,$crv95,96,$crv96,97,$crv97,98,$crv98,99,$crv99,100,$crv100,101,$crv101,102,$crv102,103,$crv103,104,$crv104,105,$crv105,106,$crv106,107,$crv107,108,$crv108,109,$crv109,110,$crv110,111,$crv111,112,$crv112,113,$crv113,114,$crv114,115,$crv115,116,$crv116,117,$crv117,118,$crv118,119,$crv119,120,$crv120,121,$crv121,122,$crv122,123,$crv123,124,$crv124,125,$crv125,126,$crv126,127,$crv127,128,$crv128,129,$crv129,130,$crv130,131,$crv131,132,$crv132,133,$crv133,134,$crv134,135,$crv135,136,$crv136,137,$crv137,138,$crv138,139,$crv139,140,$crv140,141,$crv141,142,$crv142,143,$crv143,144,$crv144,145,$crv145,146,$crv146,147,$crv147,148,$crv148,149,$crv149,150,$crv150,151,$crv151,152,$crv152,153,$crv153,154,$crv154,155,$crv155,156,$crv156,157,$crv157,158,$crv158,159,$crv159,160,$crv160,161,$crv161,162,$crv162,163,$crv163,164,$crv164,165,$crv165,166,$crv166,167,$crv167,168,$crv168,169,$crv169,170,$crv170,171,$crv171,172,$crv172,173,$crv173,174,$crv174,175,$crv175,176,$crv176,177,$crv177,178,$crv178,179,$crv179,180,$crv180,181,$crv181,182,$crv182,183,$crv183,184,$crv184,185,$crv185,186,$crv186,187,$crv187,188,$crv188,189,$crv189,190,$crv190,191,$crv191,192,$crv192,193,$crv193,194,$crv194,195,$crv195,196,$crv196,197,$crv197,198,$crv198,199,$crv199,200,$crv200,201,$crv201,202,$crv202,203,$crv203,204,$crv204,205,$crv205,206,$crv206,207,$crv207,208,$crv208,209,$crv209,210,$crv210,211,$crv211,212,$crv212,213,$crv213,214,$crv214,215,$crv215,216,$crv216,217,$crv217,218,$crv218,219,$crv219,220,$crv220,221,$crv221,222,$crv222,223,$crv223,224,$crv224,225,$crv225,226,$crv226,227,$crv227,228,$crv228,229,$crv229,230,$crv230,231,$crv231,232,$crv232,233,$crv233,234,$crv234,235,$crv235,236,$crv236,237,$crv237,238,$crv238,239,$crv239,240,$crv240,241,$crv241,242,$crv242,243,$crv243,244,$crv244,245,$crv245,246,$crv246,247,$crv247,248,$crv248,249,$crv249,250,$crv250,251,$crv251,252,$crv252,253,$crv253,254,$crv254,255,$crv255
-keep[0]
#@gui Fast Median Stack : iain_fast_median_stack, iain_fast_median_stack
#@gui : note = note{"This filter gives the median value of the input images at each pixel location and therefore a single input image will have no change. Two input images will be averaged."}
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update 16 December 2014 - filter now accepts any number of images. ")
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update 8 March 2013 - Combined <i>median_3_stack</i> and <i>median_5_stack</i> into this filter, added <i>median_4_stack</i> and added auto-select based on number of input images.</small> ")
iain_fast_median_stack:
-if {$!>2}
-if {$!%2!=0}
-repeat {$!/2}
-repeat {$!-1}
-l[$>,{$>+1}]
--max[0,1]
-min[0,1]
-endl
-done
-progress {($>/$!)*200}
-done
-keep[{round(($!/2)-.5)}]
-else
-repeat {($!/2)+1}
-repeat {$!-1}
-l[$>,{$>+1}]
--max[0,1]
-min[0,1]
-endl
-done
-progress {($>/$!)*200}
-done
-keep[{round(($!/2)-.5)},{round({$!/2}-.5)-1}]
-add
-mul .5
-endif
-elif {$!==2}
-add
-mul .5
-elif {$!==1}
-endif
iain_median_3_stack:
-iain_fast_median_stack
iain_median_4_stack:
-iain_fast_median_stack
iain_median_5_stack:
-iain_fast_median_stack
#@gui FFT Tile : fft_tile,fft_tile_preview(0)
#@gui : Threshold = float (500,0,50000)
#@gui : Tile Size = int (128,16,256)
#@gui : Fast = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 2012/08/08")
fft_tile_fft:
--fftpolar[0]
--threshold[1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-keep[-1]
fft_tile_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile_fft[0--1] $1
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$3==0}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$3==0}
-blend_median
-endif
fft_tile_preview:
-fft_tile $1,$2,$3
-n 0,255
#@gui Fill Holes : fill_holes,fill_holes_preview(0)
#@gui : Morph Radius = int (11,3,50)
#@gui : Edge Radius = int (21,0,50)
#@gui : Close Radius = int (5,0,10)
#@gui : Channel(s) = choice(0,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Fill Light Colours = bool (0)
#@gui : Fast = bool (1)
#@gui : sep = separator ()
#@gui : note = note("Set Morph radius to close holes, set Edge radius to restore edges, set Close radius to fill small holes near the edge")
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 28 August 2012 - added 'fast' option")
fill_holes:
-ac "
-if {$5==0}
-if {$6==1}
--dilate[-1] $1
-erode[-1] $2
-compose_lighten
-dilate[-1] $3
-erode[-1] $3
-endif
-if {$6==0}
--dilate_circ[-1] $1
-erode_circ[-1] $2
-compose_lighten
-dilate_circ[-1] $3
-erode_circ[-1] $3
-endif
-endif
-c 0,255
-if {$5==1}
-if {$6==1}
--erode[-1] $1
-dilate[-1] $2
-compose_darken
-erode[-1] $3
-dilate[-1] $3
-endif
-if {$6==0}
--erode_circ[-1] $1
-dilate_circ[-1] $2
-compose_darken
-erode_circ[-1] $3
-dilate_circ[-1] $3
-endif
-endif
-c 0,255
",$4
fill_holes_preview:
-fill_holes $1,$2,$3,$4,$5,$6
#@gui Grey Descreen : iain_descreen2,iain_descreen2(0)
#@gui : Analysis Window = float (3,0,20)
#@gui : Strength = float(-10000,-10000,10000)
#@gui : Range = float (10,0,20)
iain_descreen2:
-channels 0
-fftpolar
--blur[0] $1%
-sub[-1] [0]
-gt[-1] $2
-circle[-1] 50%,50%,$3%,1,1
-mul[0] [-1]
-keep[0,1]
-ifftpolar
-c 0,255
#@gui Hearttone : iain_hearttone, iain_hearttone(0)
#@gui : Scale = float(100,10,200)
#@gui : Enhance Detail = float(0,0,10)
iain_hearttone:
-if {$2>0}
--iain_fast_denoise[0] $2,0,1,0,0
-sub[1] [0]
-mul[1] -1
-add
-n 0,255
-endif
-luminance
--l
-rm
-l
190,190,1,1,0
-circle 50,50,50,1,10
-circle 140,50,50,1,10
-polygon 5,10,80,50,50,140,50,180,80,95,190,1,10
-resize[-1] {0,w+2},{0,h+2},1,1,0,0,0.5,0.5
--resize[0] 95%,95%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 90%,90%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 85%,85%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 75%,75%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 65%,65%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 55%,55%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 50%,50%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 45%,45%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 40%,40%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 35%,35%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 30%,30%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 25%,25%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 20%,20%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 15%,15%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 10%,10%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 5%,5%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
-add
-endl
[0]
-append y
-resize 200%,100%,1,1,0,0,0.5,0.5
--shift[0] 160,100,0,0
--shift[0] -160,100,0,0
-add
-crop 30,190,350,100%
-n 0,255
-endl
-resize[-1] $1,$1,1,1,2
width={w}
height={h}
w_tiles={0,round(w/$width)}
h_tiles={0,round(h/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
-append_tiles[1--1] $w_tiles,$h_tiles
-equalize[-1] 256
-blend alpha,0.5,1
-gt 128
-mul 255
#@gui Iain 2x : iain_2x, iain_2x(0)
iain_2x:
-repeat $! -local[$>]
-resize[0] 200%,200%,1,3,4
-split c
-repeat $! -local[$>]
--l[0]
(0,0,0.5;0,1,0;0.5,0,0)
-convolve[0] [1]
-remove[1]
-endl
--l[0]
(0.5,0,0;0,1,0;0,0,0.5)
-convolve[0] [1]
-remove[1]
-endl
-remove[0]
--l[0]
(0,0,0.5;0,-1,0;0.5,0,0)
-convolve[0] [1]
-remove[1]
-abs
-endl
--l[1]
(0.5,0,0;0,-1,0;0,0,0.5)
-convolve[0] [1]
-remove[1]
-abs
-endl
-dilate[-1,-2] 3
-sub[-2] [-1]
-remove[-1]
-l[-1]
--lt[0] 0
--gt[0] 0
-fill[0] 0
-sub[0] [1]
-add[0] [-1]
-keep[0]
-add[0] 1
-mul[0] 127.5
-endl
-append[1,2] c
-blend alpha,1,0
--l[0]
(0.5,1,0.5)
-convolve[0] [1]
-remove[1]
-endl
--l[0]
(0.5;1;0.5)
-convolve[0] [1]
-remove[1]
-endl
-remove[0]
--l[0]
(0.5,-1,0.5)
-convolve[0] [1]
-remove[1]
-abs
-endl
--l[1]
(0.5;-1;0.5)
-convolve[0] [1]
-remove[1]
-abs
-endl
-blur[-1,-2] 3
-sub[-2] [-1]
-remove[-1]
-l[-1]
--lt[0] 0
--gt[0] 0
-fill[0] 0
-sub[0] [1]
-add[0] [-1]
-keep[0]
-add[0] 1
-mul[0] 127.5
-endl
-append[1,2] c
-blend alpha,1,0
-endlocal -done
-append c
-endlocal -done
#@gui Iain Demosaic : iain_demosiac, iain_demosiac(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - released 6 June 2013")
iain_demosiac:
-to_rgb
-add 1000
-rgb2bayer $1,1
-replace 0,0.0000000001
--l[0]
-replace 0,0.000000001
--l[0]
-to_rgb
--split[0] c
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[-3] redblur
-name[-2] greenblur
-name[-1] blueblur
(0.25,.5,0.5,.5,0.25)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(1;1)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(0.5,1,0.5)
-convolve[greenblur] [-1]
-remove[-1]
--div[greenblur] [redblur]
--div[greenblur] [blueblur]
-name[-1] bluemul
-name[-2] redmul
-remove[redblur,greenblur,blueblur]
-mul[red] [redmul]
-mul[blue] [bluemul]
-keep[red,green,blue]
-add
-c -100000000,100000000
-endl
-l[0]
-to_rgb
--split[0] c
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[-3] redblur
-name[-2] greenblur
-name[-1] blueblur
(0.25;.5;0.5;.5;0.25)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(1,1)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(0.5;1;0.5)
-convolve[greenblur] [-1]
-remove[-1]
--div[greenblur] [redblur]
--div[greenblur] [blueblur]
-name[-1] bluemul
-name[-2] redmul
-remove[redblur,greenblur,blueblur]
-mul[red] [redmul]
-mul[blue] [bluemul]
-keep[red,green,blue]
-add
-c -100000000,100000000
-endl
## choose one without zippers
(1,-2,1)
--convolve[1] [-1]
-abs[-1]
-remove[-2]
(1;-2;1)
--convolve[0] [-1]
-abs[-1]
-remove[-2]
--add[-2] [-1]
-div[-2] [-1]
-remove[-1,-3]
-lt[-1] 0.5
-mul[-1] 255
-blur[-1] 1
-append[0,-1] c
-blend alpha,1,1
-endl
-split[0] c
-remove[1]
-reverse[1,2]
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
-convolve[0] [-1]
-convolve[2] [-1]
-remove[-1]
--resize 50%,50%,{d},{s},2
-sub[-1] [-2]
-sub[-3] [-2]
-remove[-2]
-resize[-1,-2] {0,w},{0,h},{d},{s},3
-remove[0,2]
-add[1] [0]
-add[2] [0]
-reverse[0,1]
-append c
-sub 1000
-c 0,255
#@gui Iain Remove Pattern : iain_remove_pattern,iain_remove_pattern_preview(0)
#@gui : note = note("<b>Smooth<b>")
#@gui : Pre Blur = float (3,1,50)
#@gui : Smoothness = float (3,1,14)
#@gui : Radius = float (3,1,40)
#@gui : sep = separator ()
#@gui : note = note("<b>Recover detials<b>")
#@gui : Recover Detials = bool(0)
#@gui : Recovery Amount = float (4,0,10)
#@gui : Tile Size = int(128,16,512)
#@gui : Quality = choice(1,"1","3","5","super slow")
#@gui : sep = separator ()
#@gui : Preview = choice(0,"output","FFT of input","FFT of output","FFT difference")
#@gui : sep = separator ()
#@gui : note = note("This filter remove patterns by eliminating peaks in frequency domain while protecting edges.")
#@gui : note = note("Stage 1 Pre-blur: Create a guide image that has the pattern blured out")
#@gui : note = note("Stage 2 Smooth: Use guide image to do edge-protected smoothing. Make sure pattern is removed before trying to recover detials.")
#@gui : note = note("Stage 3 Detials: Recover detials by keeping non-peaks the the frequency domain.")
iain_remove_pattern:
-remove_opacity
--l
--blur[0] $1
-guided[0] [1],$2,$3
-k[0]
-endl
-if $4
-sub[0] [1]
-add[0] 128
-iain_remove_pattern_tiles_stack[0] $5,$5,$6,1,$7
-sub[0] 128
-to_rgb
-add
-else
-k[-1]
-endif
-c 0,255
iain_remove_pattern_preview:
-if {$8==0}
-iain_remove_pattern[0] $1,$2,$3,$4,$5,$6,$7
-elif  {$8==1}
-to_rgb -display_fft
-elif {$8==2}
-iain_remove_pattern[0] $1,$2,$3,$4,$5,$6,$7
-to_rgb -display_fft
-elif {$8==3}
--iain_remove_pattern[0] $1,$2,$3,$4,$5,$6,$7
-sub
-to_rgb -display_fft
-endif
iain_remove_pattern_tiles_stack:
offset={round($3/3)}
-remove_opacity
-luminance
--l
-if {$5>0}
--shift[0] $offset,$offset,0,0
-iain_remove_pattern_tiles[-1] $1,$2,$3
-shift[-1] {$offset*-1},{$offset*-1},0,0,1
--shift[0] {$offset*-1},{$offset*-1},0,0
-iain_remove_pattern_tiles[-1] $1,$2,$3
-shift[-1] $offset,$offset,0,0,1
-endif
-if {$5>1}
--shift[0] $offset,0,0,0
-iain_remove_pattern_tiles[-1] $1,$2,$3
-shift[-1] {$offset*-1},0,0,0,1
--shift[0] 0,$offset,0,0
-iain_remove_pattern_tiles[-1] $1,$2,$3
-shift[-1] 0,{$offset*-1},0,0,1
-endif
-if {$5>2}
--shift[0] {$offset*-1},0,0,0
-iain_remove_pattern_tiles[-1] $1,$2,$3
-shift[-1] $offset,0,0,0,1
--shift[0] 0,{$offset*-1},0,0
-iain_remove_pattern_tiles[-1] $1,$2,$3
-shift[-1] 0,$offset,0,0,1
-endif
-iain_remove_pattern_tiles[0] $1,$2,$3
-blend_median
-endl
-if $4
-sub
-add 128
-else
-k[1]
-endif
iain_remove_pattern_tiles:
-l[0]
size=$3
offset={$size/3}
cropwidth1={w}
cropheight1={h}
-resize[0] {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,0
tc={round(w/$size)} tr={round(h/$size)}
-split_tiles $tc,$tr
-apply_parallel "-iain_remove_pattern_fft $1,$2,$3"
-append_tiles $tc,$tr
-crop 0,0,{$cropwidth1-1},{$cropheight1-1}
-endl
iain_remove_pattern_fft:
-luminance
-fftpolar
--log[0]
-blur[-1] 10
-exp[-1]
--l[-1]
-fill[0] $1
-circle[-1] 50%,50%,14%,1,$2
-endl
-mul[-2,-1]
--lt[-1] [0]
-circle[-1] 50%,50%,{w*.005},1,1
-mul[0] [-1]
-k[0,1]
-ifftpolar
-c 0,255
#@gui Iain Star Burst : iain_star_burst,iain_star_burst(0)
#@gui : Threshold = int (254,0,255)
#@gui : Radius = float (50,1,255)
#@gui : Intesity = float (5,0,10)
#@gui : Rotate = int (45,0,90)
#@gui : Lines = int (2,1,10)
#@gui : Colour Modify = bool(0)
#@gui : Output Stars Only = bool(0)
iain_star_burst:
-repeat $! -l[$>] -split_opacity -l[0]
width={w}
height={h}
-resize {w+($2*2)},{h+($2*2)},1,3,0,0,0.5,0.5
--gt[0] $1
-mul[1] 255
-skeleton[1] 0
-if $6
-rgb2hsl
-split c
[0]
-reverse[3,-1]
-rm[-1]
-append[0,1,2] c
-append[1,2,3] c
-hsl2rgb
-endif
-mul[1] 255
-l[1]
{$2*5},{$2*5},1,1,0
-set[-1] 1,50%,50%
-l[-1]
-repeat $5
--blur_linear[0] $2,.5,{$4+((180/$5)*($>+1))}
-done
-rm[0]
-add
-endl
-convolve_fft[0] [1]
-endl
-mul[1] {1/$5}
-mul[1] {$3*10}
-if $7
-keep[1]
-else
-max
-endif
-c 0,255
-crop {$2},{$2},{$width+$2-1},{$height+$2-1}
-endl -a c -endl -done
#@gui Iain Unindex : iain_unindex,iain_unindex_preview(0)
#@gui : Smooth = float (30,0,100)
#@gui : Edge Threshold = float (20,0,50)
#@gui : Preview Zoom = bool(1)
#@gui : Zoom Center H = float(50,0,100)
#@gui : Zoom Center V = float(50,0,100)
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - released 19 Feb 2013")
iain_unindex:
amplitude=$1
sharpness=.3
anisotropy=1
gradient_smoothness=.6
tensor_smoothness=1
spatial_precision=0.8
angular_precision=30
value_precision=2
interpolation=0
fast_approx=1
-to_rgb
--smooth[0] $amplitude,$sharpness,$anisotropy,$gradient_smoothness,$tensor_smoothness,$spatial_precision,$angular_precision,$value_precision,$interpolation,$fast_approx
--luminance[-1]
-laplacian[-1]
-abs[-1]
-blur[-1] .5
-threshold[-1] $2
-mul[-1] -1
-add[-1] 1
-mul[-1] 255
-append[1,2] c
-blend alpha,1,0
-keep[-1]
iain_unindex_preview:
-iain_unindex $1,$2
-if {$3==1}
topleftx={$4-25}
toplefty={$5-25}
botleftx={$4+25}
botlefty={$5+25}
-crop $topleftx%,$toplefty%,$botleftx%,$botlefty%
-endif
#@gui Iain Weightmap : iain_weightmap, iain_weightmap
#@gui : Lap Weight = float (1,0,4)
#@gui : Blur Width = float (40,0,100)
iain_weightmap:
-split c
-max
255,1
-set[-1] 255,128,0
-blur[-1] $2
-n[-1] 0,255
--map[0] [1]
-rm[1]
-laplacian[0]
-mul[0] $1
-abs[0]
-add
#@gui IID Demosaic : iain_iid_demosaic,iain_iid_demosaic(0)
#@gui : 1 Starting Pattern = choice(1,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : 2 Clamp Radius = int (1,1,3)
#@gui : 3 Refinement Steps = int(1,0,10)
#@gui : 4 Reduce Moire = bool(0)
#@gui : sep = separator()
#@gui : 5 Use Gamma Adjustment = bool(0)
#@gui : sep = separator()
#@gui : note = note("IID is a demosaicing algorithm that produces good colour detail and works well in the presence of chromatic aberrations. It attempts to reduce moire patterns. Noise tends to render as a maze like texture.")
#@gui : sep = separator()
#@gui : note = note("<b>Clamp Radius:</b> Interploated green pixels are clamped to local values. A clamp radius of 1 reduces ringing and overshoots but may limit some detials. A clamp radius of 3 will give more detials but also more ringing and overshoots. Not much difference can been seen unless you zoom in.")
#@gui : note = note("<b>Refinement Steps:</b> Uses the initital demosaic as a guide for a new partial demosaic, and can be repeated. Each step gives better luma details and noise rendering but degrades chroma edges. Use a low value of clamp radius to reduce arefacts but also the effectiveness. Two or three refinements steps is probably the sweet spot.")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. 25 March 2017 - First release</small>")
iain_iid_demosaic:
pattern=$1
chroma_diff=1.5
chroma_radius=5
clamp_radius1=$2
-repeat $! -l[$>]
-if $5 -apply_gamma 2 -endif
--l
-l
-to_rgb
--iain_iid_demosaic_vertical[0] $pattern,$clamp_radius1
-iain_iid_demosaic_horizontal[0] $pattern,$clamp_radius1
--l
--l[0]
(1,-1)
-convolve[0] [1]
-k[0]
-abs
-blur 1
-split c
-add
-endl
--l[1]
(1;-1)
-convolve[0] [1]
-k[0]
-abs
-blur 1
-split c
-add
-endl
-sub[-1,-2]
--l[0]
--split c
-add[-1,-2,-3]
-mul[-1] {1/3}
-sub
--blur $chroma_radius
-sub
-abs
-blur 1
-split c
-add
-endl
--l[1]
--split c
-add[-1,-2,-3]
-mul[-1] {1/3}
-sub
--blur $chroma_radius
-sub
-abs
-blur 1
-split c
-add
-endl
-sub[-1,-2]
-mul[-1] $chroma_diff
-add[-1,-2]
-gt[-1] 0
# mask edges to force interpolation direction along edges
-line[-1] 0,0,100%,0%,1,0
-line[-1] 0,100%,100%,100%,1,0
-line[-1] 0,0,0%,100%,1,1
-line[-1] 100%,0%,100%,100%,1,1
--eq[-1] 0
# combine masked images
-mul[0,-1]
-mul[1,-1]
-max
-endl
-endl
-endl
-l[0,-1]
-if {$3>0}
-iain_luma_guided_demosaic $1,$3,$2
-else
-k[1]
-endif
-endl
-if $4
-l[-1,-2]
-l[0]
-rgb2yuv
-split c
-fill[0] 0.5
-append c
-yuv2rgb
-endl
-l[1]
-rgb2yuv
-split c
-fill[0] 0.5
-append c
-yuv2rgb
-endl
-iain_min_fft3_1 128
-endl
-rgb2yuv
-split c
-k[0,-1,-2]
-append c
-yuv2rgb
-else
-k[0]
-endif
-if $5 -apply_gamma 0.5 -endif
-endl -done
iain_min_fft3_1:
--l[0,1]
-append z
size=$1
cropwidth={w}
cropheight={h}
-resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,0
h_tile={h/$1}
v_tile={w/$1}
-split_tiles $v_tile,$h_tile
-apply_parallel "
-l[0]
-split z
-rgb2yuv
-fftpolar
-min[0,2]
-min[1,2]
-ifftpolar
-yuv2rgb
-endl
"
-append_tiles $v_tile,$h_tile
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-c 0,255
-endl
-k[-1]
iain_iid_demosaic_vertical:
-resize {w+8},{h+8},{d},{s},0,0,0.5,0.5
--l
-rgb2bayer $1,1
--l[0]
-to_rgb
-channels 1
(-0.1;0;0.6;1;0.6;0;-0.1)
-convolve[0] [1]
-remove[-1]
-endl
--iain_demosaic_clamp[0] $2
-rm[2]
-min[1,2]
-max[1,2]
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
-append[0,1,2] c
-add[0] 128
-rgb2bayer[0] $1,1
-split[0] c
-k[0,2,3]
-reverse[1,2]
--l[0,1]
-reverse
-iain_guided_fillgrid
-endl
--l[1,2]
-iain_guided_fillgrid
-endl
-rm[0,2]
-reverse[0,1]
-sub[0,2] 128
-add[0] [1]
-add[2] [1]
-append c
-c 0,255
-endl
-k[1]
-crop 4,4,{w-5},{h-5}
iain_iid_demosaic_horizontal:
-resize {w+8},{h+8},{d},{s},0,0,0.5,0.5
--l
-rgb2bayer $1,1
--l[0]
-to_rgb
-channels 1
(-0.1,0,0.6,1,0.6,0,-0.1)
-convolve[0] [1]
-remove[-1]
-endl
--iain_demosaic_clamp[0] $2
-rm[2]
-min[1,2]
-max[1,2]
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
-append[0,1,2] c
-add[0] 128
-rgb2bayer[0] $1,1
-split[0] c
-k[0,2,3]
-reverse[1,2]
--l[0,1]
-reverse
-iain_guided_fillgrid
-endl
--l[1,2]
-iain_guided_fillgrid
-endl
-rm[0,2]
-reverse[0,1]
-sub[0,2] 128
-add[0] [1]
-add[2] [1]
-append c
-c 0,255
-endl
-k[1]
-crop 4,4,{w-5},{h-5}
iain_demosaic_clamp:
-channels 1
--l
-if {$1>2}
--shift[0] 3,-2,0,0
--shift[0] -3,-2,0,0
--shift[0] -2,3,0,0
--shift[0] -2,-3,0,0
--shift[0] 3,0,0,0
--shift[0] -3,0,0,0
--shift[0] 0,3,0,0
--shift[0] 0,-3,0,0
-endif
-if {$1>1}
--shift[0] 1,2,0,0
--shift[0] -1,2,0,0
--shift[0] 2,1,0,0
--shift[0] 2,-1,0,0
--shift[0] 1,-2,0,0
--shift[0] -1,-2,0,0
--shift[0] -2,1,0,0
--shift[0] -2,-1,0,0
-endif
--shift[0] 1,0,0,0
--shift[0] -1,0,0,0
--shift[0] 0,1,0,0
-shift[0] 0,-1,0,0
--min[0--1]
-max[0--2]
-endl
-add[1] [0]
-add[2] [0]
iain_luma_guided_demosaic:
-resize {w+8},{h+8},{d},{s},0,0,0.5,0.5
-remove_opacity
-repeat $2
--l
--split[1] c
-add[-1,-2,-3]
-mul[-1] .33333333333333333
-rm[1]
-sub[0] [1]
-add[0] 255
-rgb2bayer[0] $1,1
-reverse
-split[1] c
--iain_guided_diagonal_interpolation[0,1]
--iain_guided_diagonal_interpolation[0,3]
-rm[1,3]
-reverse[1,2]
--iain_guided_straight_interpolation[0,1]
--iain_guided_straight_interpolation[0,2]
--iain_guided_straight_interpolation[0,3]
-rm[1,2,3]
-sub[1,2,3] 255
-append[1,2,3] c
-to_rgb
-add
-c 0,255
-endl
-rm[1]
-if {$3>0}
-endif
-done
-k[1]
-crop 4,4,{w-5},{h-5}
#@gui Luminance NR : luminance_nr, luminance_nr(0)
#@gui : note = note{"Normal Patch based smoothing (scale 1)"}
#@gui : Patch Variance = float (10,0,50)
#@gui : Fast Approximation = bool (1)
#@gui : Iterations = int (1,1,5)
#@gui : sep = separator ()
#@gui : note = note{"Smoothing of addition scales"}
#@gui : Scale 2 = float (6,0,25)
#@gui : Scale 3 = float (5,0,25)
#@gui : Scale 4 = float (4,0,25)
#@gui : Scale 5 = float (3,0,25)
#@gui : Scale 6 = float (2,0,25)
#@gui : Scale 7 = float (1,0,25)
#@gui : sep = separator ()
#@gui : note = note{"Restore details"}
#@gui : Threshold = float (5000,0,5000)
#@gui : Tile Size = int (64,32,128)
#@gui : Gamma = float (1.3,1,4)
#@gui : sep = separator ()
#@gui : note = note("This filter is <b>slow!</b>")
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 2012/19/08")
luminance_nr:
-apply_gamma {1/$12}
-ac"
--ms_patch_smooth[0] 10,$1,3,3,0,$2,$3,0,$4,$5,$6,$7,$8,$9,1
--compose_grainextract
-fft_tile[-1] $10,$11,0
-compose_grainmerge[1,2]
-keep[-1]
",7
-apply_gamma $12
#@gui Luminance NR2 : luminance_nr_two, luminance_nr_two(0)
#@gui : Patch Variance = float (10,0.1,20)
#@gui : Fast Approximation = bool (1)
#@gui : Iterations = int (1,1,5)
#@gui : sep = separator ()
#@gui : note = note("Adjust NR for for larger scales as %")
#@gui : Scale 2 = float (.8,0,1)
#@gui : Scale 3 = float (.7,0,1)
#@gui : Scale 4 = float (.6,0,1)
#@gui : Scale 5 = float (.5,0,1)
#@gui : Scale 6 = float (.4,0,1)
#@gui : Scale 7 = float (.3,0,1)
#@gui : sep = separator ()
#@gui : note = note("Master threshold for details")
#@gui : Threshold = float (1200,0,10000)
#@gui : Tile Size = int (64,32,128)
#@gui : Nothing = float (0,0,0)
#@gui : sep = separator ()
#@gui : note = note("Adjust threshold for detials")
#@gui : Fine = float (0,-1000,1000)
#@gui : Medium = float (0,-1000,1000)
#@gui : Course = float (0,-1000,1000)
#@gui : Recover Detail = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Adjust noise reduction by tone")
#@gui : Blacks = int (0,0,500)
#@gui : Darks = int (0,0,500)
#@gui : Midtones = int (0,0,500)
#@gui : Lights = int (0,0,500)
#@gui : White = int (0,0,500)
#@gui : sep = separator ()
#@gui : Median Pass First = bool (0)
#@gui : note = note("This filter is <b>slow!</b>")
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 25 August 2012")
fft_tile2_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
-box_blur[-1] {$2*0.01}
--add[1] [-1]
-threshold[-1] {$1/(128/$2)}
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-keep[-1]
fft_tile2_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile2_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile2:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$3==0}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$3==0}
-iain_median_5_stack
-endif
luminance_nr_two:
-ac "
-mul 9.99
-apply_curve 0,0,0,510,{510-$17},1020,{1020-$17-$18},1530,{1530-$17-$18-$19},2040,{2040-$17-$18-$19-$20},2550,{2550-$17-$18-$19-$20-$21},2550,2550
-mul 0.1
-if {$22==1}
--median[0] 3
-ms_patch_smooth[-1] 10,$1,3,3,0,$2,$3,0,{$1*$4},{$1*$5},{$1*$6},{$1*$7},{$1*$8},{$1*$9},1
-endif
-if {$22==0}
--ms_patch_smooth[0] 10,$1,3,3,0,$2,$3,0,{$1*$4},{$1*$5},{$1*$6},{$1*$7},{$1*$8},{$1*$9},1
-endif
-if {$16==1}
--compose_grainextract
-fft_tile2[-1] $10,$11,3,$13,$14,$15
-compose_grainmerge[1,2]
-endif
-keep[-1]
-mul 9.99
-apply_curve 0,0,0,{510-$17},510,{1020-$17-$18},1020,{1530-$17-$18-$19},1530,{2040-$17-$18-$19-$20},2040,{2550-$17-$18-$19-$20-$21},2550,2550,2550
-mul 0.1
",7
-c 0,255
#@gui Minimum Chroma Demosaic : iain_minimum_chroma_demosaic,iain_minimum_chroma_demosaic(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : Moire Size = choice (2,"Small","Medium","Large","Extra Large")
#@gui : Detials = choice(0,"Less detial but better colour edges","More detial but degraded colour edges")
iain_minimum_chroma_demosaic:
-rgb2bayer $1,1
cropwidth={w}
cropheight={h}
-resize {w+16},{h+16},{d},{s},0,0,0.5,0.5
--l
-if {$3==0}
--iain_horizontal_interpolate[0] $1,1
-iain_vertical_interpolate[0] $1,1
-elif {$3==1}
--iain_tuned_horizontal[0] $1
-iain_tuned_vertical[0] $1
-endif
-l[0]
-rgb2yuv
-split c
-fill[0] .5
-append c
-yuv2rgb
-endl
-l[1]
-rgb2yuv
-split c
-fill[0] .5
-append c
-yuv2rgb
-endl
-append z
levels={$2+1}
size={3^$levels}
cropwidth2={w}
cropheight2={h}
-resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1
-repeat $levels
-l[-1]
--resize[0] 33.33333%,33.33333%,{d},{s},2
--iain_resize_x3[-1]
-sub[0,-1]
-endl
-done
-repeat {$!-1} -l[{$<}]
-split z
--abs
-gt[-1] [-2]
-rm[-2]
--eq[-1] 0
-mul[0,2]
-mul[1,2]
-add
-endl -done
-l[-1]
-split z
-k[1]
-endl
-repeat {$!-1}
-iain_resize_x3[-1]
-add[-1,-2]
-done
-crop 0,0,{$cropwidth2-1},{$cropheight2-1}
-c 0,255
-endl
-iain_chroma_guide $1,1
-crop 8,8,{$cropwidth+7},{$cropheight+7}
iain_chroma_guide:
-to_rgb
-rgb2bayer[0] $1,1
--l[0,1]
-split[-1] c
-split[0] c
-name[0] red -name[1] green -name[2] blue
-name[-3] redblur -name[-2] greenblur -name[-1] blueblur
--sub[greenblur] [redblur]
--sub[greenblur] [blueblur]
-name[-1] bluemul -name[-2] redmul
-remove[redblur,greenblur,blueblur]
-add[red] [redmul]
-add[blue] [bluemul]
-keep[red,green,blue]
-append c
-rgb2bayer $1,1
-split c
-add
-endl
-rm[1]
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
-append[0,1,2] c
-add[0] 128
-rgb2bayer[0] $1,1
-split[0] c
-rm[1,-1,-2,-3]
--l[0,2]
-reverse
-iain_guided_fillgrid
-endl
-rm[0]
--l[0,1]
-reverse
-iain_guided_fillgrid
-endl
-rm[0]
-reverse[0,1]
-sub[0,2] 128
-add[0] [1]
-add[2] [1]
-append c
-c 0,255
iain_resize_x3:
-resize[0] {(w*3)-2},{(h*3)-2},{d},{s},5,0
-resize[0] {w+2},{h+2},{d},{s},0,1,0.5,0.5
iain_vertical_interpolate:
-rgb2bayer[0] $1,1
--l[0]
-channels 1
(-0.1;0;0.6;1;0.6;0;-0.1)
-convolve[0] [-1]
-rm[-1]
-endl
-c 0,255
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
-append[0,1,2] c
-add[0] 128
-rgb2bayer[0] $1,1
-split[0] c
-rm[1,-1,-2,-3]
--l[0,2]
-reverse
-iain_guided_fillgrid
-endl
-rm[0]
--l[0,1]
-reverse
-iain_guided_fillgrid
-endl
-rm[0]
-reverse[0,1]
-sub[0,2] 128
-add[0] [1]
-add[2] [1]
-append c
-c 0,255
iain_horizontal_interpolate:
-rgb2bayer[0] $1,1
--l[0]
-channels 1
(-0.1,0,0.6,1,0.6,0,-0.1)
-convolve[0] [-1]
-rm[-1]
-endl
-c 0,255
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
-append[0,1,2] c
-add[0] 128
-rgb2bayer[0] $1,1
-split[0] c
-rm[1,-1,-2,-3]
--l[0,2]
-reverse
-iain_guided_fillgrid
-endl
-rm[0]
--l[0,1]
-reverse
-iain_guided_fillgrid
-endl
-rm[0]
-reverse[0,1]
-sub[0,2] 128
-add[0] [1]
-add[2] [1]
-append c
-c 0,255
iain_guided_fillgrid:
-channels 0
-l[0]
(1,0;0,-1)
--convolve[0] [1]
-rm[1]
(0,1;-1,0)
--convolve[0] [2]
-rm[2]
-l[-1,-2]
-abs
-blur 1
--max
-eq[0] [-1]
-keep[0]
-mul 255
-endl
-endl
--l[2]
--l[0]
(0,0,0.5;0,1,0;0.5,0,0)
-convolve[0] [1]
-remove[1]
-endl
-l[0]
(0.5,0,0;0,1,0;0,0,0.5)
-convolve[0] [1]
-remove[1]
-endl
-endl
-move[1] 5
-append[-1,-2] c
-blend[-1,-2] alpha,1,0
-rm[1]
-l[0]
(1,-1)
--convolve[0] [1]
-rm[1]
(1;-1)
--convolve[0] [2]
-rm[2]
-l[-1,-2]
-abs
-blur 1
--max
-eq[0] [-1]
-keep[0]
-mul 255
-endl
-endl
--l[2]
--l[0]
(0.5;1;0.5)
-convolve[0] [1]
-remove[1]
-endl
-l[0]
(0.5,1,0.5)
-convolve[0] [1]
-remove[1]
-endl
-endl
-move[1] 5
-append[-1,-2] c
-blend[-1,-2] alpha,1,0
-k[-1]
iain_tuned_horizontal:
-remove_opacity
-l[0]
--fill[0] 1
-rgb2bayer[1] $1,1
--l[0]
-split c
-add
(-0.025,0.1,-0.225,0.4,0.5,0.4,-0.225,0.1,-0.025)
-convolve[0] [1]
-rm[1]
-endl
--l[1,2]
-shift[0] 1,0,0,0,2
-mul
-endl
-add[-1] [0]
-channels[-1] 1
-k[0,-1]
-to_rgb
-iain_luma_guide $1,1,0
-endl
iain_tuned_vertical:
-remove_opacity
-l[0]
--fill[0] 1
-rgb2bayer[1] $1,1
--l[0]
-split c
-add
(-0.025;0.1;-0.225;0.4;0.5;0.4;-0.225;0.1;-0.025)
-convolve[0] [1]
-rm[1]
-endl
--l[1,2]
-shift[0] 1,0,0,0,2
-mul
-endl
-add[-1] [0]
-channels[-1] 1
-k[0,-1]
-to_rgb
-iain_luma_guide $1,1,0
-endl
iain_luma_guide:
-remove_opacity
-if $3
-mul {1/255}
-pow 2.2
-mul 255
-endif
-repeat $2
--l
--split[1] c
-add[-1,-2,-3]
-mul[-1] .33333333333333333
-rm[1]
-sub[0] [1]
-add[0] 255
-rgb2bayer[0] $1,1
-reverse
-split[1] c
--iain_guided_diagonal_interpolation[0,1]
--iain_guided_diagonal_interpolation[0,3]
-rm[1,3]
-reverse[1,2]
--iain_guided_straight_interpolation[0,1]
--iain_guided_straight_interpolation[0,2]
--iain_guided_straight_interpolation[0,3]
-rm[1,2,3]
-sub[1,2,3] 255
-append[1,2,3] c
-to_rgb
-add
-c 0,255
-endl
-rm[1]
-done
-keep[1]
-if $3
-mul {1/255}
-pow {1/2.2}
-mul 255
-endif
iain_guided_diagonal_interpolation:
--l[0]
(1,0;0,-1)
--convolve[0] [1]
-rm[1]
(0,1;-1,0)
--convolve[0] [2]
-rm[2]
-l[-1,-2]
-abs
-blur 1.5
--min
-eq[0] [-1]
-keep[0]
-endl
-rm[-2]
-endl
-l[1]
--l[0]
(0,0,0.5;0,1,0;0.5,0,0)
-convolve[0] [1]
-remove[1]
-endl
-l[0]
(0.5,0,0;0,1,0;0,0,0.5)
-convolve[0] [1]
-remove[1]
-endl
-endl
-rm[0]
--eq[-1] 0
-mul[0,2]
-mul[1,2]
-add
iain_guided_straight_interpolation :
--l[0]
(1,-1)
--convolve[0] [1]
-rm[1]
(1;-1)
--convolve[0] [2]
-rm[2]
-l[-1,-2]
-abs
-blur 1.5
--min
-eq[0] [-1]
-keep[0]
-endl
-rm[-2]
-endl
-l[1]
--l[0]
(0.5;1;0.5)
-convolve[0] [1]
-remove[1]
-endl
-l[0]
(0.5,1,0.5)
-convolve[0] [1]
-remove[1]
-endl
-endl
--eq[-1] 0
-mul[1,3]
-mul[2,3]
-add[1,2]
-keep[1]
#@gui Moire Removal Not Parallel : iain_moire_removal_NP, iain_moire_removal_NP(0)
#@gui : Smoothing = float (5,0,20)
#@gui : Smart Threshold = float (5,0,10)
#@gui : Moire Removal Method = choice(0,"Smart","Aggresive","Smooth only")
#@gui : sep = separator()
#@gui : note = note("This filter is the same as the other one but doe snot have parallel processing" )
#@gui : sep = separator()
#@gui : note = note("Moire removal consists of two parts, first, an edge-protected smoothing and second a frequency analyisis of the difference between the smoothed and original image. The image is broken into tiles, and each tile processed. A tile that is a solid colour is skipped." )
#@gui : note = note("Smoothing must be high enough to remove the moire. The <b>Smart Threshold</b> sets the detection of moire for each frequency on each colour channel. If a frequency in one colour channel is determined to be moire it is replaced by the colour channel least likely to have moire." )
#@gui : note = note("The <b>Agressive</b> setting skips the thresolding step and uses the lowest frequency level from the colour channels." )
#@gui : note = note("The filter will reduce chroma details/noise" )
iain_moire_removal_NP:
tile_size=256
overlap=16
cropwidth={w}
cropheight={h}
-if {$cropwidth%$tile_size>0}
-resize[0] {w+($tile_size-w%$tile_size)},100%,1,{s},0,1
-endif
-if {$cropheight%$tile_size>0}
-resize[0] 100%,{h+($tile_size-h%$tile_size)},1,{s},0,1
-endif
h_tiles={w/$tile_size}
v_tiles={h/$tile_size}
-repeat $v_tiles,v_count
-repeat $h_tiles,h_count
--crop[0] {($h_count*$tile_size)-$overlap},{($v_count*$tile_size)-$overlap},{($h_count*$tile_size)+($tile_size+$overlap-1)},{($v_count*$tile_size)+($tile_size+$overlap-1)},1
-done
-done
-rm[0]
-repeat $! -l[$>]
-if {iM!=im}
[0]
-l[1]
-l[0]
-repeat 3
-l[-1]
-repeat 2
-denoise[0] 10,{$1/($>+1)},5,5,0,{min($>,1)}
-done
--resize[0] 50%,50%,{d},{s},2
--resize[-1] 200%,200%,{d},{s},3
-sub[0,-1]
-endl
-done
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-done
-endl
-endl
-if {$3<2}
-sub[0] [1]
-l[0]
-fftpolar[0]
-if {$3==1}
-append[0,1] x
-split[0] c
-min
-split[0] x,2
-elif {$3==0}
-fill[1] if(max(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))-min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))<$2,min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2)),(i(x,y,z,c)))
-endif
-ifftpolar[0,1]
-keep[0]
-endl
-to_rgb
-add
-else
-keep[1]
-endif
-c 0,255
-endif
-endl
-progress {($>/$!)*100}
-done
-repeat $! -l[$>]
-crop $overlap,$overlap,{$tile_size+$overlap-1},{$tile_size+$overlap-1}
-endl
-done
-append_tiles $h_tiles,$v_tiles
-crop 0,0,{$cropwidth-1},{$cropheight-1}
#@gui Ms Nlmeans C Noise2 : ms_nlmeans_c_noise2_p,ms_nlmeans_c_noise2_p_preview(0)
#@gui : note = note("<b>Noise Reduction</b>")
#@gui : 1 Fine = float(3,0,10)
#@gui : 2 Coarse = float(1,0,10)
#@gui : 3 Blacks = float (0,-10,10)
#@gui : 4 Shadows = float (0,-10,10)
#@gui : 5 Midtones = float (0,-10,10)
#@gui : 6 Highlights = float (0,-10,10)
#@gui : 7 Whites = float (0,-10,10)
#@gui : 8 Smooth Curve = float (10,0,50)
#@gui : sep = separator ()
#@gui : note = note("<b>Advanced settings</b>")
#@gui : 9 Patch Size = float(2,1,10)
#@gui : 10 Search Radius = int(4,1,10)
#@gui : 11 Patch Size = float(2,1,10)
#@gui : 12 Search Radius = int(7,1,10)
#@gui : sep = separator ()
#@gui : note = note("Side chain Processing")
#@gui : 13 Red/Blue Median = bool(0)
#@gui : 14 Green Despeckle = bool(0)
#@gui : sep = separator ()
#@gui : 15 Use Noise Estimate = bool(0)
#@gui : sep = separator ()
#@gui : 16 Show Info = bool(0)
ms_nlmeans_c_noise2_p_preview:
-if $16
-remove_opacity
--ms_nlmeans_c_noise2[0] ${1--1}
-sub
-mul 2
-add 128
-c 0,255
-else
-ms_nlmeans_c_noise2[0] ${1--1}
-endif
ms_nlmeans_c_noise2_p:
-ms_nlmeans_c_noise2[0] ${1--1}
ms_nlmeans_c_noise2:
-remove_opacity
hf_strength={2^$1}
lf_strength={2^$2}
hf_patch=$9
hf_search=$10
lf_patch=$11
lf_search=$12
sc_rb=$13
sc_g=$14
blacks={2^$3}
shadows={2^$4}
midtones={2^$5}
highlights={2^$6}
whites={2^$7}
smooth=$8
shadow={2^$3}
highlight={2^$4}
levels=1
size={3^$levels}
cropwidth={w}
cropheight={h}
-resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1
--l[0]
-split c
-if $sc_rb
-median[0,2] 4
-endif
-if $sc_g
-l[1]
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
-endl
-endif
-append c
-luminance
-endl
-if $11
--c_noise[0] 1.6
-else
[1]
-to_rgb[-1]
-negate[-1]
-add[-1] .1
-mul[-1] .1
-blur[-1] 2
-endif
--l[1]
255,1,1,1,1
-line[-1] 0,0,50,0,1,$blacks
-line[-1] 51,0,100,0,1,$shadows
-line[-1] 101,0,152,0,1,$midtones
-line[-1] 153,0,204,0,1,$highlights
-line[-1] 205,0,255,0,1,$whites
-blur[-1] $smooth
-map[0] [1]
-keep[0]
-endl
-mul[2,-1]
--l[0,1,2]
-mul[-1] $hf_strength
-f[-1] '-3.0/i' -nlmeans_core[0] [1],[2],$hf_patch,$hf_search
-keep[0]
-endl
-reverse[0,-1]
-rm[-1]
--l[0,1,2]
-resize[0,1,2] 33.33333%,33.33333%,{d},{s},2
-mul[-1] $lf_strength
-f[-1] '-3.0/i' -nlmeans_core[0] [1],[2],$lf_patch,$lf_search
-keep[0]
-endl
-rm[1,2]
--resize[0] 33.33333%,33.33333%,{d},{s},2
-linear_x3[-1]
-sub[0,-1]
-linear_x3[-1]
-add
-c 0,255
## -repeat {$!-1}
## -done
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-c 0,255
c_noise:
width={w}
height={h}
--l[0]
--shift[0] 0,1,0,0,2
--shift[0] 0,-1,0,0,2
-blend_median
-endl
-sub
-abs
-add .1
-pow $1
-resize 25%,25%,1,3,2
-median 3
-resize $width,$height,1,3,3
#@gui MS Patch Chroma : ms_patch_c, ms_patch_c_preview(0)
#@gui : note = note{"Master Patch based smoothing (scale 1)"}
#@gui : Patch Variance = float (5,0.1,50)
#@gui : Median Pass = bool (1)
#@gui : Global Iterations = int (1,1,5)
#@gui : sep = separator ()
#@gui : Scale 2 = float (5,0,25)
#@gui : Scale 3 = float (4,0,25)
#@gui : Scale 4 = float (3,0,25)
#@gui : Scale 5 = float (2,0,25)
#@gui : Scale 6 = float (1,0,25)
#@gui : Scale 7 = float (1,0,25)
#@gui : Undo Gamma = float (1.3,1,3)
#@gui : sep = separator ()
#@gui : note = note{"Customise Luma weighting"}
#@gui : Red = float (0.375,0,1)
#@gui : Green = float (.5,0,1)
#@gui : Blue = float (0.125,0,1)
#@gui : sep = separator ()
#@gui : Show Difference = bool (0)
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 10 December 2012 - added show difference option and changed interations from local operation to global operation.")
create_luma_mix:
--split[0] c
-mul[1] {$1/($1+$2+$3)}
-mul[2] {$2/($1+$2+$3)}
-mul[3] {$3/($1+$2+$3)}
-add[1-3]
-keep[-1]
-to_gray[-1]
ms_patch_c:
-to_rgb
--create_luma_mix[0] $11,$12,$13
-name[-1] luma
-if {$2==1}
-median[0] 3
-median[0] 3
-endif
-repeat $3
-ms_patch_smooth[0] 10,$1,3,5,0,1,1,0,$4,$5,$6,$7,$8,$9,$10
-done
--create_luma_mix[0] $11,$12,$13
-sub[0] [-1]
-add[0] [1]
-keep[0]
-c 0,255
ms_patch_c_preview:
-if {$-1==0}
-ms_patch_c ${1--2}
-endif
-if {$-1==1}
--ms_patch_c ${1--2}
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
#@gui MS Patch NR : MS_Patch_NR,MS_Patch_NR(0)
#@gui : Gamma = float(1.3,.5,2)
#@gui : Fine = float(0,0,250)
#@gui : Coarse = float(0,0,250)
#@gui : Coarsest = float(0,0,250)
#@gui : Patch Size = int(3,3,7)
#@gui : Search Radius = int(5,3,17)
linear_x3:
-resize 300%,300%,{d},{s},4,1,.5,.5,0
(.11111,.22222,.33333,.22222,.11111;.22222,.44444,.66666,.44444,.22222;.33333,.66666,1,.66666,.33333;.22222,.44444,.66666,.44444,.22222;.11111,.22222,.33333,.22222,.11111)
-convolve[0] [1],0
-rm[1]
MS_Patch_NR:
-if {$1!=1}
-apply_parallel_overlap "-div 255 -pow $1 -mul 255"
-endif
cropwidth={w}
cropheight={h}
-resize[0] {w+(90-w%90)},{h+(90-h%90)},1,{s},0,1
-l[0]
width={w}
height={h}
-if {$2>0}
-apply_parallel_overlap[-1] "-denoise 10,{$2/10},$5,$6,0,0",16
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$3>0}
-apply_parallel_overlap[-1] "-denoise 10,{$3/10},$5,$6,0,0",16
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$4>0}
-apply_parallel_overlap[-1] "-denoise 10,{$4/10},$5,$6,0,0",16
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-if {$1!=1}
-apply_parallel_overlap "-div 255 -pow {1/$1} -mul 255"
-endif
-c 0,255
#@gui MS Patch NR3 : MS_Patch_NR3,MS_Patch_NR3_p(0)
#@gui : Gamma = float(1.3,.5,2)
#@gui : L Fine = int(0,0,250)
#@gui : L Coarse = int(0,0,250)
#@gui : L Coarsest = int(0,0,250)
#@gui : Patch Size = int(3,3,7)
#@gui : Search Radius = int(5,3,17)
#@gui : Fast = choice (1,"smooth","fast")
#@gui : Pre Salt and Pepper = choice (0,"none","smooth","fast","strong")
#@gui : Post Salt and Pepper = choice (0,"none","smooth","fast","strong")
#@gui : C Fine = int(0,0,250)
#@gui : C Coarse = int(0,0,250)
#@gui : C Coarsest = int(0,0,250)
MS_Patch_NR3_p:
-to_rgb
-MS_Patch_NR3[0] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
-n 0,255
linear_x3:
-resize 300%,300%,{d},{s},4,1,.5,.5,0
(.11111,.22222,.33333,.22222,.11111;.22222,.44444,.66666,.44444,.22222;.33333,.66666,1,.66666,.33333;.22222,.44444,.66666,.44444,.22222;.11111,.22222,.33333,.22222,.11111)
-convolve[0] [1],0
-rm[1]
MS_Patch_NR3:
-apply_parallel_overlap[-1] "
-if {$1!=1}
-div 255 -pow $1 -mul 255
-endif
-if {$8==1}
-iain_pixel_denoise_p 1,1,0,0,1
-elif {$8==2}
-iain_pixel_denoise_p 2,1,0,0,1
-elif {$8==3}
-hybrid16 -hybrid16 -hybrid16
-endif
cropwidth={w}
cropheight={h}
-resize[0] {w+(90-w%90)},{h+(90-h%90)},1,{s},0,1
-rgb2yuv8
-split c
-l[0]
width={w}
height={h}
-if {$2>0}
-denoise 10,{$2/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$3>0}
-denoise 10,{$3/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$4>0}
-denoise 10,{$4/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-l[1]
width={w}
height={h}
-if {$10>0}
-denoise 10,{$10/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$11>0}
-denoise 10,{$11/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$12>0}
-denoise 10,{$12/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-l[2]
width={w}
height={h}
-if {$10>0}
-denoise 10,{$10/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$11>0}
-denoise 10,{$11/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$12>0}
-denoise 10,{$12/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-append c
-yuv82rgb
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-if {$1!=1}
-div 255 -pow {1/$1} -mul 255
-endif
-if {$9==1}
-iain_pixel_denoise_p 1,1,0,0,1
-elif {$9==2}
-iain_pixel_denoise_p 2,1,0,0,1
-elif {$9==3}
-hybrid16 -hybrid16 -hybrid16
-endif
-c 0,255
",64
#@gui Multi Scale Patch Smoothing : ms_patch_smooth,ms_patch_smooth_preview(0)
#@gui : note = note{"Normal Patch based smoothing (scale 1)"}
#@gui : Spatial Variance = float (10,0,20)
#@gui : Patch Variance = float (5,0.1,50)
#@gui : Patch Size = int (3,2,21)
#@gui : Lookup Size = int (5,2,21)
#@gui : Patch Smoothness = float (0,0,4)
#@gui : Fast Approximation = bool (1)
#@gui : Iterations = int (1,1,5)
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator ()
#@gui : note = note{"Patch Variance for additional scales"}
#@gui : Scale 2 = float (5,0,25)
#@gui : Scale 3 = float (4,0,25)
#@gui : Scale 4 = float (3,0,25)
#@gui : Scale 5 = float (2,0,25)
#@gui : Scale 6 = float (1,0,25)
#@gui : Scale 7 = float (1,0,25)
#@gui : Undo Gamma = float (1.3,1,3)
#@gui : sep = separator ()
#@gui : Show Difference = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 28 August 2012 - minor speed up, but level 7 does not do anything now.")
ms_patch_smoothsmoothing:
-ac "-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done",$8 -c 0,255
ms_patch_smooth:
lvl2=2
lvl3=3
lvl4=4
lvl5=5
lvl6=6
lvl7=8
-apply_gamma {1/$15}
-ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
-name[0] full
--resize[full] {full,w/$lvl2},{full,h/$lvl2},1,{s},2 -name[1] level2
--ms_patch_smoothsmoothing[level2] $1,$9,$3,$4,$5,$6,$7,$8  -name[2] level2clean
--resize[level2] {0,w},{0,h},1,{s},5  -name[3] low2
--sub[full] [low2]  -name[4] level2high
-remove[level2,low2]
--resize[level2clean] {full,w/$lvl3},{full,h/$lvl3},1,{s},2 -name[3] level3
--ms_patch_smoothsmoothing[level3] $1,$10,$3,$4,$5,$6,$7,$8  -name[4] level3clean
--resize[level3] {level2clean,w},{level2clean,h},1,{s},5  -name[5] low3
--sub[level2clean] [low3]  -name[6] level3high
-remove[level3,low3]
--resize[level3clean] {full,w/$lvl4},{full,h/$lvl4},1,{s},2 -name[5] level4
--ms_patch_smoothsmoothing[level4] $1,$11,$3,$4,$5,$6,$7,$8  -name[6] level4clean
--resize[level4] {level3clean,w},{level3clean,h},1,{s},5  -name[7] low4
--sub[level3clean] [low4]  -name[8] level4high
-remove[level4,low4]
--resize[level4clean] {full,w/$lvl5},{full,h/$lvl5},1,{s},2 -name[-1] level5
--ms_patch_smoothsmoothing[level5] $1,$12,$3,$4,$5,$6,$7,$8  -name[-1] level5clean
--resize[level5] {level4clean,w},{level4clean,h},1,{s},5  -name[-1] low5
--sub[level4clean] [low5]  -name[-1] level5high
-remove[level5,low5]
--resize[level5clean] {full,w/$lvl6},{full,h/$lvl6},1,{s},2 -name[-1] level6
--ms_patch_smoothsmoothing[level6] $1,$13,$3,$4,$5,$6,$7,$8  -name[-1] level6clean
--resize[level6] {level5clean,w},{level5clean,h},1,{s},5  -name[-1] low6
--sub[level5clean] [low6]  -name[-1] level6high
-remove[level6,low6]
-name[-2] base
-resize[base] {level6high,w},{level6high,h},1,{s},5
-add[base] [level6high]
-remove[level6high]
-resize[base] {level5high,w},{level5high,h},1,{s},5
-add[base] [level5high]
-remove[level5high]
-resize[base] {level4high,w},{level4high,h},1,{s},5
-add[base] [level4high]
-remove[level4high]
-resize[base] {level3high,w},{level3high,h},1,{s},5
-add[base] [level3high]
-remove[level3high]
-resize[base] {level2high,w},{level2high,h},1,{s},5
-add[base] [level2high]
-remove[level2high]
-keep[-1]
-c 0,255
-apply_gamma {$15}
-c 0,255
ms_patch_smooth_preview:
-if {$-1==0}
-ms_patch_smooth ${1--2}
-endif
-if {$-1==1}
--ms_patch_smooth ${1--2}
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
#@gui Multi Scale Smoothing : ms_smooth,ms_smooth_preview(0)
#@gui : Smooth Scale 1 = float (0,0,100)
#@gui : Smooth Scale 2 = float (0,0,100)
#@gui : Smooth Scale 3 = float (0,0,100)
#@gui : Smooth Scale 4 = float (0,0,100)
#@gui : Smooth Scale 5 = float (0,0,100)
#@gui : Smooth Scale 6 = float (0,0,100)
#@gui : Smoothness = float (2,0,15)
#@gui : Log Scales = bool (0)
#@gui : Global Repeats = int (2,0,5)
#@gui : Show Difference = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 7 Dec 2012")
ms_smoothsmoothing:
-smooth {$1*5},0.7,0.7,0.6,$2,0.8,30,2,0,1
ms_smooth:
-if {$8==0}
lvl2=2
lvl3=3
lvl4=4
lvl5=5
lvl6=6
-endif
-if {$8==1}
lvl2=2
lvl3=4
lvl4=8
lvl5=16
lvl6=32
-endif
-repeat $9
-if {$1>0}
-ms_smoothsmoothing[-1] $1,$7
-endif
-name[0] full
--resize[full] {full,w/$lvl2},{full,h/$lvl2},1,{s},2 -name[1] level2
-if {$2>0}
--ms_smoothsmoothing[level2]  $2,$7
-else [level2]
-endif
-name[2] level2clean
--resize[level2] {0,w},{0,h},1,{s},5  -name[3] low2
--sub[full] [low2]  -name[4] level2high
-remove[level2,low2]
--resize[level2clean] {full,w/$lvl3},{full,h/$lvl3},1,{s},2 -name[3] level3
-if {$3>0}
--ms_smoothsmoothing[level3] $3,$7
-else [level3]
-endif
-name[4] level3clean
--resize[level3] {level2clean,w},{level2clean,h},1,{s},5  -name[5] low3
--sub[level2clean] [low3]  -name[6] level3high
-remove[level3,low3]
--resize[level3clean] {full,w/$lvl4},{full,h/$lvl4},1,{s},2 -name[5] level4
-if {$4>0}
--ms_smoothsmoothing[level4] $4,$7
-else [level4]
-endif
-name[6] level4clean
--resize[level4] {level3clean,w},{level3clean,h},1,{s},5  -name[7] low4
--sub[level3clean] [low4]  -name[8] level4high
-remove[level4,low4]
--resize[level4clean] {full,w/$lvl5},{full,h/$lvl5},1,{s},2 -name[-1] level5
-if {$5>0}
--ms_smoothsmoothing[level5] $5,$7
-else [level5]
-endif
-name[-1] level5clean
--resize[level5] {level4clean,w},{level4clean,h},1,{s},5  -name[-1] low5
--sub[level4clean] [low5]  -name[-1] level5high
-remove[level5,low5]
--resize[level5clean] {full,w/$lvl6},{full,h/$lvl6},1,{s},2 -name[-1] level6
-if {$6>0}
--ms_smoothsmoothing[level6]  $6,$7
-else [level6]
-endif
-name[-1] level6clean
--resize[level6] {level5clean,w},{level5clean,h},1,{s},5  -name[-1] low6
--sub[level5clean] [low6]  -name[-1] level6high
-remove[level6,low6]
-name[-2] base
-resize[base] {level6high,w},{level6high,h},1,{s},5
-add[base] [level6high]
-remove[level6high]
-resize[base] {level5high,w},{level5high,h},1,{s},5
-add[base] [level5high]
-remove[level5high]
-resize[base] {level4high,w},{level4high,h},1,{s},5
-add[base] [level4high]
-remove[level4high]
-resize[base] {level3high,w},{level3high,h},1,{s},5
-add[base] [level3high]
-remove[level3high]
-resize[base] {level2high,w},{level2high,h},1,{s},5
-add[base] [level2high]
-remove[level2high]
-keep[-1]
-c 0,255
-c 0,255
-done
ms_smooth_preview:
-if {$-1==0}
-ms_smooth $1,$2,$3,$4,$5,$6,$7,$8,$9
-endif
-if {$-1==1}
--ms_smooth $1,$2,$3,$4,$5,$6,$7,$8,$9
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
#@gui Noise Reduction 3 : nr3,nr3(0)
#@gui : 1 Strength = float (1,.25,4)
#@gui : 2 Threshold = float (1,.0,500)
#@gui : 3 Master Detail Recovery = float (0,0,2000)
#@gui : 4 Adjust Fine Details = float (0,-500,500)
#@gui : 5 Adjust Medium Details = float (0,-500,500)
#@gui : 6 Adjust Large Details = float (0,-500,500)
#@gui : 7 Enhance Detials = float (1,0,5)
#@gui : sep = separator ()
#@gui : note = note("<b> sharpen edges</b>")
#@gui : 8 Radius = float (.75,.25,5)
#@gui : 9 Amount = float (1,0,4)
#@gui : 10 Threshold = float (0,0,5000)
#@gui : sep = separator ()
#@gui : note = note("<b> sharpen details</b>")
#@gui : 11 Radius = float (.75,.25,5)
#@gui : 12 Amount = float (1,0,4)
#@gui : 13 Threshold = float (0,0,5000)
#@gui : sep = separator ()
#@gui : note = note{"This filter is only intented for and has only been tested on greyscale images." }
#@gui : note = note{"This filter measures noise in at five different brightnesses, if your preview does not have a full range of brightness shown the preview will not give an accurate indication of the final results."}
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 11 November 2012 - minor quality improvements.")
med3stack16:
-blend_median
med5stack16:
-blend_median
cross16:
--shift[0] 0,1,0,0,2
--shift[0] 0,-1,0,0,2
--shift[0] 1,0,0,0,2
--shift[0] -1,0,0,0,2
-blend_median
ex16:
--shift[0] 1,1,0,0,2
--shift[0] 1,-1,0,0,2
--shift[0] -1,-1,0,0,2
--shift[0] -1,1,0,0,2
-blend_median
hybrid16:
--cross16[0]
--ex16[0]
-blend_median
autonr2:
--crop 30%,30%,70%,70%
noise0=${-variance_noise}
-remove[-1]
cropwidth={w}
cropheight={h}
-resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
width={w}
height={h}
-if {$noise0>$2}
-denoise[-1] 10,{$noise0*$1},3,5,0,1
-denoise[-1] 10,{$noise0*$1},3,5,0,1
-endif
--resize[0] {$width/2},{$height/2},1,{s},2,1
--resize[-1] $width,$height,1,{s},3,1
-sub[0] [-1]
-remove[-1]
noise1=${-variance_noise}
-if {$noise1>$2}
-denoise[-1] 10,{$noise1*$1},3,5,0,0
-endif
--resize[-1] {$width/4},{$height/4},1,{s},2,1
--resize[-1] {$width/2},{$height/2},1,{s},3,1
-sub[1] [-1]
-remove[-1]
noise2=${-variance_noise}
-if {$noise2>$2}
-denoise[-1] 10,{$noise2*$1},3,5,0,1
-endif
--resize[-1] {$width/8},{$height/8},1,{s},2,1
--resize[-1] {$width/4},{$height/4},1,{s},3,1
-sub[2] [-1]
-remove[-1]
noise3=${-variance_noise}
-if {$noise3>$2}
-denoise[-1] 10,{$noise3*$1},3,5,0,1
-endif
-resize[-1] {$width/4},{$height/4},1,{s},3,1
-add[-2] [-1]
-remove[-1]
-resize[-1] {$width/2},{$height/2},1,{s},3,1
-add[-2] [-1]
-remove[-1]
-resize[-1] {$width/1},{$height/1},1,{s},3,1
-add[-2] [-1]
-remove[-1]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
fft_tile3_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
--add[1] [-1]
-threshold[-1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-remove[0,1,2]
-keep[-1]
fft_tile3_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile3:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-remove[0]
-blend_median
nr3:
-mul 256
radius={0.05*(min(h,w))}
[0]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmin={xm}
ymin={ym}
-remove[-1]
--crop[0] {$xmin-$radius},{$ymin-$radius},{$xmin+$radius},{$ymin+$radius}
minnoise=${-variance_noise}
-remove[-1]
--sub[0] {250*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmax={xm}
ymax={ym}
--crop[0] {$xmax-$radius},{$ymax-$radius},{$xmax+$radius},{$ymax+$radius}
maxnoise=${-variance_noise}
-remove[-1]
--sub[0] {128*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xave={xm}
yave={ym}
-remove[-1]
--crop[0] {$xave-$radius},{$yave-$radius},{$xave+$radius},{$yave+$radius}
midnoise=${-variance_noise}
-text[-1] $midnoise,0,0,25,1,{iM}
--sub[0] {64*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xshadow={xm}
yshadow={ym}
-remove[-1]
--crop[0] {$xshadow-$radius},{$yshadow-$radius},{$xshadow+$radius},{$yshadow+$radius}
shadownoise=${-variance_noise}
--sub[0] {192*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xbright={xm}
ybright={ym}
-remove[-1]
--crop[0] {$xbright-$radius},{$ybright-$radius},{$xbright+$radius},{$ybright+$radius}
brightnoise=${-variance_noise}
shadows={(($minnoise/$shadownoise)*64)}
mids={(($minnoise/$midnoise)*64)}
brights={(($minnoise/$brightnoise)*64)}
whites={(($minnoise/$maxnoise)*64)}
point1={$shadows+32}
point2={$mids+$shadows+32}
point3={$brights+$mids+$shadows+32}
point4={$whites+$brights+$mids+$shadows+32}
-keep[0]
cropwidth={w}
cropheight={h}
-resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
width={w}
height={h}
-apply_curve[0] 0,0,0,{32*256},{32*256},{96*256},{$point1*256},{160*256},{$point2*256},{223*256},{$point3*256},{287*256},{$point4*256}
-sub {128*256} -mul .5 -add {128*256}
--hybrid16[0]
-autonr2[-1] $1,$2
-autonr2[-1] $1,$2
--sub[0] [1]
-add[-1] {128*256}
-remove[0]
-div[-1] 256
-fft_tile3[-1] {2000-$3},48,0,$4,$5,$6,1
-mul[-1] 256
-sub[-1] {128*256} -mul[-1] $7 -add[-1] {128*256}
-unsharp[0] $8,$9,$10
-unsharp[1] $11,$12,$13
-sub[1] {128*256}
-add[0] [1]
-remove[1]
-sub {128*256} -mul 2 -add {128*256}
-apply_curve[0] 0,0,0,{32*256},{32*256},{$point1*256},{96*256},{$point2*256},{160*256},{$point3*256},{223*256},{$point4*256},{287*256}
-div 256
-c 0,255
-crop 0,0,{$cropwidth-1},{$cropheight-1}
#@gui Noise Reduction 5 : nr5,nr5_preview(0)
#@gui : 1 Luma Denoise = float (1.6,0,10)
#@gui : 2 Colour Denoie = float (5,0,20)
#@gui : sep = separator ()
#@gui : 3 Recover Details = bool(1)
#@gui : 4 Amount = float (1,0.1,10)
#@gui : sep = separator ()
#@gui : note = note("<b> sharpen details</b>")
#@gui : 5 Radius = float (.75,.25,5)
#@gui : 6 Amount = float (3,0,10)
#@gui : 7 Threshold = float (0,0,100)
#@gui : sep = separator ()
#@gui : note = note("<b> sharpen edges</b>")
#@gui : 8 Radius = float (.75,.25,5)
#@gui : 9 Amount = float (.5,0,10)
#@gui : 10 Threshold = float (0,0,100)
#@gui : sep = separator ()
#@gui : note = note("<b>Advanced options</b>")
#@gui : 11 Base Luma Method = choice (1,"Wavelet","Multi-scale patch smoothing","Semi-auto MS patch","Median first MS patch","Multi Scale Median")
#@gui : 12 Chroma Method = choice (1,"Wavelet","Multi-scale patch smoothing")
#@gui : sep = separator ()
#@gui : 13 Adjust Fine Details = float (100,-5000,500)
#@gui : 14 Adjust Medium Details = float (0,-5000,500)
#@gui : 15 Adjust Large Details = float (-100,-5000,500)
#@gui : sep = separator ()
#@gui : Experimental Curves = bool(0)
#@gui : Gamma = float (1.3,.3,2)
#@gui : Show Noise = bool(0)
#@gui : sep = separator ()
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 28 November 2012 - added abiltity to view noise")
med3stack16:
-blend_median
med5stack16:
-blend_median
fft_tile3_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
--add[1] [-1]
-threshold[-1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-remove[0,1,2]
-keep[-1]
fft_tile3_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile3:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$8>2}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
-endif
-if {$8>1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$8==3}
-blend_median
-endif
-if {$8==2}
-blend_median
-endif
nr5:
luma_strength=$1
colour_strength=$2
recovery=$3
detail_recovery={5000-($4*500)}
fine_detials=$13
medium_detials=$14
large_details=$15
detail_radius=$5
detail_amount=$6
detail_threshold=$7
edge_radius=$8
edge_amount=$9
edge_threshold=$10
quality=3
-if {$16==1}
-mul[0] 256
radius={0.05*(min(h,w))}
[0]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmin={xm}
ymin={ym}
-remove[-1]
--crop[0] {$xmin-$radius},{$ymin-$radius},{$xmin+$radius},{$ymin+$radius}
minnoise=${-variance_noise}
-remove[-1]
--sub[0] {250*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmax={xm}
ymax={ym}
--crop[0] {$xmax-$radius},{$ymax-$radius},{$xmax+$radius},{$ymax+$radius}
maxnoise=${-variance_noise}
-remove[-1]
--sub[0] {128*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xave={xm}
yave={ym}
-remove[-1]
--crop[0] {$xave-$radius},{$yave-$radius},{$xave+$radius},{$yave+$radius}
midnoise=${-variance_noise}
-text[-1] $midnoise,0,0,25,1,{iM}
--sub[0] {64*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xshadow={xm}
yshadow={ym}
-remove[-1]
--crop[0] {$xshadow-$radius},{$yshadow-$radius},{$xshadow+$radius},{$yshadow+$radius}
shadownoise=${-variance_noise}
--sub[0] {192*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xbright={xm}
ybright={ym}
-remove[-1]
--crop[0] {$xbright-$radius},{$ybright-$radius},{$xbright+$radius},{$ybright+$radius}
brightnoise=${-variance_noise}
shadows={(($minnoise/$shadownoise)*64)}
mids={(($minnoise/$midnoise)*64)}
brights={(($minnoise/$brightnoise)*64)}
whites={(($minnoise/$maxnoise)*64)}
point1={$shadows+32}
point2={$mids+$shadows+32}
point3={$brights+$mids+$shadows+32}
point4={$whites+$brights+$mids+$shadows+32}
-keep[0]
## cropwidth={w}
## cropheight={h}
## -resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
## width={w}
## height={h}
-apply_curve[0] 0,0,0,{32*256},{32*256},{96*256},{$point1*256},{160*256},{$point2*256},{223*256},{$point3*256},{287*256},{$point4*256}
-div[0] 256
-else
-apply_gamma {1/$17}
-endif
-rgb2ycbcr
-split c
-if {$1>0}
-if {$11==0}
--denoise_haar[0] $luma_strength,0,{$quality*10}
-endif
-if {$11==1}
--ms_patch[0] 10,{$luma_strength*2.5},3,5,0,1,1,0,{$luma_strength*.75},{$luma_strength*.5},{$luma_strength*0},{$luma_strength*0},1,1,1,0
-endif
-if {$11==2}
--autonr2[0] $luma_strength,1
-endif
-if {$11==3}
--median[0] 3
-ms_patch[-1] 10,{$luma_strength*2.5},3,5,0,1,1,0,{$luma_strength*.75},{$luma_strength*.5},{$luma_strength*0},{$luma_strength*0},1,1,1,0
-endif
-if {$11==4}
--msmed2[0] 3
-repeat $1
-msmed2[-1] 3
-done
-endif
--sub[0] [-1]
-add[-1] {128}
-remove[0]
-if {$recovery==1}
-resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
-rectangle[-1] 0,0,100%,48,1,128
-rectangle[-1] 0,0,48,100%,1,128
-rectangle[-1] 0,100%,100%,{h-48},1,128
-rectangle[-1] {w-48},100%,100%,0,1,128
-fft_tile3[-1] {$detail_recovery},48,0,$fine_detials,$medium_detials,$large_details,1,$quality
-crop[-1] 48,48,{w-49},{h-49}
-else
-fill[-1] 128
-endif
-unsharp[-1] $detail_radius,$detail_amount,$detail_threshold
-unsharp[2] $edge_radius,$edge_amount,$edge_threshold
-sub[-1] {128}
-add[2] [-1]
-remove[-1]
-else
-move[0] 3
-endif
-if {$2>0}
-median[0,1] 3
-median[0,1] 3
-if {$12==1}
-ms_patch[0] 10,1,3,5,0,1,1,0,{$colour_strength*1},{$colour_strength*.5},{$colour_strength*.25},{$colour_strength*0},0,1,1,0
-ms_patch[1] 10,1,3,5,0,1,1,0,{$colour_strength*1},{$colour_strength*.5},{$colour_strength*.25},{$colour_strength*0},0,1,1,0
-endif
-if {$12==0}
-denoise_haar[0] $colour_strength,0,{$quality*3}
-denoise_haar[1] $colour_strength,0,{$quality*3}
-endif
-endif
-move[-1] 0
-append c
-ycbcr2rgb
-if {16==1}
-mul[0] 256
-apply_curve[0] 0,0,0,{32*256},{32*256},{$point1*256},{96*256},{$point2*256},{160*256},{$point3*256},{223*256},{$point4*256},{287*256}
## -n 0,{256*256}
-div[0] 256
-else
-apply_gamma $17
-endif
-c 0,255
ms_patch_smoothing:
-ac "-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done",$8,0 -c 0,255
ms_patch_2:
--resize[0] 50%,50%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch_3:
--resize[0] 25%,25%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch_4:
--resize[0] 12.5%,12.5%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch_5:
--resize[0] 6.125%,6.125%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch:
-apply_gamma {1/$14}
-repeat $15
-if {$13==1}
-ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
-endif
-if {$9>0.1}
-ms_patch_2 $1,$9,$3,$4,$5,$6,$7,$8
-endif
-if {$10>0.1}
-ms_patch_3 $1,$10,$3,$4,$5,$6,$7,$8
-endif
-if {$11>0.1}
-ms_patch_4 $1,$11,$3,$4,$5,$6,$7,$8
-endif
-if {$12>0.1}
-ms_patch_5 $1,$12,$3,$4,$5,$6,$7,$8
-endif
-done
-apply_gamma $14
-c 0,255
msmed2:
medlvl2=2
medlvl3=3
medlvl4=4
medlvl5=6
medlvl6=6
medlvl7=7
-median $1
-median $1
-name[0] full
--resize[full] {full,w/$medlvl2},{full,h/$medlvl2},1,{s},2
-name[-1] level2
--resize[level2] {0,w},{0,h},1,{s},3,1
-name[-1] low2
--compose_grainextract[full,low2]
-name[-1] level2high
-remove[low2]
-median[level2] $1
-median[level2] $1
-name[1] level2
--resize[level2] {full,w/$medlvl3},{full,h/$medlvl3},1,{s},2
-name[-1] level3
--resize[level3] {level2,w},{level2,h},1,{s},3,1
-name[-1] low3
--compose_grainextract[level2,low3]
-name[-1] level3high
-remove[1,low3]
-median[2] $1
-median[2] $1
-name[2] level3
--resize[level3] {full,w/$medlvl4},{full,h/$medlvl4},1,{s},2
-name[-1] level4
--resize[level4] {level3,w},{level3,h},1,{s},3,1
-name[-1] low4
--compose_grainextract[level3,low4]
-name[-1] level4high
-remove[2,low4]
-median[-2] $1
-median[-2] $1
-name[-2] base
-resize[base] {level4high,w},{level4high,h},1,{s},3,1
-compose_grainmerge[-1,-2]
-name[-1] base
-resize[base] {level3high,w},{level3high,h},1,{s},3,1
-compose_grainmerge[-1,-2]
-resize[-1] {full,w},{full,h},1,{s},3,1
-compose_grainmerge[-1,-2]
-keep[-1]
nr5_preview:
-if {$-1==0}
-nr5 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
-endif
-if {$-1==1}
--nr5 $1,$2,$3,$4,$5,0,$7,$8,0,$10,$11,$12,$13,$14,$15,$16,$17
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
#@gui PNG Processing : iain_png_processing,iain_png_processing(0)
#@gui : Number of Colours = int (4,2,256)
#@gui : Refine Palette = bool(0)
#@gui : Dither Pattern = choice(0,"Lines","Checkerboard","Diffusion","None")
#@gui : sep = separator ()
#@gui : Pre Smooth = bool(0)
#@gui : Smooth Radius = float(3,0,20)
#@gui : Smooth Amount = float(3,0,20)
#@gui : sep = separator ()
#@gui : Pre-Sharpen (Constrained) = bool(0)
#@gui : Sharpen Radius = float(.75,0,10)
#@gui : Amount = float(2,0,10)
#@gui : Threshold = float(1,0,50)
#@gui : Constraint Radius = int(5,0,10)
#@gui : Overshoot = float(0,0,50)
#@gui : sep = separator ()
#@gui : Post Median = bool(0)
#@gui : Median Radius = int (1,1,10)
#@gui : Median Repeats = int (1,1,5)
#@gui : sep = separator ()
#@gui : note = note("This filter provides tools to improve the compressabilty or visual quality when creating an indexed image.)
#@gui : note = note("Author : <i>Iain Fergusson</i>. release: 9 September 2018 )
iain_png_processing:
-repeat $! -l[$>]
nm=${-gui_layer_name}
dither_pattern=$3
do_smooth=$4
smooth_radius=$5
smooth_amount=$6
do_sharp=$7
sharp_radius=$8
sharp_amount=$9
sharp_threshold=$10
constrant_radius=$11
overshoot=$12
do_median=$13
median_radius=$14
median_repeat=$15
-remove_opacity
-if $do_smooth
-bilateral[0] $smooth_radius,$smooth_amount
-endif
-if $do_sharp
-iain_constrained_sharpen[0] $sharp_radius,$sharp_amount,$sharp_threshold,$constrant_radius,$overshoot,0,1
-endif
--colormap $1,$2,1
-if {$dither_pattern==2}
--index[0] [1],1,0
-elif {$dither_pattern!=2}
--index[0] [1],0,0
-endif
--map[-1] [-2]
-if {$dither_pattern<=1}
--sub[0] [-1]
-abs[-1]
--add[0] [4]
--sub[0] [4]
-index[-1] [1],0,0
-index[-2] [1],0,0
-l[-1,-2]
-if {$dither_pattern==1}
(0,255;255,0)
-elif {$dither_pattern==0}
(0;255)
-endif
-resize[-1] [0],0,2
-channels[-1] 0
-append[-1,-2] c
-blend alpha
-endl
-if $do_median
-repeat $median_repeat
-l[-1]
-repeat {($median_radius*2)+1}
amount={$>-$median_radius}
-if {$amount!=0}
--shift[0] $amount,0,0,0,0
-endif
-done
-blend_median
-endl
-done
-endif
--map[-1] [1]
-k[-1]
## -rm[1]
-else
-rm[-1]
-if $do_median
-repeat $median_repeat
-horiz_median[-1] $median_radius
-done
-endif
--map[-1] [1]
-k[-1]
-endif
nm name($nm)
-endl -done
#@gui Pyramid Processing : iain_pyramid_processing,iain_pyramid_processing(0)
#@gui : 1 Levels = int(4,1,6)
#@gui : 2 Noise = float(50,1,100)
#@gui : 3 Mix = float(.5,0,1)
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. 14 June 2017 - First release</small>")
iain_pyramid_processing:
-repeat $! -l[$>]
-remove_opacity
-ac[0] "
--l
dilate=1
blur=1
mix=$3
noise=$2
levels=$1
size={3^$levels}
cropwidth={w}
cropheight={h}
#-resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1,0.5,0.5
-resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1
-repeat $levels
-l[-1]
--resize[0] 33.33333%,33.33333%,{d},{s},2
--iain_resize_x3[-1]
-blur[-1] 1
-sub[0,-1]
-endl
-done
-repeat {$!-1}
-l[{$>}]
--abs
max={iM}
-dilate[-1] $dilate
-blur[-1] $blur
-max[-1] 0.00000000000000001
--fill[-1] $max
-div[-1] [-2]
-cut[-1] -1000000000,$noise
-mul[0,-1]
-k[0]
-endl
-done
-to_rgb
-repeat {$!-1}
-iain_resize_x3[-1]
-blur[-1] 1
-add[-1,-2]
-done
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-replace_nan 0
-replace_inf 255
-n 0,255
-endl
-mul[0] {1-$mix}
-mul[1] $mix
-add
-c 0,255
",lab_l
-endl -done
#@gui Savenoiseprint :  iain_savenoiseprint, iain_savenoiseprint_p(0)
#@gui : Pass = choice ("pass 1 create noise print","pass 2 remove noise")
#@gui : Detail Threshold = float (1,0,5)
#@gui : Gamma = float(1.4,1,4)
#@gui : note = note("This filter requires 2 images as input, the bottom image should be noisey and the top image should be the same image only with some kind of noise reduction.")
#@gui : note = note("You need to do 2 passes of this filter to get the results. The first pass analyses the residual noise and creates a noise print and saves it to your computer. On the 1st pass you can click apply and the noise print will be generated after a while. When that has finished switch to 2nd pass and adjust the Detail Threshold to your liking and hit okay or apply.")
#@gui : note = note("<b> Set output mode to 'New Layers'</b>")
iain_savenoiseprint_p:
-if {$1==0}
-text "creating noiseprint",0,0,50,1,255
-elif {$1==1}
-iain_savenoiseprint[0,1] $1,$2,$3
-endif
iain_savenoiseprint:
-remove_opacity
-rgb2yuv8
-split c
-remove[-1,-2]
-l[0,3]
-apply_parallel_overlap[0] "-mul {1/255} -pow $3 -mul 255 ",0,0
-apply_parallel_overlap[1] "-mul {1/255} -pow $3 -mul 255 ",0,0
--sub[1] [0]
-add[-1] 128
-l[-1]
-if {$1==0}
--l
size=48
cropwidth={w}
cropheight={h}
-resize[0] {w+($size-w%$size)},{h+($size-h%$size)},1,{s},0,1
tc={round(w/$size)} tr={round(h/$size)}
-l[0]
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fftpolar[0]
-append[0,1] z
-endl -done
-median_median
-endl
-o noiseprint.cimg
-rm
-endl
-elif {$1==1}
size=48
cropwidth={w}
cropheight={h}
-resize[0] {w+($size-w%$size)},{h+($size-h%$size)},1,{s},0,1
tc={round(w/$size)} tr={round(h/$size)}
-i noiseprint.cimg
-mul[-1] $2
--l[0,1]
-split_tiles[0] $tc,$tr
-repeat {$!-1}
-l[$>,-1]
[-1]
-l[0,1]
-fftpolar[0]
-l[0,-1]
-split[1] z
-rm[-1]
--gt[0] [1]
-circle[-1] 50%,50%,1%,1,1
-mul[0] [-1]
-keep[0]
-endl
-ifftpolar
-endl
-endl
-done
-rm[-1]
-append_tiles $tc,$tr
-endl
--l[0,1]
-shift[0] 16,16,0,0
-split_tiles[0] $tc,$tr
-repeat {$!-1}
-l[$>,-1]
[-1]
-l[0,1]
-fftpolar[0]
-l[0,-1]
-split[1] z
-rm[-1]
--gt[0] [1]
-circle[-1] 50%,50%,1%,1,1
-mul[0] [-1]
-keep[0]
-endl
-ifftpolar
-endl
-endl
-done
-rm[-1]
-append_tiles $tc,$tr
-shift[0] -16,-16,0,0
-endl
-l[0,1]
-shift[0] 32,32,0,0
-split_tiles[0] $tc,$tr
-repeat {$!-1}
-l[$>,-1]
[-1]
-l[0,1]
-fftpolar[0]
-l[0,-1]
-split[1] z
-rm[-1]
--gt[0] [1]
-circle[-1] 50%,50%,1%,1,1
-mul[0] [-1]
-keep[0]
-endl
-ifftpolar
-endl
-endl
-done
-rm[-1]
-append_tiles $tc,$tr
-shift[0] -32,-32,0,0
-endl
-iain_fast_median_stack
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-c 0,255
-endif
-endl
-sub[-1] 128
-add[0] [-1]
-keep[0]
-apply_parallel_overlap[0] "-mul {1/255} -pow {1/$3} -mul 255 ",0,0
-endl
-append c
-yuv82rgb
-c 0,255
-if {$1==0}
-rm
-endif
median_median:
-repeat {$!/3-($!%3)}
-l[$>,{$>+1},{$>+2}]
-iain_fast_median_stack
-endl
-done
-repeat {$!/3-($!%3)}
-l[$>,{$>+1},{$>+2}]
-iain_fast_median_stack
-endl
-done
-repeat {$!/3-($!%3)}
-l[$>,{$>+1},{$>+2}]
-iain_fast_median_stack
-endl
-done
num=$!
-add
-div $num
#@gui Skin Mask : iain_fx_skin_mask,iain_fx_skin_mask_pr
#@gui : note = note("<b>Main Controls</b>")
#@gui : Magenta Ratio = float (55,0,255)
#@gui : Cyan Ratio = float (200,2,255)
#@gui : sep = separator()
#@gui : note = note("<b>Refine Hue Range</b>")
#@gui : Remove Reds = float (0,0,255)
#@gui : Remove Yellows = float(0,0,100)
#@gui : sep = separator()
#@gui : Output = choice ("Masked Image","Just the Mask")
#@gui : Preview Shows = choice (1,"Output","Highlighted Mask")
#@gui : sep = separator()
#@gui : note = note("Skin mask uses CMYK colour model to selct skin tones. Skin tones generally have a predictable ratios of Cyan, Magetna and Yellow. Different ethnicies have slighty different ratios. ")
#@gui : note = note("<small><b>Magenta Ratio:</b> This sets how much the Magenta content is allowed to be below the Yellow content. Increase to include dark skin tones and shadows.</small>")
#@gui : note = note("<small><b>Cyan Ratio:</b> This set the how much the Cyan content is allowed to be below the Yellow content. Increase to include pale skin tones and highlights.</small>")
#@gui : note = note("<small><b>Refine Hue Range:</b> This allows you to remove tones that pass through the main controls but are not present in your subject.</small>")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
iain_fx_skin_mask_pr:
-if {$6==0}
-iain_skin_mask $1,$2,$3,$4,$5
-elif {$6==1}
--iain_skin_mask $1,$2,$3,$4,1
-n[-1] 0.6,1
-mul
-endif
iain_fx_skin_mask:
-tic
-apply_parallel_overlap[0] "-iain_skin_mask[0] ${1--1}",0,0
-toc
iain_skin_mask:
dark={$1}
pale={255-$2}
red={255-$3}
yellow={255-$4}
-to_rgb
[0]
[0]
[0]
-l[1]
-if {$3>0}
red={255-$3}
-fill if(i(x,y,z,0)-i(x,y,z,1)<{$red},i,0)
-gt 0
-else
-fill 1
-endif
-endl
-l[2]
-rgb2cmyk
dark={$1}
pale={255-$2}
-fill if(i(x,y,z,2)>i(x,y,z,1),if(i(x,y,z,2)-i(x,y,z,1)<{$dark},if((i(x,y,z,0)+{$pale})<i(x,y,z,2),i,255),255),255)
-cmyk2rgb
-gt 0
-endl
-l[3]
-if {$4>0}
yellow={255-$4}
-rgb2hsv
-split c
-keep[0]
-add[0] 180
-mod[0] 360
-lt[0] $yellow
-else
-fill 1
-endif
-endl
-mul[1,2,3]
-mul[1] 255
-channels[1] 0
-if {$5}
-keep[1]
-else
-append c
-endif
#@gui Smart Demosaic : iain_smartdemos, iain_smartdemos(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : Blurradius = float (1.5,.5,3)
#@gui : Wrong Way--Zippers = float (2,0,5)
iain_smartdemos:
cropwidth={w}
cropheight={h}
-resize[0] {w+(64-w%64)},{h+(64-h%64)},{d},{s},0,2
-apply_parallel_overlap "
-to_rgb
-add 1000
-rgb2bayer[0] $1,1
--l[0]
--l[0]
-split c
-l[0,2]
(0,0,.5;0,1,0;0.5,0,0)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
(0,0,.25;0,.5,0;0.25,0,0)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
-endl
-endl
-split[0] c
-name[0] red -name[1] green -name[2] blue
-name[3] redblur -name[4] greenblur -name[5] blueblur
--div[redblur] [blueblur]
-replace_nan 0
--mul[blue] [-1]
-add[-1] [red]
--div[blueblur] [redblur]
-replace_nan 0
--mul[red] [-1]
-add[-1] [blue]
-keep[1,-1,-3]
-reverse[0,1]
-append c
-endl
-l[0]
--l[0]
-split c
-l[0,2]
(0.5,0,0;0,1,0;0,0,0.5)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
(0.25,0,0;0,.5,0;0,0,0.25)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
-endl
-endl
-split[0] c
-name[0] red -name[1] green -name[2] blue
-name[3] redblur -name[4] greenblur -name[5] blueblur
--div[redblur] [blueblur]
-replace_nan 0
--mul[blue] [-1]
-add[-1] [red]
--div[blueblur] [redblur]
-replace_nan 0
--mul[red] [-1]
-add[-1] [blue]
-keep[1,-1,-3]
-reverse[0,1]
-append c
-endl
--l[0]
(.33,0,0,0,0;0,.66,0,0,0;0,0,-2,0,0;0,0,0,.66,0;0,0,0,0,.33)
-convolve[0] [1]
-rm[1]
-abs
-split c
-rm[1]
-max
-endl
--l[1]
(0,0,0,0,.33;0,0,0,.66,0;0,0,-2,0,0;0,.66,0,0,0;.33,0,0,0,0)
-convolve[0] [1]
-rm[1]
-abs
-split c
-rm[1]
-max
-endl
-blur[-1,-2] 2
-sub[-1,-2]
-gt[-1] 0
-mul[-1] 255
-append[1,2] c
-blend alpha,1,0
--l[0]
-split[0] c
-add[0,2]
-mul[0] 0.5
-reverse
## -remove[-2,-4]
-nm[0] green -nm[1] magenta
[0] [1]
-nm[-2] greenblur -nm[-1] mblur
(0.25;.5;0.5;.5;0.25)
-convolve[mblur] [-1] -rm[-1]
(0.5;1;0.5)
-convolve[greenblur] [-1]
-rm[-1]
--div[greenblur] [mblur]
-replace_nan 0
-nm[-1] mmul
-rm[greenblur,mblur]
-mul[magenta] [mmul]
-keep[green,magenta]
-add
-endl
--l[0]
-split[0] c
-add[0,2]
-mul[0] 0.5
-reverse
## -remove[-2,-4]
-nm[0] green -nm[1] magenta
[0] [1]
-nm[-2] greenblur -nm[-1] mblur
(0.25,.5,0.5,.5,0.25)
-convolve[mblur] [-1] -rm[-1]
(0.5,1,0.5)
-convolve[greenblur] [-1]
-rm[-1]
--div[greenblur] [mblur]
-replace_nan 0
-nm[-1] mmul
-rm[greenblur,mblur]
-mul[magenta] [mmul]
-keep[green,magenta]
-add
-endl
-sub 1000
-c 0,255
--l[0,1]
-rgb2bayer[0] $1,1
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
-convolve[0] [-1]
-convolve[2] [-1]
-remove[-1]
-add[0] [3]
-add[2] [3]
-remove[1,4,5,6]
-reverse[1,2]
-append c
-endl
-l[0,2]
-rgb2bayer[0] $1,1
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
-convolve[0] [-1]
-convolve[2] [-1]
-remove[-1]
-add[0] [3]
-add[2] [3]
-remove[1,4,5,6]
-reverse[1,2]
-append c
-endl
-rm[1]
-replace_inf 255
-replace_nan 0
-reverse
-l[0]
--blur $2
-sub[0] [1]
-add[0] 128
-endl
-l[2]
--blur $2
-sub[0] [1]
-add[0] 128
-endl
-l[0,2]
-nozip $3
-endl
-l[-1,-2]
--l[0]
--l
-split c
-add
-div 3
-endl
-sub
--blur 3
-sub
-abs
-split c
-max
-endl
--l[1]
--l
-split c
-add
-div 3
-endl
-sub
--blur 3
-sub
-abs
-split c
-max
-endl
-l[-1,-2]
-blur 2
-sub
-gt 0
-mul 255
-endl
-append[1,2] c
-blend alpha,1,0
-endl
-sub[0] 128
-add
-c 0,255
",16,0
-crop 0,0,{$cropwidth-1},{$cropheight-1}
time=$|
#@gui Spot Mask : spot_mask,spot_mask_preview(0)
#@gui : Spot Size = float (4,1,10)
#@gui : Threshold = float (80,0,100)
#@gui : Mask Dilation = int (5,0,10)
spot_mask:
-to_gray[-1]
--resize[0] {w/$1},{h/$1},1,3,2
--iain_pixel_denoise[-1] 1,0
-sub[-1] [-2]
-abs[-1]
-remove[1]
-threshold[-1] $2%
-to_gray[-1]
-dilate_circ[-1] $3
-n 0,255
-resize[-1] {0,w},{0,h},1,3,3
-keep[-1]
spot_mask_preview:
--spot_mask $1,$2,$3
-n[-1] 0,255
-add[0] [1]
-keep[0]
-n 0,255
#@gui Star Tone : star_tone, star_tone(0)
#@gui : Scale = float(100,10,200)
star_tone:
sx1=50
sx2=194
sx3=281
sx4=511
sx5=742
sx6=829
sx7=972
sx8=829
sx9=742
sx10=511
sx11=281
sx12=192
sy1=450
sy2=633
sy3=849
sy4=817
sy5=849
sy6=633
sy7=450
sy8=267
sy9=50
sy10=83
sy11=50
sy12=267
level=10
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 8
-polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level
sx2={$sx2+40}
sx6={$sx6-40}
sx8={$sx8-40}
sx12={$sx12+40}
sy2={$sy2-23}
sy4={$sy4-47}
sy6={$sy6-23}
sy8={$sy8+23}
sy10={$sy10+47}
sy12={$sy12+23}
level={$level+25}
-done
-n 0,255
-resize 200,200,1,1,3
--shift[0] -69,-40,0,0
--shift[0] -69,40,0,0
--shift[0] 69,-40,0,0
--shift[0] 69,40,0,0
-add
-crop 5,5,142,84
-endl
-resize[-1] $1,$1,1,1,2
width={w}
height={h}
w_tiles={0,round(w/$width)}
h_tiles={0,round(h/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
-append_tiles[1--1] $w_tiles,$h_tiles
-equalize[-1] 256
-blend alpha,0.5,1
-gt 128
-mul 255
#@gui _
#@gui <i>J&#233;J&#233;</i>
#@gui 3D Rendering : jeje_render3d, jeje_render3d_preview
#@gui : Input Image = file()
#@gui : Size = int(8,4,16)
#@gui : Quality = int(6,2,16)
#@gui : Opacity = float(0.1,0,1)
#@gui : Angle X = float(240,0,360)
#@gui : Angle Y = float(0,0,360)
#@gui : Angle Z = float(30,0,360)
#@gui : Zoom = float(1,0,3)
#@gui : Top Color = color(32,32,64,255)
#@gui : Bottom Color = color(64,128,96,255)
#@gui : Render = bool(false)
#@gui : sep = separator(), note = note(<b>Note:</b>Adjust the 3D view first and then enable render to compute the volume rendering.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_render3d:
W={0,w}
1,2,1,4 -f[-1] $9,$13,$10,$14,$11,$15,$12,$16 -resize[-1] {0,w},{0,h},1,4,5
-blend alpha
-i "$1" -a[1--1] z
-l[-1]
-if $17 -display_volume $2,$3,$4 -else  -boundingbox3d 20 -endif
-rotate3d 0,0,1,$7
-rotate3d 0,1,0,$6
-rotate3d 1,0,0,$5
-c3d -n3d -*3d {3*$W*$8/4}
-endl
-object3d[0] [1],50%,50%,0,1
-n 0,255
-rm[1]
jeje_render3d_preview:
-jeje_render3d $"*"
#@gui Deconvolve : jeje_deconvolve, jeje_deconvolve_preview
#@gui : Iterations = int(20,1,100)
#@gui : Algorithm = choice(0,"Richardson-Lucy","Gold-Meinel")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note{"Need two layers (top layer is the blur)<br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/22/02</i>.</small>"}
jeje_deconvolve:
-if {$2==1}
-deconvolve_goldmeinel[0] [1],$1 -n[0] 0,255
-else
-deconvolve_richardsonlucy[0] [1],$1 -n[0] 0,255
-endif
jeje_deconvolve_preview:
-gui_split_preview "-jeje_deconvolve $1,$2,$3",$4
#@gui Zernike : jeje_zernike_preview
#@gui : X = float(50,0,100)
#@gui : Y = float(50,0,100)
#@gui : R = float(50,0,100)
#@gui : Piston = float(0,-1,1)
#@gui : Horizontal Tilt = float(0,-1,1)
#@gui : Vertical Tilt = float(0,-1,1)
#@gui : Oblique Astigmatism = float(0,-1,1)
#@gui : Defocus = float(0,-1,1)
#@gui : Vertical Astigmatism = float(0,-1,1)
#@gui : Vertical Trefoil = float(0,-1,1)
#@gui : Vertical Coma = float(0,-1,1)
#@gui : Horizontal Coma = float(0,-1,1)
#@gui : Oblique Trefoil = float(0,-1,1)
#@gui : Oblique Quadrafoil = float(0,-1,1)
#@gui : Oblique Secondary Astigmatism = float(0,-1,1)
#@gui : Primary Spherical = float(0,-1,1)
#@gui : Vertical Secondary Astigmatism = float(0,-1,1)
#@gui : Vertical Quadrafoil = float(0,-1,1)
#@gui : Binarize = bool(false)
#@gui : Period = float(0,0,256)
#@gui : Cycle Ratio = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note{"https://en.wikipedia.org/wiki/Zernike_polynomials <br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/03/12</i>.</small>"}
jeje_zernike:
zernike {$1*w/100},{$2*h/100},{$3*w/100},${4-18}
n 0,255
if $19 f '100*((i/$20)%1)<$21' n 0,255 endif
jeje_zernike_preview:
gui_split_preview "-jeje_zernike $*",$-1
#@gui _
#@gui <i>Jayprich</i>
#@gui About : _none_, jpr_about
#@gui : note = note{"@jayprich filters for <b>G'MIC</b>\nare proposed to you by James Prichard"}
#@gui : note = note{"source code http://www.h-ps.demon.co.uk/GMIC/jayprich.gmic"}
jpr_about : -fx_logo "@jayprich filters"
#@gui Jpr Colourillusion : jpr_colourillusion,jpr_colourillusion(1)
#@gui : note = note("recreated from a Java example http://fiji.sc/wiki/ see Spirals Macro")
#@gui : Arms = int(2,2,10)
#@gui : Scale = float(25,10,50)
#@gui : Updateauthornote = note("<small>update 2013-Feb-06 author @jayprich</small>")
#@cli jpr_colourillusion :
#@cli : Use -d0 ( or -w -1,-1,0 -d ) to avoid normalisation of colours
#@cli : optical illusion involving color spirals
#@cli : visual "green arm" and "blue arm" contain the same color
jpr_colourillusion :
-v -
arm={$1*1.5-1}
{w},{h},1,1,A=10+atan2(x-{w/2},y-{h/2})*$arm/pi;R=sqrt((x-{w/2})^2+(y-{h/2})^2)/$2+A;(int(A+R/$arm)+int(R*6-A/$arm)%2)%3
(250,200,0^20,200,190^160,100,150)
-map[-2] [-1]
-k[-2]
-v +
#@gui Jpr Coltexindex : jpr_coltexindex,jpr_coltexindex(1)
#@gui : note = note{"Index the image using its colour channels plus the local analysis of its luminance channel."}
#@gui : note = note{"Inspired by questions on masking for similar textures and how to make poster art from a photo."}
#@gui : note = note{"Watch out for JPEG block-artifacts in colour channels"}
#@gui : Number of Types = int(5,3,20)
#@gui : X1 = float(55,0,100)
#@gui : Y1 = float(55,0,100)
#@gui : X1 = float(45,0,100)
#@gui : Y2 = float(45,0,100)
#@gui : Factor (X1,Y1) Vs (X2,Y2) = float(1,0,5)
#@gui : Display (X,Y) = bool(1)
#@gui : sep =separator(),note = note{"<small>Luminance Y</small>"}
#@gui : Smoothness = float(0,0,5)
#@gui : Black = float(0.05,0,1)
#@gui : Midtone = float(0.5,0,1)
#@gui : Highlight = float(0.95,0,1)
#@gui : sep =separator(),note = note{"<small>Colour &amp; Texture</small>"}
#@gui : Colour Smoothing = float(0.5,0,5)
#@gui : sep =separator(),note = note{"<small>Locally Average Gradient Norm or Variance from Luminance</small>"}
#@gui : Use Gradient Norm = bool(1)
#@gui : Local Size = float(2,1,9)
#@gui : Weight = float(0.7,0.2,2)
#@gui : Updateauthornote = note("<small>update 2013-Mar-17 author @jayprich</small>")
#@cli jpr_coltexindex :
#@cli : Enrich colour with local analysis of luminance and index the image.
#@cli : $ -jpr_coltexindex
jpr_coltexindex : -skip ${7=1}
-e[^-1] "Index colour and texture of image$? with $1 types ($2,$3) v ($4,$5) x $6 and Smoothness $8 Black $9 Mid $10 White $11"
-v -
-repeat $!
-l[$<]
-rgb2yuv -s c
--b[-3] $8
--ge[-1] $10
--le[-2] $11
-ge[-3] $9
-b[-5,-4] $12
-if $13
-gradient[-6] xy,4
-a[-7,-6] c
-norm[-6]
-b[-6] $14
-else
--b[-6] {$14*0.5}
--[-7,-1]
-sqr[-6]
-b[-6] {$14}
-sqrt[-6]
-endif
-n[-6] 0,1
-*[-6] $15
---[-6] {-6,i(0.01*w*$2,0.01*h*$3)}
-*[-1] {i(0.01*w*$4,0.01*h*$5)}
---[-6] {-6,i(0.01*w*$2,0.01*h*$3)}
-*[-1] {i(0.01*w*$4,0.01*h*$5)}
-+[-2,-1]
---[-5] {-5,i(0.01*w*$2,0.01*h*$3)}
-*[-1] {i(0.01*w*$4,0.01*h*$5)}
-+[-2,-1]
-/[-1] {i(0.01*w*$4,0.01*h*$5)+0.00001}
-c[-1] 0,1
-*[-1] $6
-a[-7--5,-1] c
--[-4] 2
-*[-4,-1]
-+[-3] 2
-*[-3,-2]
--colormap[-2] $1,1,1
-index[-3] [-1]
-rm[-1]
-*[-2] 2
-+[-2,-1]
-n 0,255
-to_rgb
-if $7
-circle $2%,$3%,1%,1,,64,128,255
-circle $4%,$5%,1%,1,,255,64,128
-endif
-endl
-done
-v +
#@gui Jpr Decimate : jpr_decimate,jpr_decimate(1)
#@gui : note = note{"Rescale in linear RGB space by cropping the frequency domain weighted"}
#@gui : note = note{"to decrease high frequency akin to Lanczos window on Sinc lobes."}
#@gui : note = note{"This filter may corrupt the alpha channel"}
#@gui : note = note{"High sharpness just crops frequency and gives bad halo"}
#@gui : Downsample Scale = float(0.375,0.1,1)
#@gui : Sharpness Factor = float(2,1.5,4)
#@gui : Updateauthornote = note("<small>update 2013-Jun-24 author @jayprich</small>")
#@cli jpr_decimate :
#@cli : Rescale in linear RGB space by cropping the frequency domain weighted
#@cli : to decrease high frequency akin to Lanczos window on Sinc lobes
#@cli : This filter discards the alpha channel
#@cli : High sharpness just crops frequency and gives bad halo
#@cli : $ -jpr_decimate 0.375,2
jpr_decimate : -skip ${1=0.375},${2=5}
-e[^-1] "Decimate scale $1 sharpness $2"
-v -
-srgb2rgb
-repeat $!
-l[$<]
nw={round($1*w/2)}
nh={round($1*h/2)}
sc={4*$nw/w*$nh/h}
mid={round(0.5/$1-0.5)}
-shift -$mid,-$mid
-fft
-shift $nw,$nh,0,0,2
-z 0,0,{2*$nw-1},{2*$nh-1}
-shift -$nw,-$nh,0,0,2
-f i*min(1,abs(2*x/w-1)*$2)*min(1,abs(2*y/h-1)*$2)
-ifft
-rm[-1]
-* $sc
-endl
-done
-rgb2srgb
-v +
#@cli :: Input/Output
#@cli tiff3d
#@cli : Input a 3D tif as a 3D image
#@cli : Note: This is useful for loading several 3D image stack
tiff3d : -e[^-1] "Load the file $1 as a 3D image"
-v - n=$!
-i $1 -a[{$n}--1] z
-v +
#@cli toff3d
#@cli : Output a 3D tif as a 3D image
toff3d : -e[^-1] "Save the 3D image as a tiff file"
-v -
-repeat $!
-o[$>] ${"-filename \"$1\","$>}
-done
-v +
#@cli :: 3D Rendering
#@cli boundingbox3d : _separation
#@cli : Bounding box of a 3D volume
#@cli : $ 100,100,100 -boundingbox3d
boundingbox3d : -skip ${1=10}
-e[^-1] "3D Bounding box"
-v - -repeat $! -l[$>]
-box3d {0,w},{0,h},{0,d} -primitives3d[-1] 1  -opacity3d[-1] 1
-if {$1>0}
-plane3d {0,w},{0,h},$1,{round({0,h}/{0,w}*$1)} -primitives3d[-1] 1 -opacity3d[-1] .1
-endif
-rm[0] -+3d
-endl -done -v +
#@cli render_volume  : _size,_quality,_opacity
#@cli : Pseudo volumic rendering
#@cli : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -render_volume
render_volume: -check "${1=8}>3&${2=5}>2&${3=.1}>0"
-v - -repeat $! -l[$>]
-mirror x
--tones {$2+1} -rm[1,2] -r[1--1] 100%,100%,100%,{0,s} -*[1--1] [0] -rm[0]
-reverse
-repeat $! i=$< -l[$<]
-if {im!=iM}
-pointcloud3d -gaussians3d $1,{$3*($i+1)/$2}
-else
-rm
-endif
-endl -done
-+3d -md3d -1 -+3d {.5},{.5},{.5}
-endl -done -v +
#@cli display_volume : _size,_quality,_opacity
#@cli : Display the volume with black background, a bounding box
#@cli : and a volumic rendering of the data.
#@cli : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -display_volume 8,5,.1
display_volume: -check "${1=8}>3&${2=5}>2&${3=.1}>0"
-e[^-1] "display_volume with size $1 quality $2 and opactiy $3"
-v - -repeat $! -l[$>]
--boundingbox3d 20
-render_volume[0] $1,$2,$3
-+3d
-endl -done -v +
d3d_black : 1 -d3d[0--2] [-1] -rm[-1]
#@cli view3d : _angle1,_angle2
#@cli : Apply a 3D view defined by two angles
#@cli : $ 50,50,50,3 -noise 10 -blur 5 -max 0 -n 0,255 -display_volume 32,5,1 -view3d
view3d : -skip ${1=25},${2=-120}
-e[^-1] "Apply 3D view"
-v - -repeat $! -l[$>]
-rotate3d 0,0,1,$1 -rotate3d 1,0,0,$2
-endl -done -v +
#@cli colordepth
#@cli : Color depth coding
#@cli : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -colordepth 5
colordepth: -skip ${1=5}
-e "colordepth coding with lut $1"
-v - -repeat $! -l[$>]
-colordepth_volume $1 -s z -+
-endl -done -v +
#@cli colordepth_volume
#@cli : Make a 3D volume of the same size, color it, resize orignal in color and multiply
colordepth_volume: -skip ${1=5}
-v - -repeat $! -l[$>]
-i [0] -f[-1] 'z/(d-1)*255' -map[-1] $1 -resize[0] 100%,100%,100%,3 -*
-endl -done -v +
colordepth_scale: -skip ${1=5}
10,{0,h-10} -f[-1] '(h-y)/(h-1)*255' -map[-1] $1 -frame[-1] 5,5,0,0,0
#@cli make_axis: _xmin,_xmax,_ymin,_ymax
#@cli : Display an axis around an image
#@cli : $ image.jpg -make_axis 0,1,0,1
make_axis:
-e[^-1] "Add axis"
-v - -repeat $! -l[$>]
-frame 1,1,0
100%,24,1,3,255 -axes[-1] $1,$2,{-1},{-1}
24,{0,h},1,3,255 -axes[-1] {w},{w},$4,$3 24,24,1,3,255 -a[-1,-2] y
-a[0,1] y -reverse -a[0,1] x
-frame 12,12,255 100%,5,1,3,255,255,255 -reverse -a y
-endl -done -v +
#@cli xlabel: _label
#@cli : Add a label to the x-axis (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -xlabel "x-axis"
xlabel:
-e[^-1] "Add a x label"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1] --lt[-1] 90%
-image[0] [-2],{{0,w}/2+12-{1,w}/2},{{0,h}-{1,h}},0,0,1,[-1] -k[0]
-endl -done -v +
#@cli ylabel: _label
#@cli : Add a label to the y-axis (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -ylabel "y-axis"
ylabel:
-e[^-1] "Add a y label"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1]
-rotate[-1] -90 --lt[-1] 90%
-image[0] [-2],0,{{0,h}/2-12-{1,h/2}},0,0,1,[-1] -k[0]
-endl -done -v +
#@cli title: _label
#@cli : Add a title (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -title "title"
title:
-e[^-1] "Add a title"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1] --lt[-1] 90%
-image[0] [-2],{{0,w}/2-{1,w}/2},0,0,0,1,[-1] -k[0]
-endl -done -v +
#@cli :: Feature detections
#@cli jeje_dog : scale1, scale2
#@cli : Difference of Gaussian filter
#@cli : $ sp 1 jeje_dog
jeje_dog: skip ${1=1},${2=2}
e[^-1] "Difference of Gaussian"
v - repeat $! l[$>] +b $2 b.. $1 sub endl done v +
#@cli quiver2d
#@cli : Display a sequence 2D vector field on a 2D image sequence
#@cli : both being represented az a 3D stack
quiver2d:
-e[^-1] "Cumulative sum along z-axis"
-s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1],10,1,1,1,255 -endl -done -rm[{$!/2}--1] -a z
#@cli warp2d : [field]
#@cli : Warp a 2D image stack using a vector field
#@cli : $ movie.cimg  -a z -resize 50%,50% --l[0] --lucas_kanade 5,1 -cumulate[-1] z -frame 30,30,0 -warp2d -endl -frame[0] 30,30,0 -a x
warp2d:
-e[^-1] "Warp a 3d stack using a displacement field"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
-s z -repeat {$!/2} -l[$>,{$>+$!/2}]
-warp[0] [1],1,1,1
-endl -done -rm[{$!/2}--1] -a z
-endl -done -v +
#@cli lucas_kanade: scale,smoothing
#@cli : Motion estimation using lucas and kanade approach
#@cli : Works on 2D+t image stacks/ has side effect
#@cli : [vx vy] = [Ixx Ixy; Ixy Iyy]^-1 [Ixt Iyt]
#@cli : $ image.jpg -repeat 20 --shift[-1] 1,0,0,0,2 -done -a z --lucas_kanade 2 -n 0,255 -frame 2 -a x
#@cli : $ image.jpg -repeat 20 --shift[-1] 1,1,0,0,2 -done -a z --lucas_kanade 2  -s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1] -endl -done -rm[{$!/2}--1] -a z
lucas_kanade: -skip ${1=2},${2=1}
-e[^-1] "Motion estimation with Lucas et Kanade algorithm"
-v - -repeat $! -l[$>]
-blur_xy $2 -structuretensors 0 -blur_xy $1,$1,0
--l -s c -rm[0,-1] -*[1,2] -*[0,2] -reverse -- -endl
--l[0] -s c -rm[3,5] -*[0,3] -*[1,2] -- -endl
-l[0] -s c -rm[2,4,5] -*[0,2] -sqr[1] -- -endl
-/[1,2] [0]  -rm[0] -a c
-endl -done -v +
#@cli unwarp2d : iteration,scales,smoothness,keep_field
#@cli : Unwarp a 2D+T volume
#@cli :
#@cli : $ image.jpg -repeat 20 --shift[-1] 1,0,0,0,2 -done -a z -unwarp 10,20
unwarp2d: -skip ${1=5},${2=5},${3=1},${4=0}
-e[^-1] "Unwarp a 2D+t volume with $1 iterations,
$2 scales and smoothing $3"
-v - -repeat $! -l[$>]
[0] 100%,100%,100%,2,0
-repeat $1
k=$>
-repeat $2
-if {$>==($2-1)} s=1 -else  s={($>+1)/$2} -endif scale={$s*100}%
-echo_stdout $k" "$>" "$s" "$scale" "{1/$s}" "{$3*$s}
--l[1]
-norm
-r $scale,$scale,100%,1
-lucas_kanade {max(.75,$3*$s)}
-* {1/$s} -cumulate z
-endl
-r[-1] [-2],5 -+[-1,-2]
--warp2d[0] [2] -rm[1] -reverse[-1,-2]
-done -done
-if {$4==0} -rm[0,2] -else -rm[0,1] -endif
-endl -done -v +
#@cli estimate_shift_core [image]
#@cli : Estimate a translation with a reference images with sub-pixel accuray
#@cli : image.jpg  -luminance --shift {u},{u},0,0,2 -estimate_shift[1] [0]
estimate_shift_core:
-e[^-1] "Translation estimation with Lucas et Kanade algorithm"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
-blur_xy 1 --gradient[0] xy,0 --[0,1] --sqr[1,2] --*[1,2] [0] -*[1,2] -rm[0]
Ixy={0,ia} Ixx={1,ia} Iyy={2,ia} Ixt={3,ia} Iyt={4,ia}
vx={-($Iyy*$Ixt-$Ixy*$Iyt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
vy={-($Ixx*$Iyt-$Ixy*$Ixt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
-rm 1,2,1,1,$vx,$vy
-endl -done -v +
#@cli multi_resolution_pyramide : _number_of_scales
#@cli : Build a multi-resolution pyramid
multi_resolution_pyramide:
-v - -repeat $! -l[$<]
-repeat {$1-1} --resize[-1] 50%,50%,50%,100%,2 -done -reverse
-endl -done -v +
#@cli shift_subpixel : [image]
#@cli : Shift an image with subpixel translation
#@cli : $ image.jpg 1,2,1,1,5,10.1 --shift_subpixel[0] [1]
shift_subpixel :
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
{0,w},{0,h},1,2 -f[-1] 'if(c==0,{1,i(0)},{1,i(0,1)})'
-warp[0] [2],1,2,1 -rm[1,2]
-endl -done -v +
#@cli estimate_shift [image]
#@cli : Estimate a translations between image and ref image [image]
#@cli : using a multi-resolution scheme
#@cli : $ image.jpg -luminance --shift 2,3 -crop 5%,5%,95%,95% -estimate_shift[1] [0],3
estimate_shift:
-e[^-1] "Estimate translation between images and image [$1]"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
N={round(log2(min({0,w},{0,h}))-2,1,-1)}
-multi_resolution_pyramide $N
1,2
-repeat 3 -repeat $N
--*[-1] {-2.0^(-($N-$>-1))} --shift_subpixel[{$N+$>}] [-1] -rm[-2]
-estimate_shift_core[-1] [$>]
-*[-1] {2.0^($N-$>-1)}
-+[-1,-2]
-done -done
-k[-1] -*[-1] -1
-endl -done -v +
#@cli unshift : iterations,number_of_scales
#@cli : Correct drift along Z in a 3D volume (video stabilization)
#@cli : $ image.jpg  -luminance -repeat  10 --shift[-1] {2*u},{2*u},0,0,2 -done -a z --unshift 1 -a x
unshift: -skip ${1=1}
-e[^-1] "unshift image stack"
-v - -repeat $! -l[$>]
-repeat $1
-s z -repeat {$!-1} -l[$>,{$>+1}]
--estimate_shift[1] [0] -*[-1] -1
-shift_subpixel[1] [-1] -rm[-1]
-endl -done -a z
-done
-endl -done -v +
#@cli register_lucas_kanade : _iterations, _scale
#@cli : Register images using lucas kanade motion estimation
#@cli : $ movie.cimg -luminance -resize 50%,50% -a z -register_lucas_kanade 5,10
register_lucas_kanade : -skip ${1=10},${2=10}
--lucas_kanade $2 -cumulate[-1] z --warp2d
-repeat $1
-lucas_kanade[-1] $2 -cumulate[-1] z -+[-1,-2] --warp2d
-done
#@cli detect_events : _scale_xy,_scale_t,_threshold
#@cli : Detect space time events using space time interest points
#@cli : $ 100,100,100 -noise 1 -blur 2 --detect_events , -pointscoordinates[-1] -resize[0] 100%,100%,100%,3,1 -n[0] 0,255 -circles[0] [1] -k[0]
detect_events : -skip ${1=1},${2=1},${3=9}
-e[^-1] "detect events with scale_xy $1 scale_z $2 and threshold $3"
-v - -repeat $! -l[$>]
-blur_xy $1 -blur_z $2 -structuretensors -blur_xy $1 -blur_z $2
-s z -apply_parallel "-eigen -k[0] -s c -k[2]" -a z
-sqrt
thres={{0,ia}+$3*sqrt({0,iv})}
--max_patch[0] 8 -threshold[0] $thres -*
-endl -done -v +
#@cli detect_spots : _scale,_threshold
#@cli : Detect spots in the image
#@cli : $ 100,100 -noise .2,2 -blur 1 -n 0,255 -noise 5 --detect_spots , -pointscoordinates[-1] -resize[0] 100%,100%,1,3,1 -circles[0] [1] -k[0]
detect_spots : -skip ${1=1},${2=4}
-e[^-1] "detect events with scale $1 and threshold $2"
-v - -repeat $! -l[$>]
-blur $1 --blur $1 -- thres={$2*${-mad[0]}}
--max_patch[0] 3 --threshold[0] $thres -*
-endl -done -v +
#@cli measure_colocalization:
#@cli : Colocalization analysis
#@cli : Overlap RG/R RG/G RG/R+G MOC M1 and M2
#@cli : $ 256,256,1,2 -noise 3 -blur 5 -measure_colocalization
measure_colocalization:
-v - -repeat $! -l[$>]
-if {{0,s}==2}
-s c --gt 0 --sqr[0,1] --*[0] [1] --*[2] [3] --or[2] [3]
O1={{7,is}/{2,is}}
O2={{7,is}/{3,is}}
O={{7,is}/{8,is}}
-*[2] [1] -*[3] [0]
MOC={{6,is}/sqrt({4,is}*{5,is})}
M1={{3,is}/{0,is}}
M2={{2,is}/{1,is}}
-rm  1,6,1,1,$O1,$O2,$O,$MOC,$M1,$M2
-else
-echo "needs images with two channels"
1,6,1,1,0,0
-endif
-endl -done -v +
#@cli measure_colocalization_object:
#@cli : Compute the number of intersecting objects
#@cli : in each channels versus the number of objects
#@cli : $ 256,256,1,2 -noise 3 -blur 5 -gt 0 -measure_object_colocalization
measure_object_colocalization:
-v - -repeat $! -l[$>]
-if {{0,s}==2}
-gt 0 -s c -label_fg .1
n1=0 -repeat {0,iM}
--eq[0] {$>+1} -*[-1] [1]
-if  {iM>0} n1={$n1+1} -endif
-rm[-1]
-done
n1={0,100*$n1/iM}
n2=0 -repeat {1,iM}
--eq[1] {$>+1} -*[-1] [0]
-if  {iM>0} n2={$n2+1} -endif
-rm[-1]
-done
n2={1,100*$n2/iM}
-rm
1,2,1,1,$n1,$n2
-else
-echo "needs images with two channels"
1,6,1,1,0,0
-endif
-endl -done -v +
#@cli local_moments : _scale
#@cli : Compute local second order moments tensor
#@cli : http://en.wikipedia.org/wiki/Image_moment
#@cli : $ image.jpg --local_moments 1
local_moments : -skip ${1=1}
-v - -repeat $! -l[$>]
-norm
-if {d==1}
--mul[0] 'x'   --mul[0] 'y'   --mul[0] 'x*x'
--mul[0] 'x*y' --mul[0] 'y*y' -blur $1
--sqr[1] -/[-1] [0] --[3,-1] -/[3] [0]
--*[1,2] -/[-1] [0] --[4,-1] -/[4] [0]
--sqr[2] -/[-1] [0] --[5,-1] -/[5] [0]
-k[3-5] -a c
-else
--mul[0] 'x'   --mul[0] 'y'   --mul[0] 'z'   --mul[0] 'x*x'
--mul[0] 'x*y' --mul[0] 'x*z' --mul[0] 'y*y' --mul[0] 'y*z'
--mul[0] 'z*z' -blur $1
--sqr[1] -/[-1] [0] --[4,-1] -/[4] [0]
--*[1,2] -/[-1] [0] --[5,-1] -/[5] [0]
--*[1,3] -/[-1] [0] --[6,-1] -/[6] [0]
--sqr[2] -/[-1] [0] --[7,-1] -/[7] [0]
--*[2,3] -/[-1] [0] --[8,-1] -/[8] [0]
--sqr[3] -/[-1] [0] --[9,-1] -/[9] [0]
-k[4-9] -a c
-endif
-endl -done -v +
#@cli smooth_moments : _scale,_iterations,_dt
#@cli : Anisotropic diffusion using local moment tensors
#@cli : $ image.jpg --noise 10 --smooth_moments[-1] 1,10,1 -print_psnr
smooth_moments: -check "${1=1}>0&${2=100}>0&${3=1}>0"
-v - -repeat $! -l[$>]
--local_moments[-1] $1 -smooth[0] [1],$2,$3,0 -k[0]
-endl -done -v +
#@cli pointscoordinates
#@cli : Return the list of points in the image as 3xN or 2xN columns vector
#@cli : $ 100,100 -noise .1,2 ==. 1 --pointscoordinates
pointscoordinates :
-e[^-1] "return the list of points in the image"
-v - -repeat $! -l[$>]
-if {d>1}
-if {iM>0} -pointcloud3d -s3d -k[2] -split y,{h/3} -a x -else 0 -endif
-else
-if {iM>0} -pointcloud3d -s3d -k[2] -split y,{h/3} -a x -else 0 -endif
-rows 0,1
-endif
-endl -done -v +
#@cli circles : [x,y,radius,opacity,color,..] ||  [x,y,z,radius,opacity,color,..]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 -circles[0] [1] -k[0]
circles: -skip ${2=3},${3=1}
-e[^-1] "Draw circles on the image."
-v -  -pass$1 0 -repeat {$!-1} -l[$>,-1]
-if {{0,d}>1}
-if {1,h<4} -r[1] 100%,{5+{0,s}},1,1,0 -l[1] -s y -f[3] $2 -f[4] $3 -f[5--1] 255 -a y -endl -endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} o={1,i($>,4)} i=$>
-repeat {0,s}
-if {$z>=0&$z<{0,d}-1}
-sh[0] $z,$z,$> -ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,5+$>)}
-rm[-1]
-endif
-done
-done
-else
-if {1,h<3} -r[1] 100%,{4+{0,s}},1,1,0 -l[1] -s y -f[2] $2 -f[3] $3 -f[4--1] 255 -a y -endl -endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} o={1,i($>,3)} i=$> col={1,i($>,4)}
-repeat {0,s}
-sh[0] 0,0,$> -ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,{4+$>})}
-rm[-1]
-done
-done
-endif
-endl -done -rm[-1] -v +
#@cli labels: [image]
#@cli : Draw labels on the image
#@cli : The labels are defined by image as
#@cli : in 2D [x,y,label,font_size,opacity,color]
#@cli : in 3D [x,y,z,label,font_size,opacity,color]
#@cli : $ 512,512,1,3 10,2 -noise[-1] 1 -n[-1] 0,512 -labels[0] [1]
labels:
-e[^-1] "Draw labels on the image."
-v -  -pass$1 0 -repeat {$!-1} -l[$>,-1]
-if {{0,d}>1}
-if {1,h<4}
-r[1] 100%,{6+{0,s}},1,1,0
-l[1] -s y -f[3] 'x' -f[4] 13 -f[5] 1 -f[6--1] 255 -a y -endl
-endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} f={1,i($>,4)} o={1,i($>,5)} i=$>
-repeat {0,s}
-if {$z>=0&$z<{0,d}}
-sh[0] $z,$z,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,6+$>)}
-rm[-1]
-endif
-done
-done
-else
-if {1,h<3}
-r[1] 100%,{5+{0,s}},1,1,0 -l[1] -s y -f[2] 'x' -f[3] 13 -f[4] 1 -f[5--1] 255 -a y -endl
-endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} f={1,i($>,3)} o={1,i($>,4)} i=$>
-repeat {0,s}
-sh[0] 0,0,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,5+$>)}
-rm[-1]
-done
-done
-endif
-rm[-1]
-endl -done -v +
#@cli : croparound : [x,y,dx,dy] || [x,y,z,dx,dy,dz]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 -circles[0] [1] -k[0]
croparound: -skip ${2=3},${3=3},${4=3}
-e[^-1] "Crop image at coordinates "
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
-if {0,d>1}
-if {1,h<6}
-r[1] 100%,6,1,1,0
-l[1] -s y -f[3] $2 -f[4] $3 -f[5] $4 -a y -endl
-endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} dx={1,i($>,3)} dy={1,i($>,4)} dz={1,i($>,5)} i=$>
--crop[0] {$x-$dx},{$y-$dy},{$z-$dz},{$x+$dx},{$y+$dy},{$z+$dz}
-done
-else
-if {1,h<4} -r[1] 100%,4,1,1,0 -l[1] -s y -f[2] $2 -f[3] $3 -a y -endl -endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} dx={1,i($>,2)} dy={1,i($>,3)} i=$>
--crop[0] {$x-$dx},{$y-$dy},{$x+$dx},{$y+$dy}
-done
-endif
-endl -done -rm[0,1] -v +
#@cli random_walks : width,height,length,number,speed
#@cli : Generate random walks tracks (list of coordinates x,y,t as a Nx3 image.)
#@cli : $ 100,100,20 -random_walks 100,100,20,5,1 -circles[0] [1] -k[0] -blur_xy 1 -s z -max
#@cli : $ 100,100,20 -random_walks 100,100,20,10,1 -circles[0] [1] -k[0] -blur 1 -n 0,255 -display_volume 8,10,1 -rotate3d 0,0,1,25 -rotate3d 1,0,0,-120 -snapshot3d 600,1,0,0,0 -autocrop
random_walks :
number=$4 width=$1 height=$2 length=$3 speed=$5
$number,3
-l[-1]
-noise 1,1
-sh 0,0,0,0 -n[-1] 1,{$width-1} -rm[-1]
-sh 1,1,0,0 -n[-1] 1,{$height-1} -rm[-1]
-sh 2,2,0,0 -f[-1] 0 -rm[-1]
-repeat {$length-1} --l[-1]
-noise 1
-sh 0,0,0,0 -c[-1] 1,{$width-2} -rm[-1]
-sh 1,1,0,0 -c[-1] 1,{$height-2} -rm[-1]
-sh 2,2,0,0 -f[-1] '$>+1' -rm[-1]
-endl -done -a x
-endl
#@cli fibers: number,length,curvature
#@cli : Draw a serie of fibers in 2D or 3D
#@cli : $ 600,400 -pelotte 10,200,10
fibers :
-repeat $! -l[$>]
$2,$1,1,{if(d>1,3,2)}
-l[-1] -noise[-1] 10 -blur_x[-1] $3 --norm -/ -endl
-if {0,d>1} -s[-1] c -*[3] {0,2*d/(w+h)} -a[1--1] c -endif
-cumulate[-1] x -s[-1] y
-repeat {$!-1}
-l[0,{$>+1}]
-s c
-+[1] {0,w/2}
-+[2] {0,h/2}
-if {$!>3} -+[3] {0,d/2} -endif
-a[1--1] y
-circles[0] [1],0,-1
-endl
-done
-k[0]
-endl -done
#@cli :: Filtering and deconvolution
#@cli movavg : _size>=1
#@cli : moving average of image list with a box filter of size _size
#@cli : $ 11 -f 'x>w/2' --l[-1] -s x -movavg 9 -a x -endl  --blur[0] 1.2 -a c -display_graph
movavg : -check "$1>=1"
-e[^-1] "moving average with size "$1 -v -
n={$1-1}
-repeat $n
-repeat {{$!}-1} --+[{$>},{$>+1}] -*[-1] .5 -rm[$>] -mv[-1] $> -done
-reverse
-done
-if {$n%2!=0} -reverse -endif
-v +
#@cli zmean
#@cli : average along z-axis
zmean :
-v - -repeat $! -l[$>]
n={0,d} -s z -+ -/ $n
-endl -done -v +
#@cli zstd
#@cli : standard deviation along z-axis
zstd :
-v - -repeat $! -l[$>]
--zmean -sqr[-1]
-l[0] -sqr -zmean -endl
-- -sqrt
-endl -done -v +
#@cli zmax
#@cli : maximum along z-axis
zmax :
-v - -repeat $! -l[$>] -s z -max -endl -done -v +
#@cli zmin
#@cli : maximum along z-axis
zmin :
-v - -repeat $! -l[$>]  -s z -min -endl -done -v +
#@cli kymoline:
#@cli : interactively select a line and extract a line profile
kymoline:
--select 1
x1={i(0,0)} y1={i(0,1)} x2={i(0,3)} y2={i(0,4)}
d={sqrt(($x2-$x1)^2+($y2-$y1)^2)}
u={($x2-$x1)/$d} v={($y2-$y1)/$d}
-rm[-1]
-f 'if(x<=$d&&y==0,i($x1+x*$u,$y1+x*$v,z,c,1),5)'
-crop 0,0,{int($d-1)},0
#@cli fftshift
#@cli : Shift a image so that the fft has it center in the middle
#@cli : $ image.jpg -fftshift
fftshift :
-v - -repeat $! -l[$>]
-shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
-endl -done -v +
#@cli whiten_frequency : _alpha
#@cli : Whitening filter (equalize the frequency of the image; nothing todo with color)
#@cli : $ image.jpg -whiten_frequency
whiten_frequency : -check "${1=.25}>=0"
-e[^-1] "Whiten the frequency with parameter "$1
-v - -repeat $! -l[$>]
-fft --a c -norm[-1] -pow[-1] $1 -max[-1] 1e-12 -/[-1] {ia} -/[0-1] [2] -rm[2] -ifft -k[0]
-endl -done -v +
#@cli deblur_goldmeinel2 : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur and zoom x2 selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg --blur 1 --deblur_goldmeinel2[-1] 1
deblur_goldmeinel2 : -check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1} -skip ${5=1}
-e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${-arg\ 1+!$4,"",quasi-}"gaussian kernel."
-v - -repeat $! -l[$>]
[0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
--b[-1] $1,1,$4 -r[-1] 50%,50%,50% --/[0,-1] -rm[-2] -^[-1] $3 -r[-1] 200%,200%,200%,100%,5 -*[-1,-2]
-done -rm[0]
-endl -done -v +
#@cli deblur_richardsonlucy2 : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur and zoom selected images using Richardson-Lucy algorithm.
#@cli : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@cli : $ image.jpg --blur 1 --deblur_richardsonlucy2[-1] 1
deblur_richardsonlucy2 : -check "$1>=0 && ${2=50}>=0" -skip ${3=1} -skip ${4=1}
-e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${-arg\ 1+!$3,"",quasi-}"gaussian kernel."
-v - -repeat $! -l[$>]
[0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
--b[-1] $1,1,{$3!=0} -r[-1] 50%,50%,50%,100%,5 --/[0,-1] -rm[-2] -r[-1] 200%,200%,200%,100%,5 -b[-1] $1,1,{$3!=0}  -*[-1,-2]
-done -rm[0]
-endl -done -v +
#@cli correlate_fft
#@cli : Convolve selected images with image [$1]
#@cli : $ image.jpg 100%,100% -gaussian[-1] 20,1,45 --correlate_fft[0] [1]
correlate_fft :
-e[^-1] "Correlate image with image [$1]"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
w2={int({0,w}/2)} h2={int({0,h}/2)} d2={int({0,d}/2)}
-r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5  -shift[1] -$w2,-$h2,-$d2,0,2
-fft[0] -fft[2] -*[3] -1
--*[-4] [-1] --*[-4] [-3] -+[-2,-1]
-*[-5,-3] -*[-3,-2] --[-3,-2]
-ifft -rm[-1]
-endl -done -v +
#@cli deconvolve_richardsonlucy : filter,nb_iter>=1, acceletation>=0
#@cli : Deconvolve images using the first one as a blur operator (PSF)
#@cli : $ image.jpg 16,16 -gaussian[-1] 2,1,45 --convolve_fft[0] [1] -deconvolve_richardsonlucy[-1] [1],100
deconvolve_richardsonlucy : -check ${-is_image_arg\ $1}" && ${2=5}>=1"
-e[^-1] "Deblur image using Richardson-Lucy algorithm with filter [$1]."
-v - -pass$1 0
-repeat {$!-1} -l[$>,-1]
-r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1] [0]
-repeat $2
--convolve_fft[-1] [1] -max[-1] 1e-6 --/[0] [-1] -rm[-2]
-correlate_fft[-1] [1] -*[-1,-2]
-done -rm[0,1]
-endl -done -v +
#@cli deconvolve_goldmeinel : filter,nb_iter>=1,acceleration>=0
#@cli : Deblur and zoom selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg 100%,100% -gaussian[-1] 5,1,45 --convolve_fft[0] [1] --deconvolve_goldmeinel[-1] [2],5
deconvolve_goldmeinel : -check ${-is_image_arg\ $1}" && ${2=5}>=1 && ${3=1}>=1"
-e[^-1] "Deblur image using Gold-Meinel algorithm with filter $1, $2 iterationsand acceleration $3."
-v - -pass$1 0
-repeat {$!-1} -l[$>,-1]
-r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1]
--blur[0] 0.75
-repeat $2
--convolve_fft[-1] [1] -max[-1] 1e-6 --/[0] [-1] -rm[-2]
-^[-1] $3 -*[-1,-2]
-done -rm[0,1]
-endl -done -v +
#@cli deconvolve_richardsonlucy_blind : nb_iter>=1,acceleration>=0
#@cli : Deblur and zoom selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ sp 1 blur_linear 1,5,45 +deconvolve_richardsonlucy_blind[-1]
deconvolve_richardsonlucy_blind : check "${1=5}>=1"
e[^-1] "Deblur image using richardsonlucy algorithm with $1 iterations"
v -
repeat {$!} -l[$>]
-- {im-1}
avg={0,ia}
+b 0.75
+l.. autocorrelate threshold 10%,1 normalize_sum endl
repeat $1
+convolve_fft[1] [2] max[-1] 1e-6 +/[0] [-1] rm[-2]
correlate_fft. [2]
*[1,3]
*[1] {1,$avg/ia}
l[1] +iee *. 0.01 + endl
+convolve_fft[2] [1] max[-1] 1e-6 +/[0] [-1] rm[-2]
correlate_fft. [1]
*[2,3]
normalize_sum[2]
+l +powerspectrum n 0,255 append_tiles , text $> w rm endl
done rm[0]
endl done v +
#@cli blend_sharpness
#@cli : Blend images in the list according to their sharpness
blend_sharpness:
-e[^-1] "Blend images according to their sharpness (gradient norm)"
-v -
N=$! --gradient_norm
--+[$N--1] -max[$N--1] .01 -/[$N--2] [-1] -rm[-1] -a[$N--1] z -d[-1] -s[-1] z
-a[0-{$N-1}] x -a[1--1] x -* -s x,$N -+
-v +
#@cli reconstruct_laplacian : param
#@cli : Reconstruct an image from its laplacian
#@cli : $ image.jpg --laplacian -reconstruct_laplacian[-1] ,
reconstruct_laplacian: -skip ${1=0}
-e[^-1] "Reconstruct an image from its laplacian"
-v - -repeat $! -l[$>]
-s c -repeat $! -l[$>]
-fft a={0,i(0,0)} b={1,i(0,0)}
100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
-=[-1] 1 -+[-1] $1
-/[0,1] [-1] -k[0,1] -=[0] $a -=[1] $b -ifft -k[0]
-endl -done -a c
-endl -done -v +
#@cli local_variance : _radius,_robust
#@cli : Local variance filter
#@cli : $ image.jpg  --local_variance
local_variance: -skip ${1=2},${2=0}
-e[^-1] "Estimate local variance with scale "$1" and robustness "$2
-v - -repeat $! -l[$>]
-if {$2==0}
--blur $1,1,1 -- -sqr -blur $1,1,1
-else
--median {2*$1+1} -- -abs -median {2*$1+1} -* 1.4826 -sqr
-endif
-endl -done -v +
#@cli local_noise_variance : _radius,_robust
#@cli : Local noise variance filter
#@cli : $ image.jpg  --local_variance
local_noise_variance: -skip ${1=2},${2=0}
-e[^-1] "Estimate local variance with scale "$1" and robustness "$2
-v - -repeat $! -l[$>]
-laplacian -if {d==1} -* {1/sqrt(20)} -else -* {1/sqrt(42)} -endif -local_variance $1,$2
-endl -done -v +
#@cli normalize_local_variance : _amplitude,_radius,_threshold,_repeat
#@cli : Local variance normalization
#@cli : $ image.jpg  --normalize_local_variance
normalize_local_variance: -skip ${1=50},${2=2},${3=25},${4=1}
-e[^-1] "Normalize local variance with amplitude $1, scale $2, threshold $3 (x$4 times)."
-v - -repeat $! -l[$>]
-repeat $4
--local_variance $2 -sqrt[-1] -max[-1] $3
--blur[0] $2,1,1 ---[0,-1] -/[-1] [1] -*[-1] $1 -+[-2,-1] -k[-1]
-done
-endl -done -v +
#@cli local_wiener : _radius
#@cli : Local Wiener filtering
#@cli : http://en.wikipedia.org/wiki/Wiener_filter
#@cli : $ image.jpg --noise 10 --local_wiener[-1] 1 -print_psnr
local_wiener : -skip ${1=2}
-e[^-1] "Local Wiener filtering"
-v - -repeat $! -l[$>]
sigma=${-noise_std}
--blur $1
--local_variance[0] $1 ---[-1] {$sigma*$sigma} -reverse[-1,-2] -/[-1,-2]
---[0,1]
-*[-1,-2] -+[-1,-2] -k[-1]
-endl -done -v +
#@cli periodize
#@cli : Periodization of the image
#@cli : $ image.jpg -periodize
periodize :
-e[^-1] "periodize"
-v - -repeat $! -l[$>]
-if {w>1} --mirror x -a x -endif
-if {h>1} --mirror y -a y -endif
-if {d>1} --mirror z -a z -endif
-endl -done -v +
#@cli tape
#@cli : Apply a Hann window (e.g. to compute a power spectrum)
#@cli : $ image.jpg -tape
tape :
-e[^-1] "apply a Hann tapering window"
-v - -repeat $! -l[$>]
-if {w>1} -f 'i*sin(pi*x/(w-1))^2' -endif
-if {h>1} -f 'i*sin(pi*y/(h-1))^2' -endif
-if {d>1} -f 'i*sin(pi*z/(d-1))^2' -endif
-endl -done -v +
#@cli powerspectrum :
#@cli : Compute power spectrum
#@cli : $ image.jpg -powerspectrum
powerspectrum :
-e[^-1] "Compute power spectrum"
-v - -repeat $! -l[$>] -display_fft -k[0] -endl -done -v +
#@cli fouriermix : [image],_cut_of_frequency
#@cli :  Mix two images using their respectives low and high frequencies
#@cli : $ image1.jpg image2.jpg  --fouriermix .5
fouriermix : -skip ${2=10%}
-e[^-1] "fourier mix images."
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
-fft[0] -fft[2] -fftshift
100%,100% -circle[-1] 50%,50%,$2,1,1 -blur[-1] 1,1,1 -n[-1] 0,1 -d
-*[0,1] [-1] -negate[-1] -*[2,3] [-1] -rm[-1] -+[0,2] -+[1,2] -fftshift
-ifft
-endl -done -rm[-1] -v +
#@cli blend_fft: [image]
#@cli : blend images using strongest frequencies
blend_fft : -skip ${2=2}
-v - -pass$1 0
--l[-1]
-tape -powerspectrum -blur 1 --blur 2 --
-max '{ia+$2*sqrt(iv)}' -circle 50%,50%,20,1,@{0,im} -n 0,1 -d
-fftshift
-endl -fft[-2] -*[-2,-3] [-1] -negate[-1]
-repeat {$!-3} -l[$>,-1,-2,-3]
-fft[0] -*[0,1] [-1] -+[0] [2] -+[1] [3] -ifft[0,1] -rm[1]
-endl -done -rm[-1,-2,-3] -v +
#@cli denoise_fft : _threshold
#@cli : Illustrate the thresholding of Fourier coefficients
#@cli : $ 256,256 -f '128+128*sin(x+y)' --noise 50 --denoise_fft[-1] 70%
denoise_fft : -skip ${1=1}
-e[^-1] "Threshold Fourier coefficients with threshold "$1"."
-v - -repeat $! -l[$>]
--l[-1] -tape -powerspectrum -threshold $1 -fftshift -endl
-fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft -k[0]
-n 0,255
-endl -done -v +
#@cli unstrip : _smoothness,_scale,_threshold
#@cli : Remove stripes in an image
#@cli : $ image.jpg -f '.5*i*(1+.25*sin(x))' --unstrip
unstrip : -skip ${1=25},${2=20},${3=4}
-e[^-1] "Remove stripes"
-v - -repeat $! -l[$>]
--l[-1]
-tape -powerspectrum -norm -detect_spots 1,$3 -dilate_circ $2 -gt 0
-n 0,1 -negate -circle 50%,50%,$2,1,1
-if {im<.9}
active=1 -blur $1 -n 0,1 -fftshift -if {iM==0} -f 1 -endif
-else
active=0
-endif
-endl
-if {$active==1}
-fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft
-endif
-k[0]
-endl -done -v +
#@cli autocorrelate
#@cli : Autocorrelation using fourier transform
#@cli : $ image.jpg -autocorrelate
autocorrelate :
-e[^-1] "Compute autocorrelation"
-v - -repeat $! -l[$>] -fft -sqr -+ -sqrt -ifft -k[0] -fftshift -endl -done -v +
#@cli spotify : _scale>0,_nb_iter>0,
#@cli : Make everything look like a spot
#@cli : Default values '_nb_iter=1, _scale=1'
#@cli : $ image.jpg --spotify 1,10
#@cli : $ image.jpg --spotify 1,20 -norm[-1] -gt[-1] 5% -blur 1 -*
spotify : -check "${1=1}>0 && ${2=1}>0"
-e[^-1] "Spotify with scale $1 with $2 iterations"
-v - -repeat $! -l[$>]
-if {0,im!=iM}
s={0,ia}
-repeat $2
-b $1 --b {2*$1} -- -max 0 -* '{0,$s/ia}'
-done
-endif
-endl -done -v +
#@cli mapblur : _levels
#@cli : Blur the image with a map
#@cli : $ image.jpg --f '10*x/w' -mapblur
mapblur: -check "${1=10}>0"
-e[^-1] "Blur images using a blur map (works using pairs of images)."
-v - -repeat {$!/2} -l[{2*$>},{2*$>+1}]
smin={1,im} smax={1,iM}
-l[0] -repeat $1 --blur[0] {$smin+$>*($smax-$smin)/($1)} -done -rm[0] -a z -endl
-l[1] -tones $1 -gt 0 -blur 1 -a z -endl
-* -s z -+
-endl -done -v +
#@cli vesselness : _scale>0,coefA,coefB,coefC
#@cli : Frangi's vesselness filter based on the eigen value of the Hessian
#@cli : Reference:
#@cli : A. F. Frangi, W. J. Niessen, K. . L. Vincken, M. A. Viergever,
#@cli : "Multiscale vessel enhancement filtering"
#@cli : Medical Image Computing and Computer Assisted Intervention MICCAI'98,
#@cli : vol. 1496, pp. 130 137, 1998.
#@cli : $ vessel.png --negate -vesselness[-1] 3
vesselness : -skip ${1=1},${2=1},${3=1},${4=1}
-e[^-1] "Tubeness with scale $1."
-v - -repeat $! -l[$>]
-blur $1
-s c -repeat $! -l[$>]
-hessian -a c -eigen -k[0] --sign -abs[-2] -sort[-2] +,c -* --norm -a c
-if {d>1}
-f 'if(i(x,y,z,1)<0&&i(x,y,z,2)<0,exp(-0.5/$2^2*(i(x,y,z,1)/i(x,y,z,2))^2)*exp(-0.5/$3^2*(i(x,y,z,0)^2/abs(i(x,y,z,1)*i(x,y,z,2))))*(1-exp(-0.5/$4^2*i(x,y,z,3)^2)),0)'
-else
-f 'if(i(x,y,z,1)<0,exp(-0.5/($2)^2*(i(x,y,z,0)/i(x,y,z,1))^2)*(1-exp(-0.5/($3)^2*i(x,y,z,2)^2)),0)'
-endif
-endl -done -a c
-endl -done -v +
#@cli bgsubstract : _length>0
#@cli : Substract the background using a temporal top-hat filter
#@cli : $ 100,100,100 -noise 1 -blur 1 --bgsubstract 10
bgsubstract:  -check "${1=5}>0"
-e[^-1] "Temporal background substraction with length $1."
-v - -repeat $! -l[$>]
1,1,$1 -f[-1] 1 --erode[0] [1] --[0] [-1] -rm[1,-1]
-endl -done -v +
#@cli schizo : _amplitude,_amplitude_normal,_nb_iterations,_strength
#@cli : Schizo filter gives either a furry image or a smoothed image
#@cli : Default values '_amplitude=100,amplitude_normal=-50 _nb_iter=5,_strength=.75'
#@cli : $ image.jpg --schizo 100,-50 --schizo[0] -50,100 -max 0
schizo : -skip ${1=100},${2=-50},${3=5},${4=.75}
-e[^-1] "Schizo filter smoothing with // $1 and T $2 and $3 iterations."
-v - -repeat $! -l[$>]
[0]
-repeat $3
-l[-1]
--iee -*[-1] {$1/(0.0001+max(abs(im),abs(iM)))}
--inn[0] -*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}
-+
-endl
-*[-1] $4  --*[0] {1-$4} -+[-1,-2]
-done -rm[0]
-endl -done -v +
#@cli scandoc : _smooth,_background,_black,_white
#@cli : improve scanned document
#@cli : $ image.jpg -scandoc
scandoc: -skip ${1=3},${2=100},${3=10%},${4=90%}
-v - -repeat $! -l[$>] -split_opacity -l[0]
-median $1 --blur $2 -- -min 0
-s c -n 0,1 -a c -c $3,$4 -n 0,255
-endl -a c -endl -done -v +
#@cli warp_affine [3x3 affine matrix]
#@cli : Warp the image [0] using an 2D affine field defined by a 3x3 matrix
#@cli : $ image.jpg 3,1,1,1,1 -diagonal[-1] -noise[-1] .1 --warp_affine[0] [1]
warp_affine :
-e[^-1] "Warp image using affine transform defined by 3x3 image ["$1"]"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
params=({1,i(0,0)},{1,i(1,0)},{1,i(2,0)};\
{1,i(0,1)},{1,i(1,1)},{1,i(2,1)};\
{1,i(0,2)},{1,i(1,2)},{1,i(2,2)})
{0,w},{0,h},1,1,1 --f[-1] x --f[-1] y -a[-3--1] c
-mix_channels[-1] $params
-channels[-1] 1,2
-warp[0] [-1],0,2,0 -rm[-1]
-endl -done -rm[-1] -v +
#@cli solve_least_square: X
#@cli : Solves $|Ax-b|^2$
#@cli : $  (1,1,1,1;1,2,1,2;1,1,2,2) (-1,1,0;-2,0,1) -mmul[1] [0] -solve_least_square[0] [1]
solve_least_square:
-e[^-1] "Solves least square"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
--transpose --mmul[0,2] --mmul[0,3]
-k[-1,-2] -invert[0] -mmul -transpose
-endl -done -v +
#@cli calibrate_affine_transform : image
calibrate_affine_transform :
-e[] "Interactive affine transformation calibration between image and image $1"
-e[] "- Use mouse button 1 to select matching points on the two images."
-e[] "- Use mouse button 2 to remove points in the list"
-e[] "- Press Space to re-init the list of points"
-e[] "- Close the window to finish\n"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1] -reverse
0 0 (1,0,0;0,1,0;0,0,1) Z=0
-do
x1={*1,x} y1={*1,y}
x2={*2,x} y2={*2,y}
-if {$x1>=0}
-if {{*1,b}&1}
(1;{$x1/{*1,w}*{0,w}};{$y1/{*1,h}*{0,h}})
-if {2,h>1} -a[2,-1] x -else -rm[2] -mv[-1] 2 -endif
-else
-if {{*1,b}&2}
-if {2,w>1} -columns[2] 0,{2,w-2} -else -rm[2] 0 -mv[-1] 2 -endif
-endif
-endif
-endif
-if {$x2>=0}
-if {{*2,b}&1}
(1;{$x2/{*2,w}*{1,w}};{$y2/{*2,h}*{1,h}})
-if {3,h>1} -a[3,-1] x -else -rm[3] -mv[-1] 3 -endif
-else
-if {{*2,b}&2}
-if {3,w>1} -columns[3] 0,{3,w-2} -else -rm[3] 0 -mv[-1] 3 -endif
-endif
-endif
-endif
-if {{*0,SPACE}" || "{*1,SPACE}" || "{*2,SPACE}} -rm[2,3,4] 0 0 (1,0,0;0,1,0;0,0,1) -endif
-if {*1,o} Z={max(0,min({0,d}-1,$Z+{*1,o}))} -wait -1 -endif
-if {*2,o} Z={max(0,min({0,d}-1,$Z+{*2,o}))} -wait -1 -endif
-if {*3,o} Z={max(0,min({0,d}-1,$Z+{*3,o}))} -wait -1 -endif
N={min({2,w},{3,w})}
-if {{2,h}>1" && "{3,h}>1}
-if {$N<=3}
-rm[4] --l[2,3]
-rows 1,2 -columns 0,{$N-1} -- -s x -+ -/ $N
(1,0,0;{-i(0,0)},1,0;{-i(0,1)},0,1) -rm[-2]
-endl
-else
-rm[4] --l[2,3] -columns 0,{$N-1} -solve_least_square[0] [1] -rm[1] -endl
-endif
-endif
--l[0,2]
-if {{0,d}>1} -slices[0] $Z -endif
-r[0] 200%,200%,1,1,5
-r[0] 100%,100%,1,3,0 -grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
-if {1,h>1} -rows[1] 1,2  -*[1] 2
1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  -circles[0] [1]
-labels[0] [1] -endif -w1[0] -1,-1,-1,-1,"First image (n="{1,w}")" -rm
-endl
--l[1,3]
-if {{0,d}>1} -slices[0] $Z -endif
-r[0] 200%,200%,1,1,5
-r[0] 100%,100%,1,3,0  -shift[0] 0,0,0,1 -grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
-if {1,h>1} -rows[1] 1,2 -*[1] 2
1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  -circles[0] [1]
-labels[0] [1] -endif -w2[0] -1,-1,-1,-1,"Second image (n="{1,w}")" -rm
-endl
--l[0,1,4]
-if {{0,d}>1} -slices[0,1] $Z -endif
-warp_affine[1] [2] -rm[2] -a c
-r[0] 200%,200%,1,100%,5
-grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
-w3 -1,-1,-1,-1,"merge "$N" Z="$Z -rm
-endl
-wait
-while {{*1}" && "!{*1,Q}" && "!{*1,ESC}" && "{*2}}
-w1[] 0 -w2[] 0 -w3[] 0
-k[-1]
-endl -done -v +
#@cli vobs : _scale
#@cli : Motion quantity (Normal motion)  h * (|Ixy|^2 |It|/|Ixy|) / h * Ixy^2
#@cli : Irani, Michal and Rousso, Benny and Peleg, Shmuel, Detecting and tracking multiple moving objects using temporal integration, ECCV'92.
#@cli : $ 100,100,10 -noise 1 -blur 1 --vobs
vobs : -check "${1=1}>0 && ${2=3}>0"
-e[^-1] "Motion quantity with scale $1"
-v - -repeat $! -l[$>]
-gradient -a[0,1] c -norm[0] -abs[1] -*[1] [0] -sqr[0] -blur $1,1,1 -reverse -max[1] 5% -/
-endl -done -v +
#@cli display_vobs
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 -noise .7,2 ==. 1 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_vobs
display_vobs :
--vobs 1 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1] 100%,{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Vobs ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x
#@cli display_pseudocolor : predefined_palette
#@cli : Display an indexed image in pseudocolors using a palette
#@cli : $ image.jpg -luminance -display_pseudocolor
display_pseudocolor : -skip ${1=5}
-e[^-1] "Display an indexed image in pseudocolors using map "$1
-v - -repeat $! -l[$>]
A={round(im,0.0001)} B={round(iM,0.0001)}
-n[-1] 0,255 -map[-1] $1
-rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
-add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},$A,$B,6,255
-endl -done -v +
#@cli display_colordepth : _dz
display_colordepth :
-e[^-1] "display the 3D image with a depth color coded."
-v - -repeat $! -l[$>]
H={d*$1} -colordepth , -a z -min {ia+10*sqrt(iv)} -n 0,255 -s z
-rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
-add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},0,$H,6,255
-endl -done -v +
#@cli map_hilo
#@cli : Map a grascale image to a RGB with maw in red and min in blue
#@cli : This help to check if images are saturated
map_hilo:
-v - -repeat $! -l[$>]
-round m={0,im} -- $m
1,1,1,3,0,0,{0,iM} {0,iM-1},1,1,3,'x+1' 1,1,1,3,{0,iM},0,0 -a[1,2,3] x
-map[0] [1]
-+ $m -rm[1]
-endl -done -v +
#@cli add_colorbar : x0,y0,x1,y1,_min,_max,_ntics,color,colormap
#@cli : Add a colorbar
#@cli : $ image.jpg -luminance -map 5 -add_colorbar {w-40},20,{w-30},{h-20},0,255,6,255,5
add_colorbar : -skip ${5=0},${6=255},${7=6},${8=255},${9=""},${10=5}
-e[^-1] "Add a colorbar"
-v - -repeat $! -l[$>]
{$3-$1},{$4-$2} -l[-1] -f 'h-y' -n 0,255 -map $10 -endl
-frame[1] 1,1,$8 -image[0] [1],$1,$2,0,0,1 -k[0]
-repeat $7
val={round($5+$>/($7-1)*($6-$5),.001)}
-text "- "$val" "$9,{$3+1},{$4-$>*($4-$2-5)/($7-1)-10},13,1,$8
-done
-endl -done -v -
#@cli local_diffusion_coefficient : _scale,_threshold
#@cli : Estimate local diffusion coefficient It - D (Ixx+Iyy)=0 using D=It/(Ixx+Iyy)
#@cli : $ 100,100 -noise .7,2 ==. 1 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -local_diffusion_coefficient 2,.5
local_diffusion_coefficient : -check "${1=2}>0 && ${2=.5}>=0"
-e[^-1] "Local diffusion coefficient estimation using scale $1 and threshold $2"
-v - -repeat $! -l[$>]
--l[0] -s z -laplacian -a z -endl
--l[0] -s z -gradient_norm -a z -sqr -endl
-gradient[0] z,1
-l[0,1]
R={1,ia+$2*sqrt(iv)}
-a c -f 'b=i(x,y,z,0);a=i(x,y,z,1);if(abs(a)>abs(b),b/a,if(abs(b)>$R,1/(b/a),0))'
-channels 0
-endl
-*[0] [1] -blur $1,1,1 -max[1] {1,ia+$2*sqrt(iv)}  -/
-channels 0
-v + -endl -done
ldc :
-local_diffusion_coefficient $*
ldc_residuals :
--l[0] -s z -laplacian -a z -endl
-gradient[0] z,1
-*[1,2]
-- -abs -blur 1
#@cli display_ldc :
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 -noise .7,2 ==. 1 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_ldc
display_ldc :
--ldc 2,3 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1]
100%,{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Local diffusion coefficient ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x
#@cli print_psnr : _max_value
#@cli : Display the psnr on the image list taking the first one as a reference
#@cli : $ image.jpg --noise 20 --blur[-1] 1 -print_psnr
print_psnr : -skip ${1=255}
-e[^-1] "Compute PSNR with image 0 and print it on the other images."
-v - --psnr $1
-repeat {$!-2} -text_outline[{$>+1}] "PSNR:"{round(i(0,$>+1),.01)}"dB",5,5,30,1 -done
-rm[-1] -v +
#@cli noise_std
#@cli : Estimate the noise variance
#@cli : $ image.jpg -noise 10 sigma={round(${-noise_std},.1)} -text_outline "Noise std:"$sigma,5,5,30,1
noise_std :
-e[^-1] "Compute noise std."
-v - --laplacian -if {{0,d}==1}  -u {${-mad[-1]}/sqrt(20.0)} -else -u {${-mad[-1]}/sqrt(42.0)} -endif -rm[-1]
-v +
#@cli pca
#@cli : Principal component analysis
#@cli : $ image2.jpg --l -split_tiles 64,64 -y y -a x -pca -k[-1] -s x -r 8,8,1,1,-1 -n 0,255 -frame 1,1,255 -append_tiles , -r[-1] 400%,400% -frame 0,20 -title dictionary -endl
pca :
-e[^-1] "Principal component analysis"
-v - -repeat $! -l[$>]
n={w} -- {ia} --transpose[-1] -m*[-2,-1] -/ $n -eigen
-endl -done -v +
spca: -skip ${2=20}
-v - -repeat $! -l[$>]
-repeat $2
p={sqrt(h)}
--l --pca -k[0,-1]  -reverse -transpose[0] --m* -threshold[-1] $1,1 -rm[1] -transpose[0] -m* -endl
-*[0] .25 -*[1] .75 -+
-done
-pca
-endl -done -v +
#@cli denoise_karmuen_loeve : _number_of_components
#@cli : Denoise with a bloc Karumen-Loeve transform
#@cli : http://en.wikipedia.org/wiki/Karhunen%E2%80%93Lo%C3%A8ve_theorem
#@cli : $ image2.jpg --noise 10 --denoise_karmuen_loeve[-1] 8 -print_psnr
denoise_karmuen_loeve:
-v - -repeat $! -l[$>]
-split_tiles 64,64 oW={0,w} oH={0,h} oS={0,s}
-y y -a x --pca -k[0,-1] -reverse -crop[0] 0,$1
-transpose[0] --m* -rm[1] -transpose[0] -m* -s x
-resize $oW,$oH,1,$oS,-1 -append_tiles ,
-endl -done -v +
#@cli denoise_patch_dict : _patch_size,_nb_of_shifts,_thres_comp,_thres_coef
#@cli : Denoising using a dictionnary of patches learned on the image
#@cli : $ image.jpg --noise 10 --denoise_patch_dict[1] , -print_psnr
denoise_patch_dict: -skip ${1=8},${2=8},${3=1.1},${4=1.1}
-e[^-1] "Denoising using a dictionnary of "$1"x"$1" patches with "$2" shifts, threshold $3x(noise std) for components and $4x(std) for coefficients."
-v - -repeat $! -l[$>]
Sigma=${-noise_std[0]}
--crop 0,0,$1,100% -mirror[-1] x -reverse --crop[-1] {w-$1-1},0,100%,100% -mirror[-1] x -a x
--crop 0,0,100%,$1 -mirror[-1] y -reverse --crop[-1] 0,{h-$1-1},100%,100% -mirror[-1] y -a y
oW={0,w} oH={0,h} oS={0,s} nW={$1*round($oW/$1,1,1)} nH={$1*round($oH/$1,1,1)}
--crop {2*$oW-$nW},0,100%,100% -mirror[-1] x -a x
--crop 0,{2*$oH-$nH},100%,100% -mirror[-1] y -a y
NtileX={round($nW/$1)}  NtileY={round($nH/$1)}
--l[-1]
-repeat $2
-if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} -else dx=0 dy=0 -endif
--shift[0] $dx,$dy,0,0,2
-split_tiles[-1] $NtileX,$NtileY pW={1,w} pH={1,h}
-done -rm[0]
-y y -a x n={w} -- 'ia' --transpose[-1] -m*[-2,-1] -/ $n -eigen
-l[-2] -unroll x -sqrt -gt {$3*$Sigma} -f 'abs(i(x+1)-i(x))'
T={[xM,yM,zM,cM]} 4 -f[-1] $T T={i(0)} -endl
-if {$T==0} T=100% -endif -k[-1] -columns 0,$T
-endl
-repeat $2
-if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} -else dx=0 dy=0 -endif
--shift[0] $dx,$dy,0,0,2
-l[1,-1]
-l[1] -split_tiles $NtileX,$NtileY -unroll y -a x -endl
-transpose[0] --m*
t=${-mad[-1]}
-f[-1] 'if(abs(i)<$4*$t,0,i)'
-rm[1] -transpose[0] --m* -rm[-2]
-endl
-l[-1]
-s x -resize $pW,$pH,1,$oS,-1
-append_tiles $NtileX,$NtileY
-shift {-$dx},{-$dy},0,0,2
-endl
-done
-rm[0,1]
-+ -/ $2
-crop {$1+1},{$1+1},{$oW-$1-2},{$oH-$1-2}
-endl -done -v +
std_noise :
-v - --laplacian[-1] -u {${-mad[-1]}/sqrt(if(d==1,20,42))} -rm[-1] -v +
#@cli iuwt : _nlevels>2,_spline>1
#@cli : Compute the "isotropic undecimated wavelet transform" using
#@cli : a trou algorithm for the B3-Spline wavelet.
#@cli : The inverse is obtained as the sum of all coefficients
#@cli : $ image.jpg -iuwt 4,1 -n 0,255 -append_tiles
#@cli : $ image.jpg -iuwt 3,1 -+
iuwt: -skip ${1=3},${2=3}
-e[^-1] "Compute isotropic undecimated wavelet transform"
-v - -repeat $! -l[$<]
50
-l[-1]
-f 'if(x==w/2|x==w/2-1,1,0)' -i [0]
-repeat $2 -convolve[-1] [0] -done
-k[-1] -autocrop 0 -/ {ia*w}
-endl
-repeat {$1-1}
-l[-1,-2]
--convolve[0] [1]
-y[1] y -convolve[-1] [1]
---[0] [-1] -rm[0] -reverse
-endl
-l[-1] -y y 100% -a x -s y -s x -rm[-1] -a x -endl
-done
-rm[-1] -reverse
-endl -done -v +
#@cli iuwt_std : _nlevels>2,_spline>1
#@cli : Compute noise at each level of the iuwt
#@cli : $ image.jpg -iuwt_std 10,10
iuwt_std:
-v - -repeat $! -l[$>]
sigma=${-noise_std}
-if 1
-f 1 -noise $sigma -iuwt $1,$2
-repeat $! -l[$>]
x={sqrt(iv)} -rm 1 -f $x
-endl -done -a x
-else -rm
50
-l[-1]
-f 'if(x==w/2|x==w/2-1,1,0)' -i [0]
-repeat $2 -convolve[-1] [0] -done
-k[-1] -autocrop 0 -/ {ia*w}
-endl
-sqr
alpha={is} -rm
$1,1,1,1,'$sigma*sqrt((1+$alpha)*$alpha^(w-x-1))'
-endif
-endl -done -v +
#@cli denoise_iuwt:_threshold>0,_nlevels>2,_spline>1
#@cli : Denoising by thresholding the coefficients of the
#@cli : "isotropic undecimated wavelet transform"
#@cli : $ image.jpg --noise 10 --denoise_iuwt[-1] , -print_psnr
denoise_iuwt: -check "${1=1.4}>0&&${2=4}>1&&${3=1}>0"
-e[^-1] "Denoise using the isotropic undecimated B"$3" spline wavelet transform"
-v - -repeat $! -l[$>]
--iuwt_std[0] $2,$3 -reverse
-iuwt[-1] $2,$3
-repeat {$!-2} -threshold[{$>+2}] {0,$1*i($>+1)},1 -done
-+[1--1]
-rm[0]
-endl -done  -v +
#@cli noise_poisson_gaussian : gain,offset,noise_std
camera_noise:
-v - -repeat $! -l[$>]
-noise 0,3 -* $1 -+ $2 -noise $3
-endl -done -v +
#@cli analyze_camera_noise :
analyze_camera_noise:
-v - -repeat $! -l[$>]
--local_noise_variance $1 -blur[0] $1 -y -a c
-display_parametric 800,600,.0,1,1,0,signal,noise
-endl -done -v +
#@cli dehaze : scale,gamma1,min_va,max_val,gamma2
#@cli : Dehaze an image using Dark Channel Prior appraoch
#@cli : return the dehazed image and a transmittance image
#@cli : $ http://media.lcpc.fr/ext/img/prod/frida/K080-000000.jpg -r 600,400,1,3,5 --dehaze
dehaze: -skip ${1=5},${2=1},${3=.2},${4=1},${5=0},${6=0},${7=0}
-v - -repeat $! -l[$>]
--l
--l -s c -min -blur 10 -erode_circ $1 -dilate_circ $1  -endl
-gt[-1] 80% -*
-s c aR={0,iM} aG={1,iM} aB={2,iM} -rm
-endl
--l
-s c -/[0] $aR -/[1] $aG -/[2] $aB
-repeat 10 -median 3 -erode_circ $1 -dilate_circ $1 -done
-min -f 'max($3,min($4,1-0.95*i))'
-endl
-pow[1] $2
-s[0] c --[0] $aR --[1] $aG --[2] $aB
-/[0-2] [3]
-+[0] $aR -+[1] $aG -+[2] $aB -a[0-2] c
-c[0] 0,255
-adjust_colors[0] $5,$6,$7
-endl -done -v +
#@cli :: Segmentation
#@cli contour2d: _tolerance
#@cli : Draw a 2D contour of regions with tolerance _tolerance
#@cli : Default value _tolerance=.1
#@cli : $ image.jpg -norm -blur 1 -gt 50% --contour2d
contour2d: -skip ${1=.1}
-v - -f 'if(abs(i-j(1,1))>$1||abs(i-j(1,0))>$1,1,0)' -v +
#@cli segment_snake : _nb_iter,_time_step,_lambda,_threshold,_smoothness
#@cli : Segment an image using an adaptation of Chan and Vese's method.
#@cli : Default values _nb_iter=10,_time_step=1,_smoothness=100,_threshold=50%
#@cli : Reference Chan and L. Vese,Active contours without edges, IEEE transactions on image processing 10(2) (2001), pp. 266-277
#@cli : $ 256,128 -text "GMIC",40,10,100,1,255 -blur 1 -noise 20 --segment_snake , -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_snake: -skip ${1=100},${2=1},${3=.1},${4=.1},${5=10},${6=0}
-e[^-1] "Segment the image using active contours without edges using $1 iterations and time step $2, smoothness $3 and initialize with threshold of $4."
-v - -repeat $! -l[$>]
-if {s>1} -luminance -endif
--blur $5 -gt[-1] {ia+$4*sqrt(iv)}
-l[-1] --distance 0 -negate[0] -distance[0] 0 -*[0] -1 -+ -endl
-repeat $1
--lt[-1] 0 -blur[-1] 1 --*[0,-1] swx={ia} sw={-2,ia} M1={$swx/$sw}
-sqr[-1] swx2={ia}  S1={max(1e-3,$swx2/$sw^2-$M1^2)} -rm[-1,-2]
--gt[-1] 0 -blur[-1] 1 --*[0,-1] swx={ia} sw={-2,ia} M2={$swx/$sw}
-sqr[-1] swx2={ia}  S2={max(1e-3,$swx2/$sw^2-$M2^2)} -rm[-1,-2]
--iee[-1]
--f[0] '(1.0/$3)*(((i(x,y)-$M1)^2)/$S1-((i(x,y)-$M2)^2)/$S2)'
-+[-2,-1]
-*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}
-+[-2,-1]
-if {$6==1}
--l -gt[1] 0 -contour2d[1] , -n 0,1 -a c -text $>,0,0,13,1,{iM} -w -wait 10  -rm -endl
-endif
-done
-blur[-1] 1 -gt[-1] 0 -rm[0]
-endl -done -v +
#@cli segment_cells: scale1,scale2,threshold,size_threshold
#@cli : Cell segmentation using watershed
#@cli : $ 256,256 noise .05,2 ==. 1 b 10,1,1 min 80% noise 5% +segment_cells 2,10% contour2d[-1] , r[-1] 100%,100%,1,3,0 n 0,255 blend add
segment_cells: skip ${1=3},${2=10},${3=1},${4=3}
e[^-1] "Cell segmentation using difference of Gaussians and watershed"
v - repeat $! l[$>]
jeje_dog $1,$2 +gt {ia+$3*${-mad}} area_fg 0 gt $4 +distance[1] 0
max_patch[0] {round($4,1,1)} mul[0] [1] label[0] 0 watershed[0] [2] rm[-1] mul
endl done v +
#@cli zernike:
zernike:
-skip  ${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=0},${12=0},${13=0},${14=0},${15=0},${16=0},${17=0},${18=0}
f 'r=sqrt((x-$1)^2+(y-$2)^2);if(r<$3,a=atan2(y-$2,x-$1);$4+$5*2*r*sin(a)+$6*r*cos(a)+$7*sqrt(6)*r^2*sin(2*a)+$8*sqrt(3)*(2*r^2-1)+$9*sqrt(6)*r^2*cos(2*a)+$10*sqrt(8)*r^3*sin(3*a)+$11*sqrt(8)*(3*r^3-2*r)*sin(a)+$12*sqrt(8)*(3*r^3-2*r)*cos(a)+$13*sqrt(8)*r^3*cos(3*a)+$14*sqrt(10)*r^4*sin(4*a)+$15*sqrt(10)*(4*r^4-3*r^2)*sin(2*a)+$16*sqrt(5)*(6*r^4-3*r^2)*cos(2*a)+$17*sqrt(10)*(4*r^4-3*r^2)*cos(2*a)+$18*sqrt(10)*r^4*cos(4*a),0)'
#@cli :: Patterns
_challenge:
108,86,1,3 -l[-1] -fractional_brownian_motion .25  -n 0,128 --norm -gt[-1] 60% -* -resize 1080,860,1,3,1  --l[-1] -blur 10 -shift[-1] 10,10 -endl -max -crop 10,10,100%,100% -negate -endl -n 0,255
#@cli periodic_dots : _nb_angles,_scale,_start_angle
#@cli : Generate a peridic dot pattern with 'nb angles', 'scale' and 'start angle'.
#@cli : Default values 'nb angle=6', 'scale=4' and 'start_angle=0'
#@cli : $ 64,64 -periodic_dots 3,6,.1 -repeat 34 -i [0] -done -append_tiles
periodic_dots : -skip ${1=6},${2=4},${3=.5}
-e[^-1] "Generate a periodic dot pattern with "$1" angles, scale "$2", and orientation "$3"."
-v - -repeat $! -l[$>]
-s c -repeat $! -l[$>]
--resize {max(w,h)},{max(w,h)},100%,100%,0
-l[-1]
-f 0
-repeat $1
-circle {w*(.5+.5/$2*cos(2*pi*($>+$3/180*pi)/$1))},{w*(.5+.5/$2*sin(2*pi*($>+$3/180*pi)/$1))},0,1,255
-done
-fft -a c -norm -fftshift -n 0,255
-endl
-resize[-1] [0],0
-k[-1]
-endl -done -a c
-endl -done -v +
#@cli turing_pattern : iter,dt,a,b,q,r,D
#@cli : Generate Turing pattern using a rection-diffusion equation
#@cli : du/dt = au(1-qv) + v(1-ru)
#@cli : dv/dt =  v(b-aquv) + u(-a+rv)
#@cli : the two parameters q and r are dictating the pattern final shape
#@cli : the diffusivity parameter influcences the scale
#@cli : http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf
#@cli : http://eprints.maths.ox.ac.uk/430/1/102.pdf
turing_pattern: -skip ${1=2000},${2=.1},${3=0.855},${4=-0.95},${5=2},${6=.1},${7=.5},${8=0}
-v - -repeat $! -l[$>]
-r 100%,100%,100%,2 -blur 1 -n 0,1
-repeat $1
-progress {$>/$1*100}
--laplacian[0] -mix_channels[-1] ($7,0;0,1)
--f[0] 'u=i(x,y,z,0);v=i(x,y,z,1);a=$3;b=$4;q=$5;r=$6;if(c==0,a*u*(1-q*v*v)+v*(1-r*u),v*(b+a*q*u*v)+u*(-a+r*v))'
-+[-1,-2]
-*[-1] {$2/(1+max(abs(im),abs(iM)))}
-+
-if {$8==1} --l -s c -n 0,1 -a c -text $> -w -rm -endl -endif
-done
-s c -n 0,1 -a c
-endl -done -v +
#@cli rays : _center_x,_center_y,_scale,_phase
#@cli : Generate rays patterns
#@cli : $ image.jpg --rays 155,127,10,10 -n[-1] 0,1 -mul
rays :
-e[^-1] "Generate a ray pattern centered in ($1,$2)"
-f 't=atan2(y-$2,x-$1);sin($3*t+$4)'
#@cli fractional_brownian_motion : 0<=_hurst_index<=1,_epsilon>0
#@cli : Generate fractional brownian motion nd signal
#@cli : Using a power low of the form (eps+|f|)^(-2^H-1)
#@cli : where f is the module of the frequency, H the husrt index and eps _epsilon.
#@cli : (see also -clouds)
#@cli : $ 400,300 -fractional_brownian_motion
fractional_brownian_motion : -skip ${1=.5},${2=1} -check "$1>=0&&$1<=1" -check "$2>0"
-e[^-1] "Generate pseudo fractional brownian motion"
-v - -repeat $! -l[$>]
-f 0 -noise 1
-fft -fftshift
-if {{0,d}==1}
-f 'rx=x-w/2;ry=y-h/2;i*($2+sqrt(rx*rx+ry*ry))^(-2*$1-1)'
-else
-f 'rx=x-w/2;ry=y-h/2;rz=z-d/2;i*($2+sqrt(rx*rx+ry*ry+rz*rz))^(-2*$1-1)'
-endif
-fftshift -ifft
-k[0]
-endl -done -v +
#@cli clouds : _density_of_blue_sky>0,_amplitude,0<=_hurst_index<=1,_epsilon>0
#@cli : Generate clouds on the image (see also 'frational_brownian_motion')
#@cli : $ 64,64 -repeat 3 --clouds {10+20*$>}% -done -rm[0]
clouds : -skip ${1=50%},${2=1},${3=.5},${4=1}
-e[^-1] "Generate a cloud"
-v - -repeat $! -l[$>]
-channels 0
-fractional_brownian_motion $3,$4 -negate -min $1 -negate -resize 100%,100%,1,4
-n 0,255 -s c -n[0-2] 190,255  -n[3] 0,255 -a c
-endl -done -v +
#@cli clearbluesky:
#@cli : Generate a Clear Blue Sky
#@cli : $ 400,300,1,3 -clearbluesky --clouds 50% -blend alpha
clearbluesky :
-e[^-1] "Generate a blue sky"
-v - -repeat $! -l[$>]
1,2,1,3 -f[-1] '63,70,120,144,190,215' -resize[-1] [0],5 -k[-1]
-endl -done -v +
#@cli mm_mozaic: size
#@cli : Create a mozaic image from the selected image
#@cli : -sp ? -mm_mozaic
mm_mozaic: -skip ${1=1}
-repeat $! -l[$>]
--gradient_norm -negate.
--l. -b. .75 --ge $1 -max_patch.. 3 -d -* -endl -to_rgb. -*[0,2] -d
-watershed.. . -rm.
-endl -done
segment_watershed2 : -check "${1=2}>=0"
-e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
-v - -repeat $! -l[$>]
min={im}
-+ {1+$min} --gradient_norm
-if {d>1} --f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && i<j(0,0,1) && i<j(0,0,-1),1,0)"
-else --f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
-endif
-*[-3,-1] -*. -1 -watershed.. . -rm.
-- {1+$min}
-endl -done -v +
#@cli freqy_pattern
#@cli : Create a periodic pattern containing a lot of frequencies
#@cli : sp ? freqy_pattern
freqy_pattern: skip ${1=1%},${2=100}
e[^-1] "Generate a periodic pattern with many frequencies with parameter $1,$2"
v - repeat $! l[$>]
fftpolar +gaussian $1 mul[0] [2] rm. ifftpolar rm. n 0,{$2*pi} sin
endl done v +
#@cli ::  Colors
#@cli wavelength_color: _wavelength
#@cli : Convert a wavelength [380,780] to RGB color
#@cli : from http://scienceprimer.com
#@cli : $ 1,1,1,1,1 -repeat 100 --wavelength_color[0] {380+3*$>} -done -rm[0] -a x
wavelength_color:
-v -
-if {$1>=380&$1<440}
R={-1*($1-440)/(440-380)}
G=0
B=1
-elif {$1>=440&$1<490}
R=0
G={($1-440)/(490-440)}
B=1
-elif {$1>=490&$1<510}
R=0
G=1
B={-1*($1-510)/(510-490)}
-elif {$1>=510&$1<580}
R={($1-510)/(580-510)}
G=1
B=0
-elif {$1>=580&$1<645}
R=1
G={-1*($1-645)/(645-580)}
B=0
-elif {$1>=645&$1<780}
R=1
G=0
B=0
-else
R=0
G=0
B=0
-endif
-repeat $! -l[$>]
-mix_channels ($R;$G;$B)
-endl -done
#@cli ::  GIMP
#@gui Jpr Gradient Smooth : jpr_gradient_smooth,jpr_gradient_smooth(1)
#@gui : note = note("image and its gradient in x y are treated as solid angles and smoothed on the topology of the surface of a sphere\nthis means a loop bright/dark/bright cannot contract through the centre of the sphere")
#@gui : Offset Brightness = float(0,-0.9,0.9)
#@gui : Smoothing Amount = float(1.5,0.8,2.5)
#@gui : Updateauthornote = note("<small>update 2013-Feb-03 author @jayprich</small>")
#@cli jpr_gradient_smooth :
#@cli : image and its gradient in x y are treated as solid angles
#@cli : and locally smoothed on the surface of a sphere
#@cli : which can retain bright/dark/bright sequences
jpr_gradient_smooth:
-v -
-repeat $!
-l[$>]
-norm
--g xy,0
-n[0] {$1-1},{$1+1}
-a c
-repeat 25
--norm
-/[0,1]
-b {w*$2/500}
-done
-f atan2(i,abs(i(x,y,0,0)))
-channels 1,2
-endl
-r 100%,100%,1,3,0,1
-n 0,255
-done
-v +
#@gui Jpr Line Edges : jpr_line_edges,jpr_line_edges(1)
#@gui : note = note{"combines the results in several orientations, each one blurs one way and looks for points of max gradient at 90 degrees to the blur"}
#@gui : note = note{"works best on photographs not line-art"}
#@gui : Angles per Quadrant = int(2,1,9)
#@gui : Blurring = int(2,2,24)
#@gui : Gradient Threshold = float(4,0,30)
#@gui : Anti Alias = bool(1)
#@gui : Updateauthornote = note("<small>update 2013-Jan-22 author @jayprich</small>")
#@cli jpr_line_edges : Angles,Blurring,AntiAlias
#@cli : Similar in concept to a Hough Transform and voting
#@cli : here multiple orientations are blurred a little
#@cli : this augments line segments along the blur and suppresses
#@cli : noise improving edge detection by finding
#@cli : max gradient orthogonal to each linear blur
#@cli : $ -jpr_line_edges 5,5,1
jpr_line_edges : -skip ${1=5},${2=5},${3=1}
-e[^-1] "Find edges in image$? using $1 angles per quadrant with $2 blurring and $3 anti-alias"
-v -
-repeat $! -l[$>]
-norm
-fft
100%,100%,1,1,x-w/2
100%,100%,1,1,y-h/2
-shift[2,3] {-round(w/2)},{-round(h/2)},0,0,2
100%,100%,1,1
-repeat {$1}
ac={3*cos(($>+0.5)*pi/$1/2)/sqrt(pi)*$2/w}
as={3*sin(($>+0.5)*pi/$1/2)/sqrt(pi)*$2/w}
--*[2] $ac
--*[3] $as
-+[-2,-1]
--sqr[-1]
-*[-1] -1
-exp[-1]
-*[-2,-1]
--mirror[-1] x
-*[-1] -1
[1]x1
-*[-1] -1
[0]x1
-*[-2,-1] [-4]
-rm[-4]
-ifft[-2,-1]
-rm[-1]
[1]x1
-*[-1] -1
[0]x1
-*[-2,-1] [-4]
-rm[-4]
-ifft[-2,-1]
-rm[-1]
-abs[-2,-1]
-max[-2,-1] $3
ac={round(1.45*cos(($>+0.5)*pi/$1/2))}
as={round(1.45*sin(($>+0.5)*pi/$1/2))}
--shift[-2] {-$ac},{-$as}
--shift[-3] {$ac},{$as}
--shift[-3] {$ac},{-$as}
--shift[-4] {-$ac},{$as}
-if $4
--max[-6,-4,-3]
--min[-7,-5,-4]
--[-2,-1]
-+[-5,-4]
-*[-4] 0.5
--[-6,-4]
-/[-5,-1]
--[-4] 0.1
-max[-4] 0
-*[-4] 2
--[4,-4]
--max[-3,-2,-1]
--min[-4,-3,-2]
--[-2,-1]
-+[-3,-2]
-*[-2] 0.5
--[-3,-2]
-/[-2,-1]
--[-1] 0.1
-max[-1] 0
-*[-1] 2
--[4,-1]
-else
-max[-4,-3]
-gt[-5,-3]
--[4,-4]
-max[-2,-1]
-gt[-2,-1]
--[4,-1]
-endif
-done
-rm[0,1,2,3]
-n 0,255
-endl -done
-v +
#@gui Jpr Orientedthinning : jpr_orientedthinning,jpr_orientedthinning(1)
#@gui : note = note{"Skeleton of a shape against a zero-value (pure-black) background using locally oriented local maxima to find only relevant ridges - not micro ridges from a noisy boundary"}
#@gui : Pre Smooth Borders = float(5,0,10)
#@gui : Propagate Direction = float(15,3,50)
#@gui : Threshold Width = int(1,1,10)
#@gui : Preview Orientation = bool(0)
#@gui : Distance Metric = choice(max |x| |y| chebyshev,|x|+|y| manhattan,|x y| euclidean)
#@gui : Updateauthornote = note("<small>update 2013-Apr-14 author @jayprich</small>")
#@cli jpr_orientedthinning:
#@cli : Skeleton of a shape against a zero-value (pure-black) background using locally oriented local maxima to find only relevant ridges - not micro ridges from a noisy boundary.
#@cli : $ -jpr_orientedthinning
jpr_orientedthinning :
-e[^-1] "Oriented Thinning image$? with Pre-Smooth $1, Propagate Direction $2, Threshold Width $3"
-repeat $!
-l[$<]
-norm
--b $1
-structuretensors[-1] 0
-mix_channels[-1] (1,0,-1)
-b[-1] $2
-le[-1] 0
-if $4
-rm[-2]
-* 255
-else
(1.1,0^0,1.1)
-map[-2] [-1]
-rm[-1]
-distance[-2] 0,$5
-max[-2] $3
--warp[-2] [-1],1
-*[-2] -1
--warp[-3] [-2],1
-rm[-3]
-max[-2,-1]
-gt[-2,-1]
-* 255
-endif
-endl
-done
-v +
#@gui Jpr Phasecongruence : jpr_phasecongruence,jpr_phasecongruence(1)
#@gui : note = note{"Edge detect with directional Phase Congruence using proportionality to Local Energy."}
#@gui : Start Angle = float(45,0,360)
#@gui : Directions = int(1,1,20)
#@gui : Energy Threshold = float(50,0,500)
#@gui : Local Maxima = bool(1)
#@gui : Updateauthornote = note("<small>update 2013-Mar-31 author @jayprich</small>")
#@cli jpr_phasecongruence :
#@cli : Edge detection via Phase Congruence method relies on low noise source and uses FFT to compute Local Energy.  This could be extended to apply to each channel in multiple orientations but for now we apply one orientation, ignore colour and delete the alpha channel.
#@cli : $ -jpr_phasecongruence
jpr_phasecongruence :
-e[^-1] "Phase Congruence image$? with StartAngle $1, Directions $2, Threshold $3, IsLines $4"
-v -
-repeat $!
-l[$<]
-norm
100%,100%,1,1,0
-repeat $2
[0]x1
t={($1/180+$</$2)*pi}
a={cos($t)}
b={sin($t)}
-fft[2]
-mv[3] 2
100%,100%,1,1,sx=if(x>w/2,x-w,x);sy=if(y>h/2,y-h,y);if(abs($a*sx+$b*sy)>0.7,sign($a*sx+$b*sy),0)
-*[3] -1
-*[2,3] [4]
-rm[4]
-ifft[2,3]
-rm[3]
c={max(abs($a),abs($b))*.8}
-abs[2]
-max[2] $3
-if $4
a={$a/$c}
b={$b/$c}
-f[2] i>i(x+$a,y+$b)&i>i(x-$a,y-$b)
-endif
-+[1,2]
-done
-rm[0]
-n 0,255
-endl
-done
-v +
#@gui Jpr Remove Blocks1 : jpr_remove_blocks1,jpr_remove_blocks1(0)
#@gui : sep = separator()
#@gui : note = note("subtracts square edged blocks with limited-amplitude while masking less-smooth areas of an image\n\nthis can reduce low quality jpeg artifacts in very smooth parts of an image\n1. choose a block size in pixels to fit\n2. set smallest amplitude that catches block noise in smooth areas but masks real edges in the image\n3. fine tune the strength around 70, the amount of estimated block-noise to subtract")
#@gui : Spatial Block Size = float(4,2,25)
#@gui : Amplitude = float(3,1,64)
#@gui : Strength Fine-Tune = float(70,20,300)
#@gui : Updateauthornote = note("<small>update 2012-Nov-30 author @jayprich</small>")
#@cli jpr_remove_blocks1 : _spatial,_amplitude,_strength
#@cli : remove block artefacts from smooth areas
#@cli : spatial drives the size of blocks to try and fit
#@cli : amplitude set to a minimum to catch only noise blocks
#@cli : strength expect 70 but fine tune up or down
jpr_remove_blocks1 :
-v -
-repeat $! -l[$<]
-keep[0]
spatial=$1
amplitude=$2
strength=$3
--b[0] {$spatial*1.2} --b[0] {$spatial*0.8} --[1,2] [0]
-c[1,2] {-$amplitude},{$amplitude}
--==[1,2] {-$amplitude}
--==[1,2] {$amplitude} -or[3,4,5,6]
wh={w},{h}
-shift[1] 2,2
-r[1,2] {w/$spatial},{h/$spatial},1,3,2
-r[1,2] $wh
-shift[1] -2,-2
-c[1,2] {-$amplitude/2},{$amplitude/2}
--==[1,2] {-$amplitude/2}
--==[1,2] {$amplitude/2} -or[3,4,5,6,7]
-compose_channels[3] or
-blur[3] {2*$spatial} -threshold[3] 0.1
-blur[3] {2*$spatial}
--[3] 1
-+[1] [2] -rm[2]
-*[1] [2] -rm[2]
-*[1] {0.01*$strength}
--[0] [1] -rm[1]
-endl -done
-v +
#@gui Jpr Shapes Gradient : jpr_shapes_gradient,jpr_shapes_gradient(0)
#@gui : note = note("convert an image to local patches with some gradient patch shape is via watershed algorithm")
#@gui : Pre Blur = float(2,0,15)
#@gui : Watershed Threshold = float(0.25,0.01,10)
#@gui : Gradient Flatten = float(0.001,0.001,0.1)
#@gui : Gradient Cap = float(100,5,200)
#@gui : Updateauthornote = note("<small>update 2017-Jun-10 author @jayprich</small>")
#@cli jpr_shapes_gradient :
#@cli : convert an image to local patches with some gradient
#@cli : patch shape is via watershed algorithm
#@cli : pre-blur,threshold,grad-flatten,grad-cap
#@cli : e.g. 2,0.5,0.01,100
jpr_shapes_gradient:
-v -
-repeat $! -l[$<]
100%,100%,1,1,0.1*(x-w/2)
--norm[0]
-b[-1] $1
-segment_watershed[-1] $2,0
--blend[1,-1] shapeaverage0
--[1,-1]
--sqr[1]
[-2]x1
-blend[-2,-1] shapeaverage0
-+[-1] $3
-sqrt[-1]
-/[1,-1]
--blend[0,-1] shapeaverage0
-*[0] [-3]
-blend[0,-2] shapeaverage0
-c[0] -$4,$4
-*[0,1]
-+[0,1]
-c 0,255
-endl -done
-v +
#@gui Jpr Specularbumps : jpr_specularbumps,jpr_specularbumps(1)
#@gui : note = note{"Add highlights using brightness gradient."}
#@gui : Gradient Illuminate Angle = float(270,0,360)
#@gui : Pre Smooth = float(1,0,5)
#@gui : Gradient Range = float(13,0,30)
#@gui : Illumination Adjust = float(0,-45,45)
#@gui : Illumination Offset = float(80,0,90)
#@gui : Highlight Size = float(0.1,0,0.25)
#@gui : Roughness = float(0.1,0.05,0.35)
#@gui : Output Type = choice("black and white","white with alpha","compose to image")
#@gui : Updateauthornote = note("<small>update 2013-Mar-31 author @jayprich</small>")
#@cli jpr_specularbumps :
#@cli : Specular highlights as if the image has bumps based on luminance.  Ignores and deletes alpha channel.
#@cli : $ -jpr_specularbumps
jpr_specularbumps :
-e[^-1] "Specular highlights image$? with GradientAngle $1, Pre-Smooth $2, GradientRange $3, AdjustAngle $4, IlluminationOffset $5, HighlightSize $6, Roughness $7, OutputType $8"
-v -
t={$1*pi/180}
a={cos($t)}
b={sin($t)}
-repeat $!
-l[$<]
-to_rgb
--b $2
-l[-1]
-norm
-gradient xy
-a c
-mix_channels ($a,$b;{-$b},$a)
-div $3
-c 0,1
--norm
-f[-1] "0.1/(0.1+i)"
-a c
--norm
-div[-2,-1]
-b 2
--norm
-div[-2,-1]
wh={w},{h},1,3
({cos((45+$4)*pi/180)*sin($5*pi/180)}^{sin((45+$4)*pi/180)*sin($5*pi/180)}^{cos($5*pi/180)})
-r $wh
--
-norm
-c $6,{$6+$7}
-* -1
-n 0,255
-endl
-if {$8==0}
-rm[-2]
-else
-if {$8==1}
-rm[-2]
100%,100%,1,3,255
-mv[-1] -2
-a[-2,-1] c
-else
-blend dodge
-endif
-endif
-endl
-done
-v +
#@gui Jpr Warpfromthreshold : jpr_warpfromthreshold,jpr_warpfromthreshold(1)
#@gui : note = note("a dummy 100x100 grid is warped using smoothed orientation as a map")
#@gui : Brightness Threshold = float(170,10,245)
#@gui : Simplify Regions = float(2,0,6)
#@gui : Blur & Renormalise Loop = int(10,3,50)
#@gui : Blur Amount per Step = float(2,1,10)
#@gui : Updateauthornote = note("<small>update 2013-Feb-03 author @jayprich</small>")
#@cli jpr_warpfromthreshold :
#@cli : test trying to create a patch local warp effect
jpr_warpfromthreshold:
-v -
-repeat $!
-l[$>]
-norm
--g xy
-a[1,2] c
-ge[0] $1
-b[0] $2
-ge[0] 0.5
-f[0] i!=i(x+1,y)|i!=i(x,y+1)
-repeat $3
--norm[1]
-*[2] [0]
-a[1,2] c
-f[1] if(i(x,y,0,2)==0,i,i/i(x,y,0,2))
-channels[1] 0,1
-b[1] $4
-done
-rm[0]
-s c
-n 0,100
-a c
100,100,1,3,((x/2)%4)==0|(c==2&((y/2)%4)==0)
-warp[1] [0]
-rm[0]
-n 0,255
-endl
-done
-v +
#@gui _
#@gui <i>Joan Rake</i>
#@gui <i>Artistic</i>
#@gui Dreamy Abstraction : fx_dreamy_abstraction, fx_dreamy_abstraction_preview()
#@gui : note = note("A less-aggressive alternative to the Painting filter. Yes, 'Joan Rake' made a filter that isn't aggressive! What kind of digital paint has she been sniffing?")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 1. Edge Threshold = float(2,0,30)
#@gui : 2. Smoothness = float(1,0,10)
#@gui : 3. Blend Mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 4. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 5. Noise Amplitude = float(10,0,100)
#@gui : 6. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 7. Noise Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 8. Blend Mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 9. Opacity = float(1,0,1)
#@gui : 10. Sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 11. Blur Strength = float(3,0,20)
#@gui : 12. Sharpen Radius Factor = float(1,0,5)
#@gui : 13. Amount Factor = float(1,0,5)
#@gui : 14. Threshold = float(1,0,5)
#@gui : 15. Constraint Radius Factor = float(1,0,5)
#@gui : 16. Overshoot Factor = float(1,0,20)
#@gui : 17. Sharpen Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 18. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 19. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("Glow")
#@gui : 20. Size = float(5,0,50)
#@gui : 21. Intensity = float(1,0,3)
#@gui : 22. Darken = float(0,0,1)
#@gui : 23. Saturation = float(1.5,0,4)
#@gui : sep = separator(), 24-26. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_dreamy_abstraction :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption1=$3
Opacity1=$4
MergingOption2=$8
Opacity2=$9
if {$4>=0}
+fx_segment_watershed $1,$2,1,1 blend ${_mode{$MergingOption1+1}},$Opacity1
fi
if {$5>=0}
+fc 0,0,0 -to_rgb
if {$6==5}
ac. "spread {([$5,$5]/100)*max(w,h)}",$7,1
else
ac. "_jr_fx_noise {255*$5/100},$6",$7,1
fi
blend ${_mode{$MergingOption2+1}},$Opacity2
if {$10>=0}
_fx_gaussian_blur $10,0,0,1
fi
fi
radius={$10*$11*2}
amount={$10*$12*2}
cradius={$10*$14*2}
overshoot={$10*$15/10}
iain_constrained_sharpen $radius,$amount,$13,$cradius,$overshoot,$16,$17
if {$18>=0}
fx_smooth_antialias {$18+(5*$10)},0,{($18+(5*$10))/20}
fi
fx_dreamy_abstraction_preview:
gui_split_preview "-fx_dreamy_abstraction $*",${-3--1}
#@gui Dreamy Watercolour : fx_dreamy_watercolour, fx_dreamy_watercolour(0)
#@gui : note = note("Creates abstract watercolour images.")
#@gui : sep = separator(), note = note("<b>Gradient norm</b>")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.3,0,2)
#@gui : 3. Min Threshold = float(40,0,100)
#@gui : 4. Max Threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 7. Amplitude = float(50,0,200)
#@gui : 8. Edge Threshold (%) = float(0,0,100)
#@gui : 9. Smoothness = float(10,0,20)
#@gui : sep = separator(), note = note("<b>Dreamy abstraction</b>")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 10. Edge Threshold = float(2,0,30)
#@gui : 11. Smoothness = float(1,0,10)
#@gui : 12. Blend Mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 13. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 14. Noise Amplitude = float(10,0,100)
#@gui : 15. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 16. Noise Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 17. Blend Mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 18. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 19. Blur Strength = float(3,0,20)
#@gui : 20. Sharpen Radius Factor = float(1,0,5)
#@gui : 21. Amount Factor = float(1,0,5)
#@gui : 22. Threshold = float(1,0,5)
#@gui : 23. Constraint Radius Factor = float(1,0,5)
#@gui : 24. Overshoot Factor = float(1,0,20)
#@gui : 25. Sharpen Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 26. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 27. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("<b>Deform colour layer</b>")
#@gui : 28. Amplitude = float(5,0,50)
#@gui : 29. Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : 30. Matrix Density = float(10,1,100)
#@gui : 31. Matrix Interpolation = choice(1,"Linear","Bicubic")
#@gui : 32. Mode = choice("Noise","Spread noise")
#@gui : 33. Character = float(0,-100,100)
#@gui : 34. Boundary = choice(1,"Dirichlet","Neumann","Periodic","Mirror")
#@gui : sep = separator(), note = note("<b>Plasma</b>")
#@gui : 35. Alpha = float(0.5,0,5)
#@gui : 36. Beta = float(0,0,100)
#@gui : 37. Scale = float(8,1,20)
#@gui : 38. Randomize = bool(1)
#@gui : 39. Transparency = bool(0)
#@gui : 40-42. Color Balance = color(128,128,128)
#@gui : 43. Fix Edges = float(0.5,0,1)
#@gui : sep = separator(), note = note("<b>Transfer colours</b>")
#@gui : 44. Enable = bool(1)
#@gui : 45. Regularization = int(8,0,32)
#@gui : 46. Preserve Luminance = float(0.2,0,1)
#@gui : 47. Precision = _choice(1,"Low","Normal","High","Very high")
#@gui : 48. Reference Colors = choice(1,"Plasma","Painting")
#@gui : 49. Add User-Defined Constraints (Interactive) = _bool(0)
#@gui : 50. Blend Mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 51. Opacity = float(0.75,0,1)
#@gui : 52. Reverse Order = bool(0)
#@gui : sep = separator(), note = note("<b>Local normalisation</b>")
#@gui : 53. Amplitude = float(1,0,80)
#@gui : 54. Radius = int(20,1,96)
#@gui : 55. Neighborhood Smoothness = float(40,0,60)
#@gui : 56. Average Smoothness = float(40,0,60)
#@gui : 57. Constrain Values = bool(1)
#@gui : 58. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<b>Noise</b>")
#@gui : 59. Power = float(1.25,0,5)
#@gui : 60. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : 61. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 62. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 63. Blend Mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 64. Opacity = float(1,0,1)
fx_dreamy_watercolour :
repeat $! l[$>]
to_rgb
if $6
+b $1
l[1] gradient_norm c 0,255 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255
if {$9!=0||$10!=100}
fx_smooth_antialias ${7-9}
fi
endl
fi
fx_jr_deform[0] 0,${28-34}
fx_dreamy_abstraction[0] ${10-27}
n[1] 0,255 negate[1] blend[0,1] multiply,$6
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
100%,100%,1,3
CF={$37*20*$38}
l[1] if {$43} z {-$CF},{-$CF},{w+$CF},{h+$CF} fi fx_plasma ${35-42} if {$43} z {$CF},{$CF},{w-$CF},{h-$CF} fi endl
if $44 fx_transfer_rgb ${45-49} fi
if $52 rv fi
blend ${_mode{$50+1}},$51
fx_normalize_local ${53-58}
if $59
100%,100%,1,3 fc[1] 127,127,127 jr_fx_noise[1] {(2^($59/5))*($59*20)},${60-62}
blend ${_mode{$63+1}},$64
fi
endl done
fx_dreamy_watercolour_preview :
fx_dreamy_watercolour $*
#@gui Hard Painting : fx_hard_painting, fx_hard_painting_preview(0)+
#@gui : note = note("Modular filter which can be used to apply an extremely-glossy paint effect.")
#@gui : sep = separator(), note = note("<small>Painting authors: <i>Lyle Kroll</i>, <i>Angelo Lama</i> and <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.\nLatest update: <i>2011/28/02</i>.</small>")
#@gui : 1. Abstraction = int(1,0,20)
#@gui : 2. Details Scale = float(2.5,0,100)
#@gui : 3. Color = float(4,0,25)
#@gui : 4. Smoothness = float(50,0,2000)
#@gui : 5. Sharpen Shades = bool(1)
#@gui : sep = separator (), note = note("<small>Graphic novel author: <i>PhotoComiX</i>. Latest update : <i>2011/13/11</i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=1582")
#@gui : 6. Graphic Novel Iterations = int(1,0,10)
#@gui : sep = separator ()
#@gui : note = note("Apply Local Normalization")
#@gui : 7. Skip This Step = bool(false)
#@gui : sep = separator ()
#@gui : note = note("Local Normalization Controls")
#@gui : 8. Ln Amplititude = float(2,0,60)
#@gui : 9. Ln Size = float(6,0,64)
#@gui : 10. Ln Neightborhood-Smoothness = float(5,0,40)
#@gui : 11. Ln Average-Smoothness = float(20,0,40)
#@gui : sep = separator()
#@gui : 12. Skip All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note(" Pencil Options")
#@gui : 13. Pencil Size = float(0.62,0,4)
#@gui : 14. Pencil Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : 15. Skip All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : 16. Activate "pencil Smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : sep = separator()
#@gui : 17. Pencil Smoother Sharpness = float(0.5,0,2)
#@gui : 18. Pencil Smoother Edge Protection = float(0.78,0,1)
#@gui : 19. Pencil Smoother Smoothness = float(1.92,0,10)
#@gui : sep = separator()
#@gui : 20. Skip All Other Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator()
#@gui : note = note ("Boost Merging Options")
#@gui : 21. Swap Layers = bool (false)
#@gui : 22. Mixer = choice("Overlay","Multiply","Soft light","Color Burn","Darken","Stamp","Hard Light","Value","Grain Merge","Freeze","Lightness", "Luminance","*Colors Doping","*Comix Colors*" ,"Graphic Colours","*Graphix Colors","*Vivid Edges*","*Dark Edges*","*Dark Screen*","*Vivid Screen*","Interpolate")
#@gui : 23. Opacity = float(1,0,1)
#@gui : 24. Intensity = float(1,0,1)
#@gui : sep = separator ()
#@gui : 25. Add Painter's Touch = bool(true)
#@gui : sep = separator ()
#@gui : 26. Painter's Touch Sharpness = float(0.5,0,2)
#@gui : 27. Painter's Edge Protection Flow = float(0.8,0,1)
#@gui : 28. Painter's Smoothness = float(1.28,0,10)
#@gui : sep = separator(), 29-31. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_hard_painting : skip ${4=0},${5=0}
repeat $! l[$>]
to_colormode {max(3,s)} split_opacity -rv
repeat $1 fx_normalize_local. 10,6,5,20,1,11 done
fx_smooth_anisotropic. {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
fx_mix_lab. 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
if $5 fx_segment_watershed. 10,1,0 fi
smooth. $4,0,1,1,1
-split_opacity -l[0]
-repeat {max(0,$6)}
-if {$7==0} -fx_normalize_local $8,$9,$10,$11,1,3,0 -endif
-if {$12==0} --fx_pencilbw $13,$14,0,0,0 -endif
-if {$15==1} -keep[-1] -break -endif
-if {$16==1} -fx_smooth_anisotropic[-1] 60,$17,$18,$19,1.1,0.8,30,2,0,1,1,0 -endif
-if {$20==1} -keep[-1] -break -endif
-if {$21==1} -reverse -endif
-if {$22==0} -fx_compose_overlay $23,0
-elif {$22==1} -fx_compose_multiply $23,0
-elif {$22==2} -fx_compose_softlight $23,0
-elif {$22==3} -fx_compose_colorburn $23,0
-elif {$22==4} -fx_compose_darken $23,0
-elif {$22==5} -fx_compose_stamp $23,0
-elif {$22==6} -fx_compose_hardlight $23,0
-elif {$22==7} -fx_compose_value $23,1
-elif {$22==8} -fx_compose_grainmerge $23,0
-elif {$22==9} -fx_compose_freeze $23,0
-elif {$22==10} -fx_compose_lightness $23,1
-elif {$22==11} -fx_compose_luminance $23,1
-elif {$22==12} -fx_compose_colordoping $23,0
-elif {$22==13} -fx_compose_comix_color $23,0,$24
-elif {$22==14} -fx_compose_graphicolor $23,0,$24
-elif {$22==15} -fx_compose_graphixcolor $23,0
-elif {$22==16} -fx_compose_vividedges $23,0.50,0,$24
-elif {$22==17} -fx_compose_darkedges $23,0.50,0,$24
-elif {$22==18} -fx_compose_vividscreen $23,0,$24
-elif {$22==19} -fx_compose_darkscreen $23,0,$24
-elif {$22==20} -fx_compose_interpolation $23,0 -endif
-if {$25==1} -fx_smooth_anisotropic 60,$26,$27,$28,1.1,0.8,30,2,0,1,1,0 -endif
-done
endl done
rv a c
endl
fx_hard_painting_preview :
gui_split_preview "-fx_hard_painting $*",${-3--1}
#@gui Neon : fx_neon, fx_neon_preview(0)
#@gui : note = note("Turns bright image outlines into bright, neon-like lines.")
#@gui : sep = separator(), note = note("Lines")
#@gui : 1. Norm Mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient")
#@gui : 2. Smoothness = float(0,0,10)
#@gui : 3. Contrast = float(0.45,0,1.5)
#@gui : 4. Min Threshold = float(40,0,100)
#@gui : 5. Max Threshold = float(60,0,100)
#@gui : 6. Negative = bool(0)
#@gui : 7. Opacity = float(1,0,1)
#@gui : 8. Saturation = float(1.15,0,4)
#@gui : 9. Blur Original = float(2,0,20)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 10. Amplitude = float(3,0,100)
#@gui : 11. Edge Threshold (%) = float(0,0,100)
#@gui : 12. Smoothness = float(3,0,5)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 13. Size = float(20,0,100)
#@gui : 14. Intensity = float(0.4,0,3)
#@gui : 15. Darken = float(0.1,0,1)
#@gui : 16. Saturation = float(1.5,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 17. Size = float(5,0,100)
#@gui : 18. Intensity = float(0.2,0,3)
#@gui : 19. Darken = float(0.1,0,1)
#@gui : 20. Saturation = float(1,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 21. Size = float(2,0,5)
#@gui : 22. Intensity = float(1,0,2)
#@gui : sep = separator()
#@gui : 23. Smooth Hues = float(0,0,20)
#@gui : sep = separator()
#@gui : 24. Alpha = bool(0)
#@gui : 25. Alpha Power = float(1,0,5)
#@gui : 26. Alpha Multiplier = float(1,0,5)
#@gui : sep = separator(), 27-29. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_neon :
repeat $! l[$>]
if $9
b $9
fi
+fc 0,0,0 rv blend alpha
to_rgb rgb2hsl s c
*.. {$8^2.5}
a[0-2] c hsl2rgb
if $7
[0] l[1]
if {$1==1}
b $2
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1] b $2
s={s} s. c +[-$s--1] sqrt.
elif {$1==2}
b $2 laplacian abs to_gray to_rgb
elif {$1==3}
b $2 gradient xyz abs blend add to_gray to_rgb
else
b $2 gradient_norm
fi
c 0,255
^ $3
c $4%,$5%
if $6 negate fi
n 0,255
if {$10!=0||$11!=100}
fx_smooth_antialias ${10-12}
fi
endl
if $9
b.. $9
fi
blend multiply,$7
fi
+b[0] {$13%*100},1 *[1] {$14*sqrt($13%)*10} -[1] {(($14*sqrt($13%)*128)-1)^(sqrt($15))}
+b[0] {$17%*100},1 *[2] {$18*sqrt($17%)*10} -[2] {(($18*sqrt($17%)*128)-1)^(sqrt($19))}
+b[0] $21,1 *[3] {($14+$18)*$21*$22}
rgb2hsl[1-3] s[1-3] c
*[2] {$16^2.5}
*[5] {$20^2.5}
*[8] 0
a[1-3] c a[2-4] c a[3-5] c hsl2rgb[1-3]
blend add,$7
if $23
rgb2ycbcr s c b[1,2] {$23%*100} a c ycbcr2rgb
fi
if $24
rgb2hsv8 100%,100%,1,1 f[1] "((j(#0,0,0,0,2)/255)^(1/$25))*255*$26" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
fi
endl done
fx_neon_preview :
gui_split_preview "-fx_neon ${1-26}",${-3--1}
#@gui Neon Alpha : fx_neon_alpha, fx_neon_alpha_preview(0)
#@gui : note = note("An attempt to make the Neon filter work with alpha channels. Low-quality, comes with some artefacts.")
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.45,0,1.5)
#@gui : 3. Min Threshold = float(40,0,100)
#@gui : 4. Max Threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Blur Original = float(2,0,20)
#@gui : 7. Saturation = float(1.15,0,4)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 8. Size = float(20,0,100)
#@gui : 9. Intensity = float(0.4,0,3)
#@gui : 10. Darken = float(0.1,0,1)
#@gui : 11. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 12. Size = float(5,0,100)
#@gui : 13. Intensity = float(0.2,0,3)
#@gui : 14. Darken = float(0.1,0,1)
#@gui : 15. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 16. Size = float(2,0,5)
#@gui : 17. Intensity = float(1,0,2)
fx_neon_alpha :
repeat $! l[$>]
to_rgba
+split_opacity
rm[1]
fx_solidify_td[0] 100,0,10,2,0 +invert_rgb[0]
blend[1,2] difference
fx_gradient_norm[1] ${1-4},0
if {$7!=1}
l[0] to_rgb[0] rgb2hsl[0] s[0] c
*[1] {$7^2.5}
a[0-2] c hsl2rgb[0]
endl fi
if $6
b[0] $6
fi
[0] [1] a[2,3] c b[2] $8,1 *[2] {$9*sqrt($8)} -[2] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
[0] [1] a[3,4] c b[3] $12,1 *[3] {$13*sqrt($12)} -[3] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
split_opacity[2,3]
l[2] to_rgb[0] rgb2hsv[0] s[0] c
*[1] {$11^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] endl
l[4] to_rgb[0] rgb2hsv[0] s[0] c
*[1] {$15^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] endl
blend[3,5] average
blend[2,4] add
b[2] {$9*13}
+blend[0,2] add rm[0] mv[3] 0
[1]
a[0,1] c a[1,2] c [1] mv[3] 0
blend[0,1] alpha blend[0,1] add
endl done
fx_neon_alpha_preview :
fx_neon_alpha $*
#@gui Otsu-Hessian Blend : fx_otsu_hessian_blend, fx_otsu_hessian_blend_preview(1)
#@gui : note = note("Expansion of <a href="https://discuss.pixls.us/t/one-liner-challenge/8785/7?u=joan_rake1">a one-line filter by Afre</a>.")
#@gui : Otsu Levels = int(4,1,32)
#@gui : Norm 1 = float(0,-5,5)
#@gui : Norm 2 = float(1,-5,5)
#@gui : Merging Option = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Opacity = float(1,0,1)
#@gui : Reverse Order = bool(0)
fx_otsu_hessian_blend :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption=$4
Opacity=$5
ReverseOrder={!$6}
+l otsu $1 af_hnorm n $2,$3 endl +* blend ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
fx_otsu_hessian_blend_preview :
repeat {max(0,l)}
fx_otsu_hessian_blend[$>] $*
done
#@gui Whirling Lines : fx_whirling_lines, fx_whirling_lines_preview()
#@gui : note = note("Creates fingerprint-like lines out of images by blurring and rounding their values. Works best with single-channel images.")
#@gui : 1. Blur = float(30,0,100)
#@gui : 2. Round = float(6,0,255)
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 3. Norm Mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient")
#@gui : 4. Smoothness = float(0,0,10)
#@gui : 5. Contrast = float(0.45,0,1.5)
#@gui : 6. Min Threshold = float(40,0,100)
#@gui : 7. Max Threshold = float(60,0,100)
#@gui : 8. Dilate or Erode = int(0,-5,20)
#@gui : 9. Negative = bool(0)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 10. Amplitude = float(30,0,100)
#@gui : 11. Edge Threshold (%) = float(0,0,100)
#@gui : 12. Smoothness = float(3,0,10)
#@gui : 13. Value Action = choice(3,"None","Cut","Normalize","Cut then normalize")
fx_whirling_lines :
b $1 f "round(i,$2)"
if {$3==1}
b $4
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1] b $4
s={s} s. c +[-$s--1] sqrt.
elif {$3==2}
b $4 laplacian abs to_gray to_rgb
elif {$3==3}
b $4 gradient xyz abs blend add to_gray to_rgb
else
b $4 gradient_norm
fi
c 0,255
^ $5
c $6%,$7%
n 0,255
if {$8>=0}
dilate_circ $8
elif {$8<=0}
erode {-$8}
fi
if $9 negate fi
if {$10!=0||$11!=100}
fx_smooth_antialias ${10-12}
fi
if {$13==1} c 0,255 elif {$13==2} n 0,255 elif {$13==3} c 0,255 n 0,255 fi
fx_whirling_lines_preview :
fx_whirling_lines $*
#@gui _
#@gui <i>Contours</i>
#@gui Gradient Norm [JR's Mod] : fx_jr_gradient_norm, fx_jr_gradient_norm_preview(1)
#@gui : Smoothness = float(0,0,10)
#@gui : Contrast = float(0.45,0,1.5)
#@gui : Min Threshold = float(40,0,100)
#@gui : Max Threshold = float(60,0,100)
#@gui : Negative = bool(0)
#@gui : Include Orientation = choice("Off","On","On &#40;extrapolate if negative&#41;")
#@gui : Scale X = float(1,0,5)
#@gui : Scale Y = float(1,0,5)
#@gui : Interpolation = choice(2,"Nearest","Average","Bilinear","Bicubic")
#@gui : Alpha = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
jr_dir2rgb :
v - channels 0,1 repeat $! l[$>] nm={0,n}
s c complex2polar round.. 0.001
*. {180/pi} %. 360 100%,100%,1,1,1 mv... $!
c 0,360 if {im!=iM} n. 0,1 else f. 1  fi
a c hsv2rgb
nm $nm endl done v +
jr_gradient_norm :
b $1 gradient_norm c 0,255 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255
fx_jr_gradient_norm :
repeat $! l[$>]
if {$9==3}
inter=5
else
inter={1+$9}
fi
if {$7!=1||$8!=1}
ww={w}
hh={h}
shift -0.5,-0.5,0,0,1
r {max(1,$7*w)},{max(1,$8*h)},100%,100%,$inter
fi
if $6
+l luminance gradient append c
blur $1 orientation +jr_dir2rgb
endl rm[1]
if $5
l[1]
rgb2hsv8 100%,100%,1,1 f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
if {$6==2}
fx_solidify_td 100,0,10,2,0
fi
rgb2hsv8 f "[i0,i1,255]" hsv82rgb
endl
fi
fi
jr_gradient_norm[0] ${1-5}
if {$7!=1||$8!=1}
r $ww,$hh,100%,100%,$inter
fi
if $6 blend multiply fi
if {$6==1} c 0,255 f "I==[255,255,255]?[0,0,0]:I" fi
if $10 rgb2hsv8 100%,100%,1,1 if {$6} [1] f[2] "j(#0,0,0,0,1)" f[0] "[i0,255,i2]" fi f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0] if {$6} blend[1,2] multiply fi a c fi
endl done
fx_jr_gradient_norm_preview :
gui_split_preview "fx_jr_gradient_norm $*",${-3--1}
bitplane8 :
100%,100%,8,100%,"(i(#-1,x,y,0,c)>>z)&1" rm[0]
debitplane8 :
f "a=0;for(k=0,k<8,++k,a+=i(x,y,k)*2^k)"
#@gui _
#@gui <i>Deformations</i>
#@gui Custom Box : fx_custom_box, fx_custom_box_preview()
#@gui : Float 1 = float(0,-2,2)
#@gui : Box 2 = text(1,"\n")
fx_custom_box :
skip ${2="-skip skip"}
m "_fx_custom_box_start : $2"
_fx_custom_box_start
uncommand _fx_custom_box_start
fx_custom_box_preview:
skip ${2="-skip skip"}
_gcp_arg="$2"
fx_custom_box $_gcp_arg
#@gui Layer Cake : fx_layer_cake, fx_layer_cake_preview(1)
#@gui : note = note("Splits image into annular or circular layers and rotates each layer. Based on <a href="https://forums.getpaint.net/topic/26566-layer-cake-plugin/">the Paint.NET plugin</a>.")
#@gui : Iterations = int(4,1,32)
#@gui : Angle at Centre = float(360,-1440,1440)
#@gui : Angle Times Iteration = bool(0)
#@gui : Size = float(75,0,200)
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Boundary = choice(3,"None","Nearest","Periodic","Mirror")
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Blur = float(0,0,200)
#@gui : sep = separator()
#@gui : Anti-Alias Amplitude = float(30,0,100)
#@gui : Edge Threshold (%) = float(0,0,100)
#@gui : Smoothness = float(3,0,10)
#@gui : Output Layers = choice("Off","Hollow","Filled")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_layer_cake :
repeat $! l[$>]
iter=$1
angle=$2
if $3 angle*=$iter fi
size=$4/2
to_rgba split_opacity to_rgb
repeat 2
part={1-$>}
l[$part]
repeat $iter
[0] rotate[-1] {$angle/$iter*($>+1)},$8,$7,$5%,$6%
100%,100%,1,1 ellipse. $5%,$6%,{$size/$iter*($iter-$>)}%,{$size/$iter*($iter-$>)}%,0,1,255
if {$13!=2} ellipse. $5%,$6%,{$size/$iter*($iter-1-$>)}%,{$size/$iter*($iter-1-$>)}%,0,1,1 fi
blur. {$9/$iter}
fx_smooth_antialias. ${10-12}
blend[-1,-2] multiply
done
if {!$13} blend[^0] add fi
if {$13!=2} 100%,100%,1,1 fc. 255,255,255 ellipse. $5%,$6%,{$size}%,{$size}%,0,1,0
blur. {$9/$iter}
fx_smooth_antialias. ${9-11}
blend[-1,0] multiply fi
if {!$13} blend add fi
if $part to_gray fi
endl
done
list={int($!/2)}
repeat {$list} a[$>,$list] c done
endl
done
fx_layer_cake_preview:
if {!$13} gui_split_preview "fx_layer_cake $*",${-3--1} else fx_layer_cake $* fi
#@cli jr_deform : _amplitude>=0,_interpolation,_matrix_density[%]>=0,_matrix_interpolation,_mode,-100<=_character<=100
#@cli : Apply random smooth deformation on selected images. An upgrade to the existing deform command.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'matrix_interpolation' can be { 0=linear | 1=bicubic }.
#@cli : 'mode' can be { 0=noise | 1=spread_noise }.
#@cli : 'boundary' can be  { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
jr_deform : skip ${1=10},${2=1},${3=2%},${4=1},${5=0},${6=0}
e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
v - repeat $! l[$>]
S={${"is_percent $3"}?max(w,h)*$3:$3}
P={$4==0?3:5}
if {$5==1} +r. $3,$3,1,4 spread. {max(w,h)*($6+100)/200},{max(w,h)*($6+100)/200} else
$3,$3,1,4 noise. $1
fi
ac. "adjust_colors 0,$6,0,0,0",rgba r. ..,..,1,4,$P warp.. .,1,$2,$7 rm.
endl done v +
#@gui Random Deformations (JR's Mod) : fx_jr_deform, fx_jr_deform_preview(1)
#@gui : Recompute = button(0)
#@gui : Amplitude = float(5,0,50)
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Matrix Density = float(10,1,100)
#@gui : Matrix Interpolation = choice(1,"Linear","Bicubic")
#@gui : Mode = choice("Noise","Spread noise")
#@gui : Character = float(0,-100,100)
#@gui : Boundary = choice(1,"Dirichlet","Neumann","Periodic","Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_jr_deform :
repeat $! l[$>]
jr_deform ${2-8}
endl done
fx_jr_deform_preview :
gui_split_preview "fx_jr_deform $*",${-3--1}
#@gui Rays from Image : fx_rays_from_image, fx_rays_from_image(1)
#@gui : Power = float(5,0,10)
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
rays_from_image:
fx_transform_polar 0,$2,$3,"(R-a)*(4^(($1)-5))*$1/5","a",3
fx_rays_from_image:
repeat {max(0,l)}
ac[$>] "rays_from_image $*",$-2,$-1
done
#@gui Shifter : fx_shifter, fx_shifter_preview(1)
#@gui : Recompute = button(0)
#@gui : X Amplitude = float(1,0,10)
#@gui : X Iterations = int(20,0,400)
#@gui : Y Amplitude = float(1,0,10)
#@gui : Y Iterations = int(20,0,400)
#@gui : Matrix Warp Multiplier = float(1,0,5)
#@gui : Matrix Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
_shifter:
repeat $! l[$>]
100%,100%,1,3 [1] fc[1,2] 0
rectexture[1] $2,0,$5,$6,2,0
rectexture[2] $4,0,$5,$6,2,0
to_gray[^0]
f[1] "$1*510*(0.25-abs(0.5-i/255))"
f[2] "$3*510*(0.25-abs(0.5-i/255))"
a[^0] c
if {$7==0}
f={u(0,3)}
elif {$7==1}
f={u(0,2)+1}
else
f={($7)-2}
fi
warp.. .,1,0,{int($f)}
rm.
endl done
fx_shifter:
_shifter ${2-8}
fx_shifter_preview:
gui_split_preview "fx_shifter $*",${-3--1}
#@gui UltraWarp++++ : fx_ultrawarpplusplusplusplus, fx_ultrawarpplusplusplusplus(1)
#@gui : note = note("Sequence of multiple partially-randomised texture generation and image deformation filters with multi-iteration warping")
#@gui : note = note("<small>This modular filter is extremely complex and its logic may not follow that which you expect. Left on its default settings, it is very likely to munge your image beyond recognition.</small>"), sep = separator()
#@gui : 1.  Recompute = button(0)
#@gui : sep = separator()
#@gui : 2.  Plasma Texture [Discards Input Image] = bool(0)
#@gui : 3.  Plasma Scale = float(3.3,0,20)
#@gui : 4.  Plasma Alpha Channel = bool(0)
#@gui : sep = separator()
#@gui : 5.  Segmentation [No Alpha Channel] = bool(0)
#@gui : 6.  Edge Threshold = float (5,0.01,60)
#@gui : 7.  Smoothness = float (0,0,60)
#@gui : sep = separator()
#@gui : 8.  Blur = float (0,0,30)
#@gui : sep = separator()
#@gui : 9.  Quadtree Pixelisation [No Alpha Channel] = bool(0)
#@gui : 10.  Quadtree Min Precision = int(4,2,8192)
#@gui : 11.  Quadtree Max Precision = int(256,0,8192)
#@gui : 12.  Quadtree Min Homogeneity = float(4.8,0,5)
#@gui : 13.  Quadtree Max Homogeneity = float(5,0,5)
#@gui : sep = separator()
#@gui : 14. Noise Type = choice(2,"Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : 15. Minimum Noise = float(0,0,8)
#@gui : 16. Maximum Noise = float(0,0,8)
#@gui : 17. Noise Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Warping</small>")
#@gui : 18. Warp Iterations = int(3,0,30)
#@gui : 19. Warp Intensity = float(3,0,10)
#@gui : 20. Warp Offset = float(20,0,2000)
#@gui : 21. Scale to Width = bool(1)
#@gui : 22. Scale to Height = bool(1)
#@gui : 23. Correlated Channels = choice("Random","Off","On")
#@gui : 24. Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : 25. Warp Channel(s) = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 26. Random Negation = bool(1)
#@gui : 27. Random Negation Channel(s) = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 28. Gamma Offset = float(0.25,0,1)
#@gui : 29. Hue Offset = float(1,0,1)
#@gui : 30. Normalise = bool(1)
#@gui : sep = separator(), note = note("<small>Final HSV Scaling</small>")
#@gui : 31. Minimum Hue = float(0,0,20)
#@gui : 32. Maximum Hue = float(5,0,20)
#@gui : 33. Minimum Saturation = float(0,0,20)
#@gui : 34. Maximum Saturation = float(3,0,20)
#@gui : 35. Minimum Value = float(0.5,0,20)
#@gui : 36. Maximum Value = float(2,0,20)
#@gui : note = note("<small>Set these to their minimum values for randomisation</small>")
#@gui : 37. Hue Offset = float(-180.01, -180.01, 180)
#@gui : 38. Saturation Offset = float(0, -1.01, 1)
#@gui : 39. Value Offset = float(0,-20.01,20)
#@gui : sep = separator(),
#@gui : -4. Normalise = bool(1)
#@gui : -3. Normalisation Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(),
#@gui : -2. UltraWarp++++ Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : -1. Value Action = choice("None","Cut","Normalize")
ultrawarpplusplusplusplus:
hue_min={$30}
hue_max={$31}
sat_min={$32}
sat_max={$33}
val_min={$34}
val_max={$35}
j={min($hue_min,$hue_max)+(u*(max($hue_min,$hue_max)-min($hue_min,$hue_max)))}
k={min($sat_min,$sat_max)+(u*(max($sat_min,$sat_max)-min($sat_min,$sat_max)))}
l={min($val_min,$val_max)+(u*(max($val_min,$val_max)-min($val_min,$val_max)))}
if {$1}
if {$2} ch=0 -else ch=2 -endif
ac  "rr={round(u*255)}
gg={round(u*255)}
bb={round(u*255)}
fx_plasma 0.5,0,{$2},1,1,{$rr},{$gg},{$bb}
if {$3} to_rgba else ch=2 -to_rgb -endif",{$ch} fi
fx_gaussian_blur {$7},0,0,1,2,0,0
n_min={$14}
n_max={$15}
if {$n_min > $n_max}
n_min = {$n_min + $n_max}
n_max = {$n_min - $n_max}
n_min = {$n_min - $n_max}
fi
noise_exp={max(0,$n_min+(u*($n_max-$n_min)))}
n_amt={(2^($noise_exp-3))*$noise_exp}
if {$4} fx_segment_watershed {$5},{$6},0,2,0 fi
if {$8}
p_min={$9}
p_max={$10}
h_min={$11}
h_max={$12}
if {$p_min > $p_max}
p_min = {$p_min + $p_max}
p_max = {$p_min - $p_max}
p_min = {$p_min - $p_max}
fi
if {$h_min > $h_max}
h_min = {$h_min + $h_max}
h_max = {$h_min - $h_max}
h_min = {$h_min - $h_max}
fi
fx_noise {$n_amt},{$13},{$16},1,0
fx_quadtree 0,{max(2,round($p_min+(u*($p_max-$p_min))))},{max(0,round($h_min+(u*($h_max-$h_min))))},0,3,1.5,1,1,0
fi
fx_noise {$n_amt},{$13},{$16},1,0
f={$17}
i={$18}
m={$19}
s={$20}
v={$21}
repeat {max(0,$f)}
if {$20}
scale_x=w/10
a={((2^($18-5))*$18)*(u-0.5)*$scale_x*0.025}
else
scale_x=1
a={((2^($18-5))*$18)*(u-0.5)}
fi
if {$22}
scale_y=h/10
b={((2^($18-5))*$18)*(u-0.5)*$scale_y*0.025}
else
scale_y=1
b={((2^($18-5))*$18)*(u-0.5)}
fi
c=(u-0.5)*$m*sign($m)*$scale_x
d=(u-0.5)*$m*sign($m)*$scale_y
g={round((u*33.98)-0.49)}
h={(u-0.5)*$s*200}
o={(u-0.5)*$v*200}
if {$22==1}
e=0
elif {$22==2}
e=1
else
e={round(u)}
fi
if {$23==0}
f={round((u*2.98)-0.49)}
elif {$23==1}
f={round((u*2.98)+0.51)}
else
f={($23)-2}
fi
ac  "_fx_warp_by_intensity "{$a}","{$b}","{$c}","{$d}","{$e}",0,"{$f}"",{$24},0
if {$25}
nn={round(u)}
if {$nn}
if {$26==0}
nch={round((u*33.98)-0.49)}
ac "-negate",{$nch}
else
ac "-negate",{$26}
fi
fi
fi
fx_adjust_colors 0,0,{$h},{$o},0,0
if {$29}
ac "n 0,255",3
fi
done
if {$36==-180.1}
hh=((u-0.5)*360)
else
hh={$36}
fi
if {$37==-8.01}
ss=((u-0.5)*2)
else
ss={$37}
fi
if {$38==-20.01}
vv=((u-0.5)*2)
else
vv={$38}
fi
fx_mix_hsv {$j},{$hh},0,{$k},{$ss},0,{$l},{$vv},0,0,2,0
if {$-2}
ac "n 0,255",{$-1}
fi
fx_ultrawarpplusplusplusplus:
repeat $! l[$>]
ac "ultrawarpplusplusplusplus ${2--3}",$-2,$-1
fx_adjust_colors 0,0,0,{(u-0.5)*200},0,0
endl done
#@gui UltraWarp 2 : fx_ultrawarptwo, fx_ultrawarptwo_preview(1)
#@gui : 1. Recompute = button(0)
#@gui : sep = separator(), note = note("<b>Warping</b>")
#@gui : 2. Iterations = int(3,1,30)
#@gui : 3. From RGB To = choice(1,"Random","RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : 4. X-Factor Centre = float(0,-30,30)
#@gui : 5. X-Factor Range = float(3,0,30)
#@gui : 6. Y-Factor Centre = float(0,-30,30)
#@gui : 7. Y-Factor Range = float(3,0,30)
#@gui : 8. X-Offset Centre = float(0,-30,30)
#@gui : 9. X-Offset Range = float(3,0,30)
#@gui : 10. Y-Offset Centre = float(0,-30,30)
#@gui : 11. Y-Offset Range = float(3,0,30)
#@gui : 12. Correlated Channels = choice(2,"On","Off","Random")
#@gui : 13. Interpolation = choice(2,"Nearest","Linear","Random")
#@gui : 14. Boundary = choice(5,"Transparent","Nearest","Periodic","Mirror","Random","Random &#40;non-transparent&#41;")
#@gui : 15. Warp Channel(s) = choice(3,"None","Random","All","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 16. Include Alpha = bool(0)
#@gui : 17. To RGB From = choice(1,"Random","RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : 18. Random Negation = bool(1)
#@gui : sep = separator(), note = note("<b>Post-warping HSX8 mixing</b>")
#@gui : 19. Repeat for Each Iteration = bool(1)
#@gui : 20. X Channel = choice("Value","Intensity","Lightness")
#@gui : 21. Hue Factor Centre = float(1,-20,20)
#@gui : 22. Hue Factor Range = float(0.5,0,20)
#@gui : 23. Saturation Factor Centre = float(2.5,-20,20)
#@gui : 24. Saturation Factor Range = float(5,0,20)
#@gui : 25. X Channel Factor Centre = float(1,-20,20)
#@gui : 26. X Channel Factor Range = float(0,0,20)
#@gui : 27. Alpha Factor Centre = float(1,-20,20)
#@gui : 28. Alpha Factor Range = float(0,0,20)
#@gui : 29. Hue Shift Centre = float(0,-255,255)
#@gui : 30. Hue Shift Range = float(255,0,255)
#@gui : 31. Saturation Shift Centre = float(0,-255,255)
#@gui : 32. Saturation Shift Range = float(255,0,255)
#@gui : 33. X Channel Shift Centre = float(0,-255,255)
#@gui : 34. X Channel Shift Range = float(0,0,255)
#@gui : 35. Alpha Shift Centre = float(0,-255,255)
#@gui : 36. Alpha Shift Range = float(0,0,255)
#@gui : sep = separator(), note = note("<b>Custom code</b>")
ultrawarptwo :
repeat $! l[$>] to_rgba split_opacity
iter=$1
sc=$2
xfc=$3
xfr=$4
yfc=$5
yfr=$6
xoffc=$7
xoffr=$8
yoffc=$9
yoffr=$10
corr=$11
inter=$12
bound=$13
chann=$14
alpha=$15
cs=$18
rn=$19
rpo=$18
vil=$19
hfc=$20
hfr=$21
sfc=$22
sfr=$23
vilfc=$24
vilfr=$25
afc=$26
afr=$27
hoffc=$28
hoffr=$29
soffc=$30
soffr=$31
viloffc=$32
viloffr=$33
aoffc=$34
aoffr=$35
repeat $iter
if $alpha
opacity=2
else
opacity=1
fi
repeat $opacity
if {$sc==0}
frgbt={floor(u(0,23))}
else
frgbt={$sc-1}
fi
if {$cs==0}
trgbf={floor(u(0,23))}
else
trgbf={$cs-1}
fi
if {$>==0}
csswap[$>] 0,1,0,$frgbt
fi
if {$>==1||$chann!=0}
if {$chann==1}
channel={floor(u(2,37))}
else
channel=$chann
fi
if {$channel==0}
channels=0
elif {$channel>=2}
channels={$channel-1}
elif {$channel>=6}
channels=$channel
else
channels={$channel-2}
fi
if {$corr==2}
correl=round(u)
else
correl=$corr
fi
if {$inter==2}
interp=round(u)
else
interp=$inter
fi
if {$bound==4}
bounds={floor(u(4))}
elif {$bound==5}
bounds={floor(u(3))+1}
else
bounds=$bound
fi
xf={($xfc+u(-$xfr,$xfr))}
yf={($yfc+u(-$yfr,$yfr))}
xoff={($xoffc+u(-$xoffr,$xoffr))}
yoff={($yoffc+u(-$yoffr,$yoffr))}
xff={sign($xf)*w*0.00002*(abs($xf)^2)}
yff={sign($yf)*h*0.00002*(abs($yf)^2)}
xofff={sign($xoff)*w*0.00002*(abs($xoff)^2)}
yofff={sign($yoff)*w*0.00002*(abs($yoff)^2)}
fx_warp_by_intensity[$>] $xff,$yff,$xofff,$yofff,$correl,$interp,$bounds,$channels,0
fi
if {$>==0}
csswap[$>] $trgbf,1,0,0
fi
if $rn
if {round(u)}
negate[$>]
fi
fi
done
if {$>==($iter-1)||$rpo}
hf={$hfc+u(-$hfr,$hfr)}
sf={$sfc+u(-$sfr,$sfr)}
vilf={$vilfc+u(-$vilfr,$vilfr)}
af={$afc+u(-$afr,$afr)}
hoff={$hoffc+u(-$hoffr,$hoffr)}
soff={$soffc+u(-$soffr,$soffr)}
viloff={$viloffc+u(-$viloffr,$viloffr)}
aoff={$aoffc+u(-$aoffr,$aoffr)}
l[0] if {$vil==1} rgb2hsi8 elif {$vil==2} rgb2hsl8 else rgb2hsv8 fi
s c
*[0] $hf +[0] {$hoff*max(1,abs($hf))} %[0] 255
*[1] $sf +[1] {$soff*max(1,abs($sf))}
*[2] $vilf +[2] {$viloff*max(1,abs($vilf))}
a c
if {$vil==1} hsi82rgb elif {$vil==2} hsl82rgb else hsv82rgb fi
endl
*[1] $af +[1] {$aoff*max(1,abs($af))}
fi
done
to_rgb[0]
to_gray[1]
a c
endl
done
fx_ultrawarptwo :
ultrawarptwo ${2--1}
fx_ultrawarptwo_preview:
fx_ultrawarptwo $*
#@gui _
#@gui <i>Degradations</i>
#@gui Blur [Bloom Glare] : fx_blur_bloom_glare, fx_blur_bloom_glare_preview(0)
#@gui : Amplitude = float(1,0,20)
#@gui : Ratio = float(2,0,10)
#@gui : Iterations = int(5,0,200)
#@gui : Operator = choice("Add","Max","Min")
#@gui : Kernel = choice("Quasi-gaussian","Gaussian","Box","Triangle","Quadratic")
#@gui : Normalize Scales = bool(0)
#@gui : Anisotropy = bool(0)
#@gui : Angle = float(0,0,180)
#@gui : Axis = int(3,1,20)
#@gui : Opacity = float(0.5,0,1)
#@gui : note = note("Parameters <i>Angle</i>, <i>Axis</i> and <i>Opacity</i> are only active when <i>Anisotropy</i> is checked")
#@gui : sep = separator()
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator()
#@gui : Preview Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest update: <i>2015/03/02</i>.</small>")
fx_blur_bloom_glare :
op=${"arg 1+$4,+,max,min"}
if {!$7}
ac "blur_bloom ${1-3},"$op",${5-6},xy",$11
else
wh={[w,h]}
repeat $9
ang={(180/$9)*($>)+$8}
+rotate[0] $ang,2,1
ac. "blur_bloom ${1-3},"$op",${5-6},x",$11
rotate. {-$ang},2,1
r. $wh,1,100%,0,0,0.5,0.5
c. 0,255
done
repeat {$9}
blend[0,-1] screen,$10
done
fi
fx_blur_bloom_glare_preview :
gui_split_preview "fx_blur_bloom_glare $*",$-1
#@gui Bomb Blend : fx_blend_bomb, fx_blend_bomb_preview()
#@gui : note = note("Creates a random transfer function 'mesh' and then blends images accordingly. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : Recompute = button(0)
#@gui : Process As = choice(1,"Two-by-two","Self-blend for each layer")
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh Smoothness = float(2,0,10)
#@gui : Contrast Scheme = choice("Arctan","Clip","Power")
#@gui : Mesh Contrast = float(50,0,100)
#@gui : Reverse Blending Layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Alpha = bool(0)
#@gui : Normalise = bool(0)
#@gui : Output Mesh = bool(0)
_blend_bomb :
to_rgba
$1,$2,1,4 noise. 255
if $8 ac. "noise 255",rgba_a fi
r. 256,256 n. 0,255 blur. {$3^2}%
l. if {$4==0}
f "val = i/255; (val-0.5+(atan((val-0.5)*($5/10)^3)/pi)+0.5)*255" n 0,255
elif {$4==1}
c {($5-1/255)/2}%,{100-($5-1/255)/2}% n 0,255
elif {$4==2}
f "val = (2*i/255)-1; (val*(abs(val)^(0-($5/100)))+1)*255/2"
fi endl
rv
fx_mesh_blend 0,1,$6,$7,$8,$10
if $9 ac "n 0,255",rgba fi
blend_bomb :
if {$1==0} repeat {int($!/2)} l[$>,{$>+1}] _blend_bomb ${2--1} endl done
elif {$1==1} repeat $! l[$>] [0] _blend_bomb ${2--1} endl done fi
fx_blend_bomb :
blend_bomb ${2--1}
fx_blend_bomb_preview :
fx_blend_bomb $*
#@gui Cascading Self Glitching : fx_self_glitching_cascade, fx_self_glitching_cascade_preview(1)
#@gui : note = note("Shifts images in a cascading fashion but computes values based on shifted and original images.")
#@gui : note = note("<small>This filter has many channel options and many operation options allowing for extremely-distorted images. Don't always trust the preview!</small>"), sep = separator()
#@gui : 1. Shift Channels = choice("RGB&#47;sRGB","CMYK&#47;CMY","HSV&#47;HSV8","HSL&#47;HSL8","HSI&#47;HSI8","LCH&#47;LCH8","Lab&#47;Lab8","YCbCr&#47;YCbCrGLIC","YIQ&#47;YIQ8","YUV&#47;YUV8","Bayer&#47;HCY","XYZ&#47;XYZ8")
#@gui : 2. Alt Choice = bool(0)
#@gui : 3. Process Alpha = bool(0)
#@gui : 4,5. Zeroth Shift = point(50,50,0,1,255,255,255,175)
#@gui : 6. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : sep = separator()
#@gui : 7. Iterations = int(3,1,64)
#@gui : 8. Repeat Post-Shift Operations = bool(1)
#@gui : sep = separator()
#@gui : 9,10. Shift Target = point(55,55,0,1,255,0,0,175)
#@gui : 11. Target for Final &#40;Rather than First&#41; Shift = bool(0)
#@gui : 12,13. Cascade Centre Point = point(45,45,0,1,0,255,0,175)
#@gui : 14. Shift Randomness = float(0.75,0,4)
#@gui : 15. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : 16. Power = float(0,-5,5)
#@gui : 17. Bias = float(0,-256,256)
#@gui : 18. Negation = bool(0)
#@gui : 19. Shift Operator = choice("Add","Multiply","Bitwise And","Bitwise Or","Bitwise Xor","Power","Reverse Power",
#@gui : "Modulo","Reverse Modulo","Divide","Reverse Divide","Subtract","Reverse Subtract",
#@gui : "Left Bitwise Shift","Reverse LBS","Right Bitwise Shift","Reverse RBS","Left Bitwise Rotation","Reverse LBR","Right Bitwise Rotation","Reverse RBR",
#@gui : "Average","Round","Reverse Round","Sine","Reverse Sine","Cosine","Reverse Cosine","Tangent","Reverse Tangent &#40;CPU-intensive&#41;",
#@gui : "Cosecant","Reverse Cosecant","Secant","Reverse Secant","Cotangent","Reverse Cotangent","Variance","Difference","Minimum","Maximum",
#@gui : "Interference &#40;Add&#41;","Reverse Interference &#40;Add&#41;","Interference &#40;Multiply&#41;",
#@gui : "Interference &#40;Divide&#41;","Reverse Interference &#40;Div&#41;",
#@gui : "Interference &#40;Subtract&#41;","Reverse Interference &#40;Subt&#41;","Interference &#40;Rev Subt&#41;","Reverse Interference &#40;Rev Subt&#41;",
#@gui : "Interference &#40;Difference&#41;","Reverse Interference &#40;Diff&#41;","Interference &#40;Variance&#41;",
#@gui : "Screen","Colour Dodge","Reverse Colour Dodge","Colour Burn","Reverse Colour Burn","Soft Light &#40;illusions&#46;hu&#41;","Reverse Soft Light &#40;illusions&#46;hu&#41;",
#@gui : "Geometric Mean","Bright Hard Mix","Dark Hard Mix")
#@gui : 20. Multiplier 1 = float(1,-10,10)
#@gui : 21. Addition 1 = int(0,-1024,1024)
#@gui : 22. Post-Shift Modulo = int(256,0,1024)
#@gui : 23. Multiplier 2 = float(1,-10,10)
#@gui : 24. Addition 2 = int(0,-1024,1024)
#@gui : sep = separator(), 25. Run on channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Original author: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>&#59; extended by some nobody who calls themselves 'Joan Rake' or something.<p>Latest update: <i>2018/08/24</i>.</small>")
fx_self_glitching_cascade :
skip "${25=-skip ,}","${26=-skip ,}"
shift {$4-50}%,{$5-50}%,0,0,$6,0
repeat $! l[$>] if {!$3} split_opacity fi l[0] to_rgb
if {$2}
if {$1==0} rgb2srgb
elif {$1==1} rgb2cmy
elif {$1==2} rgb2hsv8
elif {$1==3} rgb2hsl8
elif {$1==4} rgb2hsi8
elif {$1==5} rgb2lch8
elif {$1==6} rgb2lab8
elif {$1==7} rgb2ycbcrglic
elif {$1==8} rgb2yiq8
elif {$1==9} rgb2yuv8
elif {$1==10} rgb2hcy
elif {$1==11} rgb2xyz8
fi else
if {$1==1} rgb2cmyk
elif {$1==2} rgb2hsv
elif {$1==3} rgb2hsl
elif {$1==4} rgb2hsi
elif {$1==5} rgb2lch
elif {$1==6} rgb2lab
elif {$1==7} rgb2ycbcr
elif {$1==8} rgb2yiq
elif {$1==9} rgb2yuv
elif {$1==10} rgb2bayer 0
elif {$1==11} rgb2xyz
fi fi
if $11 stype=$7 else stype=1 fi
repeat $7
+shift[0] {((([w,h]-1)*([$12,$13]-[$9,$10]+[u(-1,1),u(-1,1)]*sqrt((($12-$9)^2)+(($13-$10)^2))*($14^3)))/$stype)/100},0,0,$15
f.. "begin(
const sign = $18?-1:1;
);
operate(mode,s1,s2,mult,power) =
(mode==0?(s1 + s2):
mode==1?(s1 * s2):
mode==2?(s1 & s2):
mode==3?(s1 | s2):
mode==4?xor(s1,s2):
mode==5?(s1^(s2*0.01)):
mode==6?(s2^(s1*0.01)):
mode==7?(s1%s2):
mode==8?(s2%s1):
mode==9?(s1 / s2):
mode==10?(s2 / s1):
mode==11?(s2 - s1):
mode==12?(s1 - s2):
mode==13?(s1 << s2):
mode==14?(s2 << s1):
mode==15?(s1 >> s2):
mode==16?(s2 >> s1):
mode==17?for(n=0,n<(s2%32),n++,rol(s1)):
mode==18?for(n=0,n<(s1%32),n++,rol(s2)):
mode==19?for(n=0,n<(s2%32),n++,ror(s1)):
mode==20?for(n=0,n<(s1%32),n++,ror(s2)):
mode==21?avg(s2,s1):
mode==22?round(s1,s2,0):
mode==23?round(s2,s1,0):
mode==24?s2*sin(s1*2*pi/mult):
mode==25?s1*sin(s2*2*pi/mult):
mode==26?sign*s2*cos(s1*2*pi/mult):
mode==27?sign*s1*cos(s2*2*pi/mult):
mode==28?s2*tan(s1*pi/mult):
mode==29?s1*tan(s2*pi/mult):
mode==30?s2*sin(mult/(s1*2*pi)):
mode==31?s1*sin(mult/(s2*2*pi)):
mode==32?sign*s2*cos(mult/(s1*2*pi)):
mode==33?sign*s1*cos(mult/(s2*2*pi)):
mode==34?s2*tan(mult/(s1*pi)):
mode==35?s1*tan(mult/(s2*pi)):
mode==36?mult*var(s1,s2):
mode==37?abs(s2 - s1):
mode==38?min(s2,s1):
mode==39?max(s2,s1):
mode==40?0.005*s2*(((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power))+s1):
mode==41?0.005*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)+s2):
mode==42?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)*s1:
mode==43?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s1:
mode==44?0.1*s1*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s2:
mode==45?0.001*s2*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==46?0.001*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==47?0.001*s2*(s1-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==48?0.001*s1*(s2-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==49?0.001*s2*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==50?0.001*s1*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==51?0.00001*mult*var(s1,s2,(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==52?(255-((255-s1)*(255-s2))):
mode==53?(s1/(255-s2)):
mode==54?(s2/(255-s1)):
mode==55?((255-s2)/s1*255):
mode==56?((255-s1)/s2*255):
mode==57?((((s1)/255)^2)^(2*(0.5-(s2/255))))*255:
mode==58?((((s2)/255)^2)^(2*(0.5-(s1/255))))*255:
mode==59?sqrt(abs(s1*s2)):
mode==60?(if((s1+s2)>=255,255,0)):
(if((s1+s2)<=255,0,255)));
val = sign*((2^$16)*j(#-1) + $17);operate($19,val,i,$20,$16);
" rm.
if {$8}
*. $20 +. $21 if $22 %. $22 fi *. $23 +. $24
fi
done
if {!$8}
*. $20 +. $21 if $22 %. $22 fi *. $23 +. $24
fi
if {$2}
if {$1==0} srgb2rgb
elif {$1==1} cmy2rgb
elif {$1==2} hsv82rgb
elif {$1==3} hsl82rgb
elif {$1==4} hsi82rgb
elif {$1==5} lch82rgb
elif {$1==6} lab82rgb
elif {$1==7} ycbcrglic2rgb
elif {$1==8} yiq82rgb
elif {$1==9} yuv82rgb
elif {$1==10} hcy2rgb
elif {$1==11} xyz82rgb
fi else
if {$1==1} cmyk2rgb
elif {$1==2} hsv2rgb
elif {$1==3} hsl2rgb
elif {$1==4} hsi2rgb
elif {$1==5} lch2rgb
elif {$1==6} lab2rgb
elif {$1==7} ycbcr2rgb
elif {$1==8} yiq2rgb
elif {$1==9} yuv2rgb
elif {$1==10} bayer2rgb 0,0,0
elif {$1==11} xyz2rgb
fi fi
endl a c endl done
fx_self_glitching_cascade_preview :
repeat {max(0,l)}
ac[$>] "-fx_self_glitching_cascade $*",$25
done
#@gui Colour Space Swap : csswap, csswap_preview()
#@gui : To RGB From = choice("RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : Multiply = float(1,-10,10)
#@gui : Add = float(0,-360,360)
#@gui : From RGB To = choice("RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
csswap:
repeat $! l[$>] split_opacity l[0] to_rgb
cs=$1
sc=$4
if {$cs==1} srgb2rgb
elif {$cs==2} cmyk2rgb
elif {$cs==3} cmy2rgb
elif {$cs==4} hsv82rgb
elif {$cs==5} hsv2rgb
elif {$cs==6} hsl82rgb
elif {$cs==7} hsl2rgb
elif {$cs==8} hsi82rgb
elif {$cs==9} hsi2rgb
elif {$cs==10} lch82rgb
elif {$cs==11} lch2rgb
elif {$cs==12} lab82rgb
elif {$cs==13} ycbcr2rgb
elif {$cs==14} ycbcrglic2rgb
elif {$cs==15} yiq82rgb
elif {$cs==16} yiq2rgb
elif {$cs==17} yuv82rgb
elif {$cs==18} yuv2rgb
elif {$cs==19} bayer2rgb 0,0,0
elif {$cs==20} hcy2rgb
elif {$cs==21} xyz82rgb
elif {$cs==22} xyz2rgb
fi
f "(i*$2)+$3"
if {$sc==1} rgb2srgb
elif {$sc==2} rgb2cmyk
elif {$sc==3} rgb2cmy
elif {$sc==4} rgb2hsv8
elif {$sc==5} rgb2hsv
elif {$sc==6} rgb2hsl8
elif {$sc==7} rgb2hsl
elif {$sc==8} rgb2hsi8
elif {$sc==9} rgb2hsi
elif {$sc==10} rgb2lch8
elif {$sc==11} rgb2lch
elif {$sc==12} rgb2lab8
elif {$sc==13} rgb2ycbcr
elif {$sc==14} rgb2ycbcrglic
elif {$sc==15} rgb2yiq8
elif {$sc==16} rgb2yiq
elif {$sc==17} rgb2yuv8
elif {$sc==18} rgb2yuv
elif {$sc==19} rgb2bayer 0
elif {$sc==20} rgb2hcy
elif {$sc==21} rgb2xyz8
elif {$sc==22} rgb2xyz
fi
to_rgb endl a c endl done
csswap_preview :
gui_split_preview "csswap $*",${-3--1}
#@gui JIFF [JPEG] Self-Bomb : fx_jiff_bomb, fx_jiff_bomb_preview()
#@gui : note = note("OI! TRY SMOOTHING THIS!")
#@gui : note = note("<small>Adds JPEG artefacts and then self-bomb-blends. Use grid interpolation with scale factors above 1 to destroy the results even more.</small>")
#@gui : Recompute = button(0)
#@gui : sep = separator()
#@gui : Quality (%) = int(50,1,100)
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh Smoothness = float(0.5,0,10)
#@gui : Contrast Scheme = choice(1,"Arctan","Clip","Power)
#@gui : Mesh Contrast = float(75,0,100)
#@gui : Scale X = float(1,0.05,16)
#@gui : Scale Y = float(1,0.05,16)
#@gui : Interpolation = choice(0,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Normalise = bool(0)
#@gui : Output Mesh = bool(0)
#@gui : sep = separator()
#@gui : Solidify Alpha = bool(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-oriented","Edge-oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Dilation / Erosion = int(0,-20,20)
#@gui : Colorspace = choice(1,"sRGB","Linear RGB")
_fx_jiff_bomb :
repeat $! l[$>]
if $12
+fx_solidify_td ${13-15}
negate. rv blend alpha
fi
ww={w}
hh={h}
r {$7*100}%,{$8*100}%,100%,100%,$9
fx_jpeg_artefacts $1
fx_blend_bomb 0,1,${2-5},0,0,0,${10-11}
r $ww,$hh,100%,100%,$9
endl done
fx_jiff_bomb:
_fx_jiff_bomb ${2--1}
fx_jiff_bomb_preview :
fx_jiff_bomb $*
#@gui Noise [Additive] : fx_noise, fx_noise_preview(0)
#@gui : Amplitude = float(10,0,200)
#@gui : Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
jr_fx_noise :
ac "_fx_noise $1,$2",$3,$4
_jr_fx_noise :
repeat $! l[$>] split_opacity l[0] noise $1,$2 endl a c endl done
jr_fx_noise_preview :
gui_split_preview "jr_fx_noise $*",${-3--1}
#@gui Quick Desaturate : jr_desaturate, jr_desaturate_preview(1)
#@gui : note = note("Generates greyscale images, allowing for different &#40;s&#47;&#41;RGB channel intensities before merging. A smaller counterpart to the 'Black &#38; White' filter intended for generating intensity maps.")
#@gui : Colour Space = choice("RGB","sRGB")
#@gui : Channel 1 = float(1,0,3)
#@gui : Channel 2 = float(1,0,3)
#@gui : Channel 3 = float(1,0,3)
#@gui : Normalise = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
jr_desaturate :
repeat $! l[$>] split_opacity l[0] to_rgb if $1 srgb2rgb fi
f "avg(i0*$2,i1*$3,i2*$4)" if $5 n 0,255 fi c 0,255
endl a c endl done
jr_desaturate_preview :
gui_split_preview "jr_desaturate $*",${-3--1}
#@cli rgb2ycbcrglic : convert from rgb to ycbcrglic
rgb2ycbcrglic :
split_opacity l[0] to_rgb
f "R=i0;G=i1;B=i2;
[0.2988390*R+0.5868110*G+0.1143500*B,-0.168736*R-0.3312640*G+0.5000000*B+127.5,0.5000000*R-0.4186880*G-0.0813120*B+127.5]"
endl a c
#@cli ycbcrglic2rgb : convert from ycbcrglic to rgb
ycbcrglic2rgb :
split_opacity l[0] to_rgb
f "Y=i0;Cb=i1-127.5;Cr=i2-127.5;
[Y+1.402*Cr,Y-0.344136*Cb-0.714136*Cr,Y+1.772000*Cb]"
endl a c
#@gui Sawtoother [CMY(-K)] : sawtoother_cmy_k, sawtoother_cmy_k_preview(1)+
#@gui : note = note("Splits image into CMY or CMYK channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Cyan</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Magenta</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Yellow</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Key</b>")
#@gui : Include Channel = bool(0)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_cmy_k :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $26,$27
if $19 rgb2cmyk. else rgb2cmy. fi s. c
index=0
if {$19} index=-1 if {$23} b[-1] $22% +[-1] $25 %[-1] {256/$20} *[-1] $20 %[-1] 256 *[-1] $24 +[-1] $21 else *[-1] $20 +[-1] {$21*$20} b[-1] $22% fi fi
if {$4} b[{$index-3}] $3% +[{$index-3}] $6 %[{$index-3}] {256/$1} *[{$index-3}] $1 %[{$index-3}] 256 *[{$index-3}] $5 +[{$index-3}] $2 else *[{$index-3}] $1 +[{$index-3}] {$2*$1} b[{$index-3}] $3% fi
if {$10} b[{$index-2}] $9% +[{$index-2}] $12 %[{$index-2}] {256/$7} *[{$index-2}] $7 %[{$index-2}] 256 *[{$index-2}] $11 +[{$index-2}] $8 else *[{$index-2}] $7 +[{$index-2}] {$8*$7} b[{$index-2}] $9% fi
if {$16} b[{$index-1}] $15% +[{$index-1}] $18 %[{$index-1}] {256/$13} *[{$index-1}] $13 %[{$index-1}] 256 *[{$index-1}] $17 +[{$index-1}] $14 else *[{$index-1}] $13 +[{$index-1}] {$14*$13} b[{$index-1}] $15% fi
c 0,255 a[{$index-3}--1] c
if $19 cmyk2rgb. else cmy2rgb. fi
fx_end_mix $26
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_cmy_k_preview :
sawtoother_cmy_k $*
#@gui Sawtoother [HSX] : sawtoother_hsx, sawtoother_hsx_preview(1)+
#@gui : note = note("Splits image into HSV, HSI or HSL channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-180,180)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-180,180)
#@gui : sep = separator(), note = note("<b>Saturation</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-1,1)
#@gui : sep = separator(), note = note("<b>Value&#47;Intensity&#47;Lightness</b>")
#@gui : Channel = choice("Value","Intensity","Lightness)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-1,1)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_hsx :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $20,$21
if {$13==1} rgb2hsi. elif {$13==2} rgb2hsl. else rgb2hsv. fi
s. c
if {$4} +[-3] $6 %[-3] {360/($1)^2} *[-3] $1 %[-3] 360 *[-3] {$5*$1} +[-3] {$2} else *[-3] $1 +[-3] {$2*$1} fi %[-3] 360
if {$10} b[-2] $9% +[-2] $12 %[-2] {(1+(1/255))/$7} *[-2] {$7} %[-2] {(1+(1/255))} *[-2] $11 +[-2] {$8} else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$17} b[-1] $16% +[-1] $19 %[-1] {(1+(1/255))/$14} *[-1] {$14} %[-1] {(1+(1/255))} *[-1] $18 +[-1] {$15} else *[-1] $14 +[-1] {$15*$14} b[-1] $16% fi
c[-2,-1] 0,1 a[-3--1] c
if {$13==1} hsi2rgb. elif {$13==2} hsl2rgb. else hsv2rgb. fi
if $3 l[-1] +b $3% rgb2hsv[0,1] f.. "[i0(#1),i1,i2]" rm. hsv2rgb endl fi
fx_end_mix $20
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_hsx_preview :
gui_split_preview "sawtoother_hsx $*",$-1
#@gui Sawtoother [Lab8] : sawtoother_lab8, sawtoother_lab8_preview(1)+
#@gui : note = note("Splits image into Lab8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance a</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance b</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_lab8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lab8. s. c
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c lab82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_lab8_preview :
sawtoother_lab8 $*
#@cli jr_deform : _amplitude>=0,_interpolation,_matrix_density[%]>=0,_matrix_interpolation,_mode,-100<=_character<=100,_boundary
#@cli : Apply random smooth deformation on selected images. An upgrade to the existing deform command.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'matrix_interpolation' can be { 0=linear | 1=bicubic }.
#@cli : 'mode' can be { 0=noise | 1=spread_noise }.
#@cli : 'boundary' can be  { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
jr_deform : skip ${1=10},${2=1},${3=2%},${4=1},${5=0},${6=0},${7=1}
e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
v - repeat $! l[$>]
S={${"is_percent $3"}?max(w,h)*$3:$3}
P={$4==0?3:5}
if {$5==1} +r. $3,$3,1,4 spread. {max(w,h)*($6+100)/200},{max(w,h)*($6+100)/200} else
$3,$3,1,4 noise. $1
fi
ac. "adjust_colors 0,$6,0,0,0",rgba r. ..,..,1,4,$P warp.. .,1,$2,$7 rm.
endl done v +
#@gui Sawtoother [LCH8] : sawtoother_lch8, sawtoother_lch8_preview(1)+
#@gui : note = note("Splits image into LCH8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chroma</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_lch8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lch8.
s. c
if {$4} +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/($13)^2} *[-1] $13 %[-1] 256 *[-1] {$17*$13} +[-1] {$14} else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi %[-1] 256
a[-3--1] c c. 0,255 lch82rgb.
if $3 l[-1] +b $3% rgb2lch8[0,1] f.. "[i0,i1,i2(#1)]" rm. lch82rgb endl fi
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_lch8_preview :
sawtoother_lch8 $*
#@gui Sawtoother [RGB] : sawtoother_rgb, sawtoother_rgb_preview(1)+
#@gui : note = note("Splits image into RGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_rgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c. 0,255
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_rgb_preview :
gui_split_preview "sawtoother_rgb $*",$-1
#@gui Sawtoother [sRGB] : sawtoother_srgb, sawtoother_srgb_preview(1)+
#@gui : note = note("Splits image into sRGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_srgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2srgb. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 srgb2rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_srgb_preview :
sawtoother_srgb $*
#@gui Sawtoother [XYZ8] : sawtoother_xyz8, sawtoother_xyz8_preview(1)+
#@gui : note = note("Splits image into XYZ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>X</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Y</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Z</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_xyz8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2xyz8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 xyz82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_xyz8_preview :
gui_split_preview "sawtoother_xyz8 $*",$-1
#@gui Sawtoother [YCbCr] : sawtoother_ycbcr, sawtoother_ycbcr_preview(1)+
#@gui : note = note("Splits image into YCbCr channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Red Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_ycbcr :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2ycbcr. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 ycbcr2rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_ycbcr_preview :
gui_split_preview "sawtoother_ycbcr $*",$-1
#@gui Sawtoother [YCbCrGLIC] : sawtoother_ycbcrglic, sawtoother_ycbcrglic_preview(1)+
#@gui : note = note("Splits image into YCbCr channels &#40;<a href="https://web.archive.org/web/20180906062556/https://github.com/GlitchCodec/GLIC/blob/master/colorspaces.pde">using GLIC version</a>&#41; and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Red Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_ycbcrglic :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2ycbcr. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yuv82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_ycbcrglic_preview :
gui_split_preview "sawtoother_ycbcrglic $*",$-1
#@gui Sawtoother [YIQ8] : sawtoother_yiq8, sawtoother_yiq8_preview(1)+
#@gui : note = note("Splits image into YIQ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_yiq8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yiq8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yiq82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_yiq8_preview :
gui_split_preview "sawtoother_yiq8 $*",$-1
#@gui Sawtoother [YUV8] : sawtoother_yuv8, sawtoother_yuv8_preview(1)+
#@gui : note = note("Splits image into YUV8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_yuv8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yuv8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yuv82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_yuv8_preview :
gui_split_preview "sawtoother_yuv8 $*",$-1
#@gui Shredder : fx_shredder, fx_shredder_preview(0)
#@gui : note = note("<small>Re-fills an image with its own values but makes random jumps in the relative positions where the lookup for the values takes place. Can be channel-independent.</small>")
#@gui : Recompute = button(0)
#@gui : Randomised Start = bool(1)
#@gui : Channels = choice("Correlated","RGB","sRGB","HSV","HSI","HSL","CMY","CMYK","YCbCr","Lab","LCH","XYZ","HCY")
#@gui : Alpha = bool(1)
#@gui : X Chance = float(0.15,0,1)
#@gui : Y Chance = float(0.15,0,1)
#@gui : X Strength = float(0.5,0,1)
#@gui : Y Strength = float(0.5,0,1)
#@gui : Mirror = choice("None","X","Y","XY")
#@gui : Rotate = choice("None,"90 clockwise","180","90 anticlockwise")
_shredder :
repeat $! l[$>]
chancex=(1-$4^7)
chancey=(1-$5^7)
strengthx=($6^4)
strengthy=($7^4)
to_rgba split_opacity to_rgb.. to_gray.
l[0]
if {$2==2}
rgb2srgb
elif {$2==3}
rgb2hsv8
elif {$2==4}
rgb2hsi8
elif {$2==5}
rgb2hsl8
elif {$2==6}
rgb2cmy
elif {$2==7}
rgb2cmyk
elif {$2==8}
rgb2ycbcr
elif {$2==9}
rgb2lab8
elif {$2==10}
rgb2lch8
elif {$2==11}
rgb2xyz8
elif {$2==12}
rgb2hcy
fi
endl
if $3 a c fi
l[0]
if {$8==1}
mirror[0] x
elif {$8==2}
mirror[0] y
elif {$8==3}
mirror[0] xy
fi
if $9
rotate[0] {$9*90},0
fi
[0]
f[0] "begin(switchx=0;switchy=0;(!$1)?(col=0;row=0):(col=u*w^2;row=u*h^2));
u>="$chancex"?switchx=1;
u>="$chancey"?switchy=1;
switchx==1?col=(u*w^2);
switchy==1?row=(u*h^2);
switchx=0;
switchy=0;
(!$2)?J(#-1,"$strengthx"*col,"$strengthy"*row,0,0,2)
:j(#-1,"$strengthx"*col,"$strengthy"*row,0,0,0,2)"
rm[1]
if $9
rotate[0] {-$9*90},0
fi
if {$8==1}
mirror[0] x
elif {$8==2}
mirror[0] y
elif {$8==3}
mirror[0] xy
fi
if {$2>=1}
s[0] c
if {$3} a[^-1] c else a c fi
l[0]
if {$2==2}
srgb2rgb
elif {$2==3}
hsv82rgb
elif {$2==4}
hsi82rgb
elif {$2==5}
hsl82rgb
elif {$2==6}
cmy2rgb
elif {$2==7}
cmyk2rgb
elif {$2==8}
ycbcr2rgb
elif {$2==9}
lab82rgb
elif {$2==10}
lch82rgb
elif {$2==11}
xyz82rgb
elif {$2==12}
hcy2rgb
fi
endl
fi
endl
a c
endl done
fx_shredder :
_shredder ${2--1}
fx_shredder_preview :
fx_shredder $*
#@gui _
#@gui <i>Details</i>
#@gui 8-Bit Planes : fx_bitplane8, fx_bitplane8_preview(1)
#@gui : Mode = choice("Decompose","Recompose")
#@gui : Split Mode = choice(1,"Z layers","Separate images")
#@gui : Scale Mode = choice("True","1","255")
#@gui : Alpha = bool(0)
fx_bitplane8 :
if $1
if {!$2} s z fi
repeat {int($!/8)} l[$>-{$>+7}]
repeat 8
iter=$>
l[$>]
if {$3==0}
/ {2^$iter} cut 0,1 round 0,1 * {2^$iter}
elif {$3==1}
cut 0,1 round 0,1 * {2^$iter}
elif {$3==2}
/ 255 cut 0,1 round 0,1 * {2^$iter}
fi
endl done
+
endl done
else
repeat 8
[0]
&[-1] {2^$>}
if {$3==1}
/[-1] {2^$>}
elif {$3==2}
/[-1] {2^$>/255}
fi
if {!$2} a[^0] z fi
done
rm[0]
fi
fx_bitplane8_preview :
fx_bitplane8 $*
#@gui Broken Texture Afre : fx_texture_afre_broken, fx_texture_afre_broken_preview(0)
#@gui : note = note("This shouldn't have happened.")
#@gui : sep = separator()
#@gui : P1 = float(1,0,10)
#@gui : P2 = float(10,0,100)
#@gui : Difference = bool(0)
fx_texture_afre_broken:
repeat $! l[$>]
n 0,255
if $3 +l fi
+l
+l
if $1 gradient_orientation 2 n 0,1 + y50_afre 0 gradient_norm
else gradient_norm fi
b 1,1,1
endl
*. {255*$2/iM} +
n 0,255
endl
+l.. n 0,1 f gauss(i-.5) n 0,1 endl
blend_fade[0,1] . k[0]
if $3 blend difference fi
endl done
fx_texture_afre_broken_preview :
fx_texture_afre_broken $*
#@gui Butterworth Bandpass : fx_butterworth_bp, fx_butterworth_bp_preview(0)
#@gui : note = note("Lowpass and highpass zero-phase Butterworth filters.")
#@gui : sep = separator()
#@gui : LP Frequency Power = float(3,0,16)
#@gui : LP Order Cube Root = float(2,0,4)
#@gui : HP Frequency Power = float(4,0,16)
#@gui : HP Order Cube Root = float(2,0,4)
#@gui : Colour Space = choice("RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : Alpha = bool(0)
#@gui : Absolute = bool(1)
#@gui : Makeup Gain = bool(1)
_butterworth_bp :
v -
100%,100%,100% f. "scale=max(w,h,d);vx=(x-w/2)/scale;vy=(y-h/2)/scale;vz=(z-d/2)/scale;rad=(vx^2+vy^2+vz^2)^0.5;func=(1/((1+((rad/(2^$1))*scale*log2(scale))^($2^3))^0.5))*(1/((1+(((rad/(2^$3)*scale*log2(scale))^($4^3))^-1))^0.5));func"
shift. {int(w/2)},{int(h/2)},{int(d/2)},0,2 *. 2
fft.. *... . *[-2,-1] ifft rm[-1]
v +
fx_butterworth_bp:
repeat $! l[$>]
if {!$6} split_opacity fi
l[0]
gain={iM} csswap 0,1,0,$5
_butterworth_bp ${1-4}
csswap $5,1,0,0 if $7 abs fi if $8 * {$gain/iM} fi
endl
if {!$6} a c fi
endl done
fx_butterworth_bp_preview :
fx_butterworth_bp $*
#@gui Faux-QAM Glitch : fx_qam_glitch, fx_qam_glitch_preview(0)
#@gui : note = note("Tries to emulate the effect of a faulty Quadrature Amplitude Modulator.")
#@gui : sep = separator()
#@gui : note = note("<b>Channel Modulation</b>")
#@gui : 1. Amplitude = float(2,0,10)
#@gui : 2. Period = float(20,0,100)
#@gui : 3. Phase Offset = float(0,-180,180)
#@gui : 4. Angle = float(0,-180,180)
#@gui : 5. Amplitude Offset = float(1,-10,10)
#@gui : 6. Wave Offset = float(127.5,0,255)
#@gui : 7. Colour Space = choice("RGBA","sRGBA","CMYA","HSVA8","HSVA","HSLA8","HSLA","HSIA8","HSIA","LCHA8","LCHA","LabA8","LabA","YCbCrA","YCbCrAGLIC","YIQA8","YIQA","YUVA8","YUVA","BayerA","HCYA","XYZA8","XYZA")
#@gui : 8. Channel 0 = bool(1)
#@gui : 9. Channel 1 = bool(1)
#@gui : 10. Channel 2 = bool(1)
#@gui : 11. Alpha = bool(0)
#@gui : 12. Glitch Negation = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Scanlines</b>")
#@gui : 13. Amplitude = float(20,0,255)
#@gui : 14. Bandwidth = float(5,0,20)
#@gui : 15. Shape = choice(0,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : 16. Angle Offset = float(0,-180,180)
#@gui : 17. Offset = float(0,0,500)
#@gui : 18. Blur = float(2,0,10)
#@gui : 19. Amplitude Modulation = float(0.6,0,1)
#@gui : 20. Phase Modulation = float(0.05,0,1)
#@gui : sep = separator(), 21-23. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
_scanlines : skip ${1=60},${2=2},${3=0},${4=0},${5=0}
v -
theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
repeat $! l[$>]
100%,100%,1,1,"x" -. {w/2-$5} 100%,100%,1,1,'y'
-. {h/2-$5} *.. $S *. $C +[-2,-1]
_ripple$3. $1,$2
n. {-$1},$1
+ cut 0,255
endl done v +
_qam_glitch :
100%,100%,1,1 _scanlines. ${7-9},{(90+$4+$10)},$11 b. $12
*. 2 -. $7
f.. "line=i(#-1\,x\,y\,z\,0);ang=(90+$4)*pi/180;(i+(((1+line*5*$13/255)*($1*i/255+$5))*(i*sin(((x-w/2)*cos(ang)+(y-h/2)*sin(ang))/$2+($3+(line*$2*$14/10)/255*360)*pi/180))+($6*($1)-($1*i/2)))-i/255)%255"
rm.
fx_qam_glitch :
repeat $! l[$>]
to_rgba
if {$7>=2} cs={$7+1} else cs=$7 fi
if $12 negate fi
csswap 0,1,0,$cs
counter=0
if $8 sh[0] 0 fi
if $9 sh[0] 1 fi
if $10 sh[0] 2 fi
if $11 sh[0] 3 fi
repeat {$!-1} l[{$>+1}]
_qam_glitch ${1-6},${13-20}
endl done
k[0]
csswap $cs,1,0,0
if $12 negate fi
endl done
fx_qam_glitch_preview :
gui_split_preview "fx_qam_glitch $*",${-3--1}
#@gui Pseudo-ECB (Electronic Code Book Algorithm) : pseudo_ecb, _pseudo_ecb_preview(0)
#@gui : note = note("This filter is inspired by one of the glitch plugin for Paint.NET This doesn't actually emulate how the codebook encryption algorithm actually work, but it is inspired from it.  This filter uses bomb blending mode which involves RGBA Transfer Function Mesh. See Mesh Blend filter for a link. \n\n <u>Note that the filter works best on images with large patches of single colors.</u> ")
#@gui : sep = separator()
#@gui : note = note("<b>Color Space Choice</b> \n\n <i>Keep in mind that you may not necessarily get what you imagine. Just treat those as theme. </i>")
#@gui : Colour Space = choice("RGB", "CMY", "CMYK", "HSI", "HSL", "HSV", "LAB", "LCH", "YCbCr", "YCbCr-Glic", "YUV", "YIQ", "XYZ", "Bayer")
#@gui : sep = separator()
#@gui : note = note("<b>Final Color Processing</b> \n\n <i>This refers to the how the colors are going to be processed. If you find that there's too little difference in hues or chroma or luminosity in local areas, this should be on. Sometimes, the result are better without the final processing.</i>")
#@gui : Equalize Filter = bool(0)
#@gui : Psuedo-Coloring = bool(1)
#@gui : Tonality Blend = choice(20,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Tonality Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Pattern Key Generator</b>")
#@gui : Double Gradient? = bool(1)
#@gui : Length of Gradient#1 = float(5,0,32)
#@gui : ECB Gradient#1 Angle = float(0,0,360)
#@gui : ECB Inversion#1 = bool(0)
#@gui : Length of Gradient#2 = float(5,0,32)
#@gui : ECB Gradient#2 Angle = float(90,0,360)
#@gui : ECB Inversion#2 = bool(0)
#@gui : Gradient Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Gradient Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Sharpen Filtering</b>")
#@gui : Sharpening Noise Processing = float(15,0,200)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Image Processing</b>")
#@gui : Transfer Mesh Size for Image (Squared) = int(256,2,256)
#@gui : Image Mesh Contrast = int(75,25,100)
#@gui : Transfer Mesh Size for Gradient (Squared) = int(16,2,256)
#@gui : Gradient Mesh Contrast = int(100,25,100)
#@gui : Double Encryption Effect = bool(1)
#@gui : Inner Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Inner Blend Opacity = float(1,0,1)
#@gui : Outer Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Outer Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Self-Image Post-Processing</b> \n\n <i>This invokes a self-blending operation after the main psuedo-ecb has been generated with different blend mode.</i>")
#@gui : Activate Self-Image Post-Processing = bool(1)
#@gui : Equalize ECB Processing = bool(0)
#@gui : Psuedo-Coloring = bool(1)
#@gui : Self-Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Self-Blend Opacity = float(1,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>      Latest update: <i>2018/12/30</i>.</small>")
pseudo_ecb:
if {$1==1} rgb2cmy
elif {$1==2} rgb2cmyk
elif {$1==3} rgb2hsi8
elif {$1==4} rgb2hsl8
elif {$1==5} rgb2hsv8
elif {$1==6} rgb2lab8
elif {$1==7} rgb2lch8
elif {$1==8} rgb2ycbcr
elif {$1==9} rgb2ycbcrglic
elif {$1==10} rgb2yuv8
elif {$1==11} rgb2yiq8
elif {$1==12} rgb2xyz8
elif {$1==13} rgb2bayer 0
fi
repeat $! l[$>]
repeat {$20+1}
pseudo_ecb_generate ${2-19},${21-29}
done
endl
if {$1==1} cmy2rgb
elif {$1==2} cmyk2rgb
elif {$1==3} hsi82rgb
elif {$1==4} hsl82rgb
elif {$1==5} hsv82rgb
elif {$1==6} lab82rgb
elif {$1==7} lch82rgb
elif {$1==8} ycbcr2rgb
elif {$1==9} ycbcrglic2rgb
elif {$1==10} yuv82rgb
elif {$1==11} yiq82rgb
elif {$1==12} xyz82rgb
elif {$1==13} rgb2bayer 0,0,0
fi
done
pseudo_ecb_generate:
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
+ac "ecb_gradient_base[0] $6,$7,$8",rgb
if {$2==1} _pseudo_c[1] fi
local[1]
if {$5==1} +ac "ecb_gradient_base[0] $9,$10,$11",rgb
_pseudo_c[1]
blend ${_mode{$12+1}},$13 if {$1==1} equalize fi fi
endlocal
local[0]
sharpen $14
if {$2==1} +_pseudo_c[0]
elif {$2==1} [0] fi
+fx_blend_bomb[0] 0,1,$15,$15,0,0,$16,0,0,0,1,0
blend ${_mode{$19+1}},$20
endlocal
fx_blend_bomb[1] 0,1,$17,$17,0,0,$18,0,0,0,0,0
if {$1==1} equalize[1] fi
blend ${_mode{$21+1}},$22
if {$1==1} +equalize blend ${_mode{$3+1}},$4 fi
if {$1==0} [0] blend ${_mode{$3+1}},$4 fi
if {$23==1} [0] if {$24==1} equalize[1] fi if {$25==1} _pseudo_c[1] fi blend ${_mode{$26+1}},$27
fi
ecb_gradient_base:
f "ang=pi*$2/180;G=x*cos(ang)+y*sin(ang);G%$1" n 0,255
if {$3==1} mul -1 abs fi
_pseudo_c : v - if {s!=1} to_gray. fi {max(1,round(iM,1,1))},1,1,3,u(255) round. map.. . rm.  v +
_pseudo_ecb_preview :
pseudo_ecb $*
#@gui Row Shifter : fx_row_shift, fx_row_shift_preview(0)
#@gui : note = note("Shifts rows.")
#@gui : sep = separator()
#@gui : Order = choice("X then Y","Simultaneous","Y then X")
#@gui : X Shift = float(0,-5,5)
#@gui : X Centre = float(0.5,0,1)
#@gui : Y Shift = float(0,-5,5)
#@gui : Y Centre = float(0.5,0,1)
#@gui : Interpolation = choice(3,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Invert Shifts = bool(0)
fx_row_shift :
repeat $! l[$>]
inv={($7*-2)+1}
opt={int(($1-1)*$inv)}
if {$opt==-1}
f "j((y-h*$3)*$2*"$inv",0,0,0,$6,2)"
f "j(0,(x-w*$5)*$4*"$inv",0,0,$6,2)"
elif {$opt==1}
f "j(0,(x-w*$5)*$4*"$inv",0,0,$6,2)"
f "j((y-h*$3)*$2*"$inv",0,0,0,$6,2)"
else
if {$inv==1}
f "j((y-h*$3)*$2*"$inv",(x-w*$5)*$4*"$inv",0,0,$6,2)"
elif {$inv==-1}
f "j((y-h*$3)*$2*"$inv",(x-w*$5)*$4*"$inv",0,0,$6,2)"
fi
fi
endl done
fx_row_shift_preview :
fx_row_shift $*
#@gui Superstreak: fx_superstreak, fx_superstreak_preview(0)
#@gui : note = note("This filter doesn't work very well but here it is anyway.")
#@gui : sep = separator()
#@gui : 1. Iterations = int(10,1,20)
#@gui : 2. Propagation = choice(3,"Backward","Forward","Bidirectional [Sharp]","Bidirectional [Smooth]")
_superstreak :
repeat $! l[$>]
to_rgba
if {!$4} T,R,G,B,A=0 else T,R,G,B,A=${1-5} fi +select_color $T,$R,$G,$B,$A
if {$8==3} srgb2rgb.. fi
f.. "
const step = max(1,$6%*min(w,h));
const angle = $7*pi/180;
const dx = step*cos(angle);
const dy = step*sin(angle);
if (!i(#-1),I,
ixf = xf = x; iyf = yf = y; lf = 0; if ($8>=1, while (i(#-1,ixf=round(xf),iyf=round(yf)), ++lf; xf-=dx; yf-=dy));
ixb = xb = x; iyb = yb = y; lb = 0; if ($8!=1, while (i(#-1,ixb=round(xb),iyb=round(yb)), ++lb; xb+=dx; yb+=dy));
$8==0?I(ixb,iyb):
$8==1?I(ixf,iyf):
$8==2?(lf<lb?I(ixf,iyf):I(ixb,iyb)):
(lb*lb*I(ixf,iyf) + lf*lf*I(ixb,iyb))/(lb^2+lf^2);
)"
if {$8==3} rgb2srgb.. fi
rm.
endl done
fx_superstreak :
repeat $! l[$>]
repeat $1
a={u(0,512)}
b={round(u(0,255))}
c={round(u(0,255))}
d={round(u(0,255))}
e={round(u(0,255))}
f={u(10,30)}
g={u(0,360)}
_superstreak {$a},{$b},{$c},{$d},{$e},{$f},{$g},$2
done
endl done
fx_superstreak_preview :
fx_superstreak $*
#@gui _
#@gui Mesh Blend : fx_mesh_blend, fx_mesh_blend_preview(1)
#@gui : note = note("Universal blending algorithm. Resizes an RGB&#40;A&#41; image to a 256x256 image and uses it as an RGBA LUT 'transfer function mesh' to blend two other images together. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : sep = separator(), note = note("<small>[0] is bottom layer, [1] is top layer, [2] is mesh. Mesh origin is at bottom-left. Plugin GUI preview does not accurately show mesh.</small>")
#@gui : Process As = choice(0,"Three-by-three","Self-mesh and self-blend for each layer")
#@gui : Resize Interpolation = choice(3,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Reverse Blending Layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Blend Alpha Channels = bool(0)
#@gui : Keep Mesh = bool(0)
_fx_mesh_blend :
r. 256,256,100%,100%,$1
if $4 to_rgba else to_rgb fi
if $2 rv[0,1] fi
f[$3] "i(#2,i(#0),256-i(#1))"
if {!$5} rm[2] fi
if $3 rm[0] else rm[1] fi
fx_mesh_blend :
if {$1==0} repeat {int($!/3)} l[$>-{$>+2}] rv _fx_mesh_blend ${2-6} endl done
elif {$1==1} repeat $! l[$>] [0]x2 _fx_mesh_blend ${2-6} endl done fi
fx_mesh_blend_preview :
fx_mesh_blend $*
#@gui <i>Rendering</i>
#@gui Crazy Texture : fx_crazy_texture, fx_crazy_texture_preview(1)
#@gui : note = note("Generates black and white textures from deformed edge offsets around Poisson-disk noise.")
#@gui : 1. Recompute = button()
#@gui : sep = separator(), note = note("Poisson-Disk Noise")
#@gui : 2. Radius = float(75,1,1000)
#@gui : 3. Max Sampling Attempts = int(30,1,200)
#@gui : sep = separator(), note = note("Edge Offsets")
#@gui : 4. Smoothness = float(0,0,10)
#@gui : 5. Threshold = float(15,0,50)
#@gui : 6. Scale = int(6,0,32)
#@gui : 7. Thickness = int(3,0,16)
#@gui : 8. Negative Colors = bool(0)
#@gui : sep = separator(), note = note("Deform 1")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;coarse&#41;</small>")
#@gui : 9. Strength = float(15,0,30)
#@gui : 10. Interpolation = choice("none","bilinear","bicubic")
#@gui : 11. Matrix Density &#40;&#37;&#41; = float(1,1,100)
#@gui : 12. Matrix Interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : 13. Matrix Contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("Deform 2")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;fine&#41;</small>")
#@gui : 14. Strength = float(1.5,0,30)
#@gui : 15. Interpolation = choice("none","bilinear","bicubic")
#@gui : 16. Matrix Density &#40;&#37;&#41; = float(1,1,100)
#@gui : 17. Matrix Interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : 18. Matrix Contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("This can slow things down a lot if both deform strengths are high!")
#@gui : 19. Accurate Boundaries = bool(1)
#@gui : 20. Crop Strength = float(1,0,1)
_crazy_texture :
to_rgb fc 0,0,0
ms1=0 if {$10==1} ms1={0.125*max(w,h)/($2^0.375)} else ms1=$11 fi
ms2=0 if {$15==1} ms2={0.625*max(w,h)/($2^0.25)} else ms2=$16 fi
CF={$8*$13*$19}
if {$18} expand {$CF} fi
noise_poissondisk $1,$2
fx_edge_offsets ${3-7}
jr_deform $8,$9,$ms1,$11,$12
jr_deform $13,$14,$ms2,$16,$17
if {$18} shrink {$CF} fi
fx_crazy_texture:
_crazy_texture ${2-20}
fx_crazy_texture_preview :
fx_crazy_texture $*
#@gui CubeHelix : fx_cubehelix, fx_cubehelix_preview(1)
#@gui : note = note("<small>Implements and extends <a href="https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/">the CubeHelix family of colour schemes</a>, allowing for interpolation between two colours as well as scaling the helix dimensions for each individual channel based on those colours.</small>")
#@gui : Convert to Grayscale = bool(1)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Pre-Normalise = bool(0)
#@gui : Start Colour = color(0,0,0)
#@gui : End Colour = color(255,255,255)
#@gui : Start Hue = float(1,0,3)
#@gui : Rotations = float(-1.5,-20,20)
#@gui : Hue Intensity = float(1,0,5)
#@gui : Gamma Power = float(0,-4,4)
#@gui : sep = separator()
#@gui : Scale Hues = float(-0.5,-2,2)
#@gui : note = note("-2 = hyper, -1 = normal, 0 = flattened, 1 = anti, 2 = hyper-anti)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_cubehelix :
repeat $! l[$>]
if $1 to_gray fi to_rgb abs c 0,255 c $2%,$3% if $4 n 0,255 fi *. {1/255}
f "angle=(2*pi*(($11/3)+1+$12*I));fract=(I^(2^($14^2)));amp=($13*fract*(1-fract)/2);
helix=(amp*[-0.14861*cos(angle[0])+1.78277*sin(angle[0]),-0.29227*cos(angle[1])-0.90649*sin(angle[1]),1.97294*cos(angle[2])]);
scale=([${8-10}]-[${5-7}])/255;
([${5-7}]/255)-$15*(fract*scale+helix)+(1+$15)*(fract+(helix*sign(scale)))*scale"
c 0,1
*. 255
endl done
fx_cubehelix_preview :
gui_split_preview "fx_cubehelix $*",${-3--1}
#@gui Rectexture : fx_rectexture, fx_rectexture(1)
#@gui : note = note("Generates textures from rectangles, difference blending and warping.")
#@gui : Recompute = button()
#@gui : Iterations = int(10,0,500)
#@gui : Colours = choice(3,"Random colours &#40;difference blending&#41;","Random colours &#40;diffblend &#43; sine mapping&#41;","Random colours &#40;diffblend &#43; sinemap &#43; random HSV mixing&#41;","Black and white")
#@gui : Warp Multiplier = float(1,0,5)
#@gui : Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
rectexture:
split_opacity l[0]
if {$2==0}
fill_color[-1] ${-RGB}
elif {$2==1}
fill_color[-1] ${-RGB}
elif {$2==2}
fill_color[-1] ${-RGB}
else
rr={255*round(u)}
fill_color[-1] $rr,$rr,$rr
endif
repeat {max(0,$1)}
+fill_color 0,0,0
if {$2==0}
rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
blend[-1,-2] difference
elif {$2==1}
rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
blend[-1,-2] difference
elif {$2==2}
rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
blend[-1,-2] difference
else
rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,255,255,255
blend[-1,-2] difference
fi
done
if {$4==0}
f={u(0,3)}
elif {$4==1}
f={u(0,2)+1}
else
f={($4)-2}
fi
fx_warp_by_intensity {$3*(u(2)-1)},{$3*(u(2)-1)},{w*$3*(u(2)-1)},{h*$3*(u(2)-1)},0,0,{$f},0,0
if {$2==1}
normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
fi
if {$2==2}
normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
mults=u(0,2.5)
multv=u(0,2.5)
fx_mix_hsv {(2^u(0,2.5))-1},{u(-180,180)},0,{(2^$mults)-1},{max(0,2-(2^$mults))*u(-1,1)},0,{(2^$multv)-1},{max(0,2-(2^$multv))*u(-1,1)},0,0,2,0
fi
endl a c
fx_rectexture:
repeat $! l[$>]
ac "rectexture ${2-5}",$-2,$-1
endl done
#@gui Satellite : fx_satellite, fx_satellite_preview(1)
#@gui : note = note("Converts to grayscale and uses <a href="https://www.ospo.noaa.gov/Organization/FAQ/enhancements.html">image enhancement colour schemes</a> which are used in NOAA satellite weather products.")
#@gui : Enhancement = choice("Aviation","Dvorak","Funktop","JSL2","Shortwave IR2 &#40;Standard and Tropical&#41;","Shortwave IR2 &#40;Fire&#41;","Shortwave IR2 &#40;Summer Fire&#41;","Shortwave IR2 &#40;Winter Fire&#41;","Rainbow &#40;Old&#41;","Rainbow &#40;New&#41;","Water Vapour","Water Vapour &#40;Blue&#41;","IR Window","IR Window &#40;blue&#41")
#@gui : Gamma Power = float(0,-5,5)
#@gui : Lower Threshold = float(0,0,100)
#@gui : Higher Threshold = float(100,0,100)
#@gui : Normalise = bool(1)
#@gui : To sRGB = bool(0)
fx_satellite :
repeat $! l[$>]
to_gray
f "255*((i/255)^(2^(2^($2^2))))"
c $3%,$4% if $5 n 0,255 fi
to_rgb
if {$1==0}
f "(i<=48)?[0,0,0]:
(i<=52)?[8,8,8]:
(i<=56)?[20,20,20]:
(i<=60)?[28,28,28]:
(i<=64)?[40,40,40]:
(i<=68)?[52,52,52]:
(i<=72)?[60,60,60]:
(i<=76)?[72,72,72]:
(i<=80)?[84,84,84]:
(i<=84)?[92,92,92]:
(i<=88)?[104,104,104]:
(i<=92)?[112,112,112]:
(i<=96)?[124,124,124]:
(i<=100)?[136,136,136]:
(i<=104)?[144,144,144]:
(i<=108)?[156,156,156]:
(i<=112)?[168,168,168]:
(i<=116)?[176,176,176]:
(i<=120)?[188,188,188]:
(i<=124)?[196,196,196]:
(i<=128)?[208,208,208]:
(i<=132)?[220,220,220]:
(i<=136)?[228,228,228]:
(i<=140)?[240,240,240]:
(i<=144)?[252,252,252]:
(i<=148)?[244,156,0]:
(i<=152)?[236,152,0]:
(i<=156)?[228,148,0]:
(i<=160)?[220,144,0]:
(i<=164)?[212,140,0]:
(i<=168)?[208,136,0]:
(i<=172)?[200,132,0]:
(i<=176)?[192,128,0]:
(i<=180)?[184,124,0]:
(i<=184)?[176,120,0]:
(i<=188)?[0,160,160]:
(i<=192)?[0,188,188]:
(i<=196)?[0,220,220]:
(i<=200)?[0,248,248]:
(i<=204)?[0,180,252]:
(i<=208)?[0,160,232]:
(i<=212)?[0,140,216]:
(i<=216)?[0,120,196]:
(i<=220)?[0,0,232]:
(i<=224)?[0,0,248]:
(i<=250)?[88,88,88]:
(i<=256)?[255,255,255]"
elif {$1==1}
f "(i<=59)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=68)?[6+(i-59)*7,6+(i-59)*7,6+(i-59)*7]:
(i<=97)?[75+(i-68)*6.42857,75+(i-68)*6.42857,75+(i-68)*6.42857]:
(i<=175)?[112+(i-97)*1.19481,112+(i-97)*1.19481,112+(i-97)*1.19481]:
(i<=188)?[64+(i-175)*0,64+(i-175)*0,64+(i-175)*0]:
(i<=199)?[112+(i-188)*0,112+(i-188)*0,112+(i-188)*0]:
(i<=209)?[160+(i-199)*0,160+(i-199)*0,160+(i-199)*0]:
(i<=215)?[0+(i-209)*0,0+(i-209)*0,0+(i-209)*0]:
(i<=221)?[255+(i-215)*0,255+(i-215)*0,255+(i-215)*0]:
(i<=226)?[136+(i-221)*0,136+(i-221)*0,136+(i-221)*0]:
(i<=256)?[88+(i-226)*0,88+(i-226)*0,88+(i-226)*0]"
elif {$1==2}
f "(i<=44)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=152)?[20+(i-44)*1.83178,20+(i-44)*1.83178,20+(i-44)*1.83178]:
(i<=184)?[0+(i-152)*0,100+(i-152)*4.77419,100+(i-152)*4.77419]:
(i<=204)?[120+(i-184)*6.94737,0+(i-184)*13.2632,0+(i-184)*0]:
(i<=216)?[0+(i-204)*0,0+(i-204)*0,84+(i-204)*15.2727]:
(i<=224)?[80+(i-216)*8.57143,80+(i-216)*8.57143,252+(i-216)*0]:
(i<=237)?[0+(i-224)*21,252+(i-224)*0,0+(i-224)*21]:
(i<=253)?[252+(i-237)*0,252+(i-237)*0,252+(i-237)*0]:
(i<=256)?[255+(i-253)*0,255+(i-253)*0,255+(i-253)*0]"
elif {$1==3}
f "(i<=4)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=8)?[28+(i-4)*0,0+(i-4)*0,28+(i-4)*0]:
(i<=12)?[60+(i-8)*0,0+(i-8)*0,60+(i-8)*0]:
(i<=16)?[92+(i-12)*0,0+(i-12)*0,92+(i-12)*0]:
(i<=20)?[124+(i-16)*0,0+(i-16)*0,124+(i-16)*0]:
(i<=24)?[156+(i-20)*0,0+(i-20)*0,156+(i-20)*0]:
(i<=28)?[188+(i-24)*0,0+(i-24)*0,188+(i-24)*0]:
(i<=32)?[220+(i-28)*0,0+(i-28)*0,220+(i-28)*0]:
(i<=36)?[252+(i-32)*0,0+(i-32)*0,252+(i-32)*0]:
(i<=40)?[236+(i-36)*0,0+(i-36)*0,224+(i-36)*0]:
(i<=44)?[220+(i-40)*0,0+(i-40)*0,196+(i-40)*0]:
(i<=48)?[208+(i-44)*0,0+(i-44)*0,168+(i-44)*0]:
(i<=52)?[192+(i-48)*0,0+(i-48)*0,140+(i-48)*0]:
(i<=56)?[180+(i-52)*0,0+(i-52)*0,112+(i-52)*0]:
(i<=60)?[164+(i-56)*0,0+(i-56)*0,84+(i-56)*0]:
(i<=64)?[152+(i-60)*0,0+(i-60)*0,56+(i-60)*0]:
(i<=68)?[136+(i-64)*0,0+(i-64)*0,28+(i-64)*0]:
(i<=72)?[124+(i-68)*0,0+(i-68)*0,0+(i-68)*0]:
(i<=76)?[136+(i-72)*0,28+(i-72)*0,0+(i-72)*0]:
(i<=80)?[152+(i-76)*0,56+(i-76)*0,0+(i-76)*0]:
(i<=84)?[164+(i-80)*0,84+(i-80)*0,0+(i-80)*0]:
(i<=88)?[180+(i-84)*0,112+(i-84)*0,0+(i-84)*0]:
(i<=92)?[192+(i-88)*0,140+(i-88)*0,0+(i-88)*0]:
(i<=96)?[208+(i-92)*0,168+(i-92)*0,0+(i-92)*0]:
(i<=100)?[220+(i-96)*0,196+(i-96)*0,0+(i-96)*0]:
(i<=104)?[236+(i-100)*0,224+(i-100)*0,0+(i-100)*0]:
(i<=108)?[252+(i-104)*0,252+(i-104)*0,0+(i-104)*0]:
(i<=112)?[224+(i-108)*0,236+(i-108)*0,0+(i-108)*0]:
(i<=116)?[196+(i-112)*0,220+(i-112)*0,0+(i-112)*0]:
(i<=132)?[92+(i-116)*0.8,92+(i-116)*0.8,92+(i-116)*0.8]:
(i<=144)?[112+(i-132)*0.727273,112+(i-132)*0.727273,112+(i-132)*0.727273]:
(i<=156)?[128+(i-144)*0.727273,128+(i-144)*0.727273,128+(i-144)*0.727273]:
(i<=168)?[144+(i-156)*0.727273,144+(i-156)*0.727273,144+(i-156)*0.727273]:
(i<=180)?[160+(i-168)*0.727273,160+(i-168)*0.727273,160+(i-168)*0.727273]:
(i<=184)?[176+(i-180)*0,176+(i-180)*0,176+(i-180)*0]:
(i<=188)?[184+(i-184)*0,184+(i-184)*0,184+(i-184)*0]:
(i<=192)?[192+(i-188)*0,192+(i-188)*0,192+(i-188)*0]:
(i<=196)?[200+(i-192)*0,200+(i-192)*0,200+(i-192)*0]:
(i<=200)?[208+(i-196)*0,208+(i-196)*0,208+(i-196)*0]:
(i<=202)?[216+(i-200)*0,216+(i-200)*0,216+(i-200)*0]:
(i<=215)?[0+(i-202)*5,0+(i-202)*5,60+(i-202)*16.25]:
(i<=226)?[71+(i-215)*11.9,71+(i-215)*11.9,255+(i-215)*0]:
(i<=246)?[101+(i-226)*6.36842,0+(i-226)*10.5789,101+(i-226)*6.36842]:
(i<=256)?[0+(i-246)*0,0+(i-246)*0,0+(i-246)*0]"
elif {$1==4}
f "(i<=2)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=26)?[0+(i-2)*0,0+(i-2)*0,235+(i-2)*-10.2174]:
(i<=51)?[0+(i-26)*0,0+(i-26)*0,0+(i-26)*0]:
(i<=62)?[12+(i-51)*0.3,12+(i-51)*0.3,12+(i-51)*0.3]:
(i<=68)?[23+(i-62)*7.6,23+(i-62)*7.6,23+(i-62)*7.6]:
(i<=69)?[75+(i-68)*nan,75+(i-68)*nan,75+(i-68)*nan]:
(i<=81)?[76+(i-69)*7.63636,76+(i-69)*7.63636,76+(i-69)*7.63636]:
(i<=111)?[161+(i-81)*2.72414,161+(i-81)*2.72414,161+(i-81)*2.72414]:
(i<=131)?[226+(i-111)*0.736842,226+(i-111)*0.736842,226+(i-111)*0.736842]:
(i<=171)?[255+(i-131)*-3.46154,255+(i-131)*-3.46154,160+(i-131)*-1.02564]:
(i<=256)?[150+(i-171)*0.833333,50+(i-171)*0.595238,50+(i-171)*0.595238]"
elif {$1==5}
f "(i<=151)?[255+(i-0)*-1.7,255+(i-0)*-1.7,255+(i-0)*-1.7]:
(i<=256)?[0+(i-151)*0,0+(i-151)*0,0+(i-151)*0]"
elif {$1==6}
f "(i<=13)?[255+(i-0)*-2,255+(i-0)*-2,255+(i-0)*-2]:
(i<=126)?[228+(i-13)*-2.03571,228+(i-13)*-2.03571,228+(i-13)*-2.03571]:
(i<=256)?[0+(i-126)*0,0+(i-126)*0,0+(i-126)*0]"
elif {$1==7}
f "(i<=42)?[255+(i-0)*0,255+(i-0)*0,255+(i-0)*0]:
(i<=191)?[253+(i-42)*-1.70946,253+(i-42)*-1.70946,253+(i-42)*-1.70946]:
(i<=256)?[0+(i-191)*0,0+(i-191)*0,0+(i-191)*0]"
elif {$1==8}
f "(i<=4)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=8)?[28+(i-4)*0,0+(i-4)*0,28+(i-4)*0]:
(i<=12)?[60+(i-8)*0,0+(i-8)*0,60+(i-8)*0]:
(i<=16)?[92+(i-12)*0,0+(i-12)*0,92+(i-12)*0]:
(i<=20)?[124+(i-16)*0,0+(i-16)*0,124+(i-16)*0]:
(i<=24)?[156+(i-20)*0,0+(i-20)*0,156+(i-20)*0]:
(i<=28)?[188+(i-24)*0,0+(i-24)*0,188+(i-24)*0]:
(i<=32)?[220+(i-28)*0,0+(i-28)*0,220+(i-28)*0]:
(i<=36)?[252+(i-32)*0,0+(i-32)*0,252+(i-32)*0]:
(i<=40)?[236+(i-36)*0,0+(i-36)*0,224+(i-36)*0]:
(i<=44)?[220+(i-40)*0,0+(i-40)*0,196+(i-40)*0]:
(i<=48)?[208+(i-44)*0,0+(i-44)*0,168+(i-44)*0]:
(i<=52)?[192+(i-48)*0,0+(i-48)*0,140+(i-48)*0]:
(i<=56)?[180+(i-52)*0,0+(i-52)*0,112+(i-52)*0]:
(i<=60)?[164+(i-56)*0,0+(i-56)*0,84+(i-56)*0]:
(i<=64)?[152+(i-60)*0,0+(i-60)*0,56+(i-60)*0]:
(i<=68)?[136+(i-64)*0,0+(i-64)*0,28+(i-64)*0]:
(i<=72)?[124+(i-68)*0,0+(i-68)*0,0+(i-68)*0]:
(i<=76)?[136+(i-72)*0,28+(i-72)*0,0+(i-72)*0]:
(i<=80)?[152+(i-76)*0,56+(i-76)*0,0+(i-76)*0]:
(i<=84)?[164+(i-80)*0,84+(i-80)*0,0+(i-80)*0]:
(i<=88)?[180+(i-84)*0,112+(i-84)*0,0+(i-84)*0]:
(i<=92)?[192+(i-88)*0,140+(i-88)*0,0+(i-88)*0]:
(i<=96)?[208+(i-92)*0,168+(i-92)*0,0+(i-92)*0]:
(i<=100)?[220+(i-96)*0,196+(i-96)*0,0+(i-96)*0]:
(i<=104)?[236+(i-100)*0,224+(i-100)*0,0+(i-100)*0]:
(i<=108)?[252+(i-104)*0,252+(i-104)*0,0+(i-104)*0]:
(i<=112)?[224+(i-108)*0,236+(i-108)*0,0+(i-108)*0]:
(i<=116)?[196+(i-112)*0,220+(i-112)*0,0+(i-112)*0]:
(i<=120)?[168+(i-116)*0,208+(i-116)*0,0+(i-116)*0]:
(i<=124)?[140+(i-120)*0,192+(i-120)*0,0+(i-120)*0]:
(i<=128)?[112+(i-124)*0,180+(i-124)*0,0+(i-124)*0]:
(i<=132)?[84+(i-128)*0,164+(i-128)*0,0+(i-128)*0]:
(i<=136)?[56+(i-132)*0,152+(i-132)*0,0+(i-132)*0]:
(i<=140)?[28+(i-136)*0,136+(i-136)*0,0+(i-136)*0]:
(i<=144)?[0+(i-140)*0,124+(i-140)*0,0+(i-140)*0]:
(i<=148)?[0+(i-144)*0,136+(i-144)*0,28+(i-144)*0]:
(i<=152)?[0+(i-148)*0,152+(i-148)*0,56+(i-148)*0]:
(i<=156)?[0+(i-152)*0,164+(i-152)*0,84+(i-152)*0]:
(i<=160)?[0+(i-156)*0,180+(i-156)*0,112+(i-156)*0]:
(i<=164)?[0+(i-160)*0,192+(i-160)*0,140+(i-160)*0]:
(i<=168)?[0+(i-164)*0,208+(i-164)*0,168+(i-164)*0]:
(i<=172)?[0+(i-168)*0,220+(i-168)*0,196+(i-168)*0]:
(i<=176)?[0+(i-172)*0,236+(i-172)*0,224+(i-172)*0]:
(i<=180)?[0+(i-176)*0,252+(i-176)*0,252+(i-176)*0]:
(i<=184)?[0+(i-180)*0,224+(i-180)*0,236+(i-180)*0]:
(i<=188)?[0+(i-184)*0,196+(i-184)*0,220+(i-184)*0]:
(i<=192)?[0+(i-188)*0,168+(i-188)*0,208+(i-188)*0]:
(i<=196)?[0+(i-192)*0,140+(i-192)*0,192+(i-192)*0]:
(i<=200)?[0+(i-196)*0,112+(i-196)*0,180+(i-196)*0]:
(i<=204)?[0+(i-200)*0,84+(i-200)*0,164+(i-200)*0]:
(i<=208)?[0+(i-204)*0,56+(i-204)*0,152+(i-204)*0]:
(i<=212)?[0+(i-208)*0,28+(i-208)*0,136+(i-208)*0]:
(i<=216)?[0+(i-212)*0,0+(i-212)*0,124+(i-212)*0]:
(i<=220)?[0+(i-216)*0,0+(i-216)*0,160+(i-216)*0]:
(i<=224)?[0+(i-220)*0,0+(i-220)*0,192+(i-220)*0]:
(i<=228)?[0+(i-224)*0,0+(i-224)*0,216+(i-224)*0]:
(i<=232)?[0+(i-228)*0,0+(i-228)*0,252+(i-228)*0]:
(i<=236)?[252+(i-232)*0,252+(i-232)*0,252+(i-232)*0]:
(i<=256)?[0+(i-236)*13.4211,0+(i-236)*13.4211,0+(i-236)*13.4211]"
elif {$1==9}
f "(i<=61)?[0+(i-0)*2,0+(i-0)*2,0+(i-0)*2]:
(i<=91)?[3+(i-61)*3,3+(i-61)*3,3+(i-61)*3]:
(i<=101)?[91+(i-91)*1,91+(i-91)*1,91+(i-91)*1]:
(i<=145)?[103+(i-101)*3.37209,103+(i-101)*3.37209,103+(i-101)*3.37209]:
(i<=155)?[250+(i-145)*0.555556,250+(i-145)*-27.7778,250+(i-145)*-6.55556]:
(i<=171)?[255+(i-155)*0,0+(i-155)*0,191+(i-155)*-12.7333]:
(i<=191)?[242+(i-171)*-12.7368,12+(i-171)*12.7895,0+(i-171)*0]:
(i<=201)?[0+(i-191)*0,255+(i-191)*0,25+(i-191)*25.5556]:
(i<=211)?[0+(i-201)*0,229+(i-201)*-25.4444,255+(i-201)*0]:
(i<=221)?[0+(i-211)*0,0+(i-211)*0,229+(i-211)*-25.4444]:
(i<=246)?[20+(i-221)*9.79167,20+(i-221)*9.79167,20+(i-221)*9.79167]:
(i<=256)?[255+(i-246)*0,255+(i-246)*0,255+(i-246)*0]"
elif {$1==10}
f "(i<=130)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=165)?[90+(i-130)*-2.64706,160+(i-130)*-4.70588,255+(i-130)*-7.5]:
(i<=183)?[0+(i-165)*15,0+(i-165)*15,0+(i-165)*15]:
(i<=198)?[255+(i-183)*-8.92857,255+(i-183)*-12.5,255+(i-183)*-18.2143]:
(i<=206)?[130+(i-198)*2.85714,80+(i-198)*10,0+(i-198)*0]:
(i<=214)?[0+(i-206)*0,150+(i-206)*-14.2857,160+(i-206)*12.8571]:
(i<=222)?[220+(i-214)*0,0+(i-214)*0,150+(i-214)*14.2857]:
(i<=230)?[226+(i-222)*-13.1429,0+(i-222)*0,0+(i-222)*0]:
(i<=256)?[255+(i-230)*0,255+(i-230)*0,255+(i-230)*0]"
elif {$1==11}
f "(i<=110)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=142)?[0+(i-110)*0.0967742,0+(i-110)*8.09677,255+(i-110)*0]:
(i<=172)?[8+(i-142)*5.44828,243+(i-142)*-8.37931,247+(i-142)*-8.41379]:
(i<=192)?[170+(i-172)*4.47368,12+(i-172)*12.7895,15+(i-172)*12.6316]:
(i<=219)?[246+(i-192)*-9.42308,250+(i-192)*-5.5,246+(i-192)*-9.42308]:
(i<=255)?[7+(i-219)*6.88571,110+(i-219)*3.91429,1+(i-219)*0.0857143]:
(i<=256)?[255+(i-255)*0,255+(i-255)*0,255+(i-255)*0]"
elif {$1==12}
f "(i<=152)?[0+(i-0)*1.30464,0+(i-0)*1.30464,0+(i-0)*1.30464]:
(i<=174)?[0+(i-152)*0,255+(i-152)*-12.1429,255+(i-152)*-6.66667]:
(i<=187)?[0+(i-174)*0,0+(i-174)*21.25,115+(i-174)*-9.58333]:
(i<=197)?[0+(i-187)*28.3333,255+(i-187)*0,0+(i-187)*0]:
(i<=207)?[255+(i-197)*0,255+(i-197)*-28.3333,0+(i-197)*0]:
(i<=216)?[255+(i-206)*-28.3333,0+(i-206)*0,0+(i-206)*0]:
(i<=225)?[0+(i-216)*28.625,0+(i-216)*28.625,0+(i-216)*28.625]:
(i<=236)?[242+(i-225)*-11.5,114+(i-225)*-11.4,195+(i-225)*-6.8]:
(i<=256)?[255+(i-236)*0,255+(i-236)*0,0+(i-236)*13.4211]"
elif {$1==13}
f "(i<=152)?[0+(i-0)*0,0+(i-0)*1.68874,0+(i-0)*1.68874]:
(i<=174)?[0+(i-152)*0,255+(i-152)*-12.1429,255+(i-152)*-6.66667]:
(i<=187)?[0+(i-174)*0,0+(i-174)*21.25,115+(i-174)*-9.58333]:
(i<=196)?[0+(i-187)*31.875,255+(i-187)*0,0+(i-187)*0]:
(i<=207)?[255+(i-196)*0,255+(i-196)*-25.5,0+(i-196)*0]:
(i<=216)?[255+(i-206)*-28.3333,0+(i-206)*0,0+(i-206)*0]:
(i<=225)?[0+(i-216)*28.625,0+(i-216)*28.625,0+(i-216)*28.625]:
(i<=236)?[242+(i-225)*-11.5,114+(i-225)*-11.4,195+(i-225)*-6.8]:
(i<=254)?[255+(i-236)*-15,255+(i-236)*-15,0+(i-236)*0]:
(i<=255)?[255,255,255]"
fi
if $6 rgb2srgb fi
endl done
fx_satellite_preview :
fx_satellite $*
#@gui _
#@gui Vibrato Texture : fx_vibrato_texture, fx_vibrato_texture_preview(0)
#@gui : note = note("This filter is inspired by the Paint.NET plugin named Vibrato authored by MadJik for Paint.NET.")
#@gui : sep = separator()
#@gui : 1. X-Orientation = bool(1)
#@gui : 2. Y-Orientation = bool(1)
#@gui : 3. U- Factor = float(.85,.1,15)
#@gui : 4. V- Factor = float(.85,.1,15)
#@gui : 5. X-Scale Factor = float(1,.1,15)
#@gui : 6. Y-Scale Factor = float(1,.1,15)
#@gui : 7. XY-Scale Factor = float(1,.1,3)
#@gui : 8. Percentage-Based X Pixel Shift = float(0,-200,200)
#@gui : 9. Percentage-Based Y Pixel Shift = float(0,-200,200)
#@gui : 10. Elevation = float(.7,-1,1)
#@gui : 11. Z 0-1 Multiplier = float(.5,0.1,1)
#@gui : 12. Z Exponential Multiplier = float(1,1,15)
#@gui : 13. Apply Inversion Factor = bool(0)
#@gui : 14. Inversion Factor = float(1,-1,10)
#@gui : 15. Final Mod Factor = float(1,1,32)
#@gui : 16. Invert Vibrato = bool(0)
#@gui : sep = separator(), 17. Image Influence Factor = float(1,-8,8)
#@gui : sep = separator(), Channel(s) = choice{"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]"}
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>.")
fx_vibrato_texture:
ac "_fx_vibrato_texture ${1-18}",$18
_fx_vibrato_texture:
repeat $! l[$>]
n 0,255 f "q=($8/100)*w;
l=($9/100)*h;
X=(($1?w-x+q:x+q)/w-.5) * 2 * 1/$5 * 1/$7;
Y=(($2?h-y+l:y+l)/h-.5) * 2 * 1/$6 * 1/$7;
g=1*13^(-$14);
U=sqrt($3);
V=sqrt($4);
Z=((X-Y) * (X-U) * (X+U) * (Y-V) * (Y+V))+ $10;
D=$13?(1-(Z>g?Z:1-Z * -1)):Z;
C=(D+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$17)*(D+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$17)*$11*$12*$12;
F=abs(C)>1?C-int(C):C;
$16?F:1-F;
" n 0,255 mul $15 mod 256
endl done
fx_vibrato_texture_preview :
gui_split_preview "fx_vibrato_texture ${1--2}",$-1
#@gui _
#@gui <i>KaRo's Tests</i>
#@gui About : _none_, karos_about
#@gui : note = note{"KaRo's test files for <b>G'MIC</b>\n\written by"}
#@gui : note = link("Karsten Rodenacker","http://K.Rodenacker.de")
#@gui : note = note{"\n"}
#@gui : note = note{"The source code of this set of filters is available at :"}
#@gui : note = link("https://github.com/dtschump/gmic-community/blob/master/karsten_rodenacker.gmic")
#@gui : sep = separator()
#@gui : note = note{"Several operations here rely on executables existing <i>in search PATH</i> ($PATH unter Mac/Unix).
#@gui : This means that the executable is downloaded or built and properly located.
#@gui : E. g. CImg examples have to be built and copied to a location in the search path, e.g. under unix <i>/usr/local/bin</i>.
#@gui : Similar with PINK executables. For Mac they have to be built according the README with <i>./makelin</i>
#@gui : and PATH as to be extended by <i>..pink location../linux/bin</i>."}
#@gui : sep = separator()
#@gui : note = note{"  CImg Skeleton: <i>use_skeleton</i> in search PATH"}
#@gui : note = link("https://github.com/dtschump/CImg/blob/master/examples/use_skeleton.cpp")
#@gui : note = note{"  CImg nlmeans: <i>use_nlmeans</i> in search PATH"}
#@gui : note = link("https://github.com/dtschump/CImg/blob/master/examples/use_nlmeans.cpp")
#@gui : note = note{"  mM Differences: \nmathematical morphology operation differences\nmM operation size - mM operation size2"}
#@gui : note = note{"  oC Differences: \nmathematical morphology open/close differences\nmM open size - mM close size"}
#@gui : note = note{"  Pink operations binary: <i>Pink applications</i> in search PATH"}
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/index.html")
#@gui : sep = separator()
#@gui : note = note{"\nThe functions defined are quite <i>experimental</i> and subject to changes.
#@gui : Please do not rely on the fact that they will perform equally forever."}
karos_about :
fx_logo_version{round(u(0.5,3.49))} $_version [0] *. 0 text. "KaRo's",10%,22%,57,1,255 text. "Tests",40%,60%,57,1,200
+to_gray. skeleton. , n[-1--2] 0,255 dilate.. 2 -[-1--2] + n 0,255
#@cli :: PINK-library operators
_wrbytepnk :
output_pink3d ${1}.pnk
_xpink :
na={-1,n}
filename=${-file_rand}
x_filename={/$filename}
if {if(isval($GMIC_PINK_VERBOSE),0$GMIC_PINK_VERBOSE,0)>0} verb=" 2>&1" else verb=" >/dev/null 2>&1" fi
if {if(isval($GMIC_PINK_NO_RM),0$GMIC_PINK_NO_RM,0)>0} no_rm=1 else no_rm=0 fi
prefix=pink.
if {!${-is_windows}}
-x "which "${prefix}${1}$verb
if {${}!=0} prefix=""
-x "which "$1$verb
if {${}!=0} v + error "Executable (pink.)"$1" not found in PATH, status = "${}"!! Returning!!\n" fi
fi
output_pink3d ${filename}.pnk -x ${prefix}${1}" "${filename}".pnk $2 "${filename}"_o.pnk"$verb
else
output_pink3d ${filename}.pnk -x $1" "${x_filename}".pnk $2 "${x_filename}"_o.pnk"
fi
status=${}
if {!$no_rm} file_rm ${x_filename}.pnk fi
if {$status!=0" && "['"$1"']!='seuilauto'} v + error "Exec status is "${status}"."
elif ${filename}_o.pnk i ${filename}_o.pnk file_rm ${x_filename}_o.pnk k. nm. $na
else v + error "Exec error!!"
fi
_xpinks :
s={s} if {$s>1} s. c fi
repeat $! l[$>]  _xpink $1,"$2" k. endl done
if {$s>1} a[-$s--1] c fi
_xframe :
line 0%,0%,100%,0% line 0%,100%,100%,100% line 0%,0%,0%,100% line 100%,0%,100%,100%
#@cli output_pink3d : filename,_type
#@cli : Save selected images as _type-coded (P5,P8,P9) PPM files (PINK extension for 3d volumetric images).
output_pink3d : skip ${2=P5}
e[^-1] "Output image$? as file '$1' (in 3d pink extension of "$2"-coded PPM format)."
v - if {$!==1} filename0="$1"
else repeat $! filename$>=${filename\ "\"$1\"",$>} done
fi
repeat $! l[$>]
if {['"$2"']=='P5'}
if {d==1} o. ppm:${filename$>}
else
({'P5\n{w}\ {h}\ {d}\n255\n'})
+channels.. 0 y. x a[-2,-1] x
o. raw:${filename$>},uchar
rm.
fi
elif {['"$2"']=='P8'}
({'P8\n{w}\ {h}\ {d}\n{iM}\n'})
+channels.. 0 cast. uint,uchar y[-2,-1] x a[-2,-1] x
o. raw:${filename$>},uchar
rm.
elif {['"$2"']=='P9'}
({'P9\n{w}\ {h}\ {d}\n{ceil(iM)}\n'})
+channels.. 0 cast. float,uchar y[-2,-1] x a[-2,-1] x
o. raw:${filename$>},uchar
rm.
else error "Type "$2"not implemented!" fi
endl done v +
#@cli pinkxipo : [b1],..[bn],name,pn+2, .. ,pm
#@cli : Pink wrapper pinkxipo[a] [b1,..bn,]name(pn+1)[,pn+2, .. ,pm] (requires the PINK library to be installed).
#@cli : Executables with 1, 2-n input image files (xi), pos. parameters (p), output file (o)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/)
#@cli : prepares input, calls external "name inputa [inputb1 ... inputbn] [pn+2 ... pm] output" and reads output (/tmp)
#@cli : Add. images are located before the pink executable name. If images are replaced by a parameter,
#@cli : e.g. null, than it has to be located after the executable name!
#@cli : $ sp 1 ir. 0,50% +pinkxipo. distc,3 +negate.. +pinkxipo... dist,3 pinkxipo[1] [0],bisector pinkxipo[3] [2],bisector k[0,1,3] a c
#@cli : $ sp 2 +pinkxipo. dilatballnum,5 +-
#@cli : $ sp 1 ir. 0,50% +pinkxipo. dilatballnum,10 +pinkxipo.. .,distgeo,4
#@cli : $ sp 1 +pinkxipo. seuilauto,128,max,3
pinkxipo :
e[^0] "Pink cmd "$* v -
$=var
p=1
na={n}
for {$#>=$p&&${-is_image_arg\ ${var$p}}} pass${var$p} p+=1 done pl=$p-1
exec=${var$p} p+=1
if {$#==$p} pp=${var$p}
elif {$#>$p} repeat {$#-$p+1} if {$>==0} pp=${var$p} else pp=$pp" "${var$p} fi p+=1 done
else pp="" fi
filename=${-file_rand}
if {if(isval($GMIC_PINK_VERBOSE),0$GMIC_PINK_VERBOSE,0)>0} verb=" 2>&1" else verb=" >/dev/null 2>&1" fi
if {if(isval($GMIC_PINK_NO_RM),0$GMIC_PINK_NO_RM,0)>0} no_rm=1 else no_rm=0 fi
echo_stdout $verb
if {!${-is_windows}}
prefix=pink.
x "which "$prefix$exec$verb
if {${}!=0} prefix="" x "which "$exec$verb
if {${}!=0} error "executable (pink.)"$exec" not found in PATH, status = "${}"!! Returning!!\n" return fi
fi
else prefix="" fi
ni=$!
repeat $!
if {iM#$>>255} output_pink3d[$>] ${filename}$>.pnk,P8 else output_pink3d[$>] ${filename}$>.pnk fi
if {$>==0} il=${filename}$>.pnk else il=$il","${filename}$>.pnk fi done
ilk=${-karo_li2st\ $il}
cmd=$prefix$exec\ $ilk\ $pp\ ${filename}"_o.pnk"$verb
e $cmd
x $cmd
status=${}
if {!$no_rm} repeat $ni file_rm ${-arg\ {$>+1},$il} done fi
if {$status!=0" && "['$exec']!='seuilauto'} v + error $exec" Status is "$status"." return
elif ${filename}_o.pnk i ${filename}_o.pnk file_rm ${filename}_o.pnk k. nm $na~
else error "exec Error!!" fi
v +
#@cli pink
#@cli : Pink wrapper name,p1,...,pn (requires the PINK library to be installed).
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/)
#@cli : prepares input, calls external "name input p1...pn output" and reads output (/tmp)
#@cli : $ image.jpg +pink asfr,5 pink[0] asf,5
#@cli : $ image.jpg +blur 2 pink maxima,4
pink : v -
if {$#>1} ({"'${2--1}'"}) replace. {','},{"' '"} p={t} rm. else p=" " fi
v + e[^-1] "Call pink package on image$? with cmd: \"$1 [img] "$p" [img]\"." v -
repeat $! l[$>] _xpinks $1,$p endl done v +
#@cli pink_grayskel : _connectivity={ 4 | 8 | 6 | 26 }, _lambda=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/grayskel_8c.html)
#@cli : Grayscale homotopic skeleton (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'lambda=0'.
#@cli : $ image.jpg +pink_grayskel , +pink_grayskel[0] ,10 +pink_grayskel[0] ,100 append_tiles 2
pink_grayskel : skip ${1=4},${2=0}
check "${1=4}==4 || $1==8 || $1==6 || $1==26"
repeat $! l[$>] _xpinks "grayskel","null $1 $2" endl done
#@cli pink_heightmaxima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/heightmaxima_8c.html)
#@cli : Heightmaxima filtering (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'height=1'.
#@cli : $ image.jpg +blur 2 +pink_heightminima ,15 +pink_heightmaxima[0,1] ,15 -[-3,-1] -[-3,-1] keep[-1,-2]
pink_heightmaxima : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=1}
e[^-1] "Filter by heightmaxima exec with connectivity $1 height $2."
v - repeat $! l[$>]
s={s} if {$s>1} s. c fi
repeat $! l[$>] _xpink "heightmaxima","$1 $2" k. endl done
if {$s>1} a[-$s--1] c fi
endl done v +
#@cli pink_heightminima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/heightminima_8c.html)
#@cli : Heightminima filtering (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'height=1'.
#@cli : $ image.jpg +blur 2 +pink_heightminima ,15 +pink_heightmaxima[0,1] ,15 -[-3,-1] -[-3,-1] keep[-1,-2]
pink_heightminima : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=1}
e[^-1] "Apply filter by heightminima exec with connectivity $1 height $2."
v - repeat $! l[$>]
s={s} if {$s>1} s. c fi
repeat $! l[$>] _xpink "heightminima","$1 $2" k. endl done
if {$s>1} a[-$s--1] c fi
endl done v +
#@cli pink_htkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/htkern_8c.html)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/htkernu_8c.html)
#@cli : Grayscale ultimate homotopic thinning/thickening without condition (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'type=""'.
#@cli : $ image.jpg +pink_htkern ,u +pink_htkern[0] , +-[-1,-2] remove[0]
pink_htkern : skip ${1=4},${2=""} v -
repeat $! l[$>] _xpinks htkern$2,"null $1" endl done v +
#@cli pink_lvkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/lvkern_8c.html)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/lvkernu_8c.html)
#@cli : Grayscale ultimate leveling thinning/thickening without condition (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'type=""'.
#@cli : $ image.jpg pink_lvkern ,u
pink_lvkern : skip ${1=4},${2=""}
check "${1=4}==4 || $1==8 || $1==6 || $1==26" v -
repeat $! l[$>] _xpinks lvkern${2},"null $1" endl done v +
#@cli pink_reg_minima : _connectivity={ 4 | 8 | 6 | 26 }
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/minima_8c.html)
#@cli : Regional minima (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4'.
#@cli : $ image.jpg +blur 2 pink_reg_minima ,
pink_reg_minima : check "${1=4}==4 || $1==8 || $1==6 || $1==26"
e[^-1] "Compute regional minima exec with connectivity $1."
v - repeat $! l[$>]
s={s} if {$s>1} s. c fi
repeat $! l[$>]  _xpink "minima","$1" k. endl done
if {$s>1} a[-$s--1] c fi
endl done v +
#@cli pink_skelcurv : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelcurv_8c.html)
#@cli : Curvilinear binary skeleton guided by a priority function or image (requires the PINK library to be installed).
#@cli : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% {w},{h} fill[-1] 'if(x>w/2,255,0)' tp=${-path_tmp} output[-1] ${tp}/inhibit.pgm remove[-1] +pink_skelcurv[0] , +pink_skelcurv[0] ,,${tp}/inhibit.pgm exec "rm "${tp}"/inhibit.pgm"
#@cli : $ image.jpg threshold 50% +pink_skelcurv , +pink_skelcurv[-2] ,8
pink_skelcurv : skip ${1=0},${2=4},${3=""}
e[^-1] "Curvilinear binary skeleton guided by a priority function or image from image$?, prio=$1, connectivity=$2, inhibit=$3."
v - repeat $! l[$>] _xpinks "skelcurv","$1 $2 $3" endl done v +
#@cli pink_skelend : _connectivity={ 4 | 8 | 6 | 26 },_n=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelend_8c.html)
#@cli : Homotopic skeleton of a 2d or 3d binary image with dynamic detection of end points (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'n=0'.
#@cli : $ image.jpg threshold 50% +pink_skelend , +pink_skelend[-2] ,-1
pink_skelend : skip ${1=4},${2=0}
v - repeat $! l[$>] _xpinks "skelend","$1 $2" endl done v +
#@cli pink_skeleton : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skeleton_8c.html)
#@cli : Ultimate binary skeleton guided by a priority image (requires the PINK library to be installed).
#@cli : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% +pink_skeleton[-1] ,
pink_skeleton : skip ${1=0},${2=4},${3=""}
v - repeat $! l[$>] _xpinks "skeleton","$1 $2 $3" endl done v +
#@cli pink_skelpar : _algorithm={0...29},_nsteps=_1,_inhibit=""
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelpar_8c.html)
#@cli : Parallel binary skeleton (requires the PINK library to be installed).
#@cli : Default values: 'algorithm=4', 'nsteps=-1' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% +pink_skelpar[-1] 0 +pink_skelpar[-1] 2
pink_skelpar : skip ${1=4},${2=-1},${3=""}
v - repeat $! l[$>] _xframe _xpinks "skelpar","$1 $2 $3" endl done v +
#@cli pink_wshed : _connectivity={ 4 | 8 | 6 | 26 },_inverse={ 0 | 1 },_height=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/wshedtopo_8c.html)
#@cli : Watershed (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4', 'inverse=0' and 'height=0'.
#@cli : $ image.jpg +pink_wshed ,1,5 pink_wshed[0] ,,5
pink_wshed : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=0},${3=0}
e[^-1] "Compute wshedtopo exec with connectivity $1 inversion $2 height $3."
v - repeat $! l[$>]
s={s} if {$s>1} s. c fi
if {d==1}
check "${1=4}==4 || $1==8"
repeat $! l[$>]
f max(min(i,255),0)
if {$2!=0} negate 255 fi
if {$3>=0} pink heightminima,$1,$3 fi
pink wshedtopo,$1
if {$2!=0} negate 255 fi
endl done
else
check "$1==6 || $1==26"
repeat $! l[$>]
f max(min(i,255),0)
if {$2!=0} negate 255 fi
if {$3>=0}
pink heightminima,$1,$3
fi
pink wshedtopo,$1
if {$2!=0} negate 255 fi
endl done
fi
if {$s>1} a[-$s--1] c fi
endl done v +
#@cli output_pinklist : _filename (def. $TMPDIR/pink.list)
#@cli : Write a pink list file from (2,n) or (3,n) coordinate list image
output_pinklist :
check {w<=3&&w>1} skip ${1=$TMPDIR/pink.list}
e[^-1] "Generetate a pink list file $1 from the ("{w}","{h}") image"
v -
nn=$1.list
typ={w==3?'n':'b'}
($typ,32,{'{h}'})
o.. asc:$nn rm..
i raw:$nn,uchar s +,10 rm[1] a y
file_rm $nn
o raw:$1,uchar rm
v +
#@cli input_pinklist : file_name, _mode
#@cli : Read a pink list file (type G from pink.delaunay) at file_name and prepare
#@cli : _mode == 0 a 3d object or
#@cli : _mode != 0 the vertice, hull, edge lists and the adjacency matrix
#@cli : Other list file types are still not implemented
input_pinklist :
check $1 skip ${2=0}
e[^-1] "Read pinklist $1" v -
i[0] raw:$1,uchar s[0] -,10
if {{0,@0}=={'G'}}
rows[0] 2,100% n={{0,t}} rm[0]
3,$n,1,1 nm. vertices
1,$n,1,1 nm. vhull
0 nm. edges
repeat {$!-3} l[{$>},vertices,vhull,edges]
s[0] -,32
=[vertices] {0,t},0,$> =[vertices] {1,t},1,$> =[vertices] {2,t},2,$>
=[vhull] {3,t},0,$> {{4,t}*3},1,1,1 p=$>
repeat {4,t} =. 2,{$>*3} =. $p,{$>*3+1} =. {{$>+5},t},{$>*3+2} done
a[edges] .,x rm[1-4,-1]
endl done
k[vhull,vertices,edges] mv[vhull] 0
ver={vertices,h}
edg={edges,{w/3}}
nhull={vhull,is}
if {$2==0}
if {vhull,is} repeat {vertices,h}
if {vhull,@{$>}} (1,$>) a[edges] .,x rm. edg+=1 fi
done fi
({'CImg3d'}) mv. -3
($ver,$edg) mv. -3
(255^255^255) r. {$edg-$nhull}
(0,0,255) .x{$nhull-1} a[-1--$nhull] x
(0.6) r. {$edg-$nhull}
(1) .x{$nhull-1} a[-1--$nhull] x
unroll y a[-1--8] y rm..
else
$ver,$ver
repeat {{edges,w}/3}
=. 1,{edges,@{$>*3+1}},{edges,@{$>*3+2}}
done
fi
u $ver,$edg,$nhull
elif  {{0,@0}=={'b'}} e "2d list file"
rows[0] 2,100% n={{0,t}} rm[0]
error "Not implemented!"
elif  {{0,@0}=={'n'}} e "3d list file"
rows[0] 2,100% n={{0,t}} rm[0]
error "Not implemented!"
fi
v +
#@cli pink_delaunay : _mode
#@cli : Prepare the delaunay triangulation from a list of coordimates (vertices)
#@cli : using the external program pink.delaunay
#@cli : _mode == 0 a 3d object or
#@cli : _mode != 0 the vertice, hull, edge lists and the adjacency matrix
#@cli : $ 2,50,1,1 rand 0,512 pink_delaunay. 0
pink_delaunay : skip ${1=0} v -
file_rand nn=${}
output_pinklist. $nn".tmp"
x 0,"pink.delaunay "$nn".tmp "$nn".del"
input_pinklist[] $nn".del",$1
file_rm $nn.tmp
file_rm $nn.del
v +
#@cli :: KaRo's Tests
#@cli osteo : Load osteoblast cell image 128,128,1,1 (transmitted light)
osteo :
e[^-1] "Load osteoblast nucleus example image"
v - l[]
base642img "MiB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KMTI4IDEyOCAxIDEgIzExMDUwCnicLXtXkyTXmd2/U2xIsZRCWi0oihSXu9wFSC5BGAKDcT3Tvrz3lVmVZbJsl2s7Mz0Y7zDdXZXedgNShEIPelCEHvWmc24Bg5noqq7Ke+9nznc+c+3Qd2zbNhzTt2xbNxzHtAzLsxzfMSz855iO75quabuO6xiuZVv4vGlfB4bjerpjWUEY8GO2b7m+4TrXoeP5juPathW6nuVeh7bFd370XNtznRvXx4K+7eBjXujbHr5nYHmbXzAtU7extIefDd+13dCwXMN1XRvL6r7vOrbmOA6eZF07uukHBrbscz+WG4Se79u6i73iAyE+g9WxoTBwbd9zrADfdm/swLFDz3MCxw+xHde+sT2c0NQsh3v2Ld0KTcM1cVbf0TyXe8P7rs8dOhSOi9f4mOvotvOTp9tugDcsG/sOfdf3Tct2XSEBDVsKIbwwdEMs6fmh5eLIgW1f3zhOEPg3FJPncNM4NmTgmr6HZSxd8zwLMjYtqICn1iA008AWQ8vSxDYt0zN8y8cxXVd3wxvH1j0Lb3k4H+TiXEOnASTjYBnsIzBD/yYMfQ879Jww8O0gvMFvoAUcBOqzNRzUtPEY2/G4kGNBDJaHF6alWTgcdoYzBIHlu5qNk9AcsEuLevN/Clx8iH98z7dpNtceVBxee86Ptun5XujyyDi/7wd4GJQfQP831/iXwsYXYUD2KqSJwfBsWAZMEkL3PYhBg5Ic14VsrvmeExhugAdSBxY25GkrGgX0CJ27+J7rwBYt0w4CG7KADoIgcDRoEVsIsEFsiKLxvODadSExx9AhTQem4zsQPlTshVCjAeuGRVvCEVzPpFfYBozAwbFD7MPyPJ0qtUwzvBGuEUJihh3YIdTqWrTca8jHpkXgwz6sEEYDMcIJfDfwA4rJdS1rtYLkISkXp8WSjmbRIHEeHMfj103vxnPoQZA7dgGrw5aca8gKu/N81wvw0cD07DDA1zw4M3yAS/rX+IhvU/+O6f0UBN71zbUfhPQD6OWaa2ItTTMNuB83q1m0Pm4eW3Jo/5CuGXCnODG8l6DgG/iiG9I0DZPWAGOj+UO20A9MDG6LbcKSYDr4yeGHaUZY9zq8oWHBDWENDlEBixk6fM+lEjQ4F7SM89nQmUloASa5OiQfciVsgcYF3TtEBqjRtsUXHZyK8jEgA8gUHuc42Ob1DYzJA0jhXYc+QNMDgHHThB8H9uUacEOsBMU6MHyfxu/QKvELz8T+TFeHXAK+Cd9wHD2AhAmFuhNe275mwD5geL7tcwch1W3B6AAOPs4JvLqBAHyXhuvDu5wA4nAhDk8D0Gnw/xtHWy4teJdv4OEm1iQuWQZWh2XZlmdrAGhX4CR2iQ/Q0KAY3aIcTd/XeUCAnmHTjgPLCIE4ITZBCIG9Of5PsHr/JvDgDrAYF/oKXX2JdQzTBAyuNF2Ha1qaacK+oEBCHmye7gk0tgl+gBYgAp8OmRkhhQCzh8PQN7yQ9oFNG7YBV7ZDyBYfCb2ADm9B2QAR7ONHz6JRuD4hG3rWGXfwLdPQIRTEGpMapR9QxbADyBbfNPARWAwM7QZSgV7gQi52Y9OUNFvoHDYHDQQadINdBzAsHpsuhL25wCNuxbuGnuAplncTGlgLCKiHNizQ0vBduD+OahN++QphDG6IVWyBQPwLPQhAoBsatA4YqonYAKWIeGTB3QBLRGyYK0AJXgBvvglgfNeECJfoBXSCHlYaVvLhuK65BOiacC6BFB5sAU6EBQNbxzkoBcMKbxh/oX0AFgMlhGUw1kEzsEWYl23w1xCtYyI60tJ8mAn8HRuBMQKm8A5tEh/DEoGn0c/ozCb9jzKAB/iUItwKqxMeIAhYnBVCSkCXkNbE6IqdwvWJeAQ7np1QBrMUXIGKxOYDxn86qcM1gasElpvQvYERQRg0Z3iT5hraUmfss4lkOlwQ6oLMgWl0CrEapIyAKmRHBMC+IS7+6BF1LGKlI0iIR0NwQ+o+pLB9hlnICrHPvxE49hO0ICgDCAWdHhHQMFd4EBiFRlXS+3Aak3bPiI9Hgyr47uUS7oQNWVQA4gLsMrix6R5EYcgBz8BPMGHEYFd8FQEPjoHVfBE4AqyMdf1r4h/MS3M1A8fFs2AJQADLwD4IGQRfHARuRh/TrBsEL1vT4NNgZC4cE6ENdgBVQUJwH2ibhgnO5V1bhq4JsAKEYY0AUcAD4IWGH4INQCLwBqJPQM1ZS5i9CG2aAQKFbbieWJGSsikeuqRB/wd6YUEdfMoJiRBY2oCFw0AMjaYPR6KxXDvYmEuvQ3RyCL0wZe/a8YFaUABAGPwuuLGgDdgV6BQCve1oJv0P5gfqhMMbVCK0HwrE82AkpkHPgLCJgMRkclPswYDB0PuhmtAkIAD0AJhwVcqRfIYGFNqAO9+7wekgX4faDGnINMSQx1/ZDL/cG2OXRR4CEZAXAuzxbEMD4GBLBsMwA7RFf8NG8GFdMCU4IVaDC127Qm6+4C3YJGQAFKbpwyoR+EM6oSP4lCnAJIT+dMtfQVzXVCX4HSiVRmcnFtKmaI+2Bh2beLqgqGDHmkHEI+kM4Q22zrgB84HuGVWBcMLqYYQOxHxD9mcLGspfAVXwUuO3eGIDEcQSx7EAilgQsU2jJOAOmga+DEYMh6CmwhVUhqMacHYYAI3EptsjdNiC0yLWc9/wJ5KHgNgD4EYYhq0gVEHq1y7RAPRtabt4OuwacvN1sHzfNA3NCnjqJbgj46kHentNmMKakJZvga6C1JhkSDRS5CFAT5f8AXESvIbip5FDTJBmCJODQYCekacghDB0MwBiS8aKrm8LUmvbmg7uQkJkE/fM1dLzQTturu2VcAUNAgTXB7iKaGPbwgrgsWCb8FMCpcdUgMyHnoHzujQ1SAzgAA7lE/9C6ydaSRgSzV0d0jbpdh5OTyYrTA9f8RDEhFQBU0B8YWuhtxYHgo/pkmfj/DrQxl7a4GEwQJE20fMRSXFyMwwNSBkeAb05zBjgCQh8IGEABZ/UC2ZrmEuGXKxvAgTggHwwjdzlGfA1g0IkOaSJ6OCpOCjkjTC/MrSVtvxoXi7NJUyZzN9YQwcTEng0kF+QdWgdjmYjHUQwvDbpSNAKTRe6w6ow8RCngMp9nov8i/Efm3N4pOUNtuAKykVwp9RN48rQPl68ev3q1es3L1+/fvv+ChTCIYTDKCF4WNgVoi4lBqCg8yESkGvSF8EY4P7MnkA6oHABNLpur5ZQH7k4BI8tIRjgNEgkEZpJDoGvawJmW1dvX759+WgxPzo9Pz99fHx68vjZ2w9LkABNhCaGXIt2xdzH03gKn4TGYQDyyepIZClbk4yNIsf3NMtYQj2GIcIcIYYJKle1mHbjIfgQkgXth1dPzuenk6HSGR8ezucnJ6cn09n8/MXLD8sreAE2cQ2NEdfdG5NO6pKliecxC6Rzgh/SnA3hR7prLeHO8CUTWQ1hkykAIHDpiHBOWryE1SJgutbHj8+mB4eLRb8h1zuDQX/QXxw+PpxNRov5yenTNx9oqya5wzqaCu5AQxJv3dzY/o8kSUxbQJ3oWBY5KwCecVOIBtvWHB1aRLyxqDzksO4KyQ7i4fLDiyfH3e7BfKpUak112G/Vm5PRfDoeHQzHw/nhk5dXYH5L3f2JlQH8j/BD4DM9wBKCn3tNMoDU2KVs4TaG4ZGokVYt8XmfKbTFksjSYu3DEY7OTYEg65dPT06Op/PxYDYftZvV1ng4aDQVdTzo99RuuzdZLBbHz9+ugAO6KGTYEDGwCtEb8cCl94N/0yFhhDiNDQYIAwNy4pgeCyCIOxp5PojNCrhhMKqaa7Ax7Y+vxg2lNxmPBoNer9tpSK12rys3B8Nxv6+05WZvfjRdHE6nL1e2qbFEYwmmxpKLTfQ3gW+Id8h7HOEOyCM14oa9IgshYdftQFvShbFZkA2IHWGbSQBwfnn15qier7QGvUGr1Wg1O+1GvVys1huDyWw27NbkhnpwNB4t1PbB2ysKnlUhLg2P1bkcRAHOARBkBuiwPAEGybKSCd06BjPVFRisRcQwQhgEkBA5E9k4/mivHh+3m5V6q9vvNRtKS263pUw2la+1p4PZ4UTOFyvKcAIldOTx2atLSo6BH1IlfUZUogsiUDqkZGAwYDOeyTSHXgj3MIHggACimGsKjwPDuiKrhEPip1cnk6HakmvNdm/Uaqn9lqLWS8VCpTM4hPGNq9FkqVaplipyozU5+f7tB53JC6JKwIgOO2Ci5gpz8lg2umaANvgrVjJgjDpAZsXyG0M5/FUjSiHSISq6hnX17HA67HdkWWp3OtD6oNdptlt1ual0hpC+Uo08iOYLiWQ8Ue9254vj82evyOZDklCEU+gf6LOuziAMI6sWXMRgagXzs5hiI+ZifVjmUlvCYfAp8AOIjrn35YuTo9Npq9FsdrsTSVIH81FHag/6bbUmtUaDVmnrX/64kc3u7cbynYPR8Wy6ODm9QFQinANvAlGqgz8zo16DIQKyF2iXFqmjvdRYX0GmZ5IQAkRXAnRgdsgAwFCuXk6nx49mLaU9GCwOlJp0fDjtthSl3ZUgkVZXjv3ubz+5lcpsb+5IB/PewcF0Mjw+X1IDJqM1DMF0QETAuUFBoZTQFprxDN1c6vqVpZNPMqqapqheguK49EdIYOWbF8+mw+nR0bDZ6g7Uca9WkGdPp12pVq5I9U67rbRre7/9m/90p5DY2Y41Jh1JPZpOe+OTl4bLghZVzIKOTTpoMR2Ea5hgVMhCQVjAPxzSZ7Bm+9IW4dMSNU8GXs9HYNUfjdTuvNdrK1JNkpqNdDKvTg/a1VQ0W2q1Bv2WXIn86y9/9U08nk6UlG6loEwX8MOTJx91W5QkSJhD4i/LNAR02xJREGxO0y0NmHMlsp8lk0BD8HabBSHIjjWx5xNFbqudRq1ezOfzuUI8mS035XxydyOZayijYbdZzu799Yu/3I1U6s2OXNorKoPZ4vjo9IVO3BNA6IkEFeQTTo13HCYTwOFrmjz+aNyEqeksH4AK21bA5AZvWfbq5bSjtlSlXq6U8ul0NJ6KpQv5dDyejG7t55uN/mTQlkvFcnZ3I9eqNYb94l6irB6ePTpanP4gcJdsLQxIpkA8DFJx1oCxGWcV+ivHvHJYYYYrOCvdEfweVmgbOiQCOTwbK512R+0rpWq1WIxGo8l0qphIRZIFKboblweTMZC4MxwOlEpbqbV6/Xw8UeqM5rPBaPqOgRSpIgxeBH2kg4IUE5HglQ5QCt64ZApkkkGSeqz4DyyW+4FnvJp08J8yHKjVUqlYSsUS+Uw2mdiOZ5V6NrZfP5h25UprdPJoMVGGbbmjKtmEBGyqNaXu6CkTSYBAyAUFBQATtG5YQqQMwCRwwhWwdUUvA/OGYax0SJ3Zt6hGv+kWap1Oo6GoSjmdThaT2WwmlYlt39tIFbM7kWR50MmlcvXRo/PpSJHrZVmqZApKF8aZK8v9owt/BfoErsE8yV1HA9ZAyISAzyby/hUgFjEPnihaDljcAg3QPYYk8+NhJt7s48m1eqEYicQSsUg6k88ntz/99Nvtnc29aLaS2dpLSer0ZNKqFjPxVCGfLbbkajqeyJQbkycaS9qWyMNgTg77A4g+IJ7ejx5e2jQ5AYCUlMFUyAovoC94gq7Zq+e9REKaznpSrZRJ7Mey0Z29vWKulI989nf/+CACd48ltu9sZVuj6XRQTcVTu5s7mVxVbeX2tnejqUrn8BUZhMZKqs9I5xBgkVJitZtrIIymaaCAhB8QN+RcAFuQ9ktEnCvIwHq3aFbK8nA67sD14pvZ1F5kN1ko4KC3fvfPW7nYbiQaffAgklf6k4Vazubyke82kuXGoNdIbd3fiMvt0fOlaaw5NQMLE4iQuRATeViFILb8gwi9IsNl50GUu0jhrNWjfrtTrasH8PBSJhYrZGLJeC6fSqVTkTvfRavpZCKejCQyhVJd7UrlYr2a37ibbM1OJ0opvnU/LfVm50vya4f+hCQsEATeW/No8H9wf2bd0AP+wgdsWCAkDx4Ax3HMN2f98VCpSK1mtVgvZtK5VDJZhJK34vFMNpdrNarlTLZSrxSS2VQhl4Vgcpt3so3DxwO5mIlGyp3JweMrVqJYhLdI/0jOb5gEMhtl0gSjwEkNknz2HIBDBnIQjeVg982T2WQ2abeA8/W6XE4XMtF4rlzNbj3cy1TkmtztdyupYnfYqqfT8Z2dZGJ/L/Jwq9Q9GLSKpXKu0kRkfnzBzJjZFIt8NrWPlzeuoCaifmiKEhwxmhF/SV24yIVW+up83JudHAw7UjHfqFXyycTe7l4WILx9bytdrGYKValdKMqDYb9ZyMXv3L6zcW9jayNZByWt1ms1EAO1N3/yaiVKII4ow5sk/mDZLAVD/xY9DpwHGbWh+8FSp50Ci9l2MS9eHHW6g/mkU8sn0plcKrG1dfe77UylmN7bfLCfjO/FMsV8UWr3+32pWoj89U9/+fq7h9vRgjKbVUoleTQ+GLbVg0cvPnqOSLrMgGVEJqFMkCAO61pkV/jfI9hgMxocxVppuuDcH74HpnbUdiF2/5vNWCqy8/Denbv3NuPJVPTh7a8ebG5s7WWLpXZ/qKpNuRD99k+f/eX2w72cpPa7Uj5RVReHi353ND+/YpmLIZgtQVN09Hw2NJchO3cQxTV4HqQhEAC8g7QJAUl/eTqb92WpFP/yd7+6lSxlU4lEYufed3cjsf17//rZrc2N+1vRXLM97amDkdKI3Pn6y+8e7mfrHaVVKWR3M/XByQI5wuhcC1kv0gW+iIwspMeRDYFwm7owfSifEOh4S/yA6Av++e7RbDaC3yuxz//jJ18X5WZLadayO/ceJpM7X/7hD7d3t2kNZak7HKr9dnXvwd17kSIwt9OsF7PZ6H6mCQWMe+MnbFZ4LHTDsFiOQJ4HFuDy9FC3wZjPDqDhmWwy6KZoBNvL7xejYafdUjrFe//w2Xap05/Oxo1yOhbPpLZv/+WbezvR/WgkVyzWOkqzVCjE9vawpFzJ1WrVIohQNFNqtdXhaPGa7VmWRxj0RRfJIru1RGXY0FYAO59tRrDg1WqdCetL2/5wNBx2FQVkv518uFeUG+3J0axRSSdz1Xxke3NrN7r94OFGPJvJ1OrlfDadyORzJUUpRGOFfCG9vZ2u12Sp2exjfRatgMJkQkzhWaa9tsVrnBv0Y+nwzOzEsMqJHMjVdfPdpNfpNdrt8bhbz9aUZrlQ6/aa1Xg8Wyumdrej8cT+ra+/ur8TzxcKmWIhFc/j6GoztxVPpVLxzY241Faq+ZI6eW9S6jB9XxAPOIC3rhCxMQ3AA78iCuhGYCPjZNIN+eirV7NuU+31u8hp+5Ik1ZORVLUt56Jb0UIhFdvdTmRT9778+t72ZiSWSuSb+Ui+mCpUKvm9SCadjCJQtscgQjF58Q4kM/ADUYgM2NRhEVp3RTcYuZCOJEiH8FeAY9aQzBCpt2O8O5+oNQW0Exn2RK0XYts72ZpcTaT2duLgPtFIpFiPbG5Hk7sPY9FoQc7FsKFUMg19FBIRENH8YDEo72yWph/ZtbNvwLBArRD8XZYxXIcVQERZl51PEK2fO+3rbgxC4vtHyKtrzZYkNxFNKvH4VqTUkrL7+7tbO5FEOhHZKzaqtWwesBBJJ3LVXGQ7Eo0jAJYqUj6VzJVK6uKglYmV5yuHbMpmnY2s+sZiNBSUgAUmJH9ayNoz+RbigE4ggr28PxxIjVKxUq335k9nsO6Hu8V2PUKEjabjmXwS4mjW66Dge/FstlBMPdy8c3srnSlKo34zl6jV6q2e2mo22udaAH+7ccTpWVsE2GtrcuWz2Qao962VAf8IkR6vcH5WgPVXR0q9XsrXCvXW6FTNRuLRvWwpt3nr2wfJTL1QgyFGEA2LuSTOny00i5EHd7/58zfb6VJ3cdytFxudGiJWsztePNU58cAUyGYSGrDewoxINJJt1j7I8rUlAxDQd8lStmUazw+6SqUMPClJw54UjcRTe4ls7M7d25G83FO6g2Zy72F0I15IJJKpUqVWiDy4893Xt/fylc541JDkzrCnVGqd8fTJB4Zd1gHWpudygoP9GIYjkBKAj421NY2sj0yMAXllXz0a9vsy+H49I8vlTDK6t70fSaW3722ni/J42OvXth48fHAvnslk87m6IuWT9+8/3EvlcgiUjVpVbs8PR9X68GCO8MvhA5apRVPdYDHZga2zvCfKuC43YSxt6scyRdoJhzhp9QZyo1arJTLxWDp9789/vgc729m+n5KbartRyzy4fX9jex+Glk5WlHqlEt3cqgH+quVSvd1GSrwYtlq9yeHjq4B6FfwXIY81MYdlbDaa2Sxn6dhh7c83yXrpB8Ag7eq0O2hLDUDP5sZePBP/43/95C/b8Uzizuf3MhWpUc7ub21sPIAJlMuJnVJHaSj5nUi1pkgNudhsNpSOovRA2Q/PXqxEx4fIb4lehgkW6hm0B4M2QVhm4VVUP9j3WTI5W304m3TlZqdb2r31Vayk3Pvk3/6Hf7wfzeW+/W+/v5tqKvV0EhvYK0qQPEJtu6fWpHQ0nQUhaUgtZMVdqdXvdtsn528NFv59MbdjkOmJJjvrYqTaLsvkSDJ0tq4EDWQVHvL5+GjcLZZazeL+N19tNdr3/v4X//mfvtstlLc//e3ne7VmqZxNRPfjFXXYkeVirdGXipVKIhLJVOrVcrWcr/Z6YMTj3snTj6IrDBkHMGshh3VHjxUY0b1mQdgUYx0GM+91MdJdPRu0aoVmoxTZ+PpuWdr89De//tN9ZHyp+198kyxXQa+KxWSqOT4atquZfF3JpPJSJZcF/kY39/LxQmPUm57Mp9Pvlx5RH6SS8yVM+VzRMofrCw80xZAVKCebjqxwsnmPnFN7gchfR/wt7d/6Zi+78+1n//xtNFvIJXd2N/MlCLfdLBdLytGjBdfPZ5K7+1W1Wa2V9m//8x/v7sSag/HR8enR2csrP7CcpRgnYSHLZmPb9TU2j0Rb3xIjPIHh6qLFQYxkSdh8faA0pMHhXI3fvbO9v/Pt51/dTxar1VwRtLusjMY9qS7L7eF0rso1gPC9u5tVtSMXMjtf/PLvP7udkHtTZP+vn1+wm+HoIP666JVxxsSA/7M5xwKTK2ZOTGaalo8klDCJjEAzPp61qs3R8fmkuAO8j9756wNkdkW5rTSLsZSCjB8AC78fDlmUiD24s7FVaiuIxLEvP/kvv/82LvUGo6Pzl+9sMY3G/IMNm4BNal/0FdnfBtXyRa/L0MiL7culmIJj21RbPm/LcndxMqtm0/FCIb6bKJYK8mAx7JS39hoHQ6nUbHfqiPHlLOLdg7v7qWJVqpTr2dv/9PvPNwrt4WwwPXv2zgqcgMzfYvnTRaqvswFvsapNtGHEgytwAgPkeMXsW4xPGMbFs67cavf67VqukMw3KvkixD2ZLXqNfCTRnPRLuapUL9Ub1eT+7sbWw+1IIpeXmtKwsnX7u41EA3nDaHL87MJlKd0KRU0dy5msRzuiCIgMSMx+0f5BQjTOwrBtRhYKjLh4dgjyVy4UKrV0utSW87lCe3x4OFJr+WSm0R1ICPSp/Xgqm4zsP9zY3N6NZ6qtwWjaK2ZT+UpbnR4eHb14veIYIYkGOw6iXWeL5o4pWiHQtqsboubG9ooj0m9YIsv2y1en3U4lF4/L+XRK6kixvXipe3QybtZz6Vy23mxL+XL04X2k/tlUfPveZjSWrXSmRwu1rUhVSVJnh8fHb5DPsN1My+ZcAm1d9LRg+WyFgWqxW2WzB0RmivcNqAZf0vXlxaNWvZ5JxlJbG4WuUkxsP0g3e72uXEilcvFYvdVVqomHX31+L1bOZ1KJ/TTMs388P2i3e+1GXRkczIC9dsC2Dts8zGdEgAHQetZ6ioFNANNj64vzRuzci3RU1yEETdMedWoV5LqJr/6abRVyifiDFFCnHIsls8iCK62hmtv44re//vR+Mg/aW8+nsqX+YqQ22j3QJnV2MHv0FMzPopeJ7oclJvToa76YpgPd9V1vKfBHZ9dRFAU5zsJiiKlZF2etmiTVsltfp6v5Yj6VyFbLqf1bt7eTCHKNTk+J3P3DL37xd3/cipbUg3apWKq0ur1as1mv1qod4f4aodRjZ80UAzM+iI9HIzQ8tpZcFrpBvpF8+iw7aIxGFJjBBMS0Xh60Wp1OE8y+UFebDaTglb1b//C7P2/V1Fa9UlLyt3/zN//ml3/YitQnrEBWK3JHkmS5WqoVGt2D6fmFwHsQPzdErHVYyQbUmhoHaFheYz4ohM+mC0QAE9Q9UakV05fa2yO13et2y4VSXhmMughn5d3PfvW3v7qda2GRaqu6/dt/94tff7ObqHVbjWY5X2srjVJDqsqNpjqfHr8Er/SY9jmeL/ANSjYCUVaxV2wWmxaHUn1jyVkXqIPjgQwO+nriVVs97nf7aqtcqhWVk2lXlmvxb//0yb//5MtkLVsoF8v55Bef/PJfHiYT8UqpXM2nK3K302w0pE6nOz1F2k/CZbLVAANgbZtdUBoai2+Gxj4pp+Wcq6WYPrWsAEmwqRssyAOoAEavZuqgB7Ij5dSzoZTJRB7e+uLT3/zuz/vZ6N5eLF1WYl9/fieWjERSxUw1ly5Iw0mvLSEhnZw9f/nDkoPBQFiOLIhxNo63soUvsnGDrVxODYJ8IOHTXDFPxEkKy7oEZphLUMKz4XA8GKuNanPSyCS3dnc3tu/e+vyvm3vbYF5yu1NIZsqlQiKZKZaLyDua08XRtCP1RoenTz/oOvvmyGhvNE6H0emvxVSN5XmmSEbEbIeoCWMD7AkgB+NejZXGDiZo4PuTo9nBqK/Wa9VCNptPxpD8RjY39qOVotwZ9Fv1RqcNLljIZ2qVdB7k5+j08YE6Xpx9/1KjOZu+brKxaDDe0vsNEYhcVr0EA0fKzd/TDFl2sEUzCL6JCAE5WJfvXj+eD7uDjlwul6VGJZcE2BRydRnEetxTO+2GCrzpgX0qrVqpXG8uHj2Gzs7OX19wTIiHE4RGTPbaLCywri2Ga1waA2dfYSUs9yL0X8L0AT0IP54YgGNb4v33h4PesC3J5brabxbypbrUaA36HXUy6LSleqWmdEYjtar2xh25BM0v5tPJ/Pu3HxnRPdZ6OdorGK3IbH3CIMcmRBOKnU06gmi1EfvEzB7+mkyIrSX75++ezpWmLNcz5VZHbtZaUrvb6fRqcrfdlUp5ML7mwViVOuPxrF9rD2aj0Wz25NWH1XrsRoyImmJQa8nplIDsxxJJhkYiJlTB4RACjxhxNJEQa6IMzxlo7OvqzUm3nq+WCjlAS5OkVpFkpVZrNOsdJY9kuDaadKuNyeHprNMZH00mB4fPfgDfYW+XbQxyXKYfhiO6WpeXl8w7PO7JNTlIxtDA+RcOGnJ6E+dmO5ATPXiMu/p4PmwrLH5XK63+8GDca9dKpXKlUampAzmVyjSG054sz56cLwbd3vTx4dGT1ytOa3OmzAxxXAM0T9dFH+9iFa4uTN8WE74GU9AQeOTzhbA3Foo5QEFgEtJAZNTfnc9UtVPLp0vK6OjkZKJKxXSm0pQqylCtF6XmaLHodAanp2eTfn929OTJ2yXHkkV1hXVNJhWOs4R2vdW78P/+z7crR4ySinhkiyFfwb9+HpqxWQ0HIxKzLCCummG+f74Yq8h3q+rh0enhtFNJZUF+kPK0B72m2hjMjmcwvJNTKL+7ePbugikd53xN4qrGuX2sAorvX70P/t//en9pscQX/DzZ5q50MYLM8hiHRokB7rr/ageGzo1pH5/OutVkuj5cjMbjkZx8GM+UYIeD7ng+6Dab8+Oj0Wh++vzwoN9dvF8yuGjMtsAqfHydEhX1zMB4h5DwQQ8dAf14i9mAy/Y0h4ToBBqvHFicyhRzfVQToGD1w6MDRVa6B+NWp9+TI1vb8WKjD2UczNodpTM5PV4s5udn897o4MXSX4/LOyumNRyHtMV8qEbKeXl1tTJ0ylhMiRoshdD7xRSIuGUhxqCIG/RRlscA1rqlv346Gk5w+g7AUMqlUsWKNJwdPz4eNOWO0js6Oz48PD46nB0/vwLcGyFveazYvWNdF1a1csT8jOVqSzbEuS5XxhoaO8Ma5AWPpAFavMcACiqoKIgIHoBfmZc/PDl8dLLojxdztSNVms1WYzw5ODnoAX+7/fH8bH54fPrk6XtTCxzOqjCp9gG+5BKGLebJDWadHDC1OW7FRAPHJjGnxXFUH8Cn62YgSkVsvK3XZ0wyLF27+uHFs0eTg7M5RK52VVWdnE6mk+GwhxQUyf787Oz7Hy5h8yaM3zP1FZvZNlsONkVviGsERF2+Bub7jEiGmH8GDGpkHUtIS2McZBVCjAG4vFZhCPA0Vqvlmxfz+cnxWFUHB93h4Ojx2Wy6GHbVSaOkHj95/u7SEMOPDuhj4JmQrKcxozUE6WPrQUx4GqQkoLs6u5FkZUADzRaJCAHYRE5A/oUX68kbvsKGOYx49fHNoycvjnqj+WJwcDA5fXp0eDZXe7OONHt28fGSjIqVNd/wOLOC1QMd0GJqovBsMtlhtcddT2jBOSkeCsJej1jYxpKXNzg3uc4HRKGAP4uCmWNdmsb7j+/enz96xIWPzp4+PTv//uzx8/PH73Ukbis6EzMoNjd4KQFPXgkhQJ6C/QsSTAbA1J+DSeRCNnsQ9rr8v2Q/xHYDhwOlSMLW/WdSRMQDoIK10q+Wy8v3b948f/ny1eu3b3/48HG5XF7BRz0glSXGhV1OGziCaekC50x2+FesdOi0dUNUAGzdX48D0CxNxh+H0wYG2SnZuXlNuyNSMYg6eJKvMTdc6XDtpba8XF5dXmoabdWwQ900eAXL98QtHAoUGljxSDr8m0pAZHOuNE7EGHyO+XMWojlIDnWTk5uEBZdEgUVgMTPBw+MfTwcr1AV7tkUeo5umzrk9EbFdU1s3DDkDHQhdI97Y6/tjdCrYLgg182zRbBYshzjvQ2dIdlwOAGPjGv3SFMyMs8iGvb6W5nAED1C6cuAMJgOHydyAhs2obrKFDqCGDD2Il9d4QhJ5ZD5iPBKH8DV9LRSqUYypwhQRD3idRMwKcrQcMYhXvDjGvq4IchJN5xweR0DA2gAsokls2kvOSfN7OrUCqNJ4PB7X1X3+zHw2FHm8bonwSrfSOE9DNyO7Cy1RZRboTyLCASVuDscKOJXGWhCvmvFOGCfESZh5sYNcmfzMFohtc2nO67OLxLwCuGKSYfKaFKmVKfxMjHIYa/pvUe9s7vMiAxgH51Z5QYkJDzszOr/mCJ6+RmNWTe2l2B3BZRWwj8Z4LjJ5eqnJa3+8+kD18Af2dsBzsBdxoQjMWtzc4J4cXhsUhTBkgxrjrUkuYokBLyNELEL4pRawU/bFKSCqy/65M42HOcQCS8QwU8AFIU9MyRPmaXOIrBc4wIrwpglDN4mnBHUkHxoW1Tg6TlbMyyYixHIPxCnOsQtuyIk8Rj5iBXszoGIhM0iRyZssFdJEmDu7OisGph6Kqyqcnrf1y//xv68/ajRD0ioOkhMbReeLxJvftsVMpeXpItBAcsw9gJiEQ87AcQLBFWbmriGQPVNeOjPFiAT2S2unpFxeWMRHQs5ZEl1sbfnj//nvqxVbTax5mytWV5nvClPgcAkDPQFK0A8x3qeT8HEylXNoxs+EGMahcTTR5uUTS0QEDixwO2Ialt0yR19yaF2zeePG56g6eKYW2poT0oF1DwGHDkeHIpSZhu+uZ3QpFzq0mD4QBSAOpOvre6csUJGAcn86545N3kIlYtjL9YdBHTRbRBGyJkuU8wBVYnjg8sKk97HUsKKtkwoIwuEZ69RfUD1LXHRwhSlDWvyuoenwIXoEx251c8VLoSKDcDgb+jObMzmZSIfkiC0yWIt6F5RiSWs01hisi3bj8oMtmBzvSliivEpD9nl/yhN3XDRxBY05mEanc+11rYZ3WXVzeekxBHA7hhA7jIBXJHTRxaSsxIP5GYM1XIKPqGDz4qC4CmYLMiM0zh4Yi6CkATr9GTCIt3y6jSvwxF07ow0m5Iq7gPqSFyuxRWA3++JQJC1lKTJGW0QsNtLEfAuHLKmJkILhZLdg39jYhcNbpLob0Og5Z8dCv04cEUUnskTxnyHaEcJMTIFeDhRPasxoQ9lYAaMQyLVQsyZmJkifaZG8tmWLSwEG23nC1xC4nHD55s2FiCK+s2KJ0+SsPAe+bNZ5xAgwGJAmkIhesV7OYP7PQjAHtsTkNR5nITx7LBi7QshQui7mpBAkdbxgI9Fd95HEHS0e23aXL5fvyMzEEXTKnBcIeM2Elyk9AIi46YTNAls5+UA7FfchYVU6ndDRiIoAGk/XCeLC8hikSerB2Jyf2fq6hCdimJjkt4TB2C+vdBb6WdozDFFl4DQACTiDjaj3A24cFj1sQVNZo9U8cRcbFhasRzREldLURFjiaShuYbuEdFZ51+DGbQtWg3DNDdBjNUfcJxINR04Bilk33pMRMz/MMkT3gRIHadd4lcnkodmI4S4M8hVTVNBc6+PS/flyCccGqCOPnBd/nfXdZOGLHLeDDbK0ReM0yYLERT4cI9AQjJfCwGyOXyKskQAARQ3ePWXJxmehBEFPTGT5ZHGsikDqN762AgrQgn9m1o5I09YgJoyUmSadA0Bnc8KMEdsh4VinVkAH7FvMX6+vr5ORL2lXTEGAVKzEueDCnEElCSNjZmXYFJcfmJ4ghpkCBtbYTJbqehqb2bz+x1vjLOnrnPTgbnQx+Cg6L5xzEl/nJQ5Atvf/ASavTQ8xIDEwIDEgMSAjMTgKeJxz941iyC8uSc1nAAARCwMZ"
nm. osteo
endl v +
#@cli osteo_ : Load osteoblast cell image and cell mask 128,128,1,1 (transmitted light)
osteo_ :
e[^-1] "Load osteoblast nucleus example image and mask"
v - l[]
osteo
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTYzIDEgMSAjMjIzCnicVdDLSoJRGIXh5cCxgyYJCgUFlVigRZGZpuXhrrwCRzYpqEFQUVFUUqkdsCztbpo0flv+RSibBzZ78H1r7ZpqCvnIel8hQUQNJrVHTAdM6YgZHTOnUzsnqUsWdUVKt6TVZEV3rOqBNbVYV4eMHtnQE5t6thfy6lLQq71RDPTY1jsl9SkHBlQCn1T/jN6rY++DMeX/Gb9K+mDHs0cVvXu4t+AcW5Z3ppwN82WdNaO2c7ec/95dmiy7V0o3ds2SuyZ1QUJnLNi8Tpj1f0zrkLj2iWqXCdUJK/v9A/ovmeIxIDExIDEgMSAjMjcKeJxzZ/BliGJgYMhnKGYoYUgF0vFAHgApxAN4"
decompress_rle. nm osteo,osteo_
endl v +
#@cli follic : Load follicle cells image from thyroid (transmitted light)
follic :
e[^-1] "Load thyroid follicle nuclei example image from http://karo03.bplaced.net/gmic/Repo/follic.pgm"
v - l[] i http://karo03.bplaced.net/gmic/Repo/follic.pgm nm follic endl v +
#@cli follic_ : Load follicle cells image from thyroid (transmitted light)
follic_ :
e[^-1] "Load thyroid follicle nuclei and mask example image"
v - l[] follic
base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMTMzMyAxIDEgIzE0ODcKeJx1lttv1FUQx2ercrNAbbttt3vvbkv9J9QnLzHGmPhgYryAPvrqkxfAQBC5VIRSiaISE+UWpQERahHQKLQKtHR7sWIpIFGBCoXuvb/f8XNmf+1CiMluzsz3nPOdOTNz5vzEJz5+Ivw3j8+TH41PnjRV8jPjU6ZG+sx94ph75GlTJ0Pgz5gGGTV+edY0yh/8nzNBOW8i8rwJywUTkxeQL+oYk0veOAnXLcYXTROjlZvkJf5TZpG4Ji4vm4Sk4XZZY+WMqUaOqpw1tWLAlyLnsGvxpSYpBVMPHpVlKjfcIbv4YNcX8c/gl+WZxs+75SbkEOtDnhwGD+FbnDNHPDkGXpI3EYsBT3fh+MDMl0HkaTCDrc2mEj2E3ZLezpmGWDejb+VcwyYgeXQXP7dynhHOkcOeQc+ZufIFcR4GzypWz94q2cucjaHB/jXzALGKs78Ou9XyFXxT2L1mFsh13eMH98s+7GWI7xVyd1XX1/Kvl078yZrFcpbzunA57N/PufNwDSi2WONxAKzAnhTxcuGx8fqGsxbhGNR1CzXOB4m7g3+D2Jg292sOv1UsABZj/XzN8SE9cxAsCu88+BJyGNmF18bM0booYUbjW0Fs7pW/+adNs3Qpbtf7wH2aqyz4Yc2NPbePuMWJYRmzfuZn9QTzCWzP6M3UcVL1Q5r3OPMt8LZ4eozcteB/M2vmcx9Cs5hd4xCTk4pFsbMELIlv1dKjtRVlXStYQuPeextW9HLXq7UZYW+r1oeth15iVsIeZK89awC+hlmsqH4HWdeg+UgpFta49uh9CJPDVsWs3INtBx/P3oadxEeHsR+fC+yzOTxJjRWR+zhXDpv2jp0gv3l8PAOWhdvm9SdqLIvt02AZvYtx+YGaTDN/CixNv3CJeSdzvxC3KWzZuO/TuCSp4UXYTlKzC4lnk/wLX5H53WaOHIdrnLlXsX2e8RV8HNMxKOcYl+HX74x7uCNHiN8o/F9Tq0c542/gndg+yj0YgK+T+SNw9iPvZ99axgPwrMXGCerqOtzvcZ5T1EyB+5HTMcJ8hFhV41MFelTeJXYpYlBg7Rp4BuDNwLGaMcWZ05xhld6bAHFJyHLq5IwnP4q9HONjcNjxcbjzjE/AWx6TsoE9J+C3chvx6YW/gLwJ3l+R7drN2OrTWk7IFvj7VbY9pYIeE9J7W9J99JQovpX1Du8e5MC3wjuscgw8qfclA/4huRtBThOXDuRhsFvwdlAjIyoH2VuSb2K/HXmY80zi1xaVw+SyFj+XUOMhmaCvbPLkK+SkDXkQjkv4sw45Bcdr2DlLLb1F/CfJZT8xXU492LveB9cKOGxMTjOu1F6XIDaV4AFqqIlarJA34XQ4y8PYd/DtEe07Ee7vAnpzTHtLFzXSrv08JN3USAd7HXLaDec2fSNsrTTKR9ob/MhB+Ri7Oe5EN/u340+Oev0O3u1a03Pgj1Jj9i60yE7s7MeG7TM7sXOQvBXAd2GnC+4i8m64u/HbynuQrQ3bQ/Zi53t9L5pVPqpvSUk+pu9M8i75uL5TiVm5yH9GtnW6B7mH2EwTa1frJ6pYBmyUcxitjTA+JRnncscWa+/L4ccujUEl73eVrssRly81XlVyWd/kuN6NCX2nbExr6M+1ut/Rs/rkc+1bdeTdr7jtTTu0d9fzDtVpD7V52aF9q4F3q057kO05O7QfBeAv9Ty79jPtR0HqawaLg9XrG1XGmsD8ynND14cV+5TasX30hvcdYHvRJ5wvr98kZWwbNZi+A0vKeuzcvE3fAF9Zb5aN/6O7+ibM6EHt1y65fh87Jb1R9TZPd/V7ZYmnhzROjqdP6rxfa2Wj6vZbpUbfLOvPpMawdE/Wqx7R9zvn+X8D3SHnGebWqR7mnD7WxehtUeIXkj9ZswZ5Ar8uoq9Gt/I4cVzF+qv4N4ZP7+DLP+TqHP6sZP4v8j5KTbzN/GX9rlkkbzB3Afsp3vfXwcb4HngIfIQ7s2LoP/Px/+AxIDEyIDEgMSAjMjkKeJxzZ/BliGJgYEhjyGfIAcJMhmSGeCAfADE2A8c="
decompress_rle.
nm follic,follic_
endl v +
#@cli gwyddionread : _filename
#@cli : Read gwyddion ASCII file and produce image
#@cli : Data beginning after "Start of Data:" are imported
#@cli : [x-length, y-length, x-offset, y-offset, header lines] are returned in ${}
#@cli : gwyddion Example header
#@cli : |# File Format = ASCII
#@cli : |# Created by Gwyddion 2.48
#@cli : |# Original file: gwyddion_Example.asc
#@cli : |# x-pixels = 640
#@cli : |# y-pixels = 480
#@cli : |# x-length = 313789.96127244376
#@cli : |# y-length = 235219.70492879587
#@cli : |# x-offset = 0
#@cli : |# y-offset = 0
#@cli : |# Bit2nm = 1.0
#@cli : |# Start of Data:
gwyddionread : skip "${1=gwyddion_Example.asc}"
e[^-1] "Read gwyddion ASCII text data: "$1
v -
l[]
i raw:"$1",uchar nm={b}
s +,10
size_x=-1 size_y=-1
len_x=-1 len_y=-1
offs_x=-1 offs_y=-1
bit2nm=-1
hend=-1
repeat $!
if   {same(['{$>,t}'],'"# x-pixels ="',12)} rows[$>] 12,100% size_x={{$>,t}}
elif {same(['{$>,t}'],'"# y-pixels ="',12)} rows[$>] 12,100% size_y={{$>,t}}
elif {same(['{$>,t}'],'"# x-length ="',12)} rows[$>] 12,100% len_x={{$>,t}}
elif {same(['{$>,t}'],'"# y-length ="',12)} rows[$>] 12,100% len_y={{$>,t}}
elif {same(['{$>,t}'],'"# x-offset ="',12)} rows[$>] 12,100% offs_x={{$>,t}}
elif {same(['{$>,t}'],'"# y-offset ="',12)} rows[$>] 12,100% offs_y={{$>,t}}
elif {same(['{$>,t}'],'"# Bit2nm ="',10)}   rows[$>] 10,100% bit2nm={{$>,t}}
elif {same(['{$>,t}'],'"# Start of Data:"',16)} hend=$> break
fi
done
if {$hend>0}
rm[0-{$hend+1}] a y
discard 13
file_tmp=${-file_rand}
if {$!>1} o.. raw:$file_tmp,uchar rm.. i dlm:$file_tmp nm. $nm
o.. raw:${file_tmp}_,uchar rm.. i dlm:${file_tmp}_ nm. ${nm}_ file_rm ${file_tmp}_
else o raw:$file_tmp,uchar rm i dlm:$file_tmp nm. $nm
fi
file_rm $file_tmp
else
rm
fi
u [$len_x,$len_y,$offs_x,$offs_y,$bit2nm]
endl
v +
#@cli wykoread : _filename
#@cli : Read Wyko/Bruker/Vision ASCII file and produce image(s)
#@cli : Data preceded by "RAW_DATA" and/or "Intensity" are imported
#@cli : Wyko Example header
#@cli : |Wyko ASCII Data File Format 0 1 1
#@cli : |X Size 640
#@cli : |Y Size 480
#@cli : |Block Name Type Length Value
#@cli : |Wavelength 7 4 71.992500
#@cli : |Aspect 7 4 1.000000
#@cli : |Pixel_size 7 4 0.000985
#@cli : |Magnification 8 8 10.050000
#@cli : |ScannerSpeed 7 4 2.315832
#@cli : |RAW_DATA 3 1228800
wykoread : skip "${1=Wyko_Example.ASC}"
e[^-1] "Read Vision surface profilometry OPD text data: "$1
v - l[]
i raw:"$1",uchar nm={b}
s +,10
size_x=-1 size_y=-1 hend=-1 rend=-1
repeat $!
if   {same(['{$>,t}'],'"X Size"',6)} rows[$>] 6,100% size_x={{$>,t}}
elif {same(['{$>,t}'],'"Y Size"',6)} rows[$>] 6,100% size_y={{$>,t}}
elif {same(['{$>,t}'],'"RAW_DATA"',8)} hend=$>
elif {same(['{$>,t}'],'"Intensity"',9)} rend=$> break
fi
done
if {$hend>0}
rm[0-{$hend+1}]
if {$rend>$hend} a[0-{$rend-$hend-3}] y rm[1,2] a[1--1] y else a y fi
replace_str "Bad","nan"
discard 13
file_tmp=${-file_rand}
if {$!>1} o.. raw:$file_tmp,uchar rm.. i dlm:$file_tmp nm. $nm
o.. raw:${file_tmp}_,uchar rm.. i dlm:${file_tmp}_ nm. ${nm}_ file_rm ${file_tmp}_
else o raw:$file_tmp,uchar rm i dlm:$file_tmp nm. $nm
fi
file_rm $file_tmp
rotate -90,0
else
rm
fi
endl v +
#@cli pseudo_c : Pseudo coloring of greyscale image
pseudo_c : v - if {s!=1} to_gray. fi {iM},1,1,3,u(255) round. map.. . rm.  v +
#@cli sincos : _w(512), _h(512), _new(0)
#@cli : testimage
#@cli : $ sincos , +shift. 50%,0,0,0,2 +shift.. 0,50%,0,0,2 a c
sincos :
skip "${1=512},${2=$1},${3=0}" v - l[]
if {!!$3&&$_version>=216} $1,$2,1,1,'begin(a=pi*w;b=pi*h);i=sin(a/(x+1))*cos(b/(y+1));if(i<=0,i+=1,i);i*255'
else
$1,$2,1,1,'begin(a=pi*w;b=pi*h);sin(a/(x+1))*cos(b/(y+1))'
+f. 'sign(i)' eq. 1 +neq. 1 *[1] ... *. ... n[-1,-2] 0,255
f[-1,-2] 'if(i==255,0,i)' +[-1,-2] rm..
fi
nm. sincos endl v +
#@cli karo_luminance : _type = [itur1990 | itur1990-2 | gmic | gmic-2]
#@cli : Compute luminance of selected RGB images according
#@cli :   itur1990 | itur1990-2 sqr/sqrt | gmic luminance | sqr/sqrt gmic luminance.
#@cli : sRGB RGB and back only with gmic!
#@cli : Default _type=itur1990
#@cli : $ image.jpg +karo_luminance ,
karo_luminance : skip ${1=itur1990}
e[^-1] "Compute luminance $1 of image$?."
v - remove_opacity if {['"$1"']=='gmic'" || "['"$1"']=='gmic-2'} srgb2rgb fi
repeat $! l[$>]
if {s==3} sh 0,0 sh[0] 1,1 sh[0] 2,2
if   {['"$1"']=='gmic'} *[1] 0.299 *[2] 0.587 *[3] 0.114 +[1-3] rm[1]
elif {['"$1"']=='gmic-2'} sqr *[1] 0.299 *[2] 0.587 *[3] 0.114 +[1-3] sqrt rm[1]
elif {['"$1"']=='itur1990-2'} sqr *[1] 0.212655 *[2] 0.715158 *[3] 0.072187 +[1-3] sqrt rm[1]
else *[1] 0.212655 *[2] 0.715158 *[3] 0.072187 +[1-3] rm[1] fi
elif {s!=1} norm n 0,255
fi endl done
channels 0
if {['"$1"']=='gmic'" || "['"$1"']=='gmic-2'} rgb2srgb fi
v +
#@cli karo_close : '_size>0','_shape=0|1|2' (square|octagon|circle),'_invert=0|1','_scale=0|1',
#@cli : '_channel=0..33' ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : Morphological closing (dilate and erode) of given size (only 2d)
#@cli :  with fx_morpho_v2 and implicitly apply_channels!
#@cli : $ image.jpg  +karo_close 15 +karo_close[0] 15,1 +karo_close[0] 15,2 rm[0]
karo_close :
e "Compute closing image$?, with size $1 (only 2d)."
skip ${1=5},${2=0},${3=0},${4=0},${5=0} check $2<3 v -
if {$_version<175} fx_morpho 3,$1,$3,$2,$5,$4
else fx_morpho_v2 3,$2,$1,"1,0,1; 0,1,0; 1,0,1",$3,1,$5,$4
fi v +
#@cli karo_open : '_size>0', '_shape=0|1|2' (square|octagon|circle), '_invert=0|1', '_scale=0|1',
#@cli : '_channel=0..33 ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : Morphological opening (erode and dilate) of given size (only 2d)
#@cli :  with fx_morpho_v2 and implicitly apply_channels!
#@cli : $ image.jpg  +karo_open 15 +karo_open[0] 15,1 +karo_open[0] 15,2 rm[0]
karo_open :
e "Compute opening image$?, with size $1 (only 2d)."
skip ${1=5},${2=0},${3=0},${4=0},${5=0} check $2<3 v -
if {$_version<175} fx_morpho 2,$1,$3,$2,$5,$4
else fx_morpho_v2 2,$2,$1,"1,0,1; 0,1,0; 1,0,1",$3,1,$5,$4
fi v +
#@cli karo_doc : '_size>0','_shape=0|1|2' (square|octagonal|circular),
#@cli : '_channel=0..33' ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : compute difference of open+close and original (only 2d)
#@cli : $ image.jpg +karo_doc 15,2,5
karo_doc :
e "Compute difference of open/close and original image$?, with window size $1 (only 2d)." v -
skip ${1=5},${2=1},${3=0}
repeat $! l[$<]
+karo_open[0] $1,$2,0,0,$3 +karo_close[0] $1,$2,0,0,$3
+[-2,-1] /. 2 -
endl done v +
#@cli karo_doo : _size1>0,_size2>0,_type=0..3 (ero/dil/open/close),_shape=0|1|2 (sqaure|octagon|circle),'_scale=0|1',
#@cli : '_channel=0..33' ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : Compute difference of math. morph operation on selected images (only 2d).
#@cli : $ image.jpg +karo_doo 10,15,2,2,0,3
karo_doo : skip ${1=5},${2=7},${3=2},${4=1},${5=0},${6=0}
e[^-1] "Compute difference of mm op on image$?, with sizes $1 and $2 (only 2d)." v -
repeat $! l[$<]
+fx_morpho. $3,$1,0,$4,$6,0
fx_morpho.. $3,$2,0,$4,$6,0
if {{${3}&1}==0} rv[-2,-1] fi
-[-2,-1]
if {$5==1} n. 0,255 fi
endl done v +
#@cli karo_label_sort :
#@cli : Rearrange a label image (the selected image) according to the region size
#@cli : $ 400,400 rand 0,1 b 3 ge 50% label 0,1 karo_label_sort threshold 50%
#@cli : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label_sort :
e[^-1] "Sort labelled image$? by region size."
v - repeat $! l[$>]
nb={1+iM} mn={im} +histogram. $nb,0,{$nb-1}
100%,1,1,1,x a[-2,-1] y sort. -,x rows. 1
100%,1,1,1,x a[-2,-1] y sort. +,x rows. 1
map.. . rm.
endl done v +
#@cli karo_label : tolerance>=0,is_high_connectivity={ 0 | 1 },sort={ 0 | 1} : (+)
#@cli : Label connected components in selected images and possibly sort by region size.
#@cli : Default values: 'tolerance=0', 'is_high_connectivity=0' and 'sort=0'.
#@cli : $ image.jpg luminance threshold 60% label 0 normalize 0,255 map 0
#@cli : $ 400,400 set 1,50%,50% distance 1 mod 16 threshold 8 karo_label 0,,1 mod 255 map 2
#@cli : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label : check "$1>=0" skip ${2=0} skip ${3=0}
e[^-1] "Label connected components on image$?, with tolerance $1, "${-arg\ 1+!$2,high,low}" connectivity and "${-arg\ 1+!$3,sorted,unsorted}
v - repeat $! l[$>]
label. $1,$2
if {$3}
nb={1+iM} +histogram. $nb,0,{iM}
100%,1,1,1,x a[-2,-1] y sort. -,x rows. 1
100%,1,1,1,x a[-2,-1] y sort. +,x rows. 1
map.. . rm.
fi
endl done v +
#@cli karo_segmentarea : low
#@cli : Get all 4-connected non-zero regions of area>=low
#@cli : Delete small regions
#@cli : Number of remaining objects in status
karo_segmentarea :
check "$1>0"
v - repeat $! l[$>]
neq. 0 label_fg. 0,0 +histogram. {iM+1},0,{iM} =. 0,0 ge. $1
map.. . u {is} rm.
endl done v +
#@cli karo_zerleg : Partition of binary image zero areas
#@cli : using pink watershed (https://pinkhq.com/hg/pink/file/tip/src/com/wshedtopo.c)
#@cli : $ sp 6 to_gray +threshold 140 +karo_zerleg. negate. label_fg. 0
#@cli : Author : <i>KaRo</i>. Latest update : <i>2017/11/30</i>.
karo_zerleg :
e[^1] "Partition of binary image$? with pink watershed" v -
repeat $! l[$>]
+distance. 1 pink_wshed. 8,1 f. j(0,0)!=j(1,1)||j(1,0)!=j(0,1) skeleton. , or[0,-1]
endl done v +
#@cli karo_threshold : _method={ triangle | yen | otsu | _otsu | bgt | intermeans | intera | rats | fixnnn | huang | huang2 | li },_delclass>0,_smooth>0
#@cli : Calculate threshold (from ImageJ) in range [0,255], evtl. normalization necessary.
#@cli : For each method user function _karo_"_method" is called!
#@cli : If {_delclass > 0} delete cluster {_delclass-1}.
#@cli : If {_smooth > 0} blur_x histogram with amplitude _smooth.
#@cli : No histogram processing for otsu, rats and intera!
#@cli : $ image.jpg luminance. karo_threshold. otsu
karo_threshold : skip ${1="triangle"} skip ${2=0} skip ${3=0}
e[^-1] "Calculate "$1" thresholded mask from images$? with histogram in range [0,255] and binsize 1."
v -
if ${-strcontains\ $1,fix} meth=fix
else meth=$1 fi
if {['$meth']=='otsu'} otsu 256
elif {['$meth']=='rats'} karo_rats ,
elif {['$meth']=='intera'} threshold
else repeat $!
l[$>]
if {['$meth']=='fix'} _karo_fix ,,$1
else +histogram. 256,0,255
if {$2>0} =. 0,{$2-1} fi
if {$3!=0} tot={is} /. $tot blur_x. $3 /. {is} *. $tot round. fi
+_karo_$meth. 0,1 rm.
fi
th=${}
threshold[0] $th
if {$>==0} sres=$th else sres=$sres,$th fi
endl done u $sres fi
v +
#@cli _karo_fix : 0,1,fixnnn
#@cli : fix threshold nnn returned in status
_karo_fix :
skip "${1=0} ${2=1} ${3=fix005}"
u ${-strreplace\ $3,fix,\ }
#@cli _karo_triangle : _minval,_bins
#@cli : Calculate triangle threshold (from ImageJ auto thresholder)
#@cli : tested only with 256 classes from 0 to 255
#@cli : $ image.jpg luminance +histogram 256,0,255 _karo_triangle. , +threshold[0] ${}
_karo_triangle : skip "${1=0} ${2=1}"
e[^-1] "Calculate triangle threshold from 1d histogram$? in range ["$1","{$1+(w-1)*$2}"]."
v -
repeat $! l[$>]
ac=${-autocrop_coords.} wd={w}
min={${-arg\ 1,$ac}} if {$min==1&&{@0}!=0} min=0 fi
if {$min>0} min={$min-1} fi
min2={${-arg\ 4,$ac}} if {$min2<{$wd-1}} min2={$min2+1} fi
dmax={iM} max={xM}
if {($max-$min)<($min2-$max)}
inverted=1 mirror[0] x min={$wd-1-$min2} max={$wd-1-$max}
else inverted=0 fi
if {$min==$max} split=$min else
nx={i($max)} ny={$min-$max}
d={sqrt($nx*$nx+$ny*$ny)}
nx={$nx/$d} ny={$ny/$d}
d={$nx*$min+$ny*i($min)}
+f. x *. $nx *.. $ny +[-1,-2] -. $d
crop. {$min+1},$max
if {$inverted} split={$wd-(xM+$min)} else split={xM+$min+1} fi
fi
res={$1+$split*$2}
if {$>==0} sres=$res else sres=$sres\,$res fi
rm[0]
endl done u $sres v +
#@cli _karo_yen : _minval,_bins
#@cli : Calculate yen threshold (from ImageJ auto thresholder)
_karo_yen :  skip "${1=0} ${2=1}" v -
repeat $! l[$>]
if $> r_yen=${} fi
autocrop_coords. 0 range=${} mn=${-arg\ 1,$range} mx=${-arg\ 4,$range}
/. {is}
+cumulate.
+sqr.. cumulate.
+mirror... x sqr. cumulate. mirror[-1,-4] x
*[-1,-2] log. replace_inf. {iM} *. -1
+*.. -1.0 +. 1.0 *[-1,-3] log.. replace_inf.. {iM} *.. 2.0
+[-1,-2] k.
if {$mn>0} repeat $mn =. 0,$> done fi
if {$mx<(w-1)} repeat {w-$mx} =. 0,{$mx+$>} done fi
res={xM*$2+$1}
rm.
if $> u $r_yen,$res else u $res fi
endl done v +
#@cli _karo__otsu : _minval(0) _bins(1)
#@cli : Calculate otsu threshold from a histogram
#@cli : with class o = _minval and bin size = _bins
#@cli : Threshold is stored in status
#@cli : $ image.jpg to_gray +histogram 256,0,255 _karo__otsu , threshold ${}
_karo__otsu : skip "${1=0} ${2=1}" v -
l.
/. {is}
+cumulate. x
++. -1. negate.
+f. "x" +*[0] . rm.. cumulate. x
++. {-iM} negate.
/.. [-4]
/. ...
-[-2,-1] sqr.
*[-1--3] replace_nan. 0.0
u {xM*$2+$1}
rm
endl
v +
#@cli _karo_bgt : _minval,_bins
#@cli : Autothreshold using SD from whole image starting from the mode of the histogram (image range 0,255)
_karo_bgt: skip "${1=0} ${2=1}" v - fact=1.5
l.
hft=${-hist_feature\ -2} mn=${-arg\ 5,$hft} mx=${-arg\ 6,$hft} sd=${-arg\ 4,$hft} md=${-arg\ 1,$hft}
if {($mx-$md)<=($md-$mn)} res={$md-$fact*$sd}
else res={$md+$fact*$sd} fi
u {$res*$2+$1} rm
endl v +
#@cli _karo_intermeans : _minval,_bins
#@cli : Calculate intermeans threshold (from ImageJ autothreshold IsoData)
#@cli : from last selected data and store it in status
_karo_intermeans : skip "${1=0} ${2=1}"
e[^-1] "Calculate intermeans threshold from last selected (1d) histogram$? in range ["$1","{$1+(w-1)*$2}"]." v -
l. if {h>1||d>1||s>1} u "?" else
split={"
min=0; while(i(min)==0,min++);
max=w; while(i(max)==0,max--);
if(min>=max,res=w/2,
mvI=min;
do(sum1=sum2=sum3=sum4=0.0;
for(id=min,id<=mvI,id++,sum1+=id*i(id);sum2+=i(id));
for(id=mvI+1,id<=max,id++,sum3+=id*i(id);sum4+=i(id));
res=(sum1/sum2+sum3/sum4)/2.0;mvI++,
(mvI+1)<=res&&mvI<(max-1)));
round(res)"} rm
u {$1+$split*$2} fi
endl v +
#@cli karo_rats : _pow(0.5)
#@cli : Robust automatic threshold selection (Kittler et al. 1985)
#@cli : Input image (not histogram similar otsu!)
karo_rats :
check ${1=0.5}>0
e[^-1] "Calculate rats from image$? with power "$1"." v -
repeat $! l[$>]
+gradient_norm. pow. $1 gr={is} *. .. gri={is} res={$gri/$gr} rm.
threshold. $res
if {$>==0} sres=$res else sres=$sres\,$res fi
endl done
u $sres v +
_karo_huang : skip "${1=0} ${2=1}"
huang={"
threshold=-1;
first_bin=0;
for(ih=0,ih<w,if(i(ih)!=0,first_bin=ih;break());ih++);
last_bin=w-1;
for(ih=w-1,ih>=first_bin,if(i(ih)!=0,last_bin=ih;break());ih--);
term = 1.0 / ( last_bin - first_bin );
mu_0=["{^}"];
sum_pix = num_pix = 0;
for ( ih = first_bin, ih < w, sum_pix += ih * i(ih); num_pix += i(ih);
mu_0[ih] = sum_pix / num_pix; ih++ );
mu_1 = mu_0;
sum_pix = num_pix = 0;
for (ih = last_bin, ih > 0, sum_pix+=ih*i(ih);
num_pix += i(ih);
mu_1[ih-1] = sum_pix / num_pix; ih-- );
min_ent = 1e31;
for (it = 0, it < w,
ent = 0.0;
for (ih = 0,ih<=it,
mu_x = 1.0 / ( 1.0 + term * abs(ih - mu_0[it]));
if (!((mu_x  < 1e-06)||(mu_x > 0.999999)),
ent += i(ih) * ( -mu_x * log ( mu_x ) - ( 1.0 - mu_x ) * log ( 1.0 - mu_x )));
ih++);
for (ih = it + 1, ih < w,
mu_x = 1.0 / ( 1.0 + term * abs (ih - mu_1[it]));
if (!((mu_x  < 1e-06)||(mu_x > 0.999999)),
ent += i(ih) * ( -mu_x * log ( mu_x ) - ( 1.0 - mu_x ) * log ( 1.0 - mu_x )));
ih++);
if (ent < min_ent, min_ent = ent; threshold = it; _(print(min_ent,threshold)));
it++ );
threshold"}
u {$huang*$2+$1} rm
_karo_huang2 : skip "${1=0} ${2=1}"
huang2={"
for(first=0,first<w&&i(first)==0,first++);
for(last=w-1,last>first&&i(last)==0,last--);
if(first==last,break());
S=["{^}"]; W=S;
S[0]=i(0);
for(ii=max(1,first),ii<=last,S[ii]=S[ii-1]+i(ii);W[ii]=W[ii-1]+ii*i(ii);ii++);
C=last-first;
Smu=S;
for(ii=1,ii<(C+1),mu=1/(1+ii/C);Smu[ii]=-mu*log(mu)-(1-mu)*log(1-mu);ii++);
bestThreshold = 0;
bestEntropy = 1e31;
for(threshold=first,threshold<=last,
entropy=0; mu=round(W[threshold]/S[threshold]);
for(ii=first,ii<=threshold,entropy+=Smu[abs(ii-mu)]*i(ii);ii++);
mu=round((W[last] - W[threshold]) / (S[last] - S[threshold]));
for(ii=threshold+1,ii<=last,entropy+=Smu[abs(ii-mu)]*i(ii);ii++);
if(bestEntropy>entropy,bestEntropy=entropy;bestThreshold=threshold);
threshold++);
bestThreshold"}
u {$huang2*$2+$1} rm
_karo_li : skip "${1=0} ${2=1}"
li={"
tolerance=0.5;
num_pixels=0;
mean = 0.0;
for (ih = 0, ih < w, ih++, num_pixels += i(ih);mean += ih * i(ih));
mean /= num_pixels;
new_thresh = mean;
do(
old_thresh = new_thresh;
threshold = (old_thresh+0.5);
sum_back = 0;
num_back = 0;
for ( ih = 0, ih<=threshold, ih++,
sum_back += ih * i(ih);
num_back += i(ih));
if(num_back == 0,mean_back=0.0,mean_back=(sum_back/num_back));
sum_obj = 0;
num_obj = 0;
for ( ih = threshold + 1, ih < w, ih++,
sum_obj += ih * i(ih);
num_obj += i(ih));
if(num_obj == 0,mean_obj=0.0,mean_obj=(sum_obj/num_obj));
temp = ( mean_back - mean_obj ) / ( log ( mean_back ) - log ( mean_obj ) );
if (temp < -2.220446049250313e-16, new_thresh=floor(temp - 0.5),new_thresh=floor(temp + 0.5)),
abs(new_thresh-old_thresh)>tolerance);
threshold"}
u {$li*$2+$1} rm
#@cli _kr_histogram : _nb_levels>0[%],_value0[%],_value1[%]
#@cli : Computes the histogram and returns in status the value of first class and the bin size
#@cli : _nb_levels
#@cli : _value0
#@cli : _value1
#@cli : Default values: 'nb_levels=256', '_value0=0%', '_value1=100%'
#@cli : $ sp barbara /. 2 +. 32 _kr_histogram , e ${} dg 600,300,3
_kr_histogram : skip "${1=256} ${2=0%} ${3=100%}" v -
if ${-is_percent\ $2} mn={im+(iM-im)*$2} else mn=$2 fi
if ${-is_percent\ $3} mx={im+(iM-im)*$3} else mx=$3 fi
u {$mn},{($mx-$mn)/($1-1)}
histogram. ${1-3} v +
#@cli _kr_histogram8 : _nb_levels>0[%],_value0[%],_value1[%]
#@cli : same as _kr_histogram, still defaults to byte data (256,0,255) instead of (256,0%,100%)
#@cli : $ sp dog _kr_histogram8 {iM-im+1},{im},{iM} e ${} dg 600,300,3
_kr_histogram8 : skip "${1=256} ${2=0} ${3=255}" v - _kr_histogram. ${1-3} v +
#@cli hist_percentile : _nth[%],_zero={0|1},_min0,_stepw
#@cli : Estimation of _nth percentiles (lower & upper) from histogram and returning value(s) in status (${})
#@cli : _zero Class 0 is zeroed if !=0
#@cli : _min0 value of class 0
#@cli : _stepw value of class width (bin size)
#@cli : Default values: 'nth=25%', '_zero=0', '_min0=0', '_stepw=1'
#@cli : $ image.jpg luminance +dh ,,256,0,255 histogram.. 256,0,255 hist_percentile.. , rm.. t=${} text $t,40,5,23,1,128
hist_percentile :
check "${1=25%}>=0"
skip ${2=0},${3=0},${4=1}
e[^-1] "Calculate $1 percentile from 1d histogram$?."
v - repeat $!
l[$>]
if {h>1||d>1||s>1} v + e[^-1] "Image "$>" seemingly not 1d!" v - continue fi
if {$2!=0} set. 0,0 fi
m0={is}
N={if(${"-is_percent $1"},$m0*$1,$1)}
if {{$m0*$1}==0} N=1 O=$m0 else O={$m0-$N} fi
+cumulate.
+ge. $N mn={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} rm.
+ge. $O mx={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} rm[-1,-2]
res=$mn\,$mx
if {$>==0} sres=$res else sres=$sres\,$res fi
endl
done u $sres v +
#@cli hist_feature : _nofeature>=-2,_nth>0,_zero={0|1},_min0,_stepw,_percent[%]>0
#@cli : Estimation from histogram (frequency dist, 1d image) the features
#@cli :  'mode','sum' (m0),'mean' (m1),'SD' (m2),'min','max','median','iqr' (hiq-loq+1),'loq','hiq' returned in status (${}).
#@cli : nofeature=-2 mode,m0,m1,m2,min,max,med,iqr,loq,hiq,
#@cli :   -1 mode,0 sum,1 mean,2 SD,3 min,4 max,5 median,
#@cli :    6 iqr (interquantile range),7 loq (lower quantile),8 hiq (higer qunatile)
#@cli : nth extreme value (nth+1 occurence!)
#@cli : zero Class 0 is zeroed if !=0
#@cli : min0 value of class 0
#@cli : stepw value of class width (bin size)
#@cli : percent quantile
#@cli : Default valalues: '_nofeature=-2', '_nth=1', '_zero=0', '_min0=0', '_stepw=1', '_percent=25%'
#@cli : Updated 140314 (smoothing replaced by nth selection)
#@cli : Updated 100817 (percent parameter and iqr,loq,hiq feature added)
#@cli : $ image.jpg luminance +histogram 256,0,255 dh.. ,,256,0,255 hist_feature , repeat 8 t={_arg($>+1${})} text $t,40,{$>*25+5},23,1,128 done rm.
hist_feature :
check "${1=-2}>=-2&&$1<=8&&isint($1)&&isint(${2=1})&&$2>0"
skip ${3=0},${4=0},${5=1},${6=25%}
e[^-1] "Calculate md,m0,m1,m2,$2.min,$2.max,med,iqr,loq,hiq from 1d histogram$?."
v -
repeat $!
l[$>]
if {h>1||d>1||s>1} v + e[^-1] "Data["$>"] seemingly not 1d!" v - continue fi
if {$3!=0} =. 0,0 fi
md={xM*$5+$4}
m0={is}
+*. 'x*$5+$4' m1={is/$m0} rm.
+*. '(x*$5+$4)^2' m2={sqrt(is/$m0-$m1^2)} rm.
mn={"l=0; su=i(0); while(su<"$2"&&l<w, l++; su+=i(l)); l*"$5"+"$4}
mx={"l=w; su=0; while(su<"$2"&&l>=0,l--; su+=i(l)); l*"$5"+"$4}
med1={"l=0; su=0; while(su<=(is/2)&&l<w, su+=i(l); l++); l"}
med2={"l=w; su=0; while(su<=(is/2)&&l>=0, l--; su+=i(l)); l"}
med={($med1+$med2)/2*$5+$4}
hist_percentile. $6,$3,$4,$5 qu=${}
hiq=${-arg\ 2,$qu}
loq=${-arg\ 1,$qu}
iqr={${-arg\ 2,$qu}-${-arg\ 1,$qu}+1}
if {$iqr<-1} iqr-=2 fi
res=$md\,$m0\,$m1\,$m2\,$mn\,$mx\,$med\,$iqr\,$loq\,$hiq
if {$1>-2} res=${-arg\ {$1+2},$res} fi
if {$>==0} sres=$res else sres=$sres\,$res fi
endl
done u $sres v +
#@cli hist_feature_demo : Parameters like in hist_feature
#@cli : (Plot) of features in blue into the histogram with Gaussian in green
#@cli : $ sp 0 luminance +threshold 40 * histogram 256,0,255 = 0,0 hist_feature_demo , dg 600,300,3
hist_feature_demo :
check "${1=-2}>=-2&&$1<=8&&isint($1)&&isint(${2=1})&&$2>0"
skip ${3=0},${4=0},${5=1},${6=25%}
e[^-1] "Plot features from hist_feature into 1d histogram$?." v -
l.
hist_feature. -2,${2-6} vv=${}
md=${-arg\ 1,$vv} m0=${-arg\ 2,$vv} m1=${-arg\ 3,$vv} m2=${-arg\ 4,$vv}
mn=${-arg\ 5,$vv} mx=${-arg\ 6,$vv} med=${-arg\ 7,$vv}
lo=${-arg\ 9,$vv} hi=${-arg\ 10,$vv}
+gaussian. $m2,0,0 shift. {-w/2+$m1} *. {$m0/is} round. 1
v={iM#-2}
+*. 0
=. $v,$md =. $v,$m1 =. {$v*0.25},$mn =. {$v*0.25},$mx =. $v,$med
=. {$v*(1-$6)},$lo =. {$v*(1-$6)},$hi
a c
u $vv
endl v +
#@cli karo_nth_max : _n(1),_ind(=0)
#@cli : Return in the status the _n-th max or the index of the n-th max of an image
#@cli : Possibility to fetch the index instead of the value (_ind=1)
karo_nth_max : check "isint(${1=1}) && $1>0" skip ${2=0}
e[^-1] "Return in the status the $1-th max of image$?."
v - repeat $! l[$>]
if {$2} eval argkth(-$1,{^}) u {${}-1} else eval kth(-$1,{^}) fi mx=${}
if {$>==0} mx1=$mx else mx1=$mx1,$mx fi
endl done u $mx1 v +
#@cli karo_nth_min : _n(1),_ind(=0)
#@cli : Return in the status the _n-th min of an image or the index of the _n-th min of an image
#@cli : Possibility to fetch the index instead of the value (_ind!=1)
karo_nth_min : check "isint(${1=1}) && $1>0" skip ${2=0}
e[^-1] "Return in the status the $1-th min of image$?."
v - repeat $! l[$>]
if {$2} eval argkth($1,{^}) u {${}-1} else eval kth($1,{^}) fi mn=${}
if {$>==0} mn1=$mn else mn1=$mn1,$mn fi
endl done u $mn1 v +
#@cli karo_xcimg : programname ,parameterlist :
#@cli : Call external CImg Example 'programname'
#@cli : which has to be found in PATH by external call by
#@cli : 'programname' image_in 'parameterlist' image_out
#@cli : with writing image_in and reading after execution image_out
karo_xcimg :
filename=${-file_rand}
if {!${-is_windows}}
x "which "$1" >/dev/null 2>&1"
if ${} v + e "executable "$1" not found in PATH, status = "${}"!! Returning!!\n" v -
{w},{h} fx_logo "exec Error !!" return fi
fi
o ${filename}.cimg
x "$1 -i "${filename}".cimg $2 -o "${filename}".cimg"
if ${} v + e "Status is "${}"." v - {w},{h} fx_logo "exec Error !!"
else i ${filename}.cimg fi
file_rm ${filename}.cimg
#@cli karo_li2st : p1,p2,...,pn
#@cli : Convert comma separated list to space separated string.
karo_li2st :
v - u "" if {$#>=1} ({"'${1--1}'"}) replace. {','},{"' '"} u {t} rm. fi v +
#@cli karo_skeleton : _p1,..,p2n : (-median,0,-inv,0|1,-t,-0.3,-curve,0|1,-corr,0|1,-dlt,1)
#@cli : Execute use_skeleton (CImg demo) external.
karo_skeleton : v - if {$#>0} karo_li2st ${1--1} p=${} else p="" fi v +
e "Compute use_skeleton exec with options "$p" on$?" v -
repeat $! l[$>]
s={s} if {$s>1} s. c fi
repeat $! l[$>] karo_xcimg use_skeleton,${p}" -visu 0" mv. 0 k[0] endl done
if {$s>1} a[-$s--1] c fi
endl done v +
#@cli karo_nlmeans : _p1,..,pn=-zoom,1,-ng,0|1,-nu,0|1,-ns,0|1,-p,1,-lambda,-1,-sigma,-1,-alpha,3,-sampling,1
#@cli : Execute use_nlmeans  (CImg demo) external. (see also q-nlmeans p=4,lambda=4,sigma=10)
karo_nlmeans : v - if {$#>0} karo_li2st ${1--1} p=${} else p="" fi v +
e "Compute use_nlmeans exec with options "${p}" on$?" v -
repeat $! l[$>]
s={s} if {$s>1} s. c fi
repeat $! l[$>] karo_xcimg use_nlmeans,${p}" -visu 0" mv. 0 k[0] endl done
if {$s>1} a[-$s--1] c fi
endl done v +
#@cli karo_VST : _inverse(=0)
#@cli : Variance Stabilizing Transformation
#@cli : following http://hal.archives-ouvertes.fr/docs/00/51/08/66/PDF/Burst_Hal.pdf
#@cli : $ image.jpg e ${-std_noise} karo_VST 0 e ${-std_noise} +karo_VST 1
karo_VST :
v - skip ${1=0} if $1 inv=" (inverse)." else inv="." fi v +
e[^-1] "Variance Stabilizing Transformation"$inv v -
repeat $! l[$>]
if $1 /[0] 2 sqr[0] -[0] {3/8} else +[0] {3/8} sqrt[0] *[0] 2 fi
endl done v +
#@cli pearson_correlation
#@cli : Compute pearson-correlation using two-by-two selected images.
#@cli : $ image.jpg +shift -30,-20 pearson_correlation e ${}
pearson_correlation :
e[^-1] "Compute pearson-correlation using two-by-two image$?."
v - repeat {int($!/2)} l[{$>*2},{$>*2+1}]
+-[0] {0,ia} +-[1] {1,ia} +*[2,3]
sqr[2,3]
r={ia/sqrt({2,ia}*{3,ia})}
if {$>==0} u $r else u ${},$r fi
rm[2-4]
endl done v +
#@cli karo_extinction : _whitevalue[%]
#@cli : Convert (integer) transmission image into extinction with _whitevalue.
#@cli : Def. val.: '_whitevalue=100%'
karo_extinction : check "${1=100%}>0"
e[^-1] "Convert transmission image$? into extinction with white value $1." v -
repeat $! l[$>]
if ${-is_percent\ $1} WW={iM*$1} else WW=$1 fi
c. 1,{iM} /. $WW log10. *. -1
endl done v +
#@cli karo_rndbit0 :
#@cli : Randomize in [0..255] (byte) image$? bit level 0. wow randomize numbers to even and odd"
karo_rndbit0 :
e[^-1] "Randomize in [0..255] (byte) image$? bit level 0." v -
repeat $! l[$>] and 254 +rand 0,1 round. or endl done v +
#@cli karo_dtpread : filename,_bit0
#@cli : Read dtp image file format
#@cli :   (512 byte header, col[22-24] x row[25-27] byte image)
#@cli : with _bit0 != 0 bit level 1 is extracted as binary mask
#@cli :   and bit level 1 in the gray image is randomized with karo_rndbit0
#@cli : Ex.: karo_dtpread Images/Beispiele/tra005.cel,1
karo_dtpread : check $1 check "${2=0}>=0"
e[^-1] "Read dtp image file from $1." v -
i raw:$1,uchar
({@22-24}) x={t} rm.
({@25-27}) y={t} rm.
({@0-79}) _dtph={t} rm.
crop. 0,512,0,{h}
resize. $x,$y,1,1,-1
if $2
+and. 1 karo_rndbit0..
fi
v +
#@cli _kr_ch2ch : number
#@cli : return alpha channel mode string from number in status
#@cli : Ex. v - repeat 51 _kr_ch2ach $> echo_stdout $>,${} done v +
_kr_ch2ch :
if {isval("$1")} if {isint("$1")}
u ${-arg\ 1+$1,all,rgba,rgba_r,rgba_g,rgba_b,rgba_a,rgb,rgb_r,rgb_g,rgb_b,\
lrgb,lrgb_r,lrgb_g,lrgb_b,ycbcr,ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
lab,lab_l,lab_ab,lab_a,lab_b,lch,lch_l,lch_ch,lch_c,lch_h,\
hsv,hsv_h,hsv_s,hsv_v,hsi,hsi_h,hsi_s,hsi_i,hsl,hsl_h,hsl_s,hsl_l,\
cmy,cmy_c,cmy_m,cmy_y,cmyk,cmyk_c,cmyk_m,cmyk_y,cmyk_k}
else u "$1" fi else u "$1" fi
#@cli descriptive_feature :
#@cli : Estimation of features number(sum,m0),mean(m1),SD(m2),skewness(m3),kurtosis(m4),min,max,median
#@cli : from skalar images
#@cli : Ex.: image.jpg to_gray descriptive_feature e ${}
descriptive_feature :
e[^-1] "Calculate m0,m1,m2,m3,m4,min,max,med from data$?."
v -
repeat $! l[$>]
if {s>1} v + e[^-1] "Data ["$>"] seemingly not skalar! Break!" v - continue fi
if {$_version>=216} res={"
ff=stats(); ff[3]=sqrt(ff[3]); _(print(ff));
m3=0;m4=0;for(ip=0,ip<whds,ip++,m3+=(i[ip]-ff[2])^3;m4+=(i[ip]-ff[2])^4);
res=[whds,ff[2,2],m3/(whds*(ff[3])^3),m4/(whds*(ff[3])^4)-3,ff[0,2],ic()];
_(print(res)); res"}
else
m0={whds} m1={ia} m2={sqrt(iv)} med={ic} mx={iM} mn={im}
+- $m1 pow. 3 m3={is/($m0*$m2^3)} rm.
+- $m1 pow. 4 m4={is/($m0*$m2^4)-3} rm.
res=$m0\,$m1\,$m2\,$m3\,$m4\,$mn\,$mx\,$med
fi
if {$>==0} sres=$res else sres=$sres\,$res fi
endl done u $sres v +
#@cli mmorpho : action, _kernel(0), _size(5), _ckernel("1,0,1; 0,1,0; 1,0,1")
#@cli : Mathematical morphology filter
#@cli : action={0=Ero | 1=Dil | 2=Open | 3=Close | 4=Ori-Ero | 5=Dil-Ori | 6=Ori-Open | 7=Close-Ori | 8=(Ori*2-(Open+Close))*0.5 | 9=Close-Open}
#@cli : _kernel={0=Square | 1=Octogon | 2=Circle | 3=Custom}
#@cli : _size>=2(5)
#@cli : _ckernel (custom kernel only if _kernel==3)
#@cli : Derived from D Tschumperle's fx_morpho_v2 (gmic_stdlib.gmic)
mmorpho :
skip "${2=0} ${3=5} ${4=1,0,1; 0,1,0; 1,0,1}"
v - ac=Ero,Dil,Open,Close,"Ori-Ero","Dil-Ori","Ori-Open","Close-Ori","(Ori*2-(Open+Close))*0.5","Close-Open"
ke=Square,Octagon,Circle,Custom v +
e[^-1] "Math. morph. filter "${-arg\ {$1+1},$ac}" with kernel "${-arg\ {$2+1},$ke}" and size "$3 v -
({'"$4"'}) f. "(i>=_'0' && i<=_'9') || i==_',' || i==_';'?i:-1" discard. -1 ckernel={t} rm.
if {$2==0} m "my_erode: erode $""1" m "my_dilate: dilate $""1"
elif {$2==1} m "my_erode: erode_oct $""1" m "my_dilate: dilate_oct $""1"
elif {$2==2} m "my_erode: erode_circ $""1" m "my_dilate: dilate_circ $""1"
else
m "my_erode : ("$ckernel") erode[^-1] . skip $""1"" rm."
m "my_dilate : ("$ckernel") dilate[^-1] . skip $""1"" rm."
fi
if {$1==0} m "my_action : my_erode $3"
elif {$1==1} m "my_action : my_dilate $3"
elif {$1==2} m "my_action : my_erode $3 my_dilate $3"
elif {$1==3} m "my_action : my_dilate $3 my_erode $3"
elif {$1==4} m "my_action : +my_erode $3 -"
elif {$1==5} m "my_action : +my_dilate $3 rv -"
elif {$1==6} m "my_action : +my_erode $3 my_dilate. $3 -"
elif {$1==7} m "my_action : +my_dilate $3 my_erode. $3 rv -"
elif {$1==8} m "my_action : +my_erode $3 my_dilate. $3 +- rm.. +my_dilate.. $3 my_erode. $3 rv[-1,-3] -[-1,-3] rv - / 2"
elif {$1==9} m "my_action : +my_erode $3 my_dilate. $3 my_dilate.. $3 my_erode.. $3 -"
else m "my_action : +my_dilate $3 my_erode. $3 rv -"
fi
repeat $! l[$>]
my_action[0]
endl done
uncommand my_erode,my_dilate,my_action
v +
#@gui CImg Nlmeans : fx_karo_cimg_nlmeans, fx_karo_cimg_nlmeans_preview(0)
#@gui : Add Gauss Noise = float(0.0,0.0,30.0)
#@gui : Add Uniform Noise = float(0.0,0.0,30.0)
#@gui : Add Salt &amp; Pepper Noise = float(0.0,0.0,30.0)
#@gui : Half Size of Patch = int(1,1,15)
#@gui : Band Width Lambda = float(-1,-1,25)
#@gui : Noise SD Sigma = float(-1,-1,25)
#@gui : Neighborhood Size Alpha = int(3,1,15)
#@gui : Sampling Step Size = int(2,1,5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Smoothing using CImg example plugin use_nlmeans.)
#@gui : note = note{"CImg nlmeans: <i>use_nlmeans</i> in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")
#@cli fx_karo_cimg_nlmeans : add_Gauss_noise(0),add_uniform_noise(0),add_salt_pepper(0),patch_size(0),lambda(-1),noise_sd(-1),alpha(3),steps(2)
#@cli : Execute use_nlmeans (CImg demo) external.
fx_karo_cimg_nlmeans :
skip "${1=0}","${2=0}","${3=0}","${4=1}","${5=-1}","${6=-1}","${7=3}","${8=2}"
karo_nlmeans -ng,$1,-nu,$2,-ns,$3,-p,$4,-lambda,$5,-sigma,$6,-alpha,$7,-sampling,$8
fx_karo_cimg_nlmeans_preview :
gui_split_preview "-fx_karo_cimg_nlmeans ${1-8}",${-3--1}
#@gui CImg Skeleton : fx_karo_cimg_skel, fx_karo_cimg_skel_preview(0)
#@gui : Auto-Threshold = bool(1)
#@gui : Threshold \% = float(50,0,100)
#@gui : Size Median = int(0,0,15)
#@gui : Invert = bool(false)
#@gui : Threshold on Flux = float(-0.3,-5,5)
#@gui : Medial Curve = bool(false)
#@gui : Torsello Correction =bool(false)
#@gui : Discrete Step = int(1,1,15)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Skeleton using CImg example plugin use_skeleton.)
#@gui : note = note{"CImg Skeleton: <i>use_skeleton</i> in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")
#@cli fx_karo_cimg_skel : auto_thresh(1),thresh(50\%),median(0),invert(0),thresh_flux(-0.3),medial_curve(0),Torsello corr(0),steps(1)
#@cli : Execute use_skeleton (CImg demo) external.
fx_karo_cimg_skel :
skip "${1=1}","${2=50}","${3=0}","${4=0}","${5=-0.3}","${6=0}","${7=0}","${8=1}"
if $1 otsu 256 else threshold ${2}% fi
karo_skeleton median,$3,-inv,$4,-t,$5,-curve,$6,-corr,$7,-dlt,$8 n 0,255
fx_karo_cimg_skel_preview :
gui_split_preview "-fx_karo_cimg_skel ${1-8}",${-3--1}
#@gui MM Differences : fx_karo_mm_diff, fx_karo_mm_diff_preview(0)
#@gui : Size = int(5,1,25)
#@gui : Size2 = int(7,1,25)
#@gui : Operation = choice(2,"Erosion","Dilation","Open","Close")
#@gui : Shape = choice(1,"Square","Octagon","Circle")
#@gui : Channel(s) = choice(0,"all","rgba","rgba_r","rgba_g","rgba_b","rgba_a","rgb","rgb_r","rgb_g","rgb_b","lrgb","lrgb_r","lrgb_g","lrgb_b","ycbcr","ycbcr_y","ycbcr_cbcr","ycbcr_cb","ycbcr_cr","ycbcr_cg","lab","lab_l","lab_ab","lab_a","lab_b","lch","lch_l","lch_ch","lch_c","lch_h","hsv","hsv_h","hsv_s","hsv_v","hsi","hsi_h","hsi_s","hsi_i","hsl","hsl_h","hsl_s","hsl_l","cmy","cmy_c","cmy_m","cmy_y","cmyk","cmyk_c","cmyk_m","cmyk_y","cmyk_k")
#@gui : Scale = bool(true)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.")
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")
#@cli fx_karo_mm_diff : _size,_size2,_operation,_shape,_channel,_scale
#@cli : Compute difference of math. morph. operation with two sizes on selected images.
#@cli : _size = int(5,1,25)
#@cli : _size2 = int(7,1,25)
#@cli : _operation = choice(2,"Erosion","Dilation","Open","Close")
#@cli : _shape = choice(1,"Square","Octagon","Circle")
#@cli : _channel = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@cli : _scale = bool(true)
#@cli : Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.
#@cli : Author : <i>KaRo</i>. Latest update : <i>2013/07/09</i>.
fx_karo_mm_diff :
skip "${1=5}","${2=7}","${3=2}","${4=1}","${5=0}","${6=1}"
if {$2<=$1} s2={$1+2} else s2=$2 fi
karo_doo $1,${s2},$3,$4,$6,$5
to_rgb
fx_karo_mm_diff_preview :
gui_split_preview "-fx_karo_mm_diff ${1-6}",${-3--1}
#@gui OC Differences : fx_karo_oc_diff, fx_karo_oc_diff_preview
#@gui : Size = int(5,2,25)
#@gui : Shape = choice(1,"Square","Octagon","Circle")
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : Scale =bool(true)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("Difference of mean of morphological opening and closing with original.")
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2013/07/04</i>.</small>")
#@cli fx_karo_oc_diff : _size,_shape,_channel,_scale
#@cli : Compute difference of math. morph opening and closing on selected images.
#@cli : _size = int(5,1,25)
#@cli : _shape = choice(1,"Square","Octagon","Circle")
#@cli : _channel = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@cli : _scale = bool(true)
#@cli : Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.
#@cli : Author : <i>KaRo</i>. Latest update : <i>2013/07/09</i>.
fx_karo_oc_diff :
skip "${1=5}","${2=1}","${3=0}","${4=1}"
apply_channels "-karo_doc $1,$2,0",$3,$4
to_rgb
fx_karo_oc_diff_preview :
gui_split_preview "-fx_karo_oc_diff ${1-4}",${-3--1}
#@cli fx_pink : Pink example, _operator(=11), _connect(=0), _smooth(=0), _param(=5), _channel(=0)
#@cli : _operator = 0..19 ("wshedtopo","wshedtopo inv","minima","maxima","heightminima","heightmaxima","grayskel","htkern","htkernu","lvkern","lvkernu","asf","asflin","asfr","asft","asftmed","asftndg","dilatballnum","erosballnum","lintophat")
#@cli : _connect = 0..1 ("Four/x","Eight/y")
#@cli : _smooth = 0..
#@cli : _param = 0..25
#@cli : _channel = 0..22 ("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@cli : $ image.jpg +fx_pink , +-
#@cli : $ image.jpg +fx_pink. 12,1,0.582524,10,0,0 +fx_pink.. 12,0,0.582524,10,0,0 +[-1,-2] # asflin in x and y
#@gui Pink Operator : fx_pink, fx_pink_preview(1)
#@gui : Pink Operator = choice("wshedtopo","wshedtopo inv","minima","maxima","heightminima","heightmaxima","grayskel","htkern","htkernu","lvkern","lvkernu","asf","asflin","asfr","asft","asftmed","asftndg","dilatballnum","erosballnum","lintophat")
#@gui : Connectivity / Dir = choice("Four/x","Eight/y")
#@gui : Smoothness = float(0,0,5)
#@gui : Height/Rep = int(5,0,25)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
fx_pink :
skip ${1=11},${2=0},${3=0},${4=5},${5=0} v -
if   {$1==0}  apply_channels "b $3 pink heightminima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4}",$5,0
elif {$1==1}  apply_channels "b $3 pink heightmaxima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4},i",$5,0
elif {$1==2}  apply_channels "b $3 pink minima,{($2+1)*4}",$5,0
elif {$1==3}  apply_channels "b $3 pink maxima,{($2+1)*4}",$5,0
elif {$1==4}  apply_channels "b $3 pink heightminima,{($2+1)*4},$4",$5,0
elif {$1==5}  apply_channels "b $3 pink heightmaxima,{($2+1)*4},$4",$5,0
elif {$1==6}  apply_channels "b $3 pink grayskel,null,4,$4",$5,0
elif {$1==7}  apply_channels "b $3 pink htkern,null,{($2+1)*4}",$5,0
elif {$1==8}  apply_channels "b $3 pink htkernu,null,{($2+1)*4}",$5,0
elif {$1==9}  apply_channels "b $3 pink lvkern,null,{($2+1)*4}",$5,0
elif {$1==10} apply_channels "b $3 pink lvkernu,null,{($2+1)*4}",$5,0
elif {$1==11} apply_channels "b $3 pink asf,$4",$5,0
elif {$1==12}
if {$2==0} apply_channels "b $3 [0]x2 a z pink asflin,x,$4 s z k.",$5,0
else apply_channels "b $3 [0]x2 a z pink asflin,y,$4 s z k.",$5,0 fi
elif {$1==13} apply_channels "b $3 pink asfr,$4",$5,0
elif {$1==14} apply_channels "b $3 pink asft,null,null,{($2+1)*4},$4",$5,0
elif {$1==15} apply_channels "b $3 pink asftmed,{($2+1)*4},$4",$5,0
elif {$1==16} apply_channels "b $3 pink asftndg,null,null,{($2+1)*4},$4",$5,0
elif {$1==17} apply_channels "b $3 pink dilatballnum,$4",$5,0
elif {$1==18} apply_channels "b $3 pink erosballnum,$4",$5,0
elif {$1==19} apply_channels "b $3 pink lintophat,$4",$5,0
else          apply_channels "b $3 pink heightminima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4}",$5,0
fi v +
fx_pink_preview :
gui_split_preview "-fx_pink ${1-5}",${-3--1}
#@gui Pink Operator Binary : fx_karo_pink_bin, fx_karo_pink_bin_preview(1)
#@gui : Auto-Threshold = bool(1)
#@gui : Threshold \% = int(50,0,100)
#@gui : Pink Operator = choice(3,"skelpar","skelend","skelcurv","skeleton","barycentre","border","closeball","openball","convexhull","dist","distc","label pla","Lantuejoul")
#@gui : Connectivity / Dir = choice("Four/x","Eight/y")
#@gui : Height/Rep = int(5,-1,25)
#@gui : Algorithm = int(4,0,29)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Binary operations with Pink externals.)
#@gui : note = note{"Diverse Pink executables in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2014/02/05</i>.</small>")
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
fx_karo_pink_bin :
skip ${1=1},${2=50},${3=3},${4=0},${5=5},${6=4},${7=0} v -
if   {$3==0}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skelpar $6,$5 n 0,255",$7,0
elif {$3==1}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skelend {($4+1)*4},$5 n 0,255",$7,0
elif {$3==2}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skelcurv $6,{($4+1)*4} n 0,255",$7,0
elif {$3==3}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skeleton $6,{($4+1)*4} n 0,255",$7,0
elif {$3==4}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink barycentre,{($4+1)*4} n 0,255",$7,0
elif {$3==5}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink border,{($4+1)*4} n 0,255",$7,0
elif {$3==6}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink closeball,$5,$6 n 0,255",$7,0
elif {$3==7}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink openball,$5,$6 n 0,255",$7,0
elif {$3==8}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink convexhull,3 n 0,255",$7,0
elif {$3==9}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink dist,$6 n 0,255",$7,0
elif {$3==10}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink distc,$6 n 0,255",$7,0
elif {$3==11}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink label,{($4+1)*4},pla",$7,0
elif {$3==12}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink lantuejoul,$6 n 0,255",$7,0
else
fi
fx_karo_pink_bin_preview :
gui_split_preview "-fx_karo_pink_bin ${1-7}",${-3--1}
#@gui Pink Test Operator Bianca : fx_karo_pink_bianca, fx_karo_pink_bianca_preview(0)
#@gui : ASF Smooth Size = int(5,1,10)
#@gui : Threshold \% = int(60,0,100)
#@gui : Watershed Height Min = int(5,0,20)
#@gui : Opening Radius = int(1,0,10)
#@gui : Invert = bool(0)
#@gui : Use G Instead of B = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Pink test operator Bianca for RGB image; only B used.)
#@gui : note = note{"Pink executables in search PATH or C:\\Pink\\bin\\ for Windows"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2012/10/26</i>.</small>")
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
#@cli fx_karo_pink_bianca : Pink test operator bianca
#@cli : ASF smooth size = int(5,1,10)
#@cli : Threshold \% = int(60,0,100)
#@cli : Watershed height min = int(5,0,20)
#@cli : Opening radius = int(1,0,10)
#@cli : Invert = bool(0)
#@cli : Use G instead of B = bool(0)
#@cli : Pink test operator Bianca for RGB image; only B used.
#@cli : Pink executables in search PATH or C:\\Pink\\bin\\ for Windows
#@cli : Author : <i>KaRo</i>.           Latest update : <i>2012/11/18</i>
#@cli : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
fx_karo_pink_bianca :
skip "${1=5}","${2=60}","${3=5}","${4=1}","${5=0}","${6=0}"
if $5 negate fi
if {!${-is_windows}} exe="label" else exe="C:\Pink\bin\label" fi
s c if $6 k.. else k. fi
+pink asf,$1 +- k[-1,-3] threshold. ${2}%
+pink_wshed.. ,1,$3
pink. $exe,4,max threshold. 1
erode_oct.. {$4*2+1} dilate_oct.. {$4*2+1}
+*[-1,-2] negate.. n[-1,-2] 0,255 a[-1,-2,-4] c k[0]
fx_karo_pink_bianca_preview :
gui_split_preview "-fx_karo_pink_bianca ${1-6}",${-3--1}
#@gui _
#@gui <i>Lylejk</i>
#@gui Blend [Shape Average] : fx_blend_shapeaverage, fx_blend_shapeaverage(0)
#@gui : Preserve Shading = bool(1)
#@gui : Transparency = bool(0)
#@gui : Revert Layers = bool(0)
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2011/19/10</i>.</small>")
fx_blend_shapeaverage :
if ${3=0} _fx_revert_layers fi
to_rgb
repeat {int($!/2)}
rv[-2,-1]
if $1 i[0] . fi
blend[-2,-1] shapeaverage0
if $1 *[0,-1] /[0] 255 mv[0] $! fi
if $2 to_rgba. replace_color. 0,0,0,0,0,255,0,0,0,0 fi
mv. 0 done
#@gui Lylejk's Stencil : fx_lylejk_stencil, fx_lylejk_stencil(0)
#@gui : Amplitude = int(5,1,10)
#@gui : Sharpness = float(10,0,100)
#@gui : Radius = float(3,0,10)
#@gui : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll, David Tschumperl&#233;</i>.      Latest update: <i>2010/29/12</i>.</small>")
fx_lylejk_stencil :
apply_channels "repeat $1 b $3 unsharp $3,$2 c 0,255 mv. 0 done",$4,0
#@gui Lylejk Luma Invert : Lylejk_Luma_Invert , Lylejk_Luma_Invert_preview(0)
#@gui : note = note("<span foreground="orangered"><b><u>Pow</u></b></span>")
#@gui : Value = float(1,0.5,4)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>samj</i>.      Latest update: <i>2018/05/03</i>.</small>")
Lylejk_Luma_Invert :
fx_decompose_channels[-1] 5,0,1,0
negate[-3]
if {$1==1}
fx_decompose_channels[-1,-2,-3] 5,1,1,0
else
pow[-3] $1
n[-3] 0,255
fx_decompose_channels[-1,-2,-3] 5,1,1,0
endif
Lylejk_Luma_Invert_preview :
gui_split_preview "Lylejk_Luma_Invert $*",$-1
#@gui Lylejk Quantize Wicker : Lylejk_Quantize_Wicker , Lylejk_Quantize_Wicker_preview(0)
#@gui : note = note("<span foreground="orangered"><b><u>Quantize</u></b></span>")
#@gui : Levels = int(16,2,256)
#@gui : note = note("<span foreground="orangered"><b><u>Offset</u></b></span>")
#@gui : X (%) = float(50,0,100)
#@gui : Y (%) = float(50,0,100)
#@gui : Offset = choice(0,"No","Yes")
#@gui : note = note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(16,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border Opacity = float(1,0,1)
#@gui : Border Color = color(0,0,0,255)
#@gui : note = note("<span foreground="orangered"><b><u>Dilate</u></b></span>")
#@gui : Dilatation = int(1,1,16)
#@gui : note = note("<span foreground="orangered"><b><u>Lylejk_Wicker Rodilius</u></b></span>")
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(153,0,1000)
#@gui : note = note("<span foreground="orangered"><b><u>Sharpen Deblur</u></b></span>")
#@gui : Sharpen Deblur = bool(0)
#@gui : Radius = float(2,0,20)
#@gui : Iterations = int(10,0,100)
#@gui : Time Step = float(20,0,50)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Regularization = choice(1,"Tikhonov","Mean curvature","Total variation")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i> Lylejk - samj</i>.      Latest update: <i>2018/04/06</i>.</small>")
Lylejk_Quantize_Wicker :
quantize $1,1,1
-if {$4==1} shift $2%,$3%,0,0,2,1 -endif
fx_superpixels $5,$6,$7,$8,$9,$10,$11,$12,$13
-dilate $14
-if {$4==1} shift {-$2}%,{-$3}%,0,0,2,1 -endif
-resize {{w}/2},{{h}/2}
-c 0,255
Lylejk_Wicker $15,$16,$17,150,0.42,0.85,0.6,7.83,0.68,19,2.64,0,1,1,0,0.5,10.5,100,0,0,0.5,10.5,100,0,1.15,5,1,0.68,0.5,10.5,100,0,1,1,10,1,0,0
-if {$18==1} deblur ${19-23} c 0,255 -endif
Lylejk_Quantize_Wicker_preview :
gui_split_preview "Lylejk_Quantize_Wicker $*",$-1
#@gui Lylejk Ribbon : Lylejk_Ribbon, Lylejk_Ribbon_preview(0)
#@gui : note = link("http://gimpchat.com/viewtopic.php?f=11&t=16390","http://gimpchat.com/viewtopic.php?f=11&t=16390")
#@gui : note = note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(7.83,0,10)
#@gui : Spatial Precision = float(0.68,0.1,2)
#@gui : Angular Precision = float(19,1,180)
#@gui : Value Precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(2,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Diffusion tensors</u></b></span>")
#@gui : Resolution (%) = float(16,0,20)
#@gui : Size = float(3.44,0,16)
#@gui : Color Mode = choice(0,"Monochrome","Grayscale","Orientation","Color")
#@gui : Outline = int(3,0,16)
#@gui : Sharpness = float(0.79,0,1)
#@gui : Anisotropy = float(0.72,0,1)
#@gui : Gradient Smoothness = float(4.97,0,10)
#@gui : Tensor Smoothness = float(1.70,0,10)
#@gui : note = note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(7.83,0,10)
#@gui : Spatial Precision = float(0.68,0.1,2)
#@gui : Angular Precision = float(19,1,180)
#@gui : Value Precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(2,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm 3</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.32,0,1.5)
#@gui : Min Threshold = float(43.1,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Upscale [dcci2x] by Garagecoder</u></b></span>")
#@gui : Upscale = choice(2,"No","Yes","Yes and No")
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i> Lylejk - samj</i>.      Latest update: <i>2018/04/12</i>.</small>")
Lylejk_Ribbon:
Largeur_Origine={w}
Hauteur_Origine={h}
-if {{$36==1}||{$36==2}}
-split_opacity
-scale_dcci2x ${37-39}
-append c
-cut 0,255
-endif
#Fake Smudge
-repeat $11
-smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
-done
-fx_diffusiontensors $12,$13,$14,$15,$16,$17,$18,$19
#Fake Smudge
-repeat $30
-smooth $20,$21,$22,$23,$24,$25,$26,$27,$28,$29
-done
#Gradient Norm 1
-blur $31
-gradient_norm ^ $32
-cut $33%,$34%
-if $35
negate
-endif
-normalize 0,255
-if {$36==2}
-resize $Largeur_Origine,$Hauteur_Origine
-c 0,255
-endif
Lylejk_Ribbon_preview :
gui_split_preview "Lylejk_Ribbon $*",$-1
#@gui Lylejk Ripple : ripple, ripple(0)
#@gui : Amplitude = float(10,-100,100)
#@gui : Bandwidth = float(20,1,300)
#@gui : Shape = choice(2,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest update: <i>2011/23/08</i>.</small>")
#@gui Lylejk Test TRW : lylejk_test_TRW , lylejk_test_TRW_preview(0)
#@gui : note = note("<span foreground="orangered"><b><u>Offset</u></b></span>")
#@gui : X (%) = float(50,0,100)
#@gui : Y (%) = float(50,0,100)
#@gui : Offset = choice(1,"A","B")
#@gui : note = note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(16,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border Opacity = float(1,0,1)
#@gui : Border Color = color(0,0,0,255)
#@gui : note = note("<span foreground="orangered"><b><u>Euclidean - Polar</u></b></span>")
#@gui : X-Center (%) = float(50,0,100)
#@gui : Y-Center (%) = float(50,0,100)
#@gui : Stretch Factor = float(1,0.1,10)
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui : note = note("<span foreground="blue"><b><u>Lylejk_Wicker</u></b></span>")
#@gui : note = note("<span foreground="orangered"><b><u>Rodilius</u></b></span>")
#@gui : Amplitude = float(1.8,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(153,0,1000)
#@gui : note = note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(7.83,0,10)
#@gui : Spatial Precision = float(0.68,0.1,2)
#@gui : Angular Precision = float(19,1,180)
#@gui : Value Precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm 1</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(10.5,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm 2</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(10.5,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Upscale [dcci2x] by Garagecoder</u></b></span>")
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(1)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm 3</u></b></span>")
#@gui : Smoothness = float(0.68,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(10.5,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Option Lylejk stencil</u></b></span>")
#@gui : Apply Lylejk Stencil = bool(0)
#@gui : Amplitude = int(1,1,10)
#@gui : Sharpness = float(10,0,100)
#@gui : Radius = float(1,0,10)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll - samj</i>.      Latest update: <i>2018/04/06</i>.</small>")
lylejk_test_TRW :
-if {$3==0} shift $1%,$2%,0,0,2,1 -endif
fx_superpixels $4,$5,$6,$7,$8,$9,$10,$11,$12
-if {$3==1} shift $1%,$2%,0,0,2,1 -endif
if {!$16} to_a fi
euclidean2polar $13%,$14%,$15,$16
fx_superpixels $4,$5,$6,$7,$8,$9,$10,$11,$12
if {!$16} to_a fi
polar2euclidean $13%,$14%,$15,$16
shift {-$1}%,{-$2}%,0,0,2,1
-resize {{w}/2},{{h}/2}
-c 0,255
Lylejk_Wicker $17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53
lylejk_test_TRW_preview :
gui_split_preview "lylejk_test_TRW $*",$-1
#@gui Lylejk Wicker : Lylejk_Wicker , Lylejk_Wicker_preview(0)
#@gui : note = link("https://github.com/dtschump/gmic-community/blob/master/tutorial/WickerTute.pdf","https://github.com/dtschump/gmic-community/blob/master/tutorial/WickerTute.pdf")
#@gui : note = note("<span foreground="orangered"><b><u>Rodilius</u></b></span>")
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(153,0,1000)
#@gui : note = note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(7.83,0,10)
#@gui : Spatial Precision = float(0.68,0.1,2)
#@gui : Angular Precision = float(19,1,180)
#@gui : Value Precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm 1</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(10.5,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm 2</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(10.5,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Upscale [dcci2x] by Garagecoder</u></b></span>")
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(1)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm 3</u></b></span>")
#@gui : Smoothness = float(0.68,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(10.5,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Option Lylejk stencil</u></b></span>")
#@gui : Apply Lylejk Stencil = bool(0)
#@gui : Amplitude = int(1,1,10)
#@gui : Sharpness = float(10,0,100)
#@gui : Radius = float(1,0,10)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Lyle Kroll</i>.      Latest update: <i>2018/04/03</i>.</small>")
Lylejk_Wicker : skip ${33=0},${34=1},${35=10},${36=1},${37=0}
# Option Lylejk stencil
-if $33
-apply_channels "-repeat $34 -b $36 -unsharp $36,$35 -c 0,255 -mv[-1] 0 -done",$37,0
-endif
#Rodilius
-rodilius $1,$2,$3,5,30,1
-smooth 10,0,1,1,1,0.8,45
-sharpen 30
-cut 0,255
#Fake Smudge
-repeat $14
-smooth $4,$5,$6,$7,$8,$9,$10,$11,$12,$13
-done
#Gradient Norm 1
-blur $15
-gradient_norm ^ $16
-cut $17%,$18%
-if $19
-negate
-endif
-normalize 0,255
#Gradient Norm 2
-blur $20
-gradient_norm ^ $21
-cut $22%,$23%
-if $24
-negate
-endif
-normalize 0,255
#Upscale [dcci2x] by Garagecode
-split_opacity
-scale_dcci2x ${25-27}
-append c
-cut 0,255
#Gradient Norm 3
-blur $28
-gradient_norm ^ $29
-cut $30%,$31%
-if $32
-negate
-endif
-normalize 0,255
Lylejk_Wicker_preview : skip ${33=0},${34=1},${35=10},${36=1},${37=0}
gui_split_preview "Lylejk_Wicker $*",$-1
#
#
#@gui Lylejk Wicker 2 : Lylejk_Wicker_2 , Lylejk_Wicker_2_preview(0)
#@gui : note = link("https://github.com/dtschump/gmic-community/blob/master/tutorial/wicker_tut.pdf","https://github.com/dtschump/gmic-community/blob/master/tutorial/wicker_tut.pdf")
#@gui : note = note("<small>Applying the tutorial from page 1 to 8</small>")
#@gui : sep = separator()
#@gui : note = note("<span foreground="orangered"><b><u>Offset</u></b></span>")
#@gui : X (%) = float(50,0,100)
#@gui : Y (%) = float(50,0,100)
#@gui : Offset = choice(1,"No","Yes")
#@gui : note = note("<span foreground="orangered"><b><u>Euclidean - Polar</u></b></span>")
#@gui : X-Center (%) = float(50,0,100)
#@gui : Y-Center (%) = float(50,0,100)
#@gui : Stretch Factor = float(1,0.1,10)
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui : note = note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(12,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border Opacity = float(1,0,1)
#@gui : Border Color = color(0,0,0,255)
#@gui : note = note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.54,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(7.83,0,10)
#@gui : Spatial Precision = float(0.68,0.1,2)
#@gui : Angular Precision = float(19,1,180)
#@gui : Value Precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(3,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.29,0,1.5)
#@gui : Min Threshold = float(28.7,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("<b><u>Improve Contrast</u></b>")
#@gui : Apply a Contrast = choice(0,"No","Sharpen Deblur","Improve Contrast By Lyle Kroll")
#@gui : sep = separator()
#@gui : note = note("<span foreground="blue"><b><u>Sharpen Deblur</u></b></span>")
#@gui : Radius = float(1,0,20)
#@gui : Iterations = int(10,0,100)
#@gui : Time Step = float(20,0,50)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Regularization = choice(1,"Tikhonov","Mean curvature","Total variation")
#@gui : sep = separator()
#@gui : note = note("<span foreground="blue"><b>Improve Contrast By Lyle Kroll</u></span>")
#@gui : note = note("<span foreground="orangered"><b><u>Smooth Bilateral Contrast</u></b></span>")
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(12,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Fake Smudge Contrast</u></b></span>")
#@gui : Amplitude = float(40,0,1000)
#@gui : Sharpness = float(0.7,0,2)
#@gui : Anisotropy = float(0.3,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(1.1,0,10)
#@gui : Spatial Precision = float(0.8,0.1,2)
#@gui : Angular Precision = float(30,1,180)
#@gui : Value Precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(3,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Grain Merge Contrast</u></b></span>")
#@gui : Amplitude = float(1,0,1)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("<b><u>Option Start With Quantize</u></b>")
#@gui : Quantize = choice(0,"No","Yes")
#@gui : Levels = int(16,2,256)
#@gui : note = note("<b><u>Option Euclidian To Polar</u></b>")
#@gui : Euclidian To Polar = choice(1,"No","Yes")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Lyle Kroll</i>.      Latest update: <i>2018/04/07</i>.</small>")
Lylejk_Wicker_2 :
-if {$33==2} -i [-1] -i [-1] -endif
-if {$54==1} quantize[-1] $55,1,1 -endif
-if {$3==1}
shift[-1] $1%,$2%,0,0,2,1
-if {$56==1} if {!$7} to_a[-1] fi euclidean2polar[-1] $4%,$5%,$6,$7 -endif
fx_superpixels[-1] $8,$9,$10,$11,$12,$13,$14,$15,$16
-endif
-if {$3==0}
-if {$56==1} if {!$7} to_a[-1] fi euclidean2polar[-1] $4%,$5%,$6,$7 -endif
fx_superpixels[-1] $8,$9,$10,$11,$12,$13,$14,$15,$16
-endif
-if {$56==1} if {!$7} to_a[-1] fi polar2euclidean[-1] $4%,$5%,$6,$7 -endif
-if {$3==1} shift[-1] {-$1}%,{-$2}%,0,0,2,1 -endif
#Fake Smudge
-repeat $27
-smooth[-1] $17,$18,$19,$20,$21,$22,$23,$24,$25,$26
-done
#Gradient Norm
-blur[-1] $28
-gradient_norm[-1] ^[-1] $29
-cut[-1] $30%,$31%
-if $32
-negate[-1]
-endif
-normalize[-1] 0,255
-if {$33==1}
deblur[-1] ${34-38} c[-1] 0,255
-elif {$33==2}
repeat $41 bilateral[-2] $39,$40 done
-blend[-2,-3] grainextract
-repeat $52
-smooth[-2] $42,$43,$44,$45,$46,$47,$48,$49,$50,$51
-done
-blend[-1,-2]  grainmerge,$53,1
-endif
Lylejk_Wicker_2_preview :
gui_split_preview "Lylejk_Wicker_2 $*",$-1
#@gui Lylejk Woven : Lylejk_Woven , Lylejk_Woven_preview(0)
#@gui : note = link("http://gimpchat.com/viewtopic.php?f=11&t=16384&start=10#p226895","http://gimpchat.com/viewtopic.php?f=11&t=16384&start=10#p226895")
#@gui : note = note("<span foreground="orangered"><b><u>Ripple 1</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui : note = note("<span foreground="orangered"><b><u>Ripple 2</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui : note = note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(12,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border Opacity = float(1,0,1)
#@gui : Border Color = color(0,0,0,255)
#@gui : note = note("<span foreground="orangered"><b><u>Ripple 3</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui : note = note("<span foreground="orangered"><b><u>Ripple 4</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui : note = note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.61,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(7.83,0,10)
#@gui : Spatial Precision = float(0.68,0.1,2)
#@gui : Angular Precision = float(19,1,180)
#@gui : Value Precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.29,0,1.5)
#@gui : Min Threshold = float(37.2,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator()
#@gui : note = note("<span foreground="orangered"><b><u>Options Start With ...</u></b></span>")
#@gui : Start With Blur = bool(0)
#@gui : Blur = float(2,0,20)
#@gui : Start With Quantize = bool(0)
#@gui : Quantize Levels = int(16,2,256)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Lyle Kroll</i>.      Latest update: <i>2018/04/22</i>.</small>")
Lylejk_Woven :
-if {$48==1} quantize $49,1,1 -endif
-if $46 blur $47 -endif
ripple $1,$2,$3,$4,$5
ripple $6,$7,$8,$9,$10
fx_superpixels $11,$12,$13,$14,$15,$16,$17,$18,$19
mirror x
ripple $20,$21,$22,$23,$24
mirror x
mirror x
ripple $25,$26,$27,$28,$29
mirror x
#Fake Smudge
-repeat $40
-smooth $30,$31,$32,$33,$34,$35,$36,$37,$38,$39
-done
#Gradient Norm
-blur $41
-gradient_norm ^ $42
-cut $43%,$44%
-if $45
negate
-endif
-normalize 0,255
Lylejk_Woven_preview :
gui_split_preview "Lylejk_Woven $*",$-1
#@gui Point Star Outline : garagecoder_lylejk_samj_points_outlines , garagecoder_lylejk_samj_points_outlines_preview(0)
#@gui : note = link("https://discuss.pixls.us/t/place-some-points-on-outlines-with-gmic/7006/5","https://discuss.pixls.us/t/place-some-points-on-outlines-with-gmic/7006/5")
#@gui : note = note("<span foreground="orangered"><b><u>Choice Filter</u></b></span>")
#@gui : Choice Filter = choice(0,"Garagecoder Staroutline","Garagecoder Pointoutline","samj")
#@gui : note = note("<span foreground="orangered"><b><u>Garagecoder Staroutline</u></b></span>")
#@gui : Less Than Staroutline = float(0.05,0,0.5)
#@gui : Shapecloud = int(10,3,20)
#@gui : note = note("<span foreground="orangered"><b><u>Garagecoder Pointoutline</u></b></span>")
#@gui : Less Than Pointoutline = float(0.12,0,0.5)
#@gui : note = note("<span foreground="orangered"><b><u>samj</u></b></span>")
#@gui : Determination Contours = int(0,0,2)
#@gui : Type Rendu = int(0,0,2)
#@gui : Dilatation = int(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i>Garagecoder - Lyle Kroll - samj</i>.      Latest update: <i>2018/04/04</i>.</small>")
garagecoder_lylejk_samj_points_outlines :
Choice_Filter=$1
Less_Than_Staroutline=$2
Shapecloud_Staroutline=$3
Less_Than_Pointoutline=$4
Determination_Contours=$5
Type_Rendu=$6
Dilatation={2+$7}
-if {$Choice_Filter==0}
normalize[-1] 0,255
blur[-1] 2
isophotes[-1] 6
100%,100%,1,1
noise[-1] 0.5,1
lt[-1] {$Less_Than_Staroutline-0.5}
mul[-1,-2]
shape_star ,
garagecoder_example_shapecloud[-2] [-1],$Shapecloud_Staroutline
rm[-1]
-elif {$Choice_Filter==1}
normalize[-1] 0,255
blur[-1] 2
isophotes[-1] 6
100%,100%,1,1
noise[-1] 0.5,1
lt. {$Less_Than_Pointoutline-0.5}
mul[-1,-2]
_circle 5
dilate[-2] [-1]
rm.
-elif {$Choice_Filter==2}
-if {$Determination_Contours==0}
-blur[-1] 2
-isophotes[-1] 6
-elif {$Determination_Contours==1}
-n[-1] 128,255
-to_pseudogray[-1] 5,1,8
-blur[-1] 2
-isophotes[-1] 6
-elif {$Determination_Contours==2}
-tones[-1] 3
-isophotes[-1,-2]  3
-blend[-1,-2] alpha
-blend[-1,-2] alpha
-mul[-1] 255
-isophotes[-1] 3
-endif
{w},{h},1,4
-repeat {{{w}+{h}}/1.5}
-line[-2] 50%,50%,{u(100)}%,{u(100)}%,1,0,0,0,0
-done
-repeat {{{w}+{h}}/2}
-line[-1] {u(100)}%,{u(100)}%,{u(100)}%,{u(100)}%,1,255,255,255,255
-done
-repeat {{{w}+{h}}/5}
-point {u(100)}%,{u(100)}%,0,1,255,255,255,255
-done
-and[-1,-2]
-if {$Type_Rendu==0}
-dilate_circ[-1] $Dilatation
-elif {$Type_Rendu==1}
-i [-1]
-i [-1]
-dilate_circ[-3] $Dilatation
-dilate[-2] 6,1
-dilate[-1] 1,6
-blend[-1,-2,-3] alpha
-elif {$Type_Rendu==2}
-dilate_circ[-1] $Dilatation
-sponge[-1] 5
-endif
-endif
garagecoder_lylejk_samj_points_outlines_preview :
gui_split_preview "garagecoder_lylejk_samj_points_outlines $*",$-1
garagecoder_example_shapecloud : -check ${"is_image_arg $1"}" && isval(${2=9})"
-repeat $! -pass$1 0 -l[$>,-1]
kw={$2+1-$2%2} r. $kw,$kw,1,1,5 n. 0,1
+gt[0,1] 0 convolve[-2] [-1] -rm.
convolve[0] [1] rm[1] +eq. 0 +[-2,-1] /
-endl -done
#@gui _
#@gui <i>McCap</i>
#@gui Hue Overlay Masks : fx_hue_overlay_masks, fx_hue_overlay_masks_preview(0)
#@gui : note = note{"This plugin creates RGB hue masks. They are be exported in overlay mode into Gimp. Try each one to see how it changes your picture. Alternatively you can use them as masks to select regions based on hue."}
#@gui : sep = separator()
#@gui : Stretch Constrast = bool(0)
#@gui : sep = separator(), Preview type = choice(5,"Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
#@gui : sep = separator(), note = note("More details <a href="https://discuss.pixls.us/t/hue-overlay-masks-my-first-filter">here</a>.")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="https://discuss.pixls.us/u/McCap">McCap/pixls.us</a></i>.      Latest update: <i>2017/09/02</i>.</small>")
fx_hue_overlay_masks :
100%,100%,1,1,"R#0/2-(G#0+B#0)/4+128"
100%,100%,1,1,"G#0/2-(R#0+B#0)/4+128"
100%,100%,1,1,"B#0/2-(R#0+G#0)/4+128"
-name[-3] "name(Red), mode(overlay)"
-name[-2] "name(Green),mode(overlay)"
-name[-1] "name(Blue),mode(overlay)"
-if {$1==1}
-if '{iM[1]-128 > 128-im[1]}'
-fill[1] '(i-128)/abs(iM-128)*128+128'
-else
-fill[1] '(i-128)/abs(im-128)*128+128'
-endif
-if '{iM[2]-128 > 128-im[2]}'
-fill[2] '(i-128)/abs(iM-128)*128+128'
-else
-fill[2] '(i-128)/abs(im-128)*128+128'
-endif
-if '{iM[3]-128 > 128-im[3]}'
-fill[3] '(i-128)/abs(iM-128)*128+128'
-else
-fill[3] '(i-128)/abs(im-128)*128+128'
-endif
-endif
-move[1] 0
-move[2] 1
-move[3] 2
fx_hue_overlay_masks_preview :
-fx_hue_overlay_masks $*
-r2dx 50% -to[0] "Red" -to[1] "Green" -to[2] "Blue" -to[3] "Original"
-to_rgba -frame 1,1,0,0,0,255 -frame 3,3,255 -append_tiles ,
#@gui _
#@gui <i>Naggobot</i>
#@gui Abstract Flood : fx_AbstractFlood, fx_AbstractFlood_Preview(1)
#@gui : sep = separator()
#@gui : note = note("Warning: Really really slow filter especially with Cubism enabled. Use a maximum of 1 megapixel image. Random walk algorihm is used to select new areas to flood. If Cubism is enabled the filter has to run cubims for every succesful repeat defined in the flood settings section.")
#@gui : Preprocess with Bilateral Filtering = bool(1)
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator()
#@gui : note = note("Flood settings")
#@gui : Activate Flood = bool(0)
#@gui : Repeats = int(10,1,1000)
#@gui : Flood Tolerance = int(5,0,100)
#@gui : Flood Base Step = int(3,1,10)
#@gui : Canvas Color = color(255,255,255,255)
#@gui : sep = separator()
#@gui : note = note("Abstraction setting, Consider disabling preview if using high flood repeats!")
#@gui : Activate Cubism = bool(0)
#@gui : Cubism Iterations = int(300,1,2000)
#@gui : Bloc Size = float(10,0,40)
#@gui : Angle = float(90,0,360)
#@gui : Opacity = float(0.7,0.01,1)
#@gui : Smoothness = float(0,0,5)
#@gui : note = note("Opacity threshold used to make decision about flooding. Use 0 if Cubism is not enabled.")
#@gui : Opacity Tolerance = int(0,0,254)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6243715666")
fx_AbstractFlood :
Prep=$1
SpatialVariance=$2
ValueVariance=$3
Iterations=$4
ActivateFlood=$5
Repeats=$6
Tolerance=$7
FloodBaseStep=$8
CanvasR=$9
CanvasG=$10
CanvasB=$11
Opacity=$12
ActivateCubism=$13
CubismIterations=$14
Blocsize=$15
Angle=$16
CubismOpacity=$17
Smoothness=$18
StepThreshold={$19+0.1}
Step=$FloodBaseStep
Delta=1
DeltaOrg=$Delta
-to_rgba[0]
-if {$Prep==1}
-fx_smooth_bilateral[0] $SpatialVariance,$ValueVariance,$Iterations,0,0
-endif
({$CanvasR}^{$CanvasG}^{$CanvasB}^0)
-to_rgba[1]
-r[1] [0]
X={(w)/2}
Y={(h)/2}
ImageH={(h)}
ImageW={(w)}
DoLoop=0
IsGood=0
-if {$ActivateFlood==1}
#A comment here is needed
-repeat $Repeats
-flood[0] {100*$X/w}%,{100*$Y/h}%,0,$Tolerance,0,1,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)}
--fx_select_color[0] 0,1,0,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)},0,0
-if {$ActivateCubism==1}
-cubism[2] $CubismIterations,$Blocsize,$Angle,$CubismOpacity,$Smoothness
-endif
-blend[1,2] alpha
-do
Rstep={$Step+$Delta}
theta={u(360)}
Xnew={int($X+$Rstep*cos($theta))}
Ynew={int($Y+$Rstep*sin($theta))}
-if {{$Xnew>0}" && "{$Xnew<$ImageW}" && "{$Ynew>0}" && "{$Ynew<$ImageH}}
X=$Xnew
Y=$Ynew
-if {1,i($X,$Y,0,3)>$StepThreshold}
Delta={min({$Delta+$Delta*2},{max($ImageW,$ImageH)/5})}
-endif
-if {1,i($X,$Y,0,3)<$StepThreshold}
IsGood=10
-endif
-if {$DoLoop>100}
IsGood=10
-endif
-endif
DoLoop=$DoLoop+1
-while {$IsGood<1}
IsGood=0
DoLoop=0
Delta=$DeltaOrg
-done
-endif
({$CanvasR}^{$CanvasG}^{$CanvasB}^{$Opacity})
-r[2] [0]
-reverse[1,2]
-blend[1,2] alpha
-if {$ActivateFlood==1}
-keep[1]
-elif  {$ActivateFlood==0}
-keep[0]
-endif
fx_AbstractFlood_Preview :
-gui_split_preview "-fx_AbstractFlood ${1--2}",$-1
#@gui Black &amp; White Film : fx_bwfilmsimulate, fx_bwfilmsimulate_preview(1)
#@gui : Film Type / RGB Balance = choice(0,"Manual","Agfa 200X","Agfapan 25","Agfapan 100","Agfapan 400","Iford Delta 100","Iford Delta 400","Iford Delta 400 pro & 3200","Ilford FP4","Ilford HP4","Ilford Pan F","Ilford SFX","Ilford XP2 Super","Kodak Tmax 100","Kodak Tmax 400","Kodak Tri-X")
#@gui : note = note("Simpler version available in main tree. This filter will be removed in future from testing. PM me if you need this for some reason.")
#@gui : note = note("RGB sliders work only with manual selection")
#@gui : Red Level = float(0.299,0,1)
#@gui : Red Smoothness = float(0,0,10)
#@gui : Green Level = float(0.587,0,1)
#@gui : Green Smoothness = float(0,0,10)
#@gui : Blue Level = float(0.114,0,1)
#@gui : Blue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Gamma = float(1,0.01,5)
#@gui : Contrast = float(1,0,4)
#@gui : Brightness = float(0,-255,255)
#@gui : Hue = float(0,0,360)
#@gui : Saturation = float(0,0,1)
#@gui : sep = separator()
#@gui : Grain (Shadows) = float(0,0,200)
#@gui : Grain (Midtones) = float(0,0,200)
#@gui : Grain (Highlights) = float(0,0,200)
#@gui : Grain Tone Fading = float(2,0,10)
#@gui : Grain Scale = float(0,0,3)
#@gui : Grain Type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : sep = separator()
#@gui : Local Contrast = float(0,0,60)
#@gui : Radius = int(16,1,512)
#@gui : Contrast Smoothness = float(4,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>David Tschumperl&#233, Arto Huotari;</i>.      Latest update : <i>2019/09/28</i>.</small>")
fx_bwfilmsimulate :
Choice=$1
P1=$2
P2=$3
P3=$4
P4=$5
P5=$6
P6=$7
P7=$8
P8=$9
P9=$10
P10=$11
P11=$12
P12=$13
P13=$14
P14=$15
P15=$16
P16=$17
P17=$18
P18=$19
P19=$20
P20=$21
-if {$Choice==1} P1={18/255} P3={41/255} P5={41/255} -endif
-if {$Choice==2} P1={25/255} P3={39/255} P5={36/255} -endif
-if {$Choice==3} P1={21/255} P3={40/255} P5={39/255} -endif
-if {$Choice==4} P1={20/255} P3={41/255} P5={39/255} -endif
-if {$Choice==5} P1={21/255} P3={42/255} P5={37/255} -endif
-if {$Choice==6} P1={22/255} P3={42/255} P5={36/255} -endif
-if {$Choice==7} P1={31/255} P3={36/255} P5={33/255} -endif
-if {$Choice==8} P1={28/255} P3={41/255} P5={31/255} -endif
-if {$Choice==9} P1={23/255} P3={37/255} P5={40/255} -endif
-if {$Choice==10} P1={33/255} P3={36/255} P5={31/255} -endif
-if {$Choice==11} P1={36/255} P3={31/255} P5={33/255} -endif
-if {$Choice==12} P1={21/255} P3={42/255} P5={37/255} -endif
-if {$Choice==13} P1={24/255} P3={37/255} P5={39/255} -endif
-if {$Choice==14} P1={37/255} P3={36/255} P5={37/255} -endif
-if {$Choice==15} P1={25/255} P3={35/255} P5={40/255} -endif
-repeat $!
-l[-1] -split_opacity -rv -to_rgb[-1] -s[-1] c
-*[-3] $P1 -b[-3] $P2%
-*[-2] $P3 -b[-2] $P4%
-*[-1] $P5 -b[-1] $P6%
-+[-3--1] -/[-1] {$P1+$P3+$P5} -c[-1] 0,255
-apply_gamma[-1] $P7
--[-1] 128 -*[-1] $P8 -+[-1] 128 -+[-1] $P9 -c[-1] 0,255
100%,100% [-1]x2
-noise[-3] 100,$P17 -b[-3] $P16% -n[-3] -$P12,$P12
-noise[-2] 100,$P17 -b[-2] $P16% -n[-2] -$P13,$P13
-noise[-1] 100,$P17 -b[-1] $P16% -n[-1] -$P14,$P14
--tones[-4] 3 -b[-3--1] $P15%
-*[-6,-3] -*[-4,-2] -*[-2,-1]
-+[-4--1] -c[-1] 0,255
-if {$P10||$P11}
-/[-1] 255
-i[-2] 100%,100%,1,1,$P11
-i[-3] 100%,100%,1,1,$P10
-a[-3--1] c -hsv2rgb[-1]
-endif
-rv -a c -endl -mv[-1] 0 -done
-normalize_local $P18,$P19,$P20,2%,1,0,255
fx_bwfilmsimulate_preview :
-gui_split_preview "-fx_bwfilmsimulate ${1--2}",$-1
#@gui Composition Analysis : fx_CompositionAnalysis, fx_no_preview
#@gui : note = note("A tool to abstract the image for subjective composition analysis. Two different methods are available. Set filter output to New layers. For actual analysis the aesthetic sense of the artist is required.")
#@gui : Method = choice(0,"Thumbnail abstraction","Value and lines")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2015/01/17</i>.</small>")
sub_thumbnailabstraction :
-to_rgb[0]
IWidth={0,w}
IHeight={0,w}
-if {$IWidth>=$IHeight}
ScaleByWidth=1
-endif
-if {$ScaleByWidth==1}
--resize2dx[0] 200,5
-blur[-1] 2
#Resize to 1024 px
-resize2dx[-1] 1024,5
#Segmentation
-fx_segment_watershed[-1] 0.5,5,0,0
-elif
--resize2dy[0] 200,5
-blur[-1] 2
#Resize to 1024 px
-resize2dy[-1] 1024,5
#Segmentation
-fx_segment_watershed[-1] 0.5,5,0,0
-endif
-resize[-1] [0]
--rgb2lab[0]
-split[-1] c
-rm[-1,-2]
-blur[-1] 10%
-normalize[-1] 0,255
-blend[-1,-2] hardlight,1,1
-keep[-1]
sub_colors_and_lines :
image_width={0,w}
image_height={0,h}
-resize2dx 1024
-luminance[0]
-normalize 0,255
-to_rgb[0]
-fx_smooth_bilateral[0] 2,15,2,0,0,24,0
-fx_colormap[0] 0,0,3,3,0,0,0,255,255,255,255,0,0,0,255,0,0,0,255,255,255,0,255,0,255,0,255,255,0
--fx_smooth_anisotropic[0] 300,0.1,1,0,10,1,1,1,0,1,1,0,0,24,0
-fx_gradient_norm[-1] 0,0.5,0,100,1,0
-blend[0,1] multiply,1
-resize[-1] $image_width,$image_height,1,3,5,1
fx_CompositionAnalysis :
method=$1
-if {$method==0} -sub_thumbnailabstraction -endif
-if {$method==1} -sub_colors_and_lines -endif
#@gui Dodge Sketch : fx_dodgesketch, fx_dodgesketchpreview(0)
#@gui : note = note("Simple BW sketch"),note = link("Method is described here","http://www.gimpusers.com/tutorials/making-a-pencil-drawing-from-a-photo.html")
#@gui : note = note("in addition an option to color the sketch is included")
#@gui : sep = separator(), note = note("Power setting for sketch")
#@gui : Power = int(3,0,10)
#@gui : sep = separator(), note = note("Presmoothing settins of bilateral filter")
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator()
#@gui : Colored? = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
fx_dodgesketch:
-to_rgb[0]
Power=$1
SpatialVariance=$2
ValueVariance=$3
Iterations=$4
Colored=$5
--fx_mix_hsv[0] 1,0,0,0,-1,0,1,0,0,0,2,0
--fx_smooth_bilateral[-1] $SpatialVariance,$ValueVariance,$Iterations,0,0
-negate[-1]
-blend[-1,-2] alpha,0.5,0
[-1]
--blend[-1,-2] dodge,1,0
-keep[0,-1]
-repeat $Power
[-1]
-blend[-1,-2] multiply
-done
-if {$Colored==1}
--blend[-1,-2] hardlight
-remove[-2]
-fx_transfer_colors[-1,-2] 0,0
-endif
-keep[-1]
fx_dodgesketchpreview :
-gui_split_preview "-fx_dodgesketch ${1--2}",$-1
#@gui Exposure Fusion Weight Map : fx_ExposureWeightMap, fx_ExposureWeightMapPreview(1)
#@gui : sep = separator()
#@gui : note = note("Create exposure fusion weight map")
#@gui : sep = separator()
#@gui : note = note("Set filter output to "New layers". Copy filter output to corresponding layer mask. Use aligned layers to combine multiple exposures.")
#@gui : sep = separator()
#@gui : Contrast Bias = float(0.3,0,1)
#@gui : Saturation Bias = float(0.3,0,1)
#@gui : Exposure Sigma = float(0.2,0,1)
#@gui : Exposure Bias = float(0.3,0,1)
#@gui : BlurMap = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2014/11/30 v2</i>.</small>")
Sub_Contrast_Bias:
-div[-1] 255
-to_gray[-1]
-laplacian[-1]
-abs[-1]
Sub_Saturation_Bias:
-div[-1] 255
--split[0] c
-blend[-1,-2,-3] average
-split[0] c
--sub[0] [1]
-rm[1]
--sub[0] [1]
-rm[1]
--sub[0] [1]
-rm[1]
-rm[0]
-pow[0] 2
-pow[1] 2
-pow[2] 2
-add[1] [2]
-rm[2]
-add[0] [1]
-rm[1]
-div[0] 3
-sqrt[0]
Sub_Exposure_Bias :
-div[0] 255
-sub[0] 0.5
-pow[0] 2
-div[0] {2*$1*$1}
-mul[0] -1
-exp[0]
-split[0] c
-mul[0] [2]
-rm[2]
-mul[0] [1]
-rm[1]
Sub_BlurPyramid :
size={0,min(w,h)}
levels={round(log($size)/log(5))}
Deviation=1
-blur[0] $Deviation,1,1
-repeat {$levels-1}
--resize[-1] 50%,50%,5,1
-blur[-1] $Deviation,1,1
-done
blndalpha=0.5
-repeat {$levels-1}
index={-($<+1)}
-resize[$index] [0],5,1
-blend[0,$index] alpha,$blndalpha,0
blndalpha={$blndalpha/2}
-done
fx_ExposureWeightMap :
wc=$1
ws=$2
sigma=$3
we=$4
BlurMap=$5
-to_rgb[0]
--Sub_Contrast_Bias[0]
--Sub_Saturation_Bias[0]
--Sub_Exposure_Bias[0] $sigma
-rm[0]
-pow[0] $wc
-pow[1] $ws
-pow[2] $we
-add[0] [1]
-add[0] [2]
-keep[0]
-normalize[0] 0,255
-if {$BlurMap==1}
-Sub_BlurPyramid[0]
-endif
fx_ExposureWeightMapPreview :
-gui_split_preview "-fx_ExposureWeightMap ${1--2}",$-1
#@gui GMic Structure Tensors : fx_StructureTensors, fx_StructureTensorsPreview(0)
#@gui : sep = separator()
#@gui : note = note("Structure tensors calculation for Gimp plugin. This is just an interface to built in GMic Structure tensors command")
#@gui : Power = float(0.1,0.1,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2011/12/06</i>.</small>")
fx_StructureTensors:
-structuretensors -abs -pow $1
-normalize 0,255
fx_StructureTensorsPreview :
-gui_split_preview "-fx_StructureTensors ${1--2}",$-1
#@gui Import 16bit Image : fx_import_image_16, fx_import_image_16
#@gui : note = note("Filter can be used to import and adjust 16 bit images to Gimp. Plugin may have limited set of import formats available depending on compilation. At minimum only .png should work reliably.")
#@gui : note = note("1. Create new empty image to Gimp")
#@gui : note = note("2. Open G'Mic from filters menu")
#@gui : note = note("3. Set G'Mic output to "new layers")
#@gui : note = note("4. Select 16 bit image from folder")
#@gui : note = note("5. Make adjustments using sliders")
#@gui : note = note("6. Image will be outputted to Gimp")
#@gui : note = note("By default a scaled down image is processed. Before processing full size disable preview window from gui.")
#@gui : note = note("LAB adjustment often yields more aesthetic results than RGB adjustment.")
#@gui : Input Image = file()
#@gui : Process Selection = choice(1,"Preview Only", "Histogram", "Logarithmic Histogram", "Full resolution")
#@gui : Gamma = float(2.2,0,5)
#@gui : sep = separator(), note = note("LAB adjustment")
#@gui : Brightness = float(0,-1,1)
#@gui : Contrast = float(1,0,3)
#@gui : Equalize = float(0,0,1)
#@gui : Saturation = float(0,-1,10)
#@gui : A(R-G) = float(0,-1,1)
#@gui : B(Y-B) = float(0,-1,1)
#@gui : sep = separator(), note = note("RGB cut and normalize histogram by percentage")
#@gui : Cut High Light Values = float(100,0,100)
#@gui : Cut Dark Values = float(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Arto Huotari;</i>.      Latest update: <i>2014/04/02</i>.</small>")
fx_import_image_16 :
ProcessTo=$2
Gamma=$3
Brightness=$4
Contrast=$5
Equalize=$6
AB=$7
A=$8
B=$9
CutHigh=$10
CutLow=$11
-rm -i
"$1"
-to_rgb
-if {$ProcessTo!=3}
-resize2dx 520,1
-endif
-apply_gamma $Gamma
-if {0,iM>256}
-if $Equalize
--equalize 65535
-blend alpha,{$Equalize/2}
-endif
#Scale values to 0 to 1 range
-div 65535
#Separate luminance from colour
-rgb2lab
-split c
-if $Brightness
-add[-3] $Brightness
-endif
-if {$Contrast!=1}
-mul[-3] $Contrast
-endif
#Adjust saturation by multiplying both A and B channels
-if $AB
-mul[-2] $AB
-mul[-1] $AB
-endif
#Adjust colour balance by multiplying A or B channel.
-if $A
-mul[-2] {1+$A}
-endif
-if $B
-mul[-1] {1+$B}
-endif
-append c
-lab2rgb
#RGB cut and normalize
-if {$CutHigh!=100" || "$CutLow!=0}
Range=1
HighValue={$CutHigh/100*$Range}
LowValue={$CutLow/100*$HighValue}
-cut $LowValue,$HighValue
-normalize 0,1
-endif
#Scale to 255 for Gimp
-mul 255
#Cut 0,255 for Gimp
-cut 0,255
-if {$ProcessTo==1}
--display_histogram {0,w},{0,h},255,0,254,0
-blend lighten,0.7
-endif
-if {$ProcessTo==2}
--display_histogram {0,w},{0,h},255,0,254,0,log(1+i)-1
-blend lighten,0.7
-endif
-endif
#@gui Luminance to Alpha : fx_split_luminance, fx_split_luminance(1)
#@gui : note = note("Filter splits image to different levels of Luminance. Set preview output to "all outputs". Order of output to Gimp from top to bottom is Midtones,Light,LL,..,Dark,DD,.. If reduced overlap is used then first Light layer is removed from output as redundant if more than one level is processed. Mutilevel output becomes Midtones,,LL,LLL,..,Dark,DD,DDD.. with intermediary light and dark levels containing midtones. ")
#@gui : sep = separator()
#@gui : Levels = int (1,1,6)
#@gui : Output as Alpha = bool(1)
#@gui : Reduce Overlap = bool(1)
#@gui : sep = separator(), note = note("Use -keep[] or -remove[] to select output images")
#@gui : Keep Custom = bool(0)
#@gui : Keep Custom = text(0,-keep[-1])
#@gui : sep = separator(), note = note("<small>Author: <i>Arto Huotari;</i>.      Latest update: <i>2014/04/13</i>.</small>")
intersect_images:
--lt[0] [1]
-mul[-1] 255
--lt[1] [0]
-mul[-1] 255
-sub[0] [-1]
-sub[1] [-2]
-remove[-1,-2]
-cut[0] 0,255
-cut[1] 0,255
-add[0] [1]
-remove[1]
create_base_levels:
Levels=$1
-repeat {$Levels-1}
#Multiply D level with loop index+1
--mul[2] {$>+1}
#Subtract i*D from L
--sub[1] [-1]
-remove[-2]
-cut[-1] 0,255
-done
-repeat {$Levels-1}
#Multiply L with loop index + 1
--mul[1] {$>+1}
#Subtract i*L from D
--sub[2] [-1]
-remove[-2]
-cut[-1] 0,255
-done
reorder_stack :
Levels=$1
-move[3] 1
-if {$Levels>1}
-reverse[2,3]
-move[2] {-$Levels+1}
-endif
reduce_overlap :
Levels=$1
-repeat {$Levels-1}
-sub[{2+$>}] [{3+$>}]
-cut[{2+$>}] 0,255
-done
-repeat {$Levels-1}
-sub[{-$Levels+$>}] [{-$Levels+$>+1}]
-cut[{-$Levels+$>}] 0,255
-done
-sub[1] [{-$Levels-1}]
-sub[1] [-1]
-cut[1] 0,255
fx_split_luminance:
Levels=$1
AlphaOutput=$2
ReduceOverlap=$3
KeepCustom=$4
KeepText=$5
-to_rgb
--rgb2lab
-split[-1] c
-rm[-1,-2]
-normalize[-1] 0,255
--negate[-1]
--intersect_images[-1,-2]
-if {$ReduceOverlap==0}
-normalize[-1] 0,255
-endif
-create_base_levels $Levels
-reorder_stack $Levels
-if {{$ReduceOverlap==1}" && "{$Levels>1}}
-reduce_overlap $Levels
-endif
-repeat {$!-1}
#add 1 to alpha  and cut 0,225 to avoid cutting of colour channels
#no idea why this is necessary, it yields correct results
#Ma and ma are already 0 and even though 1 is added the output is still
#0 for transparent areas of the mask.
-add[{$>+1}] 1
-cut[$>] 0,255
-done
-if $AlphaOutput
-repeat {$!-1}
--append[0,1] c
-remove[1]
-done
-endif
-if {{$ReduceOverlap==1}" && "{$Levels>1}}
#D and L are now equal, remove first
-remove[2]
-endif
-remove[0]
-if $KeepCustom
$KeepText
-endif
#@gui Make Old Squiggly : fx_OldSquiggly, fx_OldSquiggly
#@gui : note = note("Development version. This version will be removed in future from sources so if you prefer this then copy and save the source to your local .gmic file")
#@gui : Spread Noise Amount = float(2,0,20)
#@gui : Segmentation Edge Threshold = float(12,0,15)
#@gui : Segmentation Smoothness = float(0.8,0,5)
#@gui : GradienNormSmoothness = float(0,0,10)
#@gui : GradienNormLinearity = float(0.5,0,1.5)
#@gui : IncreaseChroma1 = float(3,1,4)
#@gui : Tone Threshold = float(0.2,0,1)
#@gui : Tone Gamma = float(0.4,0,1)
#@gui : Paper Grayness = int(50,0,255)
#@gui : Paper Whiteness = int(245,0,255)
#@gui : Squiggle Gamma = int(45,1,128)
#@gui : Squiggle Multiplier = float(0.5,0,1)
fx_OldSquiggly :
--fx_spread[0] $1,$1,0,0
-fx_segment_watershed[1] $2,$3,0,0
--fx_gradient_norm[1] $4,$5,0,100,0,0
--blend[2,1] multiply
-fx_mix_ycbcr[3] 1,0,0,$6,0,0,$6,0,0,0,2,0
-fx_map_tones[0] $7,$8,0.1,30,0,0
-blend[0,3] darken
-remove[1,2]
--fx_plasma 0.5,10,8,0
-fx_blackandwhite[1] 0.299,0,0.587,0,0.114,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0
-fx_apply_curve[1] $9,-1,128,-1,128,-1,128,-1,128,-1,128,$10,1,3,0,0,0
-fx_apply_curve[0] 0,$11,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
-mul[0] {0.5*(1+$12)}
-mul[1] {0.5*(1-$12)}
--add[0] [1]
--blend[0,2] softlight
-remove[0,1,2]
#@gui Mapped Smoothing : fx_MappedSmooth, fx_MappedSmooth
#@gui : sep = separator()
#@gui : note =note("Two layers required if automap is not used. <b>Set input to active and below</b>. Filter Smooths image with a vector field map. Map is created from R and G channels so that R128,G128 becomes [0 0]. Experiment with solid 128,128,0 color layer and add hues of red and green. Angle shift rotates the vector field and Zero point offset moves the default 0 0 point. This is somewhat a development version, sample art is still missing.")
#@gui : sep = separator()
#@gui : Map Type = choice("Automap","Layer Map")
#@gui : Angle Shift = float(0,-180,180)
#@gui : Zero Point Offset = float(0,-128,128)
#@gui : Amplitude = float(300,10,10000)
#@gui : Vector Length Multipler = float(1,0.1,5)
#@gui : sep = separator()
#@gui : note = note("Optional viewing of vector field")
#@gui : Show Quiver = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2012/02/25</i>.</small>")
fx_MappedSmooth :
MapType=$1
fi={$2*3.1415/180}
ZeroOffset=$3
Amplitude=$4
LMult=$5
ShowQuiver=$6
-if {$MapType==0}
--fx_local_orientation 0.5,0,100,0,4,0
-endif
cosfi={cos($fi)}
sinfi={sin($fi)}
-to_rgb[-2,-1]
--[-1] {128+$ZeroOffset}
-split[-1] c
-mul[3] 0
--mul[1] $cosfi
--mul[2] $sinfi
-sub[4] [5]
-rm[5]
--mul[1] $sinfi
--mul[2] $cosfi
-add[5] [6]
-rm[6]
-rm[1,2]
-rm[1]
100%,100%,100%,1,0
-append[1,2,3] c
-/[-1] {128/$LMult}
-channels[-1] 0,1
-if {$ShowQuiver==0}
-vector2tensor[-1]
-smooth[-2] [-1],$Amplitude
-endif
-if {$ShowQuiver==1}
-quiver[-2] [-1],10,{$Amplitude/20},1,0.8,255
-endif
-rm[-1]
#@gui Night HDR Image Black Noise Correction : fx_fix_HDR_black, fx_fix_HDR_black_preview(0)
#@gui : note =note("Filter to remove blue, magenta and red noise from the black areas of HDR images. Filter is designed specifically for HDR night shots but may work on other images as well. Bilateral filtering and Haar Wavelets are used to filter the noise from the image and mask is used to apply the noise removal only to dark areas.")
#@gui : sep = separator(), note=note("Mask opacity settings, Black values must be lower than Highlight values. Tick Show mask to view mask and to see the effect of the sliders.")
#@gui : note =note("Black cutoff")
#@gui : X-Coord(1) = int(20,0,255)
#@gui : Y-Coord(1) = int(25,0,255)
#@gui : note =note("Highlight raising")
#@gui : X-Coord(2) = int(50,0,255)
#@gui : Y-Coord(2) = int(200,0,255)
#@gui : Show Mask = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2013/11/02</i>.</small>")
fx_fix_HDR_black:
-to_rgb[0]
X1=$1
Y1=$2
X2=$3
Y2=$4
ShowMask=$5
--fx_smooth_bilateral[-1] 4,8,6,4,0
-fx_smooth_haar[-1] 0.6,5,2,3,1,24
--rgb2lab[-1]
-split[-1] c
-rm[-1,-2]
-fx_apply_curve[-1] 0,$X1,$Y1,$X2,$Y2,-1,128,-1,128,-1,128,255,1,0,0,21,0
-if {$ShowMask==0}
-negate[-1]
-append[-2,-1] c
-to_rgba[-1]
-blend[0,-1] alpha
-keep[0]
-endif
fx_fix_HDR_black_preview :
-gui_split_preview "-fx_fix_HDR_black ${1--2}",$-1
#@gui Noise Painting : fx_noisepainting, fx_noisepainting_preview(0)
#@gui : note = note("A preprocess suggestion for the painting filter.")
#@gui : sep = separator(), note = note("Pre process for painting")
#@gui : Spread Noise = int(0,0,20)
#@gui : Additive Noise = int(0,0,30)
#@gui : Luminance Only = bool(0)
#@gui : sep = separator(), note = note("Painting abstration")
#@gui : Abstraction = int(5,1,10)
#@gui : Details Scale = float(2.5,0,5)
#@gui : Color = float(1.5,0,4)
#@gui : Smoothness = float(50,0,1000)
#@gui : Sharpen Shades = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2012/07/12</i>.</small>")
fx_noisepainting :
DegrLarge=$1
DegrSmall=$2
Channel=$3
Abstr=$4
Details=$5
Color=$6
Smooth=$7
Sharp=$8
-to_rgb[0]
-if {$Channel} Channel=3 -elif Channel=0 -endif
-if $PreProcess -fx_segment_watershed $EdgeThresh,$WaterSmooth,0,0 -endif
-if {$DegrLarge!=0} -fx_spread $DegrLarge,$DegrLarge,0,0 -endif
-if {$DegrSmall!=0} -fx_noise $DegrSmall,2,$Channel,0,0 -endif
-fx_painting $Abstr,$Details,$Color,$Smooth,$Sharp,0
fx_noisepainting_preview :
-gui_split_preview "-fx_noisepainting ${1--2}",$-1
#@gui Smooth Sketch : fx_SmoothSketch, fx_SmoothSketch_preview(0)
#@gui : note = note("Convert image to black and white sketch. By default gradient edges are used but if filter input set to Active and Below a premade edge layer can be used from the layer below. Sketch strength slider will not have any effect if premade edges layer is used.")
#@gui : sep = separator()
#@gui : note = note("Sketch and edges")
#@gui : Create Sketch = bool(1)
#@gui : Sketch Strength = float(6,0,20)
#@gui : Sharpness = float(0.8,0,1)
#@gui : Anisotropy = float(0.3,0.1,1)
#@gui : Smoother Scaling = float(0.3,0.1,2.5)
#@gui : Smoother Degradation = float(0,0,1)
#@gui : Smoothing Amplitude = float(1000,1,3000)
#@gui : Smudge Angle = float(0,-180,180)
#@gui : sep = separator()
#@gui : note = note("Empty area coloring")
#@gui : Coloring Density = float(50,0,200)
#@gui : Coloring Stroke Length = float(10,0,100)
#@gui : Coloring Style = choice(2,"Linear","Angular","Linear wavy","Angular wavy")
#@gui : Coloring Opacity = float(0.6,0,1)
#@gui : sep = separator()
#@gui : note = note("Post processing parameters")
#@gui : Post Gamma = float(0.55,0.1,2)
#@gui : Fast = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2014/08/31</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/groups/gmic/discuss/72157628307225747")
fx_SmoothSketch :
UsmRadius=5
CreateSketch=$1
UsmAmount=$1
Sharpness=$2
Anisotropy=$3
SmScale=$4
SmAccuracy={$5}
Amplitude=$6
fi=$7
Density=$8
BlurLength=$9
Style=$10
BgOpacity=$11
PostGamma=$12
OptimizedResult=$13
-if $OptimizedResult
OriginalWidth={0,w}
#Resize to 1024 width (all in case a bottom layer is included
-resize2dx 1024
-fx_smooth_selective[-1] 5,0.5,5,1,0,0,24,0
-endif
-if {$CreateSketch==1}
#Unsharp to enhance edges and detail
#-unsharp[-1] $UsmRadius,$UsmAmount
-fx_unsharp[-1] 0,$UsmRadius,30,$UsmAmount,0,1,1,1,0,0,0
#Gradient norm for lines
--gradient_norm[-1]
#Invert for white bg
-negate[-1]
#Normalize for max range
-normalize[-1] 0,255
-endif
(255;255;255)
-r[-1] [-2]
-fx_noise[-1] $Density,0,3,0,0
-if {$Style==0}
-fx_blur_linear[-1] $BlurLength,0,135,500,1,3,0,0
-endif
-if {$Style==1}
-fx_blur_angular[-1] $BlurLength,1.2,1.2,0,0,0
-endif
-if {$Style==2}
-fx_blur_linear[-1] $BlurLength,0,135,500,1,3,0,0
-deform[-1] {$Density/5}
-endif
-if {$Style==3}
-fx_blur_angular[-1] $BlurLength,1.2,1.2,0,0,0
-deform[-1] {$Density/5}
-endif
-blend[-1,-2] multiply,$BgOpacity,0
-normalize[-1] 0,255
--diffusiontensors[0] $Sharpness,$Anisotropy,0.6,1.1,0
-rotation3d 0,0,1,{$fi}
-mix_channels[-2] ({@0-2};{@3-5};{@6-8})
-rm[-1]
-mul[-1] {$SmScale/max(abs(iM),abs(im))}
-noise[-1] {$SmAccuracy*max(abs(iM),abs(im))}
-reverse[-1,-2]
-smooth[-1] [-2],$Amplitude
-keep[-1]
-apply_gamma[-1] $PostGamma
-if $OptimizedResult
-resize2dx $OriginalWidth
-endif
fx_SmoothSketch_preview :
-gui_split_preview "-fx_SmoothSketch ${1--2}",$-1
#@gui Vector Field Rotation Demo : fx_DemoVecRot, fx_DemoVecRot
#@gui : note =note("Vector field rotation and quiver sample")
#@gui : Angle Shift = float(0,-180,180)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i> with help from <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.     Latest update : <i>2012/02/25</i>.</small>")
fx_DemoVecRot :
angle=$1
-to_rgb[0]
[0]
-to_rgb[-1]
-split[-1] c
--[-2] 128
--[-3] 128
-append[-3,-2,-1] c
-channels[-1] 0,1
-/[-1] 128
#200,200,1,2 200x200x1 px only two channels
-rotation3d 0,0,1,$angle
-z[-1] 0,0,1,1
-mix_channels[-2] ({@0-1};{@2-3})
-rm[-1]
-quiver[-2] [-1],10,10,1,0.8,255
-keep[-2]
#@gui Warp Test : fx_WarpTest, fx_WarpTest
#@gui : sep = separator()
#@gui : note =note("Two layers required if automap is not used. <b>Set input to active and below</b>. Filter offsetts image with a vector field map. Map is created from R and G channels so that R128,G128 becomes [0 0]. Experiment with solid 128,128,0 color layer and add hues of red and green. Angle shift rotates the vector field and Zero point offset moves the default 0 0 point. This is mainly for fun and testing.")
#@gui : sep = separator()
#@gui : Map Type = choice("Automap","Layer Map")
#@gui : Angle Shift = float(0,-180,180)
#@gui : Zero Point Offset = float(0,-128,128)
#@gui : Vector Length Multipler = float(1,0.1,128)
#@gui : sep = separator()
#@gui : note = note("Optional viewing of vector field")
#@gui : Show Quiver = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2012/02/28</i>.</small>")
fx_WarpTest :
MapType=$1
fi={$2*3.1415/180}
ZeroOffset=$3
LMult=$4
ShowQuiver=$5
-if {$MapType==0}
--fx_local_orientation 0.5,0,100,0,4,0
-endif
cosfi={cos($fi)}
sinfi={sin($fi)}
-to_rgb[-2,-1]
--[-1] {128+$ZeroOffset}
-split[-1] c
-mul[3] 0
--mul[1] $cosfi
--mul[2] $sinfi
-sub[4] [5]
-rm[5]
--mul[1] $sinfi
--mul[2] $cosfi
-add[5] [6]
-rm[6]
-rm[1,2]
-rm[1]
100%,100%,100%,1,0
-append[1,2,3] c
-/[-1] {128/$LMult}
-channels[-1] 0,1
-if {$ShowQuiver==0}
-warp[-2] [-1],1,1,0
-endif
-if {$ShowQuiver==1}
-quiver[-2] [-1],10,{$LMult/100},1,0.8,255
-endif
-rm[-1]
#@gui _
#@gui <i>Okyl168</i>
#@gui Jobs Colors : fx_jobs_colors, fx_jobs_colors_preview
#@gui : Gamma = float(0,-2,2)
#@gui : Equalize = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Oberon Leung</i>.      Latest update: <i>2014/25/01</i>.</small>")
fx_jobs_colors :
n 0,255 if $2 equalize 256 fi
luminance apply_gamma {10^$1} n 0,9 round
(22,187,20,36,235,240,245,243,247,209^18,97,147,157,79,110,121,142,170,200^19,158,192,60,67,65,64,64,64,185)
map[^-1] . rm.
fx_jobs_colors_preview :
gui_split_preview "fx_jobs_colors $*",$-1
#@gui _
#@gui <i>PhotoComix</i>
#@gui B&amp;W Steampunk Pencil : fx_steampen, fx_steampen_preview(0)
#@gui : sep = separator()
#@gui : Radius = float(0.95,0,4)
#@gui : Amplitude = float(14,0,200)
#@gui : Iterations = int(2,1,20)
#@gui : Steam Pressure = int(2,1,30)
#@gui : Lubrication = float(0.9,0,1.9)
#@gui : sep = separator()
#@gui : Contrast FX = choice("None-Skip","L Normalization","Mask","Boost","Fast Tone Map")
#@gui : Equalize = bool(true)
#@gui : sep = separator()
#@gui : note = note(" For a more "painted" effect")
#@gui : Add Painter's Touch = bool(false)
#@gui : note = note("If unchecked the 3 sliders below are disabled")
#@gui : sep = separator ()
#@gui : Painter's Touch Sharpness = float(0.5,0,2)
#@gui : Painter's Edge Protection Flow = float(0.75,0,1)
#@gui : Painter's Smoothness = float(0.48,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Last update : <i>2011/6/29 </i>.</small>")
fx_steampen :
-repeat $! -l[$>] -split_opacity -l[0]
-fx_pencilbw $1,$2,0,0,0
-fx_kuwahara $3,$4,0,0
-blur_xy $5
-if {$6==1} -fx_normalize_local 4.8,22,6.89,20,1,3,0
-elif {$6==2} -fx_contrast_swm 2,0,1
-elif {$6==3} -fx_contrast_swm 2,1,1
-elif {$6==4} -fx_map_tones_fast 3,0.5,3, -endif
-if {$7==1} -equalize 255 -endif
-if {$8==1} -fx_smooth_anisotropic 60,$9,$10,$11,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
fx_steampen_preview :
-gui_split_preview "-fx_steampen ${1--2}",$-1
#@gui Boost Screen : fx_compose_boostscreen,fx_compose_boostscreen
#@gui : Opacity = float(0.7,0,1)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(0.7,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_boostscreen :
-repeat $! -l[$>]
-fx_compose_screen $1,$2 [-1] -fx_compose_grainmerge $3,0
-endl -done
#@gui Color Doping : fx_compose_colordoping , fx_compose_colordoping
#@gui : Opacity = float(1,0,1)
#@gui : Revert Layers = bool(0)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_colordoping :
-reverse -fx_compose_lightness 1,$2 [^] -fx_compose_multiply $1,0
#@gui Color Sketch : fx_colorsketchbw, fx_colorsketchbw_preview(0)
#@gui : Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(1,0,10)
#@gui : Opacity = float(0.1,0,1)
#@gui : Edge = float(20,0,100)
#@gui : Fast Approximation = bool(1)
#@gui : Negative = bool(0)
#@gui : Quantize Colors = int (20,2,255)
#@gui : Color Smoothness = float(2,0.50,30)
#@gui : Mixer Mode = choice( "Color Doping","Darken","Hard Light","Grain Merge","Lightness","Multiply","Value")
#@gui : Color Intensity =float (1,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2010/29/12</i>.</small>")
fx_colorsketchbw :
--blur $3 -hardsketchbw[-1] $1,$2,$4,$5,$6
-if $7 -negate[-1] -endif
-quantize[-2] $8  -to_rgb  -blur_xy[-2] $9,$9
-if {$10==0} -fx_compose_colordoping $11,0
-elif {$10==1} -fx_compose_darken $11,0
-elif {$10==2} -fx_compose_hardlight $11,1
-elif {$10==3} -fx_compose_grainmerge $11,1
-elif {$10==4} -fx_compose_lightness $11,1
-elif {$10==5} -fx_compose_multiply $11,0
-elif {$10==6} -fx_compose_value $11,1 -endif
fx_colorsketchbw_preview :
-gui_split_preview "-fx_colorsketchbw ${1--2}",$-1
#@gui Color Stamp : fx_colorstamp, fx_colorstamp_preview(0)
#@gui : note = note ("BW module,analog to "Stamp"filter")
#@gui : sep = separator()
#@gui : Auto-Threshold = bool(1)
#@gui : Threshold = int(50,0,100)
#@gui : sep = separator()
#@gui : note = note ("Color module")
#@gui : Activate Color Module = bool(1)
#@gui : Quantize Colors =int(20,2,255)
#@gui : Color Smoothness = float(2,0,20)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i>PhotoComiX , Antaron, Mahvin, David Tschumperl&#233;</i>.             Latest update : 2011/17/05.</small>")
fx_colorstamp :
-repeat $! -l[$>] -split_opacity -l[0]
--norm
-if $1 -otsu[-1] 256 -else -t[-1] $2% -endif
-n[-1] 0,255
-apply_curve[-1] 1,0,0,101,33,170,229,255,255
-if {$3==1} -quantize[-2] $4 -to_rgb -blur_xy[-2] $5
-fx_compose_darken 1,0 -endif
-endl -a c -endl -done
fx_colorstamp_preview :
-gui_split_preview "-fx_colorstamp ${1--2}",$-1
#@gui Comix Colors : fx_compose_comix_color,fx_compose_comix_color
#@gui : Opacity = float(1,0,1)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(1,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_comix_color :
-rv -fx_compose_lightness $1,$2 [^] -fx_compose_grainmerge $3,0
#@gui Dark Edges : fx_compose_darkedges, fx_compose_darkedges(0)
#@gui : Opacity = float(1,0,1)
#@gui : Edges Smoothness = float(0.5,0,5)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(0.7,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_darkedges :
-fx_compose_edges $1,$2,$3 [^] -fx_compose_multiply $4,0
#@gui Dark Screen : fx_compose_darkscreen,fx_compose_darkscreen
#@gui : Opacity = float(0.7,0,1)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(0.7,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_darkscreen :
-repeat $! -l[$>]
-fx_compose_screen $1,$2 [-1] -fx_compose_multiply $3,0
-endl -done
#@gui Graphic Boost-Old : fx_graphic_boost, fx_graphic_boost_preview(0)
#@gui : sep = separator ()
#@gui : note = note("Unsharp Mask controls")
#@gui : Radius = float(1.25,0,20)
#@gui : Darken = float(2,0,10)
#@gui : sep = separator()
#@gui : Skip Others Steps = bool(false)
#@gui : note = note("Check for visual control, UNcheck to reactivate the other controls")
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("BW_Pencil Controls")
#@gui : Pencil Size = float(0.15,0,4)
#@gui : Pencil Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : Skip Others Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator ()
#@gui : Activate "Pencil Smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : Pencil Smoother Sharpness = float(0.5,0,2)
#@gui : Pencil Smoother Edge Protection = float(0.45,0,1)
#@gui : Pencil Smoother Smoothness = float (2,0,10)
#@gui : sep = separator()
#@gui : Skip Others Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator ()
#@gui : note = note("Merging Options")
#@gui : SWAP Layers = bool (True)
#@gui : note = note (""Swap" change the effect of Merging and Intesity")
#@gui : Merging Option = choice( "Hard Light","Grain Merge","Multiply","Color Burn","Overlay" ,"Value","Darken" ,"Stamp" )
#@gui : Intensity = float(1,0,1)
#@gui : sep = separator ()
#@gui : Add Painter's Touch = bool(true)
#@gui : note = note("If unchecked the 3 sliders below are disabled")
#@gui : sep = separator ()
#@gui : Painter's Touch Sharpness = float(0.5,0,2)
#@gui : Painter's Edge Protection Flow = float(0.45,0,1)
#@gui : Painter's Smoothness =float(1,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/10/01</i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=775")
fx_graphic_boost :
-repeat $! -l[$>] -split_opacity -l[0]
-fx_unsharp 1,$1,30,3,0,$2,0.40,1,0,0,0
-if {$3==1} -break -endif
--fx_pencilbw $4,$5,0,0,0
-if {$6==1} -keep[-1] -break -endif
-if {$7==1} -fx_smooth_anisotropic[1] 60,$8,$9,$10,1.1,0.8,30,2,0,1,1,0 -endif
-if {$11==1} -keep[-1] -break -endif
-if {$12==1}  -reverse -endif
-if {$13==0} -fx_compose_hardlight $14
-elif {$13==1} -fx_compose_grainmerge $14
-elif {$13==2} -fx_compose_multiply $14
-elif {$13==3} -fx_compose_colorburn $14
-elif {$13==4} -fx_compose_overlay $14
-elif {$13==5} -fx_compose_value $14,0
-elif {$13==6} -fx_compose_darken $14
-elif {$13==7} -fx_compose_stamp $14 -endif
-if {$15==1} -fx_smooth_anisotropic 60,$16,$17,$18,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
fx_graphic_boost_preview :
-gui_split_preview "-fx_graphic_boost ${1--2}",$-1
#@gui Graphic Colors : fx_compose_graphicolor,fx_compose_graphicolor
#@gui : Opacity = float(0.6,0,1)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(0.8,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers. ")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_graphicolor :
-reverse --fx_compose_luminance $1,$2, -rm[-2] -fx_compose_softlight $3,0
#@gui Graphic Novel-Old : fx_novelfx, fx_novelfx_preview(0)
#@gui : sep = separator ()
#@gui : note = note("Apply Local Normalization")
#@gui : SKIP This Step = bool(false)
#@gui : sep = separator ()
#@gui : note = note(" Local Normalization Controls")
#@gui : LN Amplititude = float(2,0,60)
#@gui : LN Size = float(6,0,64)
#@gui : LN Neightborhood-Smoothness = float(5,0,40)
#@gui : LN Average-Smoothness = float(20,0,40)
#@gui : sep = separator()
#@gui : SKIP All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note(" Pencil Options")
#@gui : Pencil Size = float(0.62,0,4)
#@gui : Pencil Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : SKIP All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : Activate "Pencil Smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : sep = separator()
#@gui : Pencil Smoother Sharpness = float(0.5,0,2)
#@gui : Pencil Smoother Edge Protection = float(0.78,0,1)
#@gui : Pencil Smoother Smoothness = float(1.92,0,10)
#@gui : sep = separator()
#@gui : SKIP All Other Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator()
#@gui : note = note ("Boost Merging Options")
#@gui : Swap Layers = bool (false)
#@gui : BOOST Merging Option = choice("Overlay","Multiply","Soft light","Color Burn","Darken","Stamp","Hard Light","Value","Grain Merge","Freeze")
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator ()
#@gui : Add Painter's Touch = bool(true)
#@gui : sep = separator ()
#@gui : Painter's Touch Sharpness = float(0.5,0,2)
#@gui : Painter's Edge Protection Flow = float(0.8,0,1)
#@gui : Painter's Smoothness =float(1.28,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/24/04</i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=1582")
fx_novelfx :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0} -fx_normalize_local $2,$3,$4,$5,1,3,0 -endif
-if {$6==0} --fx_pencilbw $7,$8,0,0,0 -endif
-if {$9==1} -keep[-1] -break -endif
-if {$10==1} -fx_smooth_anisotropic[-1] 60,$11,$12,$13,1.1,0.8,30,2,0,1,1,0 -endif
-if {$14==1} -keep[-1] -break -endif
-if {$15==1} -reverse -endif
-if {$16==0} -fx_compose_overlay[-1,0] $17
-elif {$16==1} -fx_compose_multiply[-1,0] $17
-elif {$16==2} -fx_compose_softlight[-1,0] $17
-elif {$16==3} -fx_compose_colorburn[-1,0] $17
-elif {$16==4} -fx_compose_darken[-1,0] $17
-elif {$16==5} -fx_compose_stamp[-1,0] $17
-elif {$16==6} -fx_compose_hardlight[-1,0] $17
-elif {$16==7} -reverse[1,0] -fx_compose_value[-1,0] $17,0
-elif {$16==8} -fx_compose_grainmerge[-1,0] $17
-elif {$16==8} -fx_compose_freeze[-1,0] $17 -endif
-if {$18==1} -fx_smooth_anisotropic 60,$19,$20,$21,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
fx_novelfx_preview :
-gui_split_preview "-fx_novelfx ${1--2}",$-1
#@gui GraphiX Colors : fx_compose_graphixcolor,fx_compose_graphixcolor
#@gui : Opacity = float(1,0,1)
#@gui : Revert Layers = bool(0)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_graphixcolor :
-reverse --fx_compose_value 1,$2 -keep[-1,-3] -fx_compose_grainmerge $1,0
#@gui Heavy Screen : fx_compose_heavyscreen, fx_compose_heavyscreen
#@gui : Opacity = float(0.6,0,1)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(0.7,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers ")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_heavyscreen :
-repeat $! -l[$>]
-fx_compose_screen $1,$2 [-1] -fx_compose_colorburn $3,0
-endl -done
#@gui Metallic Grain : fx_metalgrain, fx_metalgrain_preview
#@gui : note = note("add a metallic grain adapt to pictorial and special effects")
#@gui : sep = separator()
#@gui : note = note("dependent from "Couleurs Metalliques" by Samj ")
#@gui : sep = separator()
#@gui : Intensity = float(0.5,0.1,1)
#@gui : Swap Layers = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComix,a hack of a Samj filter</i>.      Latest update : <i>2012/29/02</i>.</small>")
fx_metalgrain :
--Couleurs_Metalliques 1,1,19.86,0,0,0,7.4,11,3.96,20,1,0,0,1,1.9,10.2,1,0,0
-fx_compose_overlay  $1,$2
fx_metalgrain_preview :
-gui_split_preview "-fx_metalgrain ${1--2}",$-1
#@gui Metallic Stencils : fx_metallicstencils , fx_metallicstencils_preview
#@gui : Set Mode = choice("Darken","Lighten","Overlay")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComix,a hack of a Samj filter</i>.      Latest update : <i>2012/03/10</i>.</small>")
fx_metallicstencils :
--Couleurs_Metalliques 0,1,22,0,0,1,7.8,9,7.6,16.6,1,0,0,1,2.4,8.2,1,0
--fx_lylejk_stencil[0] 4,26.7045,2.41477,0
-rm[0]
-if {$1==0} -fx_compose_darken 1,0
-elif {$1==1} -fx_compose_lighten 1,0
-elif {$1==2} -fx_compose_overlay 1,0 -endif
fx_metallicstencils_preview :
-gui_split_preview "-fx_metallicstencils ${1--2}",$-1
compose_average :
-e[^-1] "Compose image$? two-by-two, using average mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -+
-endl -done -/ 2 -v +
compose_colorburn :
-e[^-1] "Compose image$? two-by-two, using colorburn mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --[-2] 255 -+[-1] 0.1 -/
-endl -done -* 256 -+ 255 -c 0,255 -v +
compose_darken :
-e[^-1] "Compose image$? two-by-two, using darken mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -min
-endl -done -v +
compose_difference :
-e[^-1] "Compose image$? two-by-two, using difference mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --
-endl -done -abs -v +
compose_divide :
-e[^-1] "Compose image$? two-by-two, using divide mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -*[-2] 256 -+[-1] 1 -/
-endl -done -c 0,255 -v +
compose_dodge :
-e[^-1] "Compose image$? two-by-two, using dodge mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --[-1] 255.1 -/
-endl -done -* -256 -c 0,255 -v +
compose_edges : -check {$1>=0}
-e[^-1] "Compose image$? using edge mode, with smoothness $1."
-if {$!>1} -v - -to_rgb -r[^0] [0],0,0,0.5,0.5 -repeat $! -l[$>]
--gradient_norm -+[-1] 1 -b[-1] $1 -n[-1] 1,10 -sqr[-1] -s[-2] c -*[-4--2] [-1] -a[-4--1] c
-endl -done -r[^0] [0],0,0,0.5,0.5 -+ -s[-1] c -/[-4--2] [-1] -rm[-1] -a[-3--1] c -v + -endif
compose_exclusion :
-e[^-1] "Compose image$? two-by-two, using exclusion mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --*[-2] [-1] -/[-1] -128 -+
-endl -done -v +
compose_fade :
-e[^-1] "Compose image$? using fading mode."
-v - -r[^0] ${-max_whd},100%,3
-r[1--2] 100%,100%,100%,${-max_s} -channels[-1] 0
-repeat {$!-1} ---[-1] $> -abs[-1] --[-1] 1 -*[-1] -1 -max[-1] 0 -*[$>,-1] -done
-rm[-1] -+ -v +
compose_freeze :
-e[^-1] "Compose image$? two-by-two, using freeze mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --[-2] 255 -sqr[-2] -+[-1] 0.1 -/
-endl -done -- 255 -* -1 -c 0,255 -v +
compose_grainextract :
-e[^-1] "Compose image$? two-by-two, using grain extract mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --
-endl -done -+ 128 -c 0,255 -v +
compose_grainmerge :
-e[^-1] "Compose image$? two-by-two, using grain merge mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -+
-endl -done -- 128 -c 0,255 -v +
compose_hardlight :
-e[^-1] "Compose image$? two-by-two, using hard light mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5
--ge[-1] 128 --*[-3] [-2] -/[-1] 128
--[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
-*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1] -+
-endl -done -v +
compose_hue :
-e[^-1] "Compose image$? two-by-two, using hue mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2hsv[-2,-1] -sh[-2] 0,0 -j[-2] [-1] -rm[-5,-3,-1] -hsv2rgb[-1] -rm[-1]
-endl -done -v +
compose_interpolation :
-e[^-1] "Compose image$? two-by-two, using interpolation mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -* 0.012271846 -cos -/ -4 -+
-endl -done -+ 0.5 -* 256 -v +
compose_lighten :
-e[^-1] "Compose image$? two-by-two, using lighten mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -max
-endl -done -v +
compose_lightness :
-e[^-1] "Compose image$? two-by-two, using lightness mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2lab[-2,-1] -sh[-2] 0,0 -j[-2] [-1],0,0,0,0 -rm[-5,-3,-1] -lab2rgb[-1] -rm[-1]
-endl -done -v +
compose_luminance :
-e[^-1] "Compose image$? two-by-two, using luminance mode."
-v - -repeat {int($!/2)}
-to_colormode[-2,-1] 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba[-2,-1] -sh[-2,-1] 0,2
-rgb2ycbcr[-2,-1] -sh[-2] 0,0 -j[-2] [-1],0,0,0,0 -rm[-5,-3,-1] -ycbcr2rgb[-1] -rm[-1]
-mv[-1] 0 -done -v +
compose_median :
-e[^-1] "Compose image$? using median mode."
-if {$!==1} -return -endif
-v - -r[^0] [0],0,0,0.5,0.5 -a z -permute zxyc -s y,-64
-repeat $! -l[$>]
-r 100%,{w*100}%
-s z -median {w} w={w} -columns {int(w/2)} -r 1,{h/$w} -a z
-endl -done -a y -permute yzxc -v +
compose_multiply :
-e[^-1] "Compose image$? two-by-two, using multiply mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -*
-endl -done -/ 255 -v +
compose_negation :
-e[^-1] "Compose image$? two-by-two, using negation mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -+
-endl -done -- 255 -abs -- 255 -* -1 -v +
compose_overlay :
-e[^-1] "Compose image$? two-by-two, using overlay mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5
--ge[-2] 128
--*[-3] [-2] -/[-1] 128
--[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
-*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1] -+
-endl -done -v +
compose_reflect :
-e[^-1] "Compose image$? two-by-two, using reflect mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -sqr[-2] --[-1] 255.1 -/
-endl -done -* -1 -c 0,255 -v +
compose_rgba :
-e[^-1] "Compose image$? two-by-two, using alpha blending."
-v - -to_rgb[0--1:2] -compose_alpha -v +
compose_saturation :
-e[^-1] "Compose image$? two-by-two, using saturation mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2hsv[-2,-1] -sh[-2] 1,1 -j[-2] [-1],0,0,0,1 -rm[-5,-3,-1] -hsv2rgb[-1] -rm[-1]
-endl -done -v +
compose_screen :
-e[^-1] "Compose image$? two-by-two, using screen mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -- 255 -*
-endl -done -/ 256 -- 255 -* -1 -v +
compose_shapeaverage :
-e[^-1] "Compose image$? two-by-two, using shape average mode."
-v - -repeat {int($!/2)} -l[-2,-1] nm={0,n}
-channels[-1] 0 -ge[-1] 50% -label_fg[-1] 0 nb={iM+1} -*[-1] 256
-rv[-2,-1] m={im} M={iM} -n[-1] 0,255 -s[-1] c -+[^0] [0]
-repeat {$!-1}
-histogram[-1] {$nb*256},0,{$nb*256-1}
-i[-2] 256,1,1,1,'x' -r[-2] {w},1,1,1,0,2 -*[-2] [-1] -r[-2,-1] $nb,1,1,1,2 -max[-1] 1 -/[-2,-1]
-mv[-1] 1 -done
-/[0] 256 -a[^0] c -*[-1] {($M-$m)/256} -+[-1] $m -point[-1] 0,0,0,1,0 -map[0] [-1] -rm[-1]
-nm $nm,1 -endl -mv[-1] 0 -done -v +
compose_softlight :
-e[^-1] "Compose image$? two-by-two, using soft light mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -/ 256 --*[-2] [-1] -*[-1] 2 -sqr[-3] -*[-2] [-3] -*[-2] -2 -+
-endl -done -* 256 -v +
compose_stamp :
-e[^-1] "Compose image$? two-by-two, using stamp mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -*[-1] 2 -+
-endl -done -- 255 -c 0,255 -v +
compose_value :
-e[^-1] "Compose image$? two-by-two, using value mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2hsv[-2,-1] -sh[-2] 2,2 -j[-2] [-1],0,0,0,2 -rm[-5,-3,-1] -hsv2rgb[-1] -rm[-1]
-endl -done -v +
compose_xor :
-e[^-1] "Compose image$? two-by-two, using xor mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -xor
-endl -done -v +
_fx_compose :
-repeat {int($!/2)} --compose_$1[-2,-1] -rm[-3] -to_rgba[-1] -sh[-1] 3,3 -*[-1] $2 -rm[-1] -compose_alpha[-2,-1] -mv[-1] 0 -done
_fx_revert_layers :
-repeat {int($!/2)} -rv[{2*$>},{2*$>+1}] -done
fx_compose_average :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose average,$1
fx_compose_colorburn :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose colorburn,$1
fx_compose_darken :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose darken,$1
fx_compose_difference :
-if ${2=0} -_fx_revert_layers -endif
-to_rgb -_fx_compose difference,$1
fx_compose_divide :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose divide,$1
fx_compose_dodge :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose dodge,$1
fx_compose_edges :
-if ${3=0} -_fx_revert_layers -endif
-repeat {int($!/2)} --compose_edges[-2,-1] $2 -rm[-3] -to_rgba[-1] -sh[-1] 3,3 -*[-1] $1 -rm[-1] -compose_alpha[-2,-1] -mv[-1] 0 -done
fx_compose_exclusion :
-if ${2=0} -_fx_revert_layers -endif
-to_rgb -_fx_compose exclusion,$1
fx_compose_fade :
-if {$!==1} -return -endif
-to_colormode 4
-if {$1==0} [0],[0],1,1,"$10"
-else -_fx_compose_fade$1 $7,$8,$9 -r[-1] [0],[0],1,1,3
-endif
-n[-1] {-($!-2)*$3},{($!-2)*(1+$3)}
--[-1] {$2*(1+$3)*($!-2)}
-c[-1] 0,{$!-2}
-if $6 -rv[^-1] -endif
-if $5 -round[-1] 1
-else -roundify[-1] $4
-endif
-compose_fade
-c 0,255
_fx_compose_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_fx_compose_fade2 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1
_fx_compose_fade3 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1 -*[-1] {0.01+$3/2} -cos[-1]
_fx_compose_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"
fx_compose_freeze :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose freeze,$1
fx_compose_grainextract :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose grainextract,$1
fx_compose_grainmerge :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose grainmerge,$1
fx_compose_hardlight :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose hardlight,$1
fx_compose_hue : -skip ${2=0}
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose hue,$1
fx_compose_interpolation :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose interpolation,$1
fx_compose_lighten :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose lighten,$1
fx_compose_lightness : -skip ${2=0}
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose lightness,$1
fx_compose_luminance : -skip ${2=0}
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose luminance,$1
fx_compose_multiply :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose multiply,$1
fx_compose_negation :
-if ${2=0} -_fx_revert_layers -endif
-to_rgb -_fx_compose negation,$1
fx_compose_overlay :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose overlay,$1
fx_compose_reflect :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose reflect,$1
fx_compose_saturation : -skip ${2=0}
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose saturation,$1
fx_compose_screen :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose screen,$1
fx_compose_shapeaverage :
-if ${3=0} -_fx_revert_layers -endif
-to_rgb
-repeat {int($!/2)}
-rv[-2,-1]
-if $1 -i[0] [-1] -endif
-compose_shapeaverage[-2,-1]
-if $1 -*[0,-1] -/[0] 255 -mv[0] $! -endif
-if $2 -to_rgba[-1] -replace_color[-1] 0,0,0,0,0,255,0,0,0,0 -endif
-mv[-1] 0 -done
fx_compose_softlight :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose softlight,$1
fx_compose_stamp :
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose stamp,$1
fx_compose_value : -skip ${2=0}
-if ${2=0} -_fx_revert_layers -endif
-_fx_compose value,$1
fx_compose_xor :
-if ${2=0} -_fx_revert_layers -endif
-to_rgb -_fx_compose xor,$1
#@gui Phoenix Steam-Pencil : fx_phoenix, fx_phoenix_preview(0)
#@gui : sep = separator()
#@gui : note = note( "Controls for "Pencil" applied on a copy of original )
#@gui : sep = separator()
#@gui : Radius = float(0.95,0,4)
#@gui : Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : note = note( "Controls for "Steam" applied on the Pencil layer )
#@gui : sep = separator()
#@gui : Iterations = int(2,1,7)
#@gui : Steam Pressure = int(2,1,7)
#@gui : Lubrication = float(0.9,0,1.9)
#@gui : sep = separator()
#@gui : note = note( "To exit here or merge with the original")
#@gui : BW or Colours = choice ( "Black and White", "Colours" )
#@gui : note = note(" to activate the Merging Options below chose "Colours"" )
#@gui : sep = separator()
#@gui : SWAP Layers = bool(0)
#@gui : Merging Options = choice("Value","Lightness","Luminance","*Colors Doping*","*Comix Colors*","Graphic Colors*" ,*Dark Edges*", "*Vivid Edges*","Multiply","Color Burn","Darken","Lighten","Hard Light","Soft Light","Overlay","Grain Merge","Edges","Interpolation" )
#@gui : Opacity = float (1,0,1)
#@gui : *Intensity* = float (1,0,1)
#@gui : sep = separator(),
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Last update : <i>2011/11/14 </i>.</small>")
#@gui : note = link("Filter how to and help","http://www.gimpchat.com/viewtopic.php?f=9&t=2983")
fx_phoenix :
--fx_pencilbw $1,$2,0,0,0
-fx_kuwahara[1] $3,$4,0,0
-to_rgb[-1] -blur_xy[1] $5
-if {$6==0} -remove[0] -return -endif
-if {$8==0} -reverse -fx_compose_value $9,$7
-elif {$8==1} -reverse -fx_compose_lightness $9,$7
-elif {$8==2} -reverse -fx_compose_luminance $9,$7
-elif {$8==3} -fx_compose_colordoping $9,$7
-elif {$8==4} -fx_compose_comix_color $9,$7,$10
-elif {$8==5} -fx_compose_graphicolor $9,0,$7
-elif {$8==6} -fx_compose_graphixcolor $9,$7
-elif {$8==7} -fx_compose_vividedges $9,0.50,$7,$10
-elif {$8==8} -fx_compose_darkedges $9,0.50,$7,$10
-elif {$8==6} -fx_compose_multiply $9,$7
-elif {$8==7} -fx_compose_colorburn $9,$7
-elif {$8==8} -fx_compose_darken $9,$7
-elif {$8==9} -fx_compose_lighten $9,$7
-elif {$8==10} -fx_compose_screen $9,$7
-elif {$8==11} -fx_compose_hardlight $9,$7
-elif {$8==12} -fx_compose_softlight $9,$7
-elif {$8==13} -fx_compose_overlay $9,$7
-elif {$8==14} -fx_compose_grainmerge $9,$7
-elif {$8==15} -fx_compose_edges $9,0.80,$7
-elif {$8==16} -fx_compose_interpolation $9,$7  -endif
fx_phoenix_preview :
-gui_split_preview "-fx_phoenix ${1--2}",$-1
#@gui PhotoComiX Smoothing : fx_smooth_anisotropic, fx_smooth_anisotropic(0)
#@gui : Amplitude = float(60,0,1000)
#@gui : Sharpness = float(0.16,0,2)
#@gui : Anisotropy = float(0.63,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(2.35,0,10)
#@gui : Spatial Precision = float(0.8,0.1,2)
#@gui : Angular Precision = float(30,1,180)
#@gui : Value Precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : Channel(s) = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gui : Tiles = int(1,1,10)
#@gui : note = note{"\n<small><b>Note : </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2010/29/12</i>.</small>")
#@gui Psychedelic Glasswork Tiler : fx_psyglass, fx_psyglass_preview(1)
#@gui : sep = separator()
#@gui : note = note("Stained Glass controls")
#@gui : White Separators = bool(false)
#@gui : Edges = float(20,0,100)
#@gui : Shading = float(0.1,0,0.5)
#@gui : Thin Separators = bool(1)
#@gui : Equalize = bool(1)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("To skip Layer Fx set Opacity to 0")
#@gui : sep = separator()
#@gui : Layer Fx = choice("Grain Merge","Hard Light","Soft Light","Overlay","Color Burn ","Multiply")
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("Quick Corrections and Special Fx")
#@gui : Apply Mask = bool(true)
#@gui : note = note(" Contrast Mask preset")
#@gui : sep = separator()
#@gui : Raise Local Contrast = bool(false)
#@gui : note = note("Local Normalization preset")
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("Mirrors Controls")
#@gui : Activate Mirrors = bool(true)
#@gui : sep = separator()
#@gui : Iterations = int(1,1,10)
#@gui : X-Offset = float(0,0,100)
#@gui : Y-Offset = float(0,0,100)
#@gui : Array Mode = choice(2,"X-axis","Y-axis","XY-axes","2XY-axes")
#@gui : Initialization = choice("Original","Mirror X","Mirror Y","Rotate 90 deg.","Rotate 180 deg.","Rotate 270 deg.")
#@gui : Expand Size = _bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>. Latest update : <i>2011/30/03</i>.</small>")
fx_psyglass :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0}
-blur 0.1 -stained_glass $2,$3,$4 -n 0,255
-elif {$1==1}
-negate -blur 0.1 -stained_glass $2,$3,$4 -n 0,255 -negate
-endif
-if $5 -equalize 256 -endif
--blur 0.9
-if {$6==0} -fx_compose_grainmerge $7
-elif {$6==1} -fx_compose_hardlight $7
-elif {$6==2} -fx_compose_softlight $7
-elif {$6==3} -fx_compose_overlay $7
-elif {$6==4} -fx_compose_colorburn $7
-elif {$6==5} -fx_compose_multiply $7
-endif
-if {$8==1} -fx_contrast_swm 2,0,1,0 -endif
-if {$9==1} -fx_normalize_local 2,6,5,20,1,3,0 -endif
-if $10
-if {$15==1} -mirror x
-elif {$15==2} -mirror y
-elif {$15==3} -rotate 90
-elif {$15==4} -rotate 180
-elif {$15==5} -rotate 270
-endif
-array_mirror $11,$14,$16
-shift -$12%,-$13%,0,0,2
-endif
-endl -a c -endl -done
fx_psyglass_preview :
-gui_split_preview " -fx_psyglass ${1--2}",$-1
#@gui Scale Down Neat : fx_scaledown3, fx_scaledown3_preview(0)
#@gui : sep = separator()
#@gui : note = note(" To scale down preserving clean edges and smoothly sharpen")
#@gui : sep = separator()
#@gui : Automatic Pre-Blur = bool(false)
#@gui : sep = separator()
#@gui : note = note(  "Automatic pre-blur" disable the 2 sliders below" )
#@gui : sep = separator()
#@gui : Blur X = float (1,0.2,4)
#@gui : Blur Y = float (1,0.2,4)
#@gui : sep = separator()
#@gui : Scale Down To = choice(1," New Width and Height  ", " preserve_image_ratio Set new Width " , "preserve_image_ratio Set new Height",)
#@gui : New Width = int(1600,16,3200)
#@gui : New Height = int(1600,16,3200)
#@gui : sep = separator()
#@gui : Skip Post Sharpening = bool(false)
#@gui : sep = separator()
#@gui : note = note( ""Skip Post Sharpening": if chosen will deactivate all controls below " )
#@gui : sep = separator()
#@gui : Amount = float(2.3,0,10)
#@gui : Darkness/Lightness Level = float(1,0,4)
#@gui : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComix</i>.      Latest update : <i>2012/25/09</i>.</small>")
fx_scaledown3 :
-if {$1==0 && $4==0} -blur_xy {w/$5},{h/$6}
-elif {$1==0 && $4==1} -blur_xy {w/$5},{w/$6}
-elif {$1==0 && $4==2} -blur_xy {h/$5},{w/$6}
-elif {$1==1 && $4==0} -blur_xy $2 ,$3
-elif {$1==1 && $4==1} -blur_xy $2 ,$3
-elif {$1==1 && $4==2} -blur_xy $2 ,$3
-endif
-if {$4==0}
-resize $5,$6,2
-elif {$4==1}
-resize2dx $5,2
-elif {$4==2}
-resize2dy $6,2
-endif
-if {$7==0}
-fx_unsharp 0,1.25,30,$8,0,$9,{$9/3},1,0,$10
-endif
fx_scaledown3_preview :
-gui_split_preview "-fx_scaledown3 ${1--2}",$-1
#@gui Symmetry Master : fx_viral,fx_viral
#@gui : Scale = float(3,0,15)
#@gui : Mixer = choice ("Average","Grain Extract","Vivid Edges","Difference", "Exclusion"," Negation")
#@gui : Remix = choice ( "Vivid Edges", "Average", "Difference","Negation","Dark Edges")
#@gui : PhotoComix Preset = choice( "Neat Merge","Lighty Smooth","Dream","Moody","Soft","Naif","Dark Boost","Whitening"," None- Skip" )
#@gui : Activate Mirror = choice ("No-Skip", XY Mirror"," 2XY Mirror")
#@gui : sep = separator()
#@gui : note = note("WARNING,"Expanding Mirrors" multiply image size of x4 or if "2XY Mirrors" x9")
#@gui : sep = separator()
#@gui : Expanding Mirrors = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComix</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_viral :
-fx_rorschach $1,1,1
--mirror y
-if {$2==0} -fx_compose_average 1,0
-elif {$2==1} -fx_compose_grainextract 1,0
-elif {$2==1} -fx_compose_vividedges 1,1,0.5,1 -endif
--fx_array_mirror 1,0,0,2,0,0
-if {$3==0} -fx_compose_vividedges 1,1,0.5,1
-elif {$3==1} -fx_compose_average 1,0
-elif {$3==2} -fx_compose_difference 1,0
-elif {$3==3} -fx_compose_negation 1,0
-elif {$3==4} -fx_compose_negation 1,0
-elif {$3==5} -fx_compose_darkedges 1,1,0.8,1 -endif
-if {$4==0} -fx_graphic_novelfxl 0,2,6,5,20,0,0.62,14,0,1,0.5,0.78,1.92,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==1}-fx_graphic_novelfxl 0,7.2,14.65,5,20,0,1.06,36.14,0,1,0.5,0.85,1.93,0,0,8,1,1,1,0.5,0.95,2.89,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==2} -fx_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.6,36.1,0,1,0.5,0.6,3.6,0,0,11,1,1,1,0.5,0.8,2.16,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$4==3}  -fx_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,17,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$4==4} -fx_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.855422,1.92771,0,0,8,1,1,1,0.5,0.373494,2.89157,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==5} -fx_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,14,0,1,0.5,0.855422,1.3253,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==6} -fx_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,36.1446,0,1,0.5,0.855422,1.92771,0,0,7,1,1,1,0.5,0.951807,1.92771,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==7} -fx_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,18,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1 -endif
-if {$5==1} -fx_array_mirror 1,0,0,2,0,$6
-elif {$5==2} -fx_array_mirror 1,0,0,3,0,$6 -endif
#@gui Vivid Colors : fx_compose_vivid_color,fx_compose_vivid_color
#@gui : Opacity = float(1,0,1)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(1,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_vivid_color :
-reverse -fx_compose_lightness $1,$2 [^] -fx_compose_softlight $3,0
#@gui Vivid Edges : fx_compose_vividedges, fx_compose_vividedges
#@gui : Opacity = float(1,0,1)
#@gui : Edges Smoothness = float(0.5,0,5)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(0.7,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_vividedges :
-fx_compose_edges $1,$2,$3 [^] -fx_compose_overlay $4,0
#@gui Vivid Screen : fx_compose_vividscreen , fx_compose_vividscreen
#@gui : Opacity = float(0.6,0,1)
#@gui : Revert Layers = bool(0)
#@gui : Opacity 2 = float(0.7,0,1)
#@gui : note = note ("This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.")
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update : <i>2011/13/11</i>.</small>")
fx_compose_vividscreen :
-repeat $! -l[$>]
-fx_compose_screen $1,$2 [-1] -fx_compose_overlay $3,0
-endl -done
#@gui Wild Cartoonizer : fx_m_l_unsharp2 , fx_m_l_unsharp2_preview(0)
#@gui : sep = separator ()
#@gui : sep = separator ()
#@gui : Radius 1 = float(12,0,100)
#@gui : Amount 1 = float (2.18,0,10)
#@gui : Radius 2 = float(0.3,0,100)
#@gui : Amount 2 = float (1.5,0,10)
#@gui : Darken Merge Opacity = float (1,0,1)
#@gui : Lighten Merge Opacity = float (0.5,0,1)
#@gui : sep = separator ()
#@gui : note = note(" Additional Painter Module ")
#@gui : sep = separator ()
#@gui : Add Painter's Touch = bool(false)
#@gui : Painter's Touch Sharpness = float(0.5,0,2)
#@gui : Painter's Edge Protection Flow = float(0.8,0,1)
#@gui : Painter's Smoothness =float(1.28,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = note("<small>Author: <i>PhotoComiX</i>. Latest update : <i>12/29/2010</i>.</small>")
fx_m_l_unsharp2 :
--unsharp $1,$2,0
-unsharp $3,$4,0[1] -reverse -fx_compose_darken $5
--unsharp $3,$4,0 -reverse -fx_compose_lighten $6
-if {$7==1} -fx_smooth_anisotropic 60,$8,$9,$10,1.1,0.8,30,2,0,1,1,0 -endif
fx_m_l_unsharp2_preview :
-gui_split_preview "-fx_m_l_unsharp2 ${1--2}",$-1
#@gui _
#@gui <i>Reptorian</i>
#@gui Channel Overblur-Overline-Blur-Sharpen : fx_OOBS, _fx_OOBS_preview(0)
#@gui : sep = separator()
#@gui : 1. Color Space = choice("RGB&#47;sRGB","HSV&#47;HSV8","HSL&#47;HSL8","HSI&#47;HSI8","LCH&#47;LCH8","Lab&#47;Lab8","YCbCr&#47;YCbCrGLIC","YIQ&#47;YIQ8","YUV&#47;YUV8","XYZ&#47;XYZ8")
#@gui : 2. Alt Choice = bool(0)
#@gui : sep = separator()
#@gui : note = note("Configuration for OOBS filter")
#@gui : 3. Use Master Editor(Manipulate Multiple Channels at Once?) = bool(1)
#@gui : 4. Edit Channel #1? = bool(1)
#@gui : 5. Edit Channel #2? = bool(1)
#@gui : 6. Edit Channel #3? = bool(1)
#@gui : 7. Edit Alpha Channel? = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Master Editor</b>")
#@gui : 8. Overblur/Overline/Sharpen/Blur = choice ("Overblur","Overline","Blur","Sharpen")
#@gui : 9. Effect Factor = float (1,.1,100)
#@gui : 10. Multiplication Factor = float (1,.1,10)
#@gui : 11. Blend Operation = choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui : 12. Blending Opacity = float (100,.01,100)
#@gui : sep = separator(), note = note("<u>Individual Channels</u>"), sep = separator()
#@gui : note = note("<b>Channel #1</b>")
#@gui : 13. Overblur/Overline/Sharpen/Blur = choice ("Overblur","Overline","Blur","Sharpen")
#@gui : 14. Effect Factor = float (1,.1,10)
#@gui : 15. Multiplication Factor = float (1,.1,10)
#@gui : 16. Blend Operation = choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui : 17. Blending Opacity = float (100,.01,100)
#@gui : sep = separator()
#@gui : note = note("<b>Channel #2</b>")
#@gui : 18. Overblur/Overline/Sharpen/Blur = choice ("Overblur","Overline","Blur","Sharpen")
#@gui : 19. Effect Factor = float (1,.1,10)
#@gui : 20. Multiplication Factor = float (1,.1,10)
#@gui : 21. Blend Operation = choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui : 22. Blending Opacity = float (100,.01,100)
#@gui : sep = separator()
#@gui : note = note("<b>Channel #3</b>")
#@gui : 23. Overblur/Overline/Sharpen/Blur = choice ("Overblur","Overline","Blur","Sharpen")
#@gui : 24. Effect Factor = float (1,.1,10)
#@gui : 25. Multiplication Factor = float (1,.1,10)
#@gui : 26. Blend Operation = choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui : 27. Blending Opacity = float (100,.01,100)
#@gui : sep = separator()
#@gui : note = note("<b>Alpha Channel</b>")
#@gui : 28. Overblur/Overline/Sharpen/Blur = choice ("Overblur","Overline","Blur","Sharpen")
#@gui : 29. Effect Factor = float (1,.1,10)
#@gui : 30. Multiplication Factor = float (1,.1,10)
#@gui : 31. Blend Operation = choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui : 32. Blending Opacity = float (100,.01,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>      Latest update: <i>2019/01/7</i>.</small>")
fx_OOBS:
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor","edges","error"
split_opacity
local[0]
if {$2==0}
if ($1==1} rgb2hsv
elif ($1==2} rgb2hsl
elif ($1==3} rgb2hsi
elif ($1==4} rgb2lch
elif ($1==5} rgb2lab
elif ($1==6} rgb2ycbcr
elif ($1==7} rgb2yiq
elif ($1==8} rgb2yuv
elif ($1==9} rgb2xyz
fi
elif {$2==1}
if {$1==0} rgb2srgb
elif {$1==1} rgb2hsv8
elif {$1==2} rgb2hsl8
elif {$1==3} rgb2hsi8
elif {$1==4} rgb2lch8
elif {$1==5} rgb2lab8
elif {$1==6} rgb2ycbcrglic
elif {$1==7} rgb2yiq8
elif {$1==8} rgb2yuv8
elif {$1==9} rgb2xyz8
fi fi
s c
if {$3==1}
if {$4==1} local[0] +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 endl fi
if {$5==1} local[1] +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 endl fi
if {$6==1} local[2] +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 endl fi
elif {$3==0}
if {$4==1} local[0] +oobs_edit[0] $13,$14,$15 -blend[0,1] ${_mode{$16+1}},$17/100 endl fi
if {$5==1} local[1] +oobs_edit[0] $18,$19,$20 -blend[0,1] ${_mode{$21+1}},$22/100 endl fi
if {$6==1} local[2] +oobs_edit[0] $23,$24,$25 -blend[0,1] ${_mode{$26+1}},$27/100 endl fi
fi
a c
if {$2==0}
if ($1==1} hsv2rgb
elif ($1==2} hsl2rgb
elif ($1==3} hsi2rgb
elif ($1==4} lch2rgb
elif ($1==5} lab2rgb
elif ($1==6} ycbcr2rgb
elif ($1==7} yiq2rgb
elif ($1==8} yuv2rgb
elif ($1==9} xyz2rgb
fi
elif {$2==1}
if {$1==0} srgb2rgb
elif {$1==1} hsv82rgb
elif {$1==2} hsl82rgb
elif {$1==3} hsi82rgb
elif {$1==4} lch82rgb
elif {$1==5} lab82rgb
elif {$1==6} ycbcrglic2rgb
elif {$1==7} yiq82rgb
elif {$1==8} yuv82rgb
elif {$1==9} xyz82rgb
fi fi
endl
local[1]
if {$3==1} if {$7==1} +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 fi
elif {$3==0} if {$7==1} +oobs_edit[0] $28,$29,$30 -blend[0,1] ${_mode{$31+1}},$32/100 fi
fi
endl
a c
oobs_edit :
if {$1==0} -overblur_overline[0] 0,$2,$3 fi
if {$1==1} -overblur_overline[0] 1,$2,$3 fi
if {$1==2} -blur[0] {$2*$3} fi
if {$1==3} -sharpen[0] {$2*$3} fi
overblur_overline :
if {$1==0} +blur[0] $2
elif {$1==1} +sharpen[0] $2
fi
+blend[0,1] difference
mul[2] $3
remove[1]
-blend[0,1] add
_fx_OOBS_preview :
gui_split_preview "fx_OOBS ${1--2}",$-1
#@gui Construction Material Texture : _cons_turb, _cons_turb_preview(0)
#@gui : note = note("Construction Material Texture filter is based off the following tutorial by <b>theonlychad</b> for Paint.NET software: <a href="https://forums.getpaint.net/topic/16075-concrete-texture-tutorial/">Concrete Texture Tutorial</a>.\n")
#@gui : sep = separator(), note = note("<b>Turbulance Texture</b>")
#@gui : 1-3. Background Color = color(0,0,0)
#@gui : 4. Radius = float(88,1,1024)
#@gui : 5. Octaves = int(8,1,12)
#@gui : 6. Damping per Octave = float(2.5,1,10)
#@gui : 7. Mode = choice(2,"Turbulence","Turbulence 2","Fractal Noise","Fractured Clouds","Stardust","Pea Soup")
#@gui : 8-10. Color Balance = color(128,128,128)
#@gui : sep = separator(), note = note("<b>Noise Processing</b>")
#@gui : 11. Amplitude = float(20,0,200)
#@gui : 12. Noise Type = choice(3,"Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui : sep = separator(), 13. Channel(s) = choice(0,"RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : 14. Value Action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator(), note = note("<b>Grayscale Processing</b>")
#@gui : 15. Colour Space = choice("RGB","sRGB")
#@gui : 15. Channel 1 = float(1,0,3)
#@gui : 16. Channel 2 = float(1,0,3)
#@gui : 17. Channel 3 = float(1,0,3)
#@gui : 18. Normalise = bool(1)
#@gui : 19. Desaturation (%) = float (100,0,100)
#@gui : sep = separator(), note = note("<b>Self-Image Processing</b>")
#@gui : 21. Self-Blending = choice(20,"add","burn","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","linearburn","linearlight","luminance","multiply","negation","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","vividlight")
#@gui : 22. Self-Blending Opacity (%) = float (100,0,100)
#@gui : 23. Self-Blending V. Original Blending = choice(15,"add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor")
#@gui : 24. Self-Blend V. Original Opacity (%) = float (100,0,100)
#@gui : sep = separator(), note = note("<b>Value Processing</b>")
#@gui : 25. Value Action = choice(2,"None","Cut","Normalize")
#@gui : 26. Number #1 = float(0,0,255)
#@gui : 27. Number #2 = float(188,0,255)
#@gui : 28. Equalize? = bool(0)
#@gui : 29. Negate? = bool(0)
#@gui : sep = separator(), note = note("<b>Warp by Intensity</b>")
#@gui : 30. X-Factor = float(0.19,-6,6)
#@gui : 31. Y-Factor = float(0.52,-6,6)
#@gui : sep = separator()
#@gui : 32. X-Offset = float(128,0,255)
#@gui : 34. Y-Offset = float(128,0,255)
#@gui : sep = separator()
#@gui : 34. Correlated Channels = bool(0)
#@gui : 35. Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : 36. Boundary = choice(2,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), 37. Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), note = note("<b>Style Processing</b>")
#@gui : 38. Blur Original = float(0,0,16)
#@gui : sep = separator(), note = note("<b>Butterworth Bandpass Processing</b>")
#@gui : 39. Activate Butterworth Bandpass Processing = bool(0)
#@gui : 40. Create Copy? = bool(0)
#@gui : 41. LP Frequency Power = float(3,0,16)
#@gui : 42. LP Order Cube Root = float(2,0,4)
#@gui : 43. HP Frequency Power = float(4,0,16)
#@gui : 44. HP Order Cube Root = float(2,0,4)
#@gui : 45. Colour Space = choice("RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : 46. Absolute = bool(1)
#@gui : 47. Makeup Gain = bool(1)
#@gui : sep = separator(), note = note("<b>Relief Processing</b>")
#@gui : 48. Activate Relief Processing = bool(1)
#@gui : 49. Smoothness = float(0,0,10)
#@gui : 50. Emboss Angle = float(0,0,360)
#@gui : 51. Level 1 Depth Boost = float(1,0,1)
#@gui : 52. Level 2 Depth Boost = float(0,0,1)
#@gui : 53. Blending Mode = choice(0,"Grain Extract","Grain Merge")
#@gui : 54. Blending Opacity (%) = float(100,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: Reptorian.      Latest Update: <i>2019/1/27</i>.</small>")
_cons_turb :
repeat $! l[$>] cons_turb $* endl done
cons_turb :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
skip {$23==0},{$25==0},{$26==0},{$29==0},{$48==0}
fill_color ${1-3}
turbulence ${4-6},0,$7
balance_gamma ${8-10}
remove_opacity
if  {$13<=4} ac "_fx_noise $11,$12",{$13+2},$14
else ac "_fx_noise $11,$12",{$13+3},$14 fi
remove_opacity
+jr_desaturate ${15-19}
blend normal,$20/100
+cons_self_blend $21,$22
blend ${_mode{$23+1}},$24/100
if {$25==1} cut $26,$27
elif {$25==2} n $26,$27 fi
if {$28==1} ac "equalize",rgb fi
if {$29==1} negate fi
fx_make_seamless 256
fx_warp_by_intensity ${30-37}
if {$39==1} if {$40==0} blur $38 fx_butterworth_bp ${41-45},0,${46-47} if {$48==1} +emboss_image ${49-52} fi else +fx_butterworth_bp ${41-45},0,${46-47} blur[0] $38 if {$48==1} emboss_image[1] ${49-52} fi fi
elif {$39==0} blur $38 if {$48==1} +emboss_image ${49-52} fi fi
if {$48==1} if {$53} blend grainmerge,$54/100 else blend grainextract,$54/100 fi fi
cons_self_blend :
-m "MergeChoice : $""=_mode" -MergeChoice "add","burn","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","linearburn","linearlight","luminance","multiply","negation","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","vividlight","edges","error"
[0]
blend ${_mode{$1+1}},$2/100
_cons_turb_preview :
gui_split_preview "_cons_turb $*",${-3--1}
#@gui Emboss-Relief : fx_emboss_relief, fx_emboss_relief_preview(0)
#@gui : sep = separator()
#@gui : Smoothness = float(0,0,10)
#@gui : Emboss Angle = float(0,0,360)
#@gui : Level 1 Depth Boost = float(0,0,1)
#@gui : Level 2 Depth Boost = float(0,0,1)
#@gui : Preserve Alpha? = bool(1)
#@gui : sep = separator(), note = note("Relief Section")
#@gui : Apply Relief? = bool(1)
#@gui : Blending Mode = choice(0,"Grain Extract","Grain Merge")
#@gui : Blending Opacity = float(1,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: Reptorian.      Latest Update: <i>2019/1/9</i>.</small>")
fx_emboss_relief :
if {$6==1} split_opacity
+fx_emboss $1,$2,$3,$4,0
if {$7==0} blend[0,2] grainextract,$8
elif {$7==1} blend[0,2] grainmerge,$8 fi
if {$5==0} rm[1]
elif {$5==1} a c fi
elif {$6==0} fx_emboss $1,$2,$3,$4,$5 fi
fx_emboss :
split_opacity
emboss_image[0] $1,$2,$3,$4
if {$5==0} rm[1]
elif {$5==1} a c fi
emboss_image :
luminance
fx_gradient2rgb $1,0,100,0,0
_hue_rotation $2
+_hue_rotation 180
_angle_result[0] 0
_angle_result[1] 1
+fill_color 127.5,127.5,127.5,255
blend grainmerge
[0]
blend grainmerge,$3
[0]
blend grainmerge,$4
_angle_result :
to_rgb
s c
rm[1,2]
if {$1==0} n 128,255
elif {$1==1} negate n 0,128 fi
_hue_rotation :
rgb2hsv s c
local[0]
f "H=$1;H+i-(floor((H+i)/360)*360)"
endl
a c
hsv2rgb
fx_emboss_relief_preview :
gui_split_preview "fx_emboss_relief $*",${-3--1}
#@gui Modulos Operations : fx_modulo, fx_modulo_preview(0)
#@gui : note = note("This filters applies modulo operation after arithmetic operation. Future version of this filter might be able to be used on different color space and channels.")
#@gui : sep = separator()
#@gui : Multiply = float(1,0,32)
#@gui : Addition = int(0,0,255)
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>.      Latest update : <i>2018/08/18</i>.</small>")
fx_modulo:
repeat $! l[$>] split_opacity l[0]
mul $1 add $2 mod 256
endl a c endl done
fx_modulo_preview :
gui_split_preview "fx_modulo $*"
#@gui Modulos Operations : fx_modulo, fx_modulo_preview(0)
#@gui : note = note("This filters applies modulo operation after arithmetic operation. Future version of this filter might be able to be used on different color space and channels.")
#@gui : sep = separator()
#@gui : Multiply = float(1,0,32)
#@gui : Addition = int(0,0,255)
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>.      Latest update : <i>2018/08/18</i>.</small>")
fx_modulo:
repeat $! l[$>] split_opacity l[0]
mul $1 add $2 mod 256
endl a c endl done
fx_modulo_preview :
gui_split_preview "fx_modulo $*"
#@gui Transfer Colors [Reduced Colors] : tcrc, tcrc_preview(0)
#@gui : sep = separator(), note = note ("<b>Transfer Color Setting<b>")
#@gui : note = note ("<i>If using all layers as input layer, the layer is the reference layer. If using active and above/below, the layer is the target layer.</i>")
#@gui : Layer to Use as Reference/Target Image = choice(0,"Top Layer","Bottom Layer")
#@gui : 1. Is Reference Image Smaller than Target Image? = bool(0)
#@gui : 2. Color Count = int(16,2,4096)
#@gui : 3. Color Dithering (%) = float(50,0,100)
#@gui : 4. Color Indexing Method = choice(1,"Median Cut","Median Cut and K-Means")
#@gui : 5. Alpha Value Count = int (2,2,255)
#@gui : 6. Alpha Dithering (%) = float(50,0,100)
#@gui : sep = separator(), note = note ("<b>Local Contrast<b>")
#@gui : 8. Spatial Radius = float(80,2.5,200)
#@gui : 9. Amount = float(0.5,0,5)
#@gui : 10. Darkness Level = float(1,0,4)
#@gui : 11. Lightness Level = float(1,0,4)
#@gui : sep = separator(), note = note ("<b>RGB Adjustments<b>")
#@gui : 12. Brightness (%) = float(0,-100,100)
#@gui : 13. Contrast (%) = float(0,-100,100)
#@gui : 14. Gamma (%) = float(0,-100,100)
#@gui : 15. Saturation (%) = float(0,-100,100)
#@gui : 16. Hue Shift = float(0,-180,180)
#@gui : sep = separator(), note = note ("<b>LAB Color Adjustment<b>")
#@gui : 17. Negative A Chroma (%) = float(0,-100,100)
#@gui : 18. Positive A Chroma (%) = float(0,-100,100)
#@gui : 19. Negative B Chroma (%) = float(0,-100,100)
#@gui : 20. Positive B Chroma (%) = float(0,-100,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>      Latest update: <i>2018/2/01</i>.</small>")
tcrc : if {$1==1} rv fi ac[^0] "tcrc_adjustment ${8-20}",rgb rv[0,{$!-1}] repeat {$!-1} l[{$!-1},$<] tcrc_colormapping[0,1] ${2-7} endl done rv[0,{$!-1}] if {$1==0} rv fi
tcrc_colormapping :
rv
split_opacity[1]
to_rgba[1]
+colormap[0] {$1?$2+1:$2},$4,1
index[1] [3],{$3/100},1
l[2] (0) resize[1] {$5},1 f[1] "x" n[1] 0,255 index[0] [1],{$6/100},1 rm[1] endl
rm[3]
to_rgb[1] a[1,2] c
rv
tcrc_adjustment :
rgb2hsl
s c
modf[0] 4,360,{$9/360},0
a c
hsl2rgb
fx_LCE ${1-4},1 adjust_colors ${5-7},0,$8,0,255
rgb2lab8
s c
l[1] (0,255) +index.. .,0,1 rm.. l[0] [0] endl a[1,2] c -.. 128 *.. {exp($10/64)} +.. 128 -. 128 *. {exp($11/64)} +. 128 cut 0,255 blend normal endl
l[2] (0,255) +index.. .,0,1 rm.. l[0] [0] endl a[1,2] c -.. 128 *.. {exp($12/64)} +.. 128 -. 128 *. {exp($13/64)} +. 128 cut 0,255 blend normal endl
a c
lab82rgb
tcrc_preview :
tcrc $*
#@gui_ca hide(/About/About G'MIC)
#@gui Vibrato : fx_vibrato, _fx_vibrato_preview(0)
#@gui : note = note("This is the advanced version of the Vibrato filter. If you do want to manipulate multiple channels at once, use <u>Vibrato - Basic</u> filter. <i>Note: Disable channel mulplication for non-transparent images.</i> \n\n")
#@gui : note = note("This filter is the one of the G'MIC version of <b>MadJik's</b> <i>Paint.NET plugin</i>")
#@gui : sep = separator()
#@gui : Colour Space = choice("RGB", "CMY", "HSI", "HSL", "HSV", "LAB", "LCH", "YCbCr", "YCbCr-Glic", "YUV", "YIQ", "XYZ", "Bayer")
#@gui : sep = separator()
#@gui : Manipulate Multiple Channels at Once? = bool(1)
#@gui : Process Channel 1? = bool(1)
#@gui : Process Channel 2? = bool(1)
#@gui : Process Channel 3? = bool(1)
#@gui : Process Alpha Channel? = bool(1)
#@gui : Inherit Alpha? = bool(1)
#@gui : X-Orientation = bool(1)
#@gui : Y-Orientation = bool(1)
#@gui : U- Factor = float(.85,.1,15)
#@gui : V- Factor = float(.85,.1,15)
#@gui : X-Scale Factor = float(1,.1,15)
#@gui : Y-Scale Factor = float(1,.1,15)
#@gui : XY-Scale Factor = float(1,.1,3)
#@gui : Percentage-Based X Pixel Shift = float(0,-200,200)
#@gui : Percentage-Based Y Pixel Shift = float(0,-200,200)
#@gui : Elevation = float(.7,-100,100)
#@gui : Multiply Blending = bool(0)
#@gui : Invert Vibrato = bool(0)
#@gui : Vibrato Blending Factor = float (100,0,100)
#@gui : Channel Influence Factor = float(1,-8,8)
#@gui : Final Channel Modulos Multiplication Factor = float(1,1,32)
#@gui : sep = separator()
#@gui : note = note("- <b>Channel #1</b> - ")
#@gui : Process Channel? = bool(1)
#@gui : X-Orientation = bool(1)
#@gui : Y-Orientation = bool(1)
#@gui : U-Factor = float(.85,.1,15)
#@gui : V-Factor = float(.85,.1,15)
#@gui : X-Scale Factor = float(1,.1,15)
#@gui : Y-Scale Factor = float(1,.1,15)
#@gui : XY-Scale Factor = float(1,.1,3)
#@gui : Percentage-Based X Pixel Shift = float(0,-200,200)
#@gui : Percentage-Based Y Pixel Shift = float(0,-200,200)
#@gui : Elevation = float(.7,-100,100)
#@gui : Multiply Blending = bool(0)
#@gui : Invert Vibrato = bool(0)
#@gui : Vibrato Blending Factor = float (100,0,100)
#@gui : Channel Influence Factor = float(1,-8,8)
#@gui : Final Channel Modulos Multiplication Factor = float(1,1,32)
#@gui : sep = separator()
#@gui : note = note("- <b>Channel #2</b> - ")
#@gui : Process Channel? = bool(1)
#@gui : X-Orientation = bool(1)
#@gui : Y-Orientation = bool(1)
#@gui : U-Factor = float(.85,.1,15)
#@gui : V-Factor = float(.85,.1,15)
#@gui : X-Scale Factor = float(1,.1,15)
#@gui : Y-Scale Factor = float(1,.1,15)
#@gui : XY-Scale Factor = float(1,.1,3)
#@gui : Percentage-Based X Pixel Shift = float(0,-200,200)
#@gui : Percentage-Based Y Pixel Shift = float(0,-200,200)
#@gui : Elevation = float(.7,-100,100)
#@gui : Multiply Blending = bool(0)
#@gui : Invert Vibrato = bool(0)
#@gui : Vibrato Blending Factor = float (100,0,100)
#@gui : Channel Influence Factor = float(1,-8,8)
#@gui : Final Channel Modulos Multiplication Factor = float(1,1,32)
#@gui : sep = separator()
#@gui : note = note("- <b>Channel #3</b> - ")
#@gui : Process Channel? = bool(1)
#@gui : X-Orientation = bool(1)
#@gui : Y-Orientation = bool(1)
#@gui : U-Factor = float(.85,.1,15)
#@gui : V-Factor = float(.85,.1,15)
#@gui : X-Scale Factor = float(1,.1,15)
#@gui : Y-Scale Factor = float(1,.1,15)
#@gui : XY-Scale Factor = float(1,.1,3)
#@gui : Percentage-Based X Pixel Shift = float(0,-200,200)
#@gui : Percentage-Based Y Pixel Shift = float(0,-200,200)
#@gui : Elevation = float(.7,-100,100)
#@gui : Multiply Blending = bool(0)
#@gui : Invert Vibrato = bool(0)
#@gui : Vibrato Blending Factor = float (100,0,100)
#@gui : Channel Influence Factor = float(1,-8,8)
#@gui : Final Channel Modulos Multiplication Factor = float(1,1,32)
#@gui : sep = separator()
#@gui : note = note("- <b>Alpha Channel #1</b> - ")
#@gui : Process Channel? = bool(0)
#@gui : X-Orientation = bool(1)
#@gui : Y-Orientation = bool(1)
#@gui : U-Factor = float(.85,.1,15)
#@gui : V-Factor = float(.85,.1,15)
#@gui : X-Scale Factor = float(1,.1,15)
#@gui : Y-Scale Factor = float(1,.1,15)
#@gui : XY-Scale Factor = float(1,.1,3)
#@gui : Percentage-Based X Pixel Shift = float(0,-200,200)
#@gui : Percentage-Based Y Pixel Shift = float(0,-200,200)
#@gui : Elevation = float(.7,-100,100)
#@gui : Multiply Blending = bool(1)
#@gui : Invert Vibrato = bool(0)
#@gui : Vibrato Blending Factor = float (100,0,100)
#@gui : Channel Influence Factor = float(1,-8,8)
#@gui : Final Channel Modulos Multiplication Factor = float(1,1,32)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>      Latest update: <i>2018/12/19</i>.</small>")
fx_vibrato:
split_opacity
local[0]
if {$1==1} rgb2cmy
elif {$1==2} rgb2hsi8
elif {$1==3} rgb2hsl8
elif {$1==4} rgb2hsv8
elif {$1==5} rgb2lab8
elif {$1==6} rgb2lch8
elif {$1==7} rgb2ycbcr
elif {$1==8} rgb2ycbcrglic
elif {$1==9} rgb2yuv8
elif {$1==10} rgb2yiq8
elif {$1==11} rgb2xyz8
elif {$1==12} rgb2bayer 0
fi
s c
if {$2==1}
if {$3==1} -vibrato[0] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
if {$4==1} -vibrato[1] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
if {$5==1} -vibrato[2] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
elif {$2==0}
if {$23==1} -vibrato[0] $24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38 fi
if {$39==1} -vibrato[1] $40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53,$54 fi
if {$55==1} -vibrato[2] $56,$57,$58,$59,$60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$70 fi
fi
a c
if {$1==1} cmy2rgb
elif {$1==2} hsi82rgb
elif {$1==3} hsl82rgb
elif {$1==4} hsv82rgb
elif {$1==5} lab82rgb
elif {$1==6} lch82rgb
elif {$1==7} ycbcr2rgb
elif {$1==8} ycbcrglic2rgb
elif {$1==9} yuv82rgb
elif {$1==10} yiq82rgb
elif {$1==11} xyz82rgb
elif {$1==12} bayer2rgb 0,0,0
fi
endl
if {$2==1}
if {$6==1} -vibrato[1] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$7,$19,$20,$21,$22 fi
elif {$2==0}
if {$71==1} -vibrato[1] $72,$73,$74,$75,$76,$77,$78,$79,$80,$81,$82,$83,$84,$85,$86 fi
fi
a c
vibrato:
repeat $! l[$>]
n 0,255
f "
q=($8/100)*w;
l=($9/100)*h;
X=(($1?w-x+q:x+q)/w-.5) * 2 * 1/$5 * 1/$7;
Y=(($2?h-y+l:y+l)/h-.5) * 2 * 1/$6 * 1/$7;
U=sqrt($3);
V=sqrt($4);
Z=((X-Y) * (X-U) * (X+U) * (Y-V) * (Y+V))+ $10;
C=(Z+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$14)*(Z+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$14);
F=abs(C)>1?C-int(C):C;
A=$12?F:1-F;
B=$11?(i*A):A*200;
E=$13/100*B+(1-$13/100)*i;
" n 0,255 mul $15 mod 256
endl done
_fx_vibrato_preview :
gui_split_preview "fx_vibrato ${1--2}",$-1
#@gui _
#@gui <i>RL</i>
#@gui Plasma Transition : plasma_transition, plasma_transition
#@gui : Balance = float(0.5,0,1)
#@gui : Scale = int(5,0,50)
#@gui : Smoothness = float(1,0,10)
#@gui : Random Initialization = int(42,1,100)
#@gui : sep = separator(), note = note("<small>Authors: <i>Jean-Baptiste Rolland, Julien Levillain</i>.      Latest update: <i>2013/28/03</i>.</small>")
plasma_transition: check "isint(${4=42}) && isint(${2=5}) && ${1=0.5}>=0  && $1<=1 && $2>=0 && ${3=1}>=0"
repeat {int($!/2.0)}
local[{$>},{$>+1}]
if {$!<2} return fi
r ${-max_whds},3
100%,100% srand $4 plasma. 1,0,$2 n. 0,1
+<=. $1 b. $3
rm..
j... ..,0,0,0,0,1,.
k...
endlocal
done
#@gui RandomWaves : randomwaves, randomwaves
#@gui : Steps Number = int(84,1,1000)
#@gui : Probability of Impulse (% / Step) = float(80.,1.,100.)
#@gui : Lessening = float(1.2,0.01,10.)
#@gui : Random Initialization = int(42,1,100)
#@gui : sep = separator(), note = note("<small>Authors: <i>Jean-Baptiste Rolland, Julien Levillain</i>.      Latest update: <i>2013/28/03</i>.</small>")
randomwaves : check  "isint(${1=84})  &&  ${2=80}>=0  &&  $2<=100  && ${3=1.2}>0. && isint(${4=42})"
srand $4
(0,1,0;1,0,1;0,1,0) /. 2
nm. matconv
{0,w},{0,h},1,1 set. 255,{u(100)}%,{u(100)}%
.
repeat $1
.
if {${2}>=u(100)}
circle. {u(100)}%,{u(100)}%,{u(3)},,255
fi
convolve. [matconv] /. $3 -. ...
rm...
done
rm[-2,matconv]
g. a[-1,-2] c -warp[0] .,1 rm.
#@gui _
#@gui <i>Ronounours</i>
#@gui Auto-Adjust Orientation : fx_adjust_orientation, fx_adjust_orientation(1)
#@gui : Threshold = float(5,0,100)
fx_adjust_orientation :
repeat $!
M={max(w,h)}
+gradient_norm. ge. $1%
+*. '1+y' *.. '1+x' a[-2,-1] c
r. {w*h},2,1,1,-1 sort. +,x autocrop. 0
/. $M +r. 1,2,1,1,2 r. .. -[-2,-1]
+transpose. m*[-2,-1]
eigen. rm.. z. 0,0
if {i<0} *. -1 fi
theta={180*atan2(i(0,1),i)/pi}
rm.
if {w>h} rotate. {-$theta},1,0,50%,50%
else rotate. {-$theta+90},1,0,50%,50%
fi
mv. 0 done
#@gui Curves : fx_apply_curve, fx_apply_curve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : Display Histogram = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
fx_apply_curve :
ac "_fx_apply_curve ${1-13}",$14,$15
_fx_apply_curve :
apply_curve $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
fx_apply_curve_preview :
function1d $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
mv. 0
repeat {$!-1}
+gui_split_preview. "fx_apply_curve $*",$-1
100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
if $-2
.,. to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,1 -!=. 0 *. 255 rm...
+xor[-2,-1] j... .,0,0,0,0,$16,..,255 rm[-2,-1]
else rm.. fi
100%,100% graph. [0],1,0,255,0,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
_fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
_fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
_fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
_fx_apply_curve_preview 255,$12,6
mv. 1 done rm[0]
_fx_apply_curve_preview :
if {$1>=0}
x={$1*100/255}% y={100-$2*100/255}%
ellipse. $x,$y,3,3,0,1,0xFFFFFFFF,0,0,0 ellipse. $x,$y,2,2,0,1,0,255,0
t. $3,$x,{$y*h-20},13,1,255
fi
#@gui <i>Curves [Lab]</i>
#@gui A-Color : fx_apply_Labcurve, fx_apply_acurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui B-Color : fx_apply_Labcurve, fx_apply_bcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
fx_apply_Labcurve : skip $1
fx_apply_Labcurve_configfile
repeat {$!-1} l[$>,-1]
to_colormode[0] {max(3,s)} sh[0] 0,2 rgb2lab. rm.
sh[0] 0 *. 2.55 _fx_apply_Labcurve. {-2,@0-12} /. 2.55 rm.
sh[0] 1 +. 86 *. 1.38587 _fx_apply_Labcurve. {-2,@13-25} /. 1.38587 -. 86 rm.
sh[0] 2 +. 108 *. 1.25616 _fx_apply_Labcurve. {-2,@26-38} /. 1.25616 -. 108 rm.
sh[0] 0,2 lab2rgb. rm.
endl done
rm.
_fx_apply_Labcurve :
apply_curve $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
c 0,255
fx_apply_Lcurve_preview :
fx_apply_Labcurve_configfile
sh. 0,0,0,0 f. ${1--3} rm.
fx_apply_Labcurve_preview[^-1] {^},0,${-2,-1} rm.
fx_apply_acurve_preview :
fx_apply_Labcurve_configfile
sh. 1,1,0,0 f. ${1--3} rm.
fx_apply_Labcurve_preview[^-1] {^},1,${-2,-1} rm.
fx_apply_bcurve_preview :
fx_apply_Labcurve_configfile
sh. 2,2,0,0 f. ${1--3} rm.
fx_apply_Labcurve_preview[^-1] {^},2,${-2,-1} rm.
fx_apply_Labcurve_configfile :
filename=${-path_tmp}.gmic_Labcurve.dlm
if $filename $filename else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) r. 100%,3 fi
fx_apply_Labcurve_preview :
(${1--3}) r. 13,3,1,1,-1 o. ${-path_tmp}.gmic_Labcurve.dlm rm.
function1d $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
function1d $26,0,$14,\
${"if {$15>=0} u $15,$16, else u \"\" fi"}\
${"if {$17>=0} u $17,$18, else u \"\" fi"}\
${"if {$19>=0} u $19,$20, else u \"\" fi"}\
${"if {$21>=0} u $21,$22, else u \"\" fi"}\
${"if {$23>=0} u $23,$24, else u \"\" fi"}\
255,$25
function1d $39,0,$27,\
${"if {$28>=0} u $28,$29, else u \"\" fi"}\
${"if {$30>=0} u $30,$31, else u \"\" fi"}\
${"if {$32>=0} u $32,$33, else u \"\" fi"}\
${"if {$34>=0} u $34,$35, else u \"\" fi"}\
${"if {$36>=0} u $36,$37, else u \"\" fi"}\
255,$38
a[-3--1] y mv. 0
repeat {$!-1}
+gui_split_preview. "fx_apply_Labcurve 0",$-1
axes. 0,255,255,0,13,1,255
100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
if $-2
.,.,1,1,-{$-2*255/100} to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,0
rm... +. {$-2*255/100} +[-2,-1] c. 0,255
else rm.. fi
line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
sh[0] 0,0,0,0
graph.. .,1,0,255,0,1,255,255,255 -. 1
graph.. .,1,0,255,0,0.5,200,200,200 rm.
sh[0] 1,1,0,0
graph.. .,1,0,255,0,1,255,128,128 -. 1
graph.. .,1,0,255,0,0.5,200,0,0 rm.
sh[0] 2,2,0,0
graph.. .,1,0,255,0,1,128,128,255 -. 1
graph.. .,1,0,255,0,0.5,0,0,200 rm.
if {$40==0}
_fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
_fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
_fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
_fx_apply_curve_preview 255,$12,6
elif {$40==1}
_fx_apply_curve_preview 0,$14,0 _fx_apply_curve_preview $15,$16,1
_fx_apply_curve_preview $17,$18,2 _fx_apply_curve_preview $19,$20,3
_fx_apply_curve_preview $21,$22,4 _fx_apply_curve_preview $23,$24,5
_fx_apply_curve_preview 255,$25,6
else
_fx_apply_curve_preview 0,$27,0 _fx_apply_curve_preview $28,$29,1
_fx_apply_curve_preview $30,$31,2 _fx_apply_curve_preview $32,$33,3
_fx_apply_curve_preview $34,$35,4 _fx_apply_curve_preview $36,$37,5
_fx_apply_curve_preview 255,$38,6
fi
mv. 1 done rm[0]
cracks_old : skip ${1=0.2},${2=40},${3=0}
e[^-1] "Add random cracks to image$?, with density $1."
v - repeat $! l[$>]
({im},{iM}) ..,..,1,1 noise. $1,2 ==. 1 distance. 1 sharpen. 10000
if $3 g. xy +[-2,-1] n. -1,1 else n. 0,1 fi
*. $2 +[-3,-1] c.. {^} rm.
endl done v +
fx_cracks_old :
ac "-cracks_old $1,$2,$3",$4
negative :
e[^-1] "Compute negative of image$?."
v - repeat $! l[$>] - {iM} endl done * -1 v +
transfer_colors : skip ${2=0}
e[^-1] "Transfer colors of image $1 to image$?."
v - pass$1 0 mv. 0 to_rgb[0] to_colormode[^0] {max(3,${-max_s})} c 0,255
repeat $! l[$>] split_opacity rgb2ycbcr[0] a c endl done
l[0] s c histogram_cumul 256,1,0,255 a c * 255 endl
repeat {$!-1} l[0,{$<+1}]
if $2 repeat 3 sh[0,1] $> equalize. 256,0,255 index. ..,0,0 rm[-2,-1] done
else repeat 2 sh[0,1] {$>+1} equalize. 256,0,255 index. ..,0,0 rm[-2,-1] done
fi
endl done rm[0]
repeat $! l[$>] split_opacity ycbcr2rgb[0] a c endl done
c 0,255
v +
_transfer_colors :
repeat $! l[$>] rgb2ycbcr s c histogram 256,0,255 a c -dg 300,200 endl done
patchmatch : skip ${3=$2},${4=1},${5=5},${6=5},${7=0}
pass$1
matchpatch[^-1] .,${2-6},0,${7--1}
rm.
matchpatch : skip ${3=$2},${4=1},${5=5},${6=5},${7=0},${8=0}
pass$1
patchmatch[^-1] .,${2-6},${8--1}
rm.
#@gui Lightness : fx_apply_Labcurve, fx_apply_Lcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui _
#@gui <i>Curves [RGB]</i>
#@gui Blue : fx_apply_RGBcurve, fx_apply_Bcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
fx_apply_RGBcurve : skip $1
fx_apply_RGBcurve_configfile
repeat {$!-1} l[$>,-1]
to_colormode[0] {max(3,s)}
sh[0] 0 _fx_apply_RGBcurve. {-2,@0-12} rm.
sh[0] 1 _fx_apply_RGBcurve. {-2,@13-25} rm.
sh[0] 2 _fx_apply_RGBcurve. {-2,@26-38} rm.
endl done
rm.
_fx_apply_RGBcurve :
apply_curve $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
c 0,255
fx_apply_Rcurve_preview :
fx_apply_RGBcurve_configfile
sh. 0,0,0,0 f. ${1--3} rm.
fx_apply_RGBcurve_preview[^-1] {^},0,${-2,-1} rm.
fx_apply_Gcurve_preview :
fx_apply_RGBcurve_configfile
sh. 1,1,0,0 f. ${1--3} rm.
fx_apply_RGBcurve_preview[^-1] {^},1,${-2,-1} rm.
fx_apply_Bcurve_preview :
fx_apply_RGBcurve_configfile
sh. 2,2,0,0 f. ${1--3} rm.
fx_apply_RGBcurve_preview[^-1] {^},2,${-2,-1} rm.
fx_apply_RGBcurve_configfile :
filename=${-path_tmp}.gmic_RGBcurve.dlm
if $filename $filename else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) r. 100%,3 fi
fx_apply_RGBcurve_preview :
(${1--3}) r. 13,3,1,1,-1 o. ${-path_tmp}.gmic_RGBcurve.dlm rm.
function1d $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
function1d $26,0,$14,\
${"if {$15>=0} u $15,$16, else u \"\" fi"}\
${"if {$17>=0} u $17,$18, else u \"\" fi"}\
${"if {$19>=0} u $19,$20, else u \"\" fi"}\
${"if {$21>=0} u $21,$22, else u \"\" fi"}\
${"if {$23>=0} u $23,$24, else u \"\" fi"}\
255,$25
function1d $39,0,$27,\
${"if {$28>=0} u $28,$29, else u \"\" fi"}\
${"if {$30>=0} u $30,$31, else u \"\" fi"}\
${"if {$32>=0} u $32,$33, else u \"\" fi"}\
${"if {$34>=0} u $34,$35, else u \"\" fi"}\
${"if {$36>=0} u $36,$37, else u \"\" fi"}\
255,$38
a[-3--1] y mv. 0
repeat {$!-1}
+gui_split_preview. "fx_apply_RGBcurve 0",$-1
100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
if $-2
.,.,1,1,-{$-2*255/100} to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,0
rm... +. {$-2*255/100} +[-2,-1] c. 0,255
else rm.. fi
line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
sh[0] 0,0,0,0
graph.. .,1,0,255,0,1,255,128,128 -. 1
graph.. .,1,0,255,0,0.5,200,0,0 rm.
sh[0] 1,1,0,0
graph.. .,1,0,255,0,1,128,255,128 -. 1
graph.. .,1,0,255,0,0.5,0,200,0 rm.
sh[0] 2,2,0,0
graph.. .,1,0,255,0,1,128,128,255 -. 1
graph.. .,1,0,255,0,0.5,0,0,200 rm.
if {$40==0}
_fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
_fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
_fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
_fx_apply_curve_preview 255,$12,6
elif {$40==1}
_fx_apply_curve_preview 0,$14,0 _fx_apply_curve_preview $15,$16,1
_fx_apply_curve_preview $17,$18,2 _fx_apply_curve_preview $19,$20,3
_fx_apply_curve_preview $21,$22,4 _fx_apply_curve_preview $23,$24,5
_fx_apply_curve_preview 255,$25,6
else
_fx_apply_curve_preview 0,$27,0 _fx_apply_curve_preview $28,$29,1
_fx_apply_curve_preview $30,$31,2 _fx_apply_curve_preview $32,$33,3
_fx_apply_curve_preview $34,$35,4 _fx_apply_curve_preview $36,$37,5
_fx_apply_curve_preview 255,$38,6
fi
mv. 1 done rm[0]
#@gui Green : fx_apply_RGBcurve, fx_apply_Gcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui Red : fx_apply_RGBcurve, fx_apply_Rcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui _
#@gui <i>Curves [YCbCr]</i>
#@gui Blue Chrominance : fx_apply_YCbCrcurve, fx_apply_Cbcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui Luminance : fx_apply_YCbCrcurve, fx_apply_Ycurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui Red Chrominance : fx_apply_YCbCrcurve, fx_apply_Crcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
fx_apply_YCbCrcurve : skip $1
fx_apply_YCbCrcurve_configfile
repeat {$!-1} l[$>,-1]
to_colormode[0] {max(3,s)} sh[0] 0,2 rgb2ycbcr. rm.
sh[0] 0 _fx_apply_YCbCrcurve. {-2,@0-12} rm.
sh[0] 1 _fx_apply_YCbCrcurve. {-2,@13-25} rm.
sh[0] 2 _fx_apply_YCbCrcurve. {-2,@26-38} rm.
sh[0] 0,2 -ycbcr2rgb. rm.
endl done
rm.
_fx_apply_YCbCrcurve :
apply_curve $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
c 0,255
fx_apply_Ycurve_preview :
fx_apply_YCbCrcurve_configfile
sh. 0,0,0,0 f. ${1--3} rm.
fx_apply_YCbCrcurve_preview[^-1] {^},0,${-2,-1} rm.
fx_apply_Cbcurve_preview :
fx_apply_YCbCrcurve_configfile
sh. 1,1,0,0 f. ${1--3} rm.
fx_apply_YCbCrcurve_preview[^-1] {^},1,${-2,-1} rm.
fx_apply_Crcurve_preview :
fx_apply_YCbCrcurve_configfile
sh. 2,2,0,0 f. ${1--3} rm.
fx_apply_YCbCrcurve_preview[^-1] {^},2,${-2,-1} rm.
fx_apply_YCbCrcurve_configfile :
filename=${-path_tmp}.gmic_YCbCrcurve.dlm
if $filename $filename else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) r. 100%,3 fi
fx_apply_YCbCrcurve_preview :
(${1--3}) r. 13,3,1,1,-1 o. ${-path_tmp}.gmic_YCbCrcurve.dlm rm.
function1d $13,0,$1,\
${"if {$2>=0} u $2,$3, else u \"\" fi"}\
${"if {$4>=0} u $4,$5, else u \"\" fi"}\
${"if {$6>=0} u $6,$7, else u \"\" fi"}\
${"if {$8>=0} u $8,$9, else u \"\" fi"}\
${"if {$10>=0} u $10,$11, else u \"\" fi"}\
255,$12
function1d $26,0,$14,\
${"if {$15>=0} u $15,$16, else u \"\" fi"}\
${"if {$17>=0} u $17,$18, else u \"\" fi"}\
${"if {$19>=0} u $19,$20, else u \"\" fi"}\
${"if {$21>=0} u $21,$22, else u \"\" fi"}\
${"if {$23>=0} u $23,$24, else u \"\" fi"}\
255,$25
function1d $39,0,$27,\
${"if {$28>=0} u $28,$29, else u \"\" fi"}\
${"if {$30>=0} u $30,$31, else u \"\" fi"}\
${"if {$32>=0} u $32,$33, else u \"\" fi"}\
${"if {$34>=0} u $34,$35, else u \"\" fi"}\
${"if {$36>=0} u $36,$37, else u \"\" fi"}\
255,$38
a[-3--1] y mv. 0
repeat {$!-1}
+gui_split_preview. "fx_apply_YCbCrcurve 0",$-1
axes. 0,255,255,0,13,1,255
100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
if $-2
.,.,1,1,-{$-2*255/100} to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,0
rm... +. {$-2*255/100} +[-2,-1] c. 0,255
else rm.. fi
line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
sh[0] 0,0,0,0
graph.. .,1,0,255,0,1,255,255,255 -. 1
graph.. .,1,0,255,0,0.5,200,200,200 rm.
sh[0] 1,1,0,0
graph.. .,1,0,255,0,1,128,128,255 -. 1
graph.. .,1,0,255,0,0.5,0,0,200 rm.
sh[0] 2,2,0,0
graph.. .,1,0,255,0,1,255,128,128 -. 1
graph.. .,1,0,255,0,0.5,200,0,0 rm.
if {$40==0}
_fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
_fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
_fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
_fx_apply_curve_preview 255,$12,6
elif {$40==1}
_fx_apply_curve_preview 0,$14,0 _fx_apply_curve_preview $15,$16,1
_fx_apply_curve_preview $17,$18,2 _fx_apply_curve_preview $19,$20,3
_fx_apply_curve_preview $21,$22,4 _fx_apply_curve_preview $23,$24,5
_fx_apply_curve_preview 255,$25,6
else
_fx_apply_curve_preview 0,$27,0 _fx_apply_curve_preview $28,$29,1
_fx_apply_curve_preview $30,$31,2 _fx_apply_curve_preview $32,$33,3
_fx_apply_curve_preview $34,$35,4 _fx_apply_curve_preview $36,$37,5
_fx_apply_curve_preview 255,$38,6
fi
mv. 1 done rm[0]
#@gui _
#@gui Faded Mirror : fx_faded_mirror, fx_faded_mirror(1)
#@gui : Axis = choice("x-axis","y-axis")
#@gui : Fading = float(10,0,100)
#@gui : Overlapping = float(10,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2013/29/05</i>.</small>")
fx_faded_mirror :
repeat $! l[$>]
if {$1==0}
100%,1,1,1,"a=1/(1-w*$2%);b=-a*(w-1);a*x+b" c. 0.01,1 *.. .
r. 100%,.. a c r {2*w-w*$3%},100%,1,100%,0 +mirror x
else
1,100%,1,1,"a=1/(1-h*$2%);b=-a*(h-1);a*y+b" c. 0.01,1 r. ..,100% *.. .
a c r 100%,{2*h-h*$3%},1,100%,0 +mirror y
fi
+ s. c,-{s-1} /[-2,-1]
endl done
#@gui GAAP Test : gaap_test, gaap_test
#@gui : Sigma = float(0,0,100)
#@gui : Color = color(0,0,0)
gaap_test :
b $1
u \{{$1+10}\}\{$2,$3,255\}
#@gui Graduated Color Accent : fx_gca, fx_gca_preview
#@gui : Reference Color = color(255,255,255)
#@gui : Amplitude = float(1,0,5)
#@gui : Max Value = choice("From input","From reference color","Maximum allowed")
#@gui : Channel = choice(0,"Saturation","Lightness")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2015/15/07</i>.</small>")
fx_gca :
channel={1+$6}
repeat $! l[$>] to_color split_opacity l[0]
+fc $1,$2,$3
-[1] [0] norm[1] /[1] {1e-6+iM} *[1] -1 +[1] 1 ^[1] $4
rgb2hsl[0] s[0] c
if {$5==0} *[$channel,-1]
elif {$5==1} ($1^$2^$3) rgb2hsl. *[$channel] {i[$channel]} rm[-2,-1]
else rv[$channel,-1] rm.
fi
a c hsl2rgb
endl a c endl done
fx_gca_preview :
gui_split_preview "fx_gca $*",$-1
#@gui Grain [Old] : fx_grain, fx_grain_preview(0)
#@gui : Amplitude = float(40,0,512)
#@gui : Tone Smoothness = float(5,0,15)
#@gui : Grain Type = choice("Gaussian","Uniform")
#@gui : Channel(s) = choice(2,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator()
#@gui : note = note("<small><b>Shadows:</b></small>")
#@gui : Strength = float(0.8,0,1)
#@gui : Scale = float(0.5,0,2)
#@gui : Channel Correlation = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Mid-tones:</b></small>")
#@gui : Strength = float(1,0,1)
#@gui : Scale = float(0,0,2)
#@gui : Channel Correlation = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Highlights:</b></small>")
#@gui : Strength = float(0.6,0,1)
#@gui : Scale = float(0.2,0,2)
#@gui : Channel Correlation = float(0.5,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2013/21/11</i>.</small>")
fx_grain :
repeat $! l[$>] apply_channels "_fx_grain ${1-13}",$4,0 endl done
_fx_grain :
if {!$1} return fi
s={s} +luminance
if $5
100%,100%,1,$s noise. 1,$3 b. $6 *. {(1-$7)/max(abs(im),abs(iM))}
100%,100%,1,1 noise. 1,$3 b. $6 *. {$7/max(abs(im),abs(iM))}
+[-2,-1] +ir[1] 0,85 b. $2 n. 0,1 *[-2,-1] *. $5
fi
if $8
100%,100%,1,$s noise. 1,$3 b. $9 *. {(1-$10)/max(abs(im),abs(iM))}
100%,100%,1,1 noise. 1,$3 b. $9 *. {$10/max(abs(im),abs(iM))}
+[-2,-1] +ir[1] 86,169 b. $2 n. 0,1 *[-2,-1] *. $8
fi
if $11
100%,100%,1,$s noise. 1,$3 b. $12 *. {(1-$13)/max(abs(im),abs(iM))}
100%,100%,1,1 noise. 1,$3 b. $12 *. {$13/max(abs(im),abs(iM))}
+[-2,-1] +ir[1] 170,256 b. $2 n. 0,1 *[-2,-1] *. $11
fi
rm[1] +[-3--1] n. -$1,$1 + c 0,255
fx_grain_preview :
gui_split_preview "fx_grain $*",$-1
#@gui Krita Helper : fx_krita, fx_krita
fx_krita :
text="Krita helper:\n"\
"Image size = "{w}x{h}x{d}x{s}"\n"\
"Minimal value = "{im}"\n"\
"Maximal value = "{iM}"\n"\
"Average value = "{_round(ia,0.1)}"\n\n\n"\
"* We love Krita! *"
n 0,255 drgba r 512,512,1,3
to $text,3,3,5%
_gui_filter_sources : skip ${1=0}
#@gui Layer Info : gui_layer_info, gui_layer_info_preview
#@gui : Number of Output Layers for Each Input Layer = int(1,1,5)
#@gui : note = note("<small><b>Note:</b> This filter displays layer info on each layer.</small>")
gui_layer_info :
repeat $! l[$<] nm={n}
animate b,0,10,$1
nm $nm
endl done
repeat $! l[$>]
0 t. "Layer indice: ""#"$>"\nLayer name: "${-gui_layer_name}"\nBlending mode: "${-gui_layer_mode}"\nOpacity : "${-gui_layer_opacity}"\nPosition: "${-gui_layer_pos},0,0,40,1,255
to_rgba[0] expand_xy. 8,0 +dilate. 8 to_colormode[1] {0,s} j[0] [1],20,20,0,0,1,[2],255
k[0]
endl done
gui_layer_info_preview :
gui_layer_info $1
gui_preview
#@gui Perspective Scale : fx_perspective_scale, fx_perspective_scale_preview(1)
#@gui : Iterations = int(2,2,10)
#@gui : Factor = float(75,0,100)
#@gui : X-Offset = float(0,-100,100)
#@gui : Y-Offset = float(0,-100,100)
#@gui : Output Mode = _choice("Single layer","Multiple layers")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2013/08/02</i>.</small>")
fx_perspective_scale :
repeat $! l[$<] to_rgba
w={w} h={h}
f=100 repeat {$1-1} f={$f*$2%} +r[0] $f%,$f%,1,4,2 done
repeat {$!-1} l[{$>+1}]
sx={round(($>+1)*$w*$3%/($1-1))}
sy={round(($>+1)*$h*$4%/($1-1))}
r $w,$h,1,4,0,0,0.5,0.5 shift. $sx,$sy,0,0,0
endl done
if {!$5} repeat {$!-1} blend[0,1] alpha,1,1 done fi
endl done
fx_perspective_scale_preview :
fx_perspective_scale ${1-4},0
#@gui Shaded Segmentation : dt_segment_shaded,dt_segment_shaded(0)
#@gui : Density = float(1,0,3)
#@gui : Shading = float(0.7,0,2)
#@gui : Smoothness = float(1,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2013/01/02</i>.</small>")
dt_segment_shaded :
repeat $! l[$>]
b $3 segment_watershed $1,1
+g xy,1 a[-2,-1] c norm. !=. 0 distance[1] 1 normalize_local. 1000
n. 0,1 ^. {max(1e-5,$2)} n. 0,255
blend value
endl done
#@gui _
#@gui <i>Samj</i>
#@gui About : _none_, samj_about
#@gui : note = note(<b>Informations - Compilations :</b>)
#@gui : note = link("http://www.aljacom.com/~gmic/","http://www.aljacom.com/~gmic/")
#@gui : note = link("http://samjcreations.blogspot.ca/","http://samjcreations.blogspot.ca/")
#@gui : note = note(<b>Filtres :</b>)
#@gui : note = link("https://github.com/dtschump/gmic-community","https://github.com/dtschump/gmic-community")
#@gui : note = note("Les filtres contenus dans ce r\303\251pertoire sont majoritairement traduits en fran\303\247ais et/ou en cours de d\303\251veloppement.")
#@gui : note = note("The filters included in this directory are mostly translated into French and/or experimental.")
#@gui : note = note("Version 2018/05/15 GMIC 2.2.2")
samj_about :
#Rays_Of_Colors
Color_Intensity=480
Color_Density=(16/512*{w})
Radius=40
Border_smoothness=16
Border_width=38
Merge_Layers=1
R_a=16
V_a=8
B_a=0
{w},{h},1,3
-fill_color[-1] $R_a,$V_a,$B_a
-repeat $Color_Intensity
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
X_point={round((u)*{w})}
Y_point={round((u)*{h})}
-polygon[-1] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
-done
-fx_textured_glass[-1] 40,40,1,1,0,2,0
-fx_map_sphere[-1] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
-fill_color[-2] $R_a,$V_a,$B_a
-repeat $Color_Intensity
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
X_point={round((u)*{w})}
Y_point={round((u)*{h})}
-polygon[-2] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
-done
-fx_textured_glass[-2] 40,40,1,1,0,2,0
-fx_map_sphere[-2] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
-if {$Merge_Layers==1}
-blend[-2,-1] add
-endif
-to_rgb[-1]
-text_outline[-1] "Bonjour!",{{min({w},{h})}/20},{{min({w},{h})}/20},{{min({w},{h})}/5},1,255,255,255,255
samj_rien_arrays_and_tiles :
-Je_passe_l_hiver_en_Floride[-1]
#@gui <i>Arrays &amp; Tiles</i>
#@gui Annular Steiner Chain Round Tiles : Annular_Steiner_Chain_Round_Tile_en, Annular_Steiner_Chain_Round_Tile_en(1)
#@gui : note = note("<span foreground="orangered">Annular Steiner Chain Round Tiles</span>")
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Resulting Image</small></span>")
#@gui : Dimensions Pixels = int(800,256,1920)
#@gui : Delete Layer Source = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Image</small></span>")
#@gui : Position X Origin (%) = float(0,0,100)
#@gui : Position Y Origin (%) = float(0,0,100)
#@gui : Dimensions (%) = float(100,1,100)
#@gui : Angle Image Contour = float(0,0,360)
#@gui : Image Contour Dimensions = float(100,1,100)
#@gui : Nb Circles Surrounding = int(12,3,180)
#@gui : Angle Tilt = float(0,0,360)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Colors Geometric Shapes</small></span>")
#@gui : Activate Colors Geometric Shapes = bool(1)
#@gui : Contours = color(0,0,0,255)
#@gui : Display Contours = choice(0,"No","A","B","C","D","E","F","G")
#@gui : Circle 1 = color(255,255,0,127)
#@gui : Circle 2 = color(0,0,255,127)
#@gui : Random Colors = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/04/21</i>.</small>")
Annular_Steiner_Chain_Round_Tile_en:
-Annular_Steiner_Chain_Round_Tile $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24
#@gui Cercles Concentriques : Cercles_Concentriques_A, Cercles_Concentriques_A(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Image Finale</b></span>")
#@gui : Dimension En Pixels = int(800,256,1920)
#@gui : Supprimer Calque Origine = bool(1)
#@gui : note = note("<span foreground="orangered"><b>Cercles</b></span>")
#@gui : Nb Cercles / Circles (Anneaux) = int(6,1,180)
#@gui : Variation Dimensions Des Cercles = choice(0,"Sin A","Sin B","Lineaire")
#@gui : Angle Variation Origine = float(0,0,180)
#@gui : Angle Variation Fin = float(90,0,180)
#@gui : Coef. Variation = float(1,-1,1)
#@gui : Sens Rotation Horaire = bool(1)
#@gui : D\303\251calage Cercles % = float(50,0,500)
#@gui : Conserver Ext\303\251rieur Cercles = bool(1)
#@gui : note = note("<span foreground="orangered"><b>Rayons De Couleurs Et Contours</b></span>")
#@gui : Activer Rayons De Couleurs = bool(1)
#@gui : note = note("<span foreground="blue"><small> - Contours - </small></span>")
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = choice(0,"Sans","Rayons et Cercles","Rayons","Cercles")
#@gui : Dilate Contours = int(0,0,16)
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : Sharpen = int(0,0,600)
#@gui : note = note("<span foreground="blue"><small> - Couleurs - </small></span>")
#@gui : R\303\251p\303\251tition Des Couleurs = int(5,1,180)
#@gui : Angle D\303\251calage Des Couleurs = float(0,0,360)
#@gui : Couleur / Color A = color(0,0,255,255)
#@gui : Couleur / Color B = color(255,255,0,255)
#@gui : Couleur / Color C = color(255,0,0,255)
#@gui : Couleur / Color D = color(0,255,255,255)
#@gui : Couleur / Color E = color(255,0,255,255)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : M\303\251lange Couleurs Contours = bool(1)
#@gui : note = note("<span foreground="orangered"><b>Symmetrizoscope</b></span>")
#@gui : Activer Symmetrizoscope = bool(0)
#@gui : Iterations = int(5,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Symmetry Sides = choice("Backward","Forward","Swap")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/20</i>.</small>")
Cercles_Concentriques_A:
Dimension_Finale=$1
Supprimer_Calque_Origine=$2
Nb_Circles={$3+1}
Type_Variation_Dimensions_Cercles=$4
Angle_Variation_Origine=$5
Angle_Variation_Fin=$6
Coef_Variation=$7
Sens_Rotation_Horaire=$8
Decalage_Cercles={$9-50}
Conserver_Exterieur_Cercles=$10
Activer_Rayons_De_Couleurs=$11
R_Contours=$12
V_Contours=$13
B_Contours=$14
A_Contours=$15
Affichage_Contours=$16
Dilate_Contours=$17
Flou_Contours=$18
Sharpen_Contours=$19
Repetition_Couleurs=$20
Angle_Decalage_Couleurs=$21
R_a=$22
V_a=$23
B_a=$24
A_a=$25
R_b=$26
V_b=$27
B_b=$28
A_b=$29
R_c=$30
V_c=$31
B_c=$32
A_c=$33
R_d=$34
V_d=$35
B_d=$36
A_d=$37
R_e=$38
V_e=$39
B_e=$40
A_e=$41
Couleurs_aleatoires=$42
Melange_Couleurs_Contours=$43
Filtre_Symmetrizoscope=$44
Iterations_Symmetrizoscope=$45
Angle_Symmetrizoscope=$46
Symmetry_Sides=$47
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Rayon_Cercle_Final={round({{$Dimension_Finale/2}-1})}
Rayon_Cercle_En_Cours=0
Rayon_Cercle_Precedent=0
Rayon_Dernier_Cercle=0
Rayon_De_Couleur={round({1+{$Dimension_Finale*{2^0.5}}})}
Decrement_Rayon=0
Angle_Rayon_De_Couleur={72/$Repetition_Couleurs}
Angle_Rayon_De_Couleur_En_Cours=0
Angle_Rayon_De_Couleur_En_Cours_Fin=0
Nb_De_Rayon_De_Couleur=0
# 2 nouvelles images contours
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-if {$Activer_Rayons_De_Couleurs==0}
--Je_passe_l_hiver_en_Floride[0]
-if {$Largeur_Origine>$Hauteur_Origine}
-crop[-1] {{$Largeur_Origine-$Hauteur_Origine}/2},0,{{{$Largeur_Origine-$Hauteur_Origine}/2}+$Hauteur_Origine-1},$Hauteur_Origine
-elif {$Largeur_Origine<$Hauteur_Origine}
-crop[-1] 0,{{$Hauteur_Origine-$Largeur_Origine}/2},$Largeur_Origine,{{{$Hauteur_Origine-$Largeur_Origine}/2}+$Largeur_Origine-1}
-endif
-resize[-1] $Dimension_Finale,$Dimension_Finale
-to_rgba[-1]
-endif
-if {$Activer_Rayons_De_Couleurs==1}
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,255
-endif
-if {$Sens_Rotation_Horaire==1}
Angle_Decalage_Couleurs_En_Cours={$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
-else
Angle_Decalage_Couleurs_En_Cours={{$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}+{$Angle_Rayon_De_Couleur/2}}
-endif
-repeat $Repetition_Couleurs
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_a,$V_a,$B_a,$A_a
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_b,$V_b,$B_b,$A_b
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_c,$V_c,$B_c,$A_c
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_d,$V_d,$B_d,$A_d
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_e,$V_e,$B_e,$A_e
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-done
Rayon_Cercle_En_Cours=$Rayon_Cercle_Final
Rayon_Cercle_Precedent=$Rayon_Cercle_Final
Nb_boucles=0
# Rotation des cercles concentriques
-repeat $Nb_Circles
-if {$Type_Variation_Dimensions_Cercles==0}
-if {{$Nb_Circles-$Nb_boucles}>1}
Decrement_Rayon={abs({{{$Rayon_Cercle_Precedent*{cos({pi/180*{$Angle_Variation_Fin}})}}-{$Rayon_Cercle_Precedent*{cos({pi/180*{$Angle_Variation_Origine}})}}}/$Nb_Circles})}
-else
Decrement_Rayon={$Rayon_Cercle_Final-$Rayon_Cercle_En_Cours}
-endif
-elif {$Type_Variation_Dimensions_Cercles==1}
-if {{$Nb_Circles-$Nb_boucles}>1}
Decrement_Rayon={abs({{{$Rayon_Cercle_Precedent*{-1+{cos({pi/180*{$Angle_Variation_Fin}})}}}-{$Rayon_Cercle_Precedent*{1+{cos({pi/180*{$Angle_Variation_Origine}})}}}}/$Nb_Circles})}
-else
Decrement_Rayon={$Rayon_Cercle_Final-$Rayon_Cercle_En_Cours}
-endif
-elif {$Type_Variation_Dimensions_Cercles==2}
Decrement_Rayon={abs({{{$Rayon_Cercle_Final*{1+{cos({pi/180*{$Angle_Variation_Fin}})}}}-{$Rayon_Cercle_Final*{1+{cos({pi/180*{$Angle_Variation_Origine}})}}}}/$Nb_Circles})}
-endif
-if {$Sens_Rotation_Horaire==1}
Angle_Decalage_Couleurs_En_Cours={{$Decalage_Cercles*$Angle_Rayon_De_Couleur/100}+$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
-else
Angle_Decalage_Couleurs_En_Cours={{$Decalage_Cercles*$Angle_Rayon_De_Couleur/100*-1}+$Angle_Decalage_Couleurs_En_Cours-{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
-endif
-if {$Coef_Variation>0}
Rayon_Cercle_En_Cours={$Rayon_Cercle_En_Cours-{$Decrement_Rayon*$Coef_Variation}}
-else
Rayon_Cercle_En_Cours={$Rayon_Cercle_En_Cours-{$Decrement_Rayon*{abs($Coef_Variation)}/{$Nb_boucles+1}}}
-endif
--Je_passe_l_hiver_en_Floride[-1]
-rotate[-1] {$Angle_Decalage_Couleurs_En_Cours}
-crop[-1] {{{w}-$Dimension_Finale}/2},{{{h}-$Dimension_Finale}/2},{{{{w}-$Dimension_Finale}/2}+$Dimension_Finale-1},{{{{h}-$Dimension_Finale}/2}+$Dimension_Finale-1}
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_Precedent,1,255,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_En_Cours,1,0,0,0,255
-replace_color[-1] 100%,0,255,0,0,255,0,0,0,0
-blend[-1,-2] alpha,1,1
-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
-blend[-1,-2] alpha,1,1
-if {$Affichage_Contours>0}
-reverse[-1,-2]
$Dimension_Finale,$Dimension_Finale,1,4
--Je_passe_l_hiver_en_Floride[-2]
-rotate[-1] $Angle_Decalage_Couleurs_En_Cours
-crop[-1] {{{w}-$Dimension_Finale}/2},{{{h}-$Dimension_Finale}/2},{{{{w}-$Dimension_Finale}/2}+$Dimension_Finale-1},{{{{h}-$Dimension_Finale}/2}+$Dimension_Finale-1}
-circle[-1] 50%,50%,$Rayon_Cercle_En_Cours,1,0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_Precedent,1,0,0,0,0
-blend[-1,-2] alpha,1,1
-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
-blend[-1,-2] alpha,1,1
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}}
-ellipse[-1] 50%,50%,$Rayon_Cercle_En_Cours,$Rayon_Cercle_En_Cours,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-blend[-1,-4] alpha,1,0
-reverse[-1,-2]
-endif
Rayon_Dernier_Cercle=$Rayon_Cercle_Precedent
Rayon_Cercle_Precedent=$Rayon_Cercle_En_Cours
Nb_boucles={$Nb_boucles+1}
-done
-rm[-2]
# contour cercle
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}}
-ellipse[-2] 50%,50%,$Rayon_Cercle_Final,$Rayon_Cercle_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilate_Contours>1} -dilate_circ[-2] $Dilate_Contours -endif
-if {$Flou_Contours>0} -blur[-2] $Flou_Contours,0 -endif
-if {$Sharpen_Contours>0} -sharpen[-2] $Sharpen_Contours -endif
-if {$Filtre_Symmetrizoscope==1}
-fx_symmetrizoscope[-1,-2] $Iterations_Symmetrizoscope,$Angle_Symmetrizoscope,0,$Symmetry_Sides
Conserver_Exterieur_Cercles=0
-endif
-if {$Conserver_Exterieur_Cercles==0}
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 255,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
-replace_color[-1] 100%,0,255,0,0,255,0,0,0,0
-reverse[-1,-2]
-blend[-2,-1] add,1,0
-endif
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-if {$Melange_Couleurs_Contours==1}
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-else
-reverse[-1,-2]
-endif
-else
-if {$Melange_Couleurs_Contours==1}
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-reverse[-1,-2]
-else
-reverse[-1,-2,-3]
-endif
-endif
#@gui Color Rays : samj_Scintillements_Colores_en, samj_Scintillements_Colores_en(1)
#@gui : Color Recognition = color(64,64,64,255)
#@gui : Resolution - L = int(8,4,32)
#@gui : Resolution - H = int(8,4,32)
#@gui : Dimension - Variation = float(0.5,0.2,3)
#@gui : Color - Variation = int(384,1,768)
#@gui : Rays = int(12,3,24)
#@gui : Shift Angle = float(0,0,120)
#@gui : Random - Variation = int(0,0,100)
#@gui : Rendering = choice(0,"Normal","Invert","Normal + Invert")
#@gui : Blur = float(0,0,5)
#@gui : Background Color = color(0,0,0,255)
#@gui : Deformation = float(0,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/02/02</i>.</small>")
samj_Scintillements_Colores_en :
-samj_Scintillements_Colores $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
-if {$18>0} -deform[-1] $18 -endif
#@gui Concentric Circles : Cercles_Concentriques_A_en, Cercles_Concentriques_A_en(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Resulting Image</b></span>")
#@gui : Dimensions Pixels = int(800,256,1920)
#@gui : Delete Layer Source = bool(1)
#@gui : note = note("<span foreground="orangered"><b>Circles Rings</b></span>")
#@gui : Nb Circles (Rings) = int(6,1,180)
#@gui : Change Circles Size = choice(0,"Sin. A","Sin. B","Linear")
#@gui : Initial Size = float(0,0,180)
#@gui : Final Size = float(90,0,180)
#@gui : Coefficient Of Variation = float(1,-1,1)
#@gui : Rotate Clockwise (Outside Towards Center) = bool(1)
#@gui : Shift % = float(50,0,500)
#@gui : Keep Outside Of Circles = bool(1)
#@gui : note = note("<span foreground="orangered"><b>Colored Rays And Contours</b></span>")
#@gui : ENABLE COLORED RAYS Vs BACKGROUND IMAGE = bool(1)
#@gui : note = note("<span foreground="blue"><small> - Contours - </small></span>")
#@gui : Contours = color(0,0,0,255)
#@gui : Display = choice(0,"No","Rays and Circles","Rays","Circles")
#@gui : Dilate = int(0,0,16)
#@gui : Blur = float(0,0,5)
#@gui : Sharpen = int(0,0,600)
#@gui : note = note("<span foreground="blue"><small> - Colors - </small></span>")
#@gui : Colors Repeating (Rays) = int(5,1,180)
#@gui : Angle Tilt = float(0,0,360)
#@gui : Color A = color(0,0,255,255)
#@gui : Color B = color(255,255,0,255)
#@gui : Color C = color(255,0,0,255)
#@gui : Color D = color(0,255,255,255)
#@gui : Color E = color(255,0,255,255)
#@gui : Random Colors = bool(0)
#@gui : Blend Layers Colors & Contours = bool(1)
#@gui : note = note("<span foreground="orangered"><b>Symmetrizoscope</b></span>")
#@gui : Enable Symmetrizoscope = bool(0)
#@gui : Iterations = int(5,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Symmetry Sides = choice("Backward","Forward","Swap")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/04/26</i>.</small>")
Cercles_Concentriques_A_en:
-Cercles_Concentriques_A $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47
#@gui Hearts : samj_en_Coeurs_Hearts_002, samj_en_Coeurs_Hearts_002(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Hearts</small></span>")
#@gui : Resolution = int(16,4,128)
#@gui : Filling % = float(100,20,100)
#@gui : Tilt = int(0,0,360)
#@gui : Blur = float(0,0,2)
#@gui : Hearts = bool(1)
#@gui : Interpolation = int(0,0,3)
#@gui : Background Color = color(255,255,255,255)
#@gui : Grey = bool(0)
#@gui : Colors Boost = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Type Foreground = choice(0,"Type A","Type B")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/13</i>.</small>")
samj_en_Coeurs_Hearts_002 :
-samj_Coeurs_Hearts_002 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15
#@gui Samj Bulles Colorees : samj_Bulles_Colorees, samj_Bulles_Colorees(1)
#@gui : note = note("samj_Bulles_Colorees")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite = color(64,64,64,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Resolution</b></span>")
#@gui : Resolution = int(8,1,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Bulles</b></span>")
#@gui : Variation L = int(0,-255,255)
#@gui : Variation H = int(0,-255,255)
#@gui : Grossissement A = float(3,1,9)
#@gui : Grossissement B = float(0,-3,3)
#@gui : Angle = bool(0)
#@gui : Angle Variation = float(0,0,180)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/30</i>.</small>")
samj_Bulles_Colorees :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Variation_L=$6
Variation_H=$7
Grossissement_A=$8
Grossissement_B=$9
Angle_Validation=$10
Angle_Variation=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Angle_Origine=$Angle_Variation
KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution+$Resolution}}
-repeat {$Hauteur_Origine/{$Resolution+$Resolution}}
couleur_pixel=${-at_ancien[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}
KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}
-if {$Angle_Validation==0}
Angle_Variation=$Angle_Origine
-else
Angle_Variation={$Angle_Origine+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}*180}}
-endif
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
Hauteur={$Hauteur+$Resolution+$Resolution}
-done
Largeur={$Largeur+$Resolution+$Resolution}
Hauteur=$Resolution
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
#@gui Samj Carres Noirs : samj_Carres_Noirs , samj_Carres_Noirs (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Limite D\303\251tails = int(128,1,255)
#@gui : R\303\251solution = int(40,8,64)
#@gui : \303\211paisseur / Thickness = int(7,1,7)
#@gui : Dilate = int(0,0,8)
#@gui : Couleur Avant Plan = color(0,0,0,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Flou/Blur = float(2,0,10)
#@gui : Couleur Ombre = color(96,96,96,255)
#@gui : D\303\251calage Ombre = int(2,0,7)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Isophotes</b></span>")
#@gui : Ajout Isophotes = bool(0)
#@gui : Flou/Blur = float(2,0,10)
#@gui : Ajout Couleur = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/22</i>.</small>")
samj_Carres_Noirs :
Limite=$1
Resolution_Largeur=$2
Trait_Largeur=$3
Dilatation=$4
R_a=$5
V_a=$6
B_a=$7
A_a=$8
Flou=$9
R_b=$10
V_b=$11
B_b=$12
A_b=$13
VA=$14
R_c=$15
V_c=$16
B_c=$17
A_c=$18
Ajout_Isophotes=$19
Flou_Isophotes=$20
Ajout_Couleur=$21
Largeur={w}
Hauteur={h}
-to_rgba[-1]
-if {$Ajout_Isophotes==1}
--Je_passe_l_hiver_en_Floride[-1]
-endif
-luminance[-1]
-to_rgba[-1]
-n[-1] 0,255
-c[-1] 0,$Limite
-n[-1] 0,255
-c[-1] {255-$Limite},255
-n[-1] 0,255
--Je_passe_l_hiver_en_Floride[-1]
-samj_Lignes_Epaisseur_Variable[-1] 0,$Resolution_Largeur,$Trait_Largeur,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0.5,0.5,1.8,0,0
-samj_Lignes_Epaisseur_Variable[-2] 1,$Resolution_Largeur,$Trait_Largeur,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0.5,0.5,1.8,0,0
-blend[-1,-2] alpha
-if {$Dilatation>0}
-dilate[-1] $Dilatation
-endif
-resize[-1] $Largeur,$Hauteur
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
-replace_color[-1] 100%,0,0,0,0,255,$R_b,$V_b,$B_b,$A_b
-blur[-1] $Flou
-shift[-1] $VA,$VA,0,0,0
-crop[-1] 0,0,{{w}-1},{{h}-1}
-replace_color[-2] 100%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a
-reverse[-1,-2]
-blend[-1,-2] alpha
{w},{h},1,4
-fill_color[-1] $R_c,$V_c,$B_c,$A_c
-reverse[-1,-2]
-blend[-1,-2] alpha
-if {$Ajout_Isophotes==1}
-blur[-2] $Flou_Isophotes
-isophotes[-2] 8
-n[-2] 0,255
-if {$Ajout_Couleur==0}
-to_graya[-2]
-endif
-reverse[-1,-2]
-blend[-1,-2] alpha
-endif
#@gui Samj Coeurs Hearts 002 : samj_Coeurs_Hearts_002, samj_Coeurs_Hearts_002(1)
#@gui : sep = separator(), note = note("<span foreground="red">Des c&#339;urs aux couleurs de l'image.</span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>C&#339;urs / Hearts</small></span>")
#@gui : R\303\251solution = int(16,4,128)
#@gui : Remplissage % = float(100,20,100)
#@gui : Angle Rotation = int(0,0,360)
#@gui : Flou / Blur = float(0,0,2)
#@gui : Coeurs / Hearts = bool(1)
#@gui : Interpolation = int(0,0,3)
#@gui : Couleur Fond / Background Color = color(255,255,255,255)
#@gui : Gris = bool(0)
#@gui : Amplification Couleurs / Colors Boost = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>M\303\251lange / Blend</small></span>")
#@gui : Type Avant Plan / Foreground = choice(0,"Type A","Type B")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/20</i>.</small>")
samj_Coeurs_Hearts_002 :
Resolution=$1
Remplissage=$2
Angle_Rotation_Motif=$3
flou=$4
Coeurs_Hearts=$5
Interpolation=$6
R_Couleur=$7
V_Couleur=$8
B_Couleur=$9
A_Couleur=$10
Gris=$11
Boost=$12
Type_Avant_Plan=$13
Mode_blend=$14
Opacity_blend=$15
-if {$Type_Avant_Plan==1}
--Je_passe_l_hiver_en_Floride[-1]
-to_rgb[-2]
-negate[-2]
-endif
-to_rgb[-1]
-negate[-1]
-if {$Interpolation==0}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution}
-c[-1] 0,255
-elif {$Interpolation==1}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution},1,3,3
-c[-1] 0,255
-elif {$Interpolation==2}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution}
-n[-1] 0,255
-elif {$Interpolation==3}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution},1,3,3
-n[-1] 0,255
-endif
-if {$Type_Avant_Plan==1}
-resize[-2] {{w}*$Resolution},{{h}*$Resolution}
-rm[-1]
-else
-resize[-1] {{w}*$Resolution},{{h}*$Resolution}
-endif
-if {$Gris==1}
-to_gray[-1]
-endif
-c[-1] 0,255
-if {$Boost==1}
-balance_gamma[-1] 128,128,128,1
-n[-1] 0,255
-endif
-negate[-1]
-to_rgba[-1]
$Resolution,$Resolution,1,4
-fill_color[-1] 0,0,0,0
-if {$Coeurs_Hearts==1}
(0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0;0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0;0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0;0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0;0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0;0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0;0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0)
-else
(1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0;1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1;0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1)
-endif
-if {$Angle_Rotation_Motif>0}
-rotate[-1] $Angle_Rotation_Motif,0,0
-autocrop[-1] 0
-endif
-resize[-1] {$Resolution*$Remplissage/100},{$Resolution*$Remplissage/100}
-blend[-1,-2] alpha
-resize[-1] [-2],[-2],1,1,0,2
-to_rgba[-1]
#-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
#-replace_color[-1] 100%,0,0,0,0,255,255,255,255,255
-replace_color[-1] 100%,0,0,0,0,255,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-replace_color[-1] 100%,0,1,1,1,255,0,0,0,0
-gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0
-if {$flou>0}
-blur[-1] $flou,0
-endif
samj_rien_atistic :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Samj Ellipses Colorees : samj_Ellipses_Colorees, samj_Ellipses_Colorees(1)
#@gui : note = note("samj_Ellipses_Colorees")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite = color(64,64,64,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ellipse</b></span>")
#@gui : Rayon L = int(8,1,32)
#@gui : Rayon H = int(8,1,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/31</i>.</small>")
samj_Ellipses_Colorees :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Rayon_L=$5
Rayon_H=$6
Rendu=$7
Flou_Contours=$8
Couleur_Fond_r=$9
Couleur_Fond_v=$10
Couleur_Fond_b=$11
Couleur_Fond_a=$12
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Hauteur=$Rayon_H
Largeur=$Rayon_L
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Rayon_L+$Rayon_L}}
-repeat {$Hauteur_Origine/{$Rayon_H+$Rayon_H}}
couleur_pixel=${-at_ancien[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
Hauteur={$Hauteur+$Rayon_H+$Rayon_H}
-done
Largeur={$Largeur+$Rayon_L+$Rayon_L}
Hauteur=$Rayon_H
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
#@gui Samj Losanges Colores : samj_Losanges_Colores, samj_Losanges_Colores(1)
#@gui : note = note("samj_Losanges_Colores")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite = color(64,64,64,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Resolution</b></span>")
#@gui : Resolution = int(8,1,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Losanges - Rectangles</b></span>")
#@gui : Inclinaison = bool(0)
#@gui : Variation L = int(0,-255,255)
#@gui : Variation H = int(0,-255,255)
#@gui : Grossissement A = float(1.5,0.5,9)
#@gui : Grossissement B = float(0,-10,10)
#@gui : Dimension Variation = float(1,0.3,3)
#@gui : sep = separator(), note = note("<span foreground="Rendu"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Contours Losanges = choice(0,"Sans","Couleur Fond","Blanc","Gris moyen","Fonce")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/01</i>.</small>")
samj_Losanges_Colores :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Inclinaison_Quadrilataire=$6
Variation_L=$7
Variation_H=$8
Grossissement_A=$9
Grossissement_B=$10
Dimension_Variation=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17
Contours_Polygones=$18
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Dimension_Origine={$Dimension_Variation*$Resolution}
KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution
X_a=0
Y_a=0
X_b=0
Y_b=0
X_c=0
Y_c=0
X_d=0
Y_d=0
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution+$Resolution}}
-repeat {$Hauteur_Origine/{$Resolution+$Resolution}}
couleur_pixel=${-at_ancien[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}
KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}
Dimension_Variation={$Dimension_Origine*{1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}}}}
-if {$Inclinaison_Quadrilataire==0}
X_a={$Largeur-{$Dimension_Variation*$KL}}
Y_a=$Hauteur
X_b=$Largeur
Y_b={$Hauteur+{$Dimension_Variation*$KH}}
X_c={$Largeur+{$Dimension_Variation*$KL}}
Y_c=$Hauteur
X_d=$Largeur
Y_d={$Hauteur-{$Dimension_Variation*$KH}}
-else
X_a={$Largeur-{$Dimension_Variation*$KL}}
Y_a={$Hauteur+{$Dimension_Variation*$KH}}
X_b={$Largeur+{$Dimension_Variation*$KL}}
Y_b={$Hauteur+{$Dimension_Variation*$KH}}
X_c={$Largeur+{$Dimension_Variation*$KL}}
Y_c={$Hauteur-{$Dimension_Variation*$KH}}
X_d={$Largeur-{$Dimension_Variation*$KL}}
Y_d={$Hauteur-{$Dimension_Variation*$KH}}
-endif
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
-if {$Contours_Polygones==1}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-elif {$Contours_Polygones==2}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,255,255,255,$alpha_pixel
-elif {$Contours_Polygones==3}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},$alpha_pixel
-elif {$Contours_Polygones==4}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{$rouge_pixel*0.5},{$vert_pixel*0.5},{$bleu_pixel*0.5},$alpha_pixel
-endif
Hauteur={$Hauteur+$Resolution+$Resolution}
-done
Largeur={$Largeur+$Resolution+$Resolution}
Hauteur=$Resolution
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
#@gui Samj Moirage Spline : samj_Moirage_Spline, samj_Moirage_Spline(0)
#@gui : note = note("samj_Moirage_Spline")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Calque A</b></span>")
#@gui : Couleur A = color(0,0,0,255)
#@gui : Resolution A = int(8,2,32)
#@gui : Decalage A = float(0,-100,100)
#@gui : Spline A U0 = float(-50,-250,250)
#@gui : Spline A V0 = float(50,-250,250)
#@gui : Spline A U1 = float(-50,-250,250)
#@gui : Spline A V1 = float(50,-250,250)
#@gui : Orientation A = float(0,0,360)
#@gui : Dilate A % = int(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Calque B</b></span>")
#@gui : Couleur B = color(0,0,0,255)
#@gui : Resolution B = int(8,2,32)
#@gui : Decalage B = float(0,-100,100)
#@gui : Spline B U0 = float(-50,-250,250)
#@gui : Spline B V0 = float(50,-250,250)
#@gui : Spline B U1 = float(-50,-250,250)
#@gui : Spline B V1 = float(50,-250,250)
#@gui : Orientation A = float(0,0,360)
#@gui : Dilate B % = int(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/04</i>.</small>")
samj_Moirage_Spline :
Couleur_Ar=$1
Couleur_Av=$2
Couleur_Ab=$3
Couleur_Aa=$4
Resolution_A=$5
Decalage_A=$6
Spline_A_u0=$7
Spline_A_v0=$8
Spline_A_u1=$9
Spline_A_v1=$10
Orientation_A=$11
Dilate_A={round({$12/100*$Resolution_A})}
Couleur_Br=$13
Couleur_Bv=$14
Couleur_Bb=$15
Couleur_Ba=$16
Resolution_B=$17
Decalage_B=$18
Spline_B_u0=$19
Spline_B_v0=$20
Spline_B_u1=$21
Spline_B_v1=$22
Orientation_B=$23
Dilate_B={round({$24/100*$Resolution_B})}
Largeur_Origine={w}
Hauteur_Origine={h}
Nouvelle_Dimension={round({{{{$Largeur_Origine^2}+{$Hauteur_Origine^2}}^0.5}+1})}
Nouvelle_Dimension={$Nouvelle_Dimension+{max({abs({$Nouvelle_Dimension/100*$Spline_A_u0})},{abs({$Nouvelle_Dimension/100*$Spline_B_u0})})}+{max({abs({$Nouvelle_Dimension/100*$Spline_A_u1})},{abs({$Nouvelle_Dimension/100*$Spline_B_u1})})}}
XA_origine={round({$Resolution_A/100*$Decalage_A})}
YA_origine=0
XA_fin=$XA_origine
YA_fin=$Nouvelle_Dimension
XB_origine=0
YB_origine={round({$Resolution_B/100*$Decalage_B})}
XB_fin=$Nouvelle_Dimension
YB_fin=$XB_origine
$Nouvelle_Dimension,$Nouvelle_Dimension,1,4
-repeat {$Nouvelle_Dimension/$Resolution_A}
-spline[-1] $XA_origine,$YA_origine,{$Nouvelle_Dimension/100*$Spline_A_u0},{$Nouvelle_Dimension/100*$Spline_A_v0},$XA_fin,$YA_fin,{$Nouvelle_Dimension/100*$Spline_A_u1},{$Nouvelle_Dimension/100*$Spline_A_v1},1,$Couleur_Ar,$Couleur_Av,$Couleur_Ab,$Couleur_Aa
XA_origine={$XA_origine+$Resolution_A}
YA_origine=0
XA_fin=$XA_origine
YA_fin=$Nouvelle_Dimension
-done
-if {$Orientation_A>0} -rotate[-1] {$Orientation_A} -endif
-crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{{{{w}-$Largeur_Origine}/2}+$Largeur_Origine-1},{{{{h}-$Hauteur_Origine}/2}+$Hauteur_Origine-1}
-if {$Dilate_A>1} -dilate_circ[-1] $Dilate_A -endif
$Nouvelle_Dimension,$Nouvelle_Dimension,1,4
-repeat {$Nouvelle_Dimension/$Resolution_B}
-spline[-1] $XB_origine,$YB_origine,{$Nouvelle_Dimension/100*$Spline_B_u0},{$Nouvelle_Dimension/100*$Spline_B_v0},$XB_fin,$YB_fin,{$Nouvelle_Dimension/100*$Spline_B_u1},{$Nouvelle_Dimension/100*$Spline_B_v1},1,$Couleur_Br,$Couleur_Bv,$Couleur_Bb,$Couleur_Ba
XB_origine=0
YB_origine={$YB_origine+$Resolution_B}
XB_fin=$Nouvelle_Dimension
YB_fin=$YB_origine
-done
-if {$Orientation_B>0} -rotate[-1] {$Orientation_B} -endif
-crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{{{{w}-$Largeur_Origine}/2}+$Largeur_Origine-1},{{{{h}-$Hauteur_Origine}/2}+$Hauteur_Origine-1}
-if {$Dilate_B>1} -dilate_circ[-1] $Dilate_B -endif
-blend[-1,-2] alpha,1,1
-reverse[-1,-2]
#@gui Samj Moirage Spline XY : samj_Moirage_Spline_XY, samj_Moirage_Spline_XY(0)
#@gui : note = note("samj_Moirage_Spline_XY")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Calque A</b></span>")
#@gui : Couleur A = color(0,0,0,255)
#@gui : Resolution A = int(8,2,32)
#@gui : Decalage A = float(0,-100,100)
#@gui : Spline A U0 = float(-50,-400,400)
#@gui : Spline A V0 = float(50,-400,400)
#@gui : Spline A U1 = float(-50,-400,400)
#@gui : Spline A V1 = float(50,-400,400)
#@gui : Dilate A % = int(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Calque B</b></span>")
#@gui : Couleur B = color(0,0,0,255)
#@gui : Resolution B = int(8,2,32)
#@gui : Decalage B = float(0,-100,100)
#@gui : Spline B U0 = float(-50,-400,400)
#@gui : Spline B V0 = float(50,-400,400)
#@gui : Spline B U1 = float(-50,-400,400)
#@gui : Spline B V1 = float(50,-400,400)
#@gui : Dilate B % = int(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Calques Visibles</b></span>")
#@gui : Choix = choice(0,"Calques A B","Calque A","Calque B")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/21</i>.</small>")
samj_Moirage_Spline_XY :
Couleur_Ar=$1
Couleur_Av=$2
Couleur_Ab=$3
Couleur_Aa=$4
Resolution_A=$5
Decalage_A=$6
Spline_A_u0=$7
Spline_A_v0=$8
Spline_A_u1=$9
Spline_A_v1=$10
Dilate_A={round({$11/100*$Resolution_A})}
Couleur_Br=$12
Couleur_Bv=$13
Couleur_Bb=$14
Couleur_Ba=$15
Resolution_B=$16
Decalage_B=$17
Spline_B_u0=$18
Spline_B_v0=$19
Spline_B_u1=$20
Spline_B_v1=$21
Dilate_B={round({$22/100*$Resolution_B})}
Choix_Calques_Visibles=$23
Largeur_Origine={w}
Hauteur_Origine={h}
XA_origine={round({{$Resolution_A/100*$Decalage_A}-{$Largeur_Origine/2}})}
YA_origine=0
XA_fin={round({{$Resolution_A/100*$Decalage_A}+{$Largeur_Origine*1.5}})}
YA_fin=$Hauteur_Origine
Iterations_A={round({{{abs($XA_origine)}+$XA_fin}/$Resolution_A})}
XB_origine=0
YB_origine={round({{$Resolution_B/100*$Decalage_B}-{$Hauteur_Origine/2}})}
XB_fin=$Largeur_Origine
YB_fin={round({{$Resolution_B/100*$Decalage_B}+{$Hauteur_Origine*1.5}})}
Iterations_B={round({{{abs($YB_origine)}+$YB_fin}/$Resolution_B})}
-if {{$Choix_Calques_Visibles==0}||{$Choix_Calques_Visibles==1}}
$Largeur_Origine,$Hauteur_Origine,1,4
-repeat $Iterations_A
XA_origine={$XA_origine+$Resolution_A}
XA_fin=$XA_origine
-spline[-1] $XA_origine,$YA_origine,{$Largeur_Origine/100*$Spline_A_u0},{$Largeur_Origine/100*$Spline_A_v0},$XA_fin,$YA_fin,{$Largeur_Origine/100*$Spline_A_u1},{$Largeur_Origine/100*$Spline_A_v1},1,$Couleur_Ar,$Couleur_Av,$Couleur_Ab,$Couleur_Aa
-done
-if {$Dilate_A>1} -dilate_circ[-1] $Dilate_A -endif
-endif
-if {{$Choix_Calques_Visibles==0}||{$Choix_Calques_Visibles==2}}
$Largeur_Origine,$Hauteur_Origine,1,4
-repeat $Iterations_B
YB_origine={$YB_origine+$Resolution_B}
YB_fin=$YB_origine
-spline[-1] $XB_origine,$YB_origine,{$Hauteur_Origine/100*$Spline_B_u0},{$Hauteur_Origine/100*$Spline_B_v0},$XB_fin,$YB_fin,{$Hauteur_Origine/100*$Spline_B_u1},{$Hauteur_Origine/100*$Spline_B_v1},1,$Couleur_Br,$Couleur_Bv,$Couleur_Bb,$Couleur_Ba
-done
-if {$Dilate_B>1} -dilate_circ[-1] $Dilate_B -endif
-endif
-if {$Choix_Calques_Visibles==0}
-blend[-1,-2] alpha,1,1
-endif
-reverse[-1,-2]
#@gui Samj Pixelisation Contours : samj_Pixelisation_Contours , samj_Pixelisation_Contours(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Pixelisation</b></span>")
#@gui : Flou/Blur = float(0.5,0,16)
#@gui : Forme = choice(0,"Carree","Hexagonale","Triangulaire A","Triangulaire B","Triangulaire C","Triangulaire D","Triangulaire E","Triangulaire F")
#@gui : Pixelisation = int(20,2,128)
#@gui : Levels = int(8,1,256)
#@gui : Smoothness = float(0,0,5)
#@gui : Decalages = int(0,0,32)
#@gui : Rendu = int(1,1,6)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Amplitude = float(0,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/20</i>.</small>")
samj_Pixelisation_Contours  :
Flou=$1
Forme=$2
Pixelisation=$3
TM_Levels=$4
TM_Smoothness=$5
VA=$6
Type_Rendu=$7
V_Amplitude=$8
V_Edge_Threshold=$9
V_Smoothness=$10
Largeur={w}
Hauteur={h}
-blur[-1] $Flou
-if {$Forme==0}
-pixelize[-1] {$Largeur/$Pixelisation},{$Hauteur/$Pixelisation}
-elif {$Forme==1}
-imagegrid_hexagonal[-1] {round({2*$Largeur/$Pixelisation})},0
-elif {$Forme==2}
-imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},0,0
-elif {$Forme==3}
-imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},1,0
-elif {$Forme==4}
-imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},2,0
-elif {$Forme==5}
-imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},3,0
-elif {$Forme==6}
-imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},4,0
-elif {$Forme==7}
-imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},5,0
-endif
-topographic_map[-1] $TM_Levels,$TM_Smoothness
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-if {$Type_Rendu==1}
-shift[-1] 0,$VA,0,0,0
-shift[-2] $VA,0,0,0,0
-shift[-3] $VA,$VA,0,0,0
-elif {$Type_Rendu==2}
-shift[-1] 0,$VA,0,0,0
-shift[-2] $VA,$VA,0,0,0
-shift[-3] $VA,0,0,0,0
-elif {$Type_Rendu==3}
-shift[-1] $VA,0,0,0,0
-shift[-2] 0,$VA,0,0,0
-shift[-3] $VA,$VA,0,0,0
-elif {$Type_Rendu==4}
-shift[-1] $VA,0,0,0,0
-shift[-2] $VA,$VA,0,0,0
-shift[-3] 0,$VA,0,0,0
-elif {$Type_Rendu==5}
-shift[-1] $VA,$VA,0,0,0
-shift[-2] $VA,0,0,0,0
-shift[-3] 0,$VA,0,0,0
-elif {$Type_Rendu==6}
-shift[-1] $VA,$VA,0,0,0
-shift[-2] 0,$VA,0,0,0
-shift[-3] $VA,0,0,0,0
-endif
-crop[-1,-2,-3] 0,0,{$Largeur-1-$VA},{$Hauteur-1-$VA}
-blend[-1,-2,-3,-4] edges
-fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness
#@gui Samj Pointes De Diamants Colorees : samj_Pointes_De_Diamants_Colorees, samj_Pointes_De_Diamants_Colorees(1)
#@gui : note = note("samj_Pointes_De_Diamants_Colorees")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite = color(64,64,64,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Resolution</b></span>")
#@gui : Resolution = int(8,1,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Polygones</b></span>")
#@gui : Variation L = int(0,-255,255)
#@gui : Variation H = int(0,-255,255)
#@gui : Grossissement A = float(1.5,0.5,9)
#@gui : Grossissement B = float(0,-10,10)
#@gui : Angle Variation = float(0,0,180)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Contours Polygones = choice(0,"Sans","Couleur Fond","Blanc","Gris moyen","Fonce")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/31</i>.</small>")
samj_Pointes_De_Diamants_Colorees :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Variation_L=$6
Variation_H=$7
Grossissement_A=$8
Grossissement_B=$9
Angle_Variation=$10
Rendu=$11
Flou_Contours=$12
Couleur_Fond_r=$13
Couleur_Fond_v=$14
Couleur_Fond_b=$15
Couleur_Fond_a=$16
Contours_Polygones=$17
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Angle_Origine={45+$Angle_Variation}
KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution
X_a=0
Y_a=0
X_b=0
Y_b=0
X_c=0
Y_c=0
X_d=0
Y_d=0
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution+$Resolution}}
-repeat {$Hauteur_Origine/{$Resolution+$Resolution}}
couleur_pixel=${-at_ancien[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}
KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}
Angle_Variation={$Angle_Origine+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}*180}}
X_a={$Largeur-{{$Resolution*$KL}*{cos({pi/180*$Angle_Variation})}}}
Y_a=$Hauteur
X_b=$Largeur
Y_b={$Hauteur+{{$Resolution*$KH}*{sin({pi/180*$Angle_Variation})}}}
X_c={$Largeur+{{$Resolution*$KL}*{cos({pi/180*$Angle_Variation})}}}
Y_c=$Hauteur
X_d=$Largeur
Y_d={$Hauteur-{{$Resolution*$KH}*{sin({pi/180*$Angle_Variation})}}}
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
-if {$Contours_Polygones==1}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-elif {$Contours_Polygones==2}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,255,255,255,$alpha_pixel
-elif {$Contours_Polygones==3}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},$alpha_pixel
-elif {$Contours_Polygones==4}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{$rouge_pixel*0.5},{$vert_pixel*0.5},{$bleu_pixel*0.5},$alpha_pixel
-endif
Hauteur={$Hauteur+$Resolution+$Resolution}
-done
Largeur={$Largeur+$Resolution+$Resolution}
Hauteur=$Resolution
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
#@gui Samj Reptile : samj_reptile, samj_reptile(1)
#@gui : note = note("samj_reptile")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Texture Peau</b></span>")
#@gui : Forme = choice(0,"hexagonal","grid","triangular Ha","triangular Hb","triangular Va","triangular Vb")
#@gui : Resolution = int(64,1,256)
#@gui : Spread = int(25,5,100)
#@gui : Color = float(2,0,10)
#@gui : Orientation = float(0,0,1)
#@gui : Light = int(40,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/20</i>.</small>")
samj_reptile :
Texture_Forme=$1
Texture_Resolution=$2
Texture_Spread=$3
Texture_Color=$4
Texture_Orientation=$5
Texture_Light=$6
Opacity=$7
Largeur_Origine={w}
Hauteur_Origine={h}
Coeff_Echelle_L=1
Coeff_Echelle_H=1
--Je_passe_l_hiver_en_Floride[-1]
-fx_isophotes[-1] 8,2,1,0
-if {$Largeur_Origine<{10*$Texture_Resolution}}
Coeff_Echelle_L={{10*$Texture_Resolution}/$Largeur_Origine}
-endif
-if {$Hauteur_Origine<{10*$Texture_Resolution}}
Coeff_Echelle_H={{10*$Texture_Resolution}/$Hauteur_Origine}
-endif
-if {{$Coeff_Echelle_L+$Coeff_Echelle_H}>2}
-if {$Coeff_Echelle_L>$Coeff_Echelle_H}
-resize[-1,-2] {round({$Largeur_Origine*$Coeff_Echelle_L})},{round({$Hauteur_Origine*$Coeff_Echelle_L})}
-else
-resize[-1,-2] {round({$Largeur_Origine*$Coeff_Echelle_H})},{round({$Hauteur_Origine*$Coeff_Echelle_H})}
-endif
-endif
-to_rgb[-1,-2]
-if {$Texture_Forme==0}
-fx_imagegrid_hexagonal[-1] $Texture_Resolution,0.1,1
-elif {$Texture_Forme==1}
-imagegrid[-1] {round({{w}/$Texture_Resolution})},{round({{h}/$Texture_Resolution})}
-elif {$Texture_Forme==2}
-fx_imagegrid_triangular {round({{w}/$Texture_Resolution})},{round({1.8*{w}/$Texture_Resolution})},0,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-elif {$Texture_Forme==3}
-fx_imagegrid_triangular {round({{h}/{1.8*$Texture_Resolution}})},{round({{h}/$Texture_Resolution})},0,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-elif {$Texture_Forme==4}
-fx_imagegrid_triangular {round({{w}/$Texture_Resolution})},{round({1.8*{w}/$Texture_Resolution})},1,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-elif {$Texture_Forme==5}
-fx_imagegrid_triangular {round({{h}/{1.8*$Texture_Resolution}})},{round({{h}/$Texture_Resolution})},1,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-endif
-fx_spread {{{w}*$Texture_Spread}/{100*$Texture_Resolution}},{{{h}*$Texture_Spread}/{100*$Texture_Resolution}},0,0,0
-fx_boost_fade[-1] $Texture_Color,0
--Je_passe_l_hiver_en_Floride[-1]
-fx_local_orientation[-1] $Texture_Orientation,0,100,0,16,0
-fx_blend[-1,-2] 14,0,1,1
-fx_lightglow[-1] $Texture_Light,0.5,8,0.8,0,0
-blend[-1,-2] grainmerge,1,$Opacity
#@gui Samj Scintillements Colores : samj_Scintillements_Colores, samj_Scintillements_Colores(1)
#@gui : note = note("samj_Scintillements_Colores")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite = color(64,64,64,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Scintillement</b></span>")
#@gui : Resolution L = int(8,1,32)
#@gui : Resolution H = int(8,1,32)
#@gui : Dimension Variation = float(1,0.3,3)
#@gui : Variation Couleur = int(768,1,768)
#@gui : Scintillement = int(12,3,24)
#@gui : Angle Decalage = float(0,0,120)
#@gui : Variation Aleatoire = int(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="Rendu"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Scintillements_Colores :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution_L=$5
Resolution_H=$6
Dimension_Variation=$7
Variation_Couleur=$8
Scintillement=$9
Angle_Decalage=$10
Variation_Aleatoire=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Hauteur=$Resolution_H
Largeur=$Resolution_L
Rayon_Scintillement_Origine={{$Resolution_H+$Resolution_L}*$Dimension_Variation}
Rayon_Scintillement=0
Angle_Variation={360/$Scintillement}
Angle_Variation_En_Cours=0
Coeff_Variation_Aleatoire=0
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution_L+$Resolution_L}}
-repeat {$Hauteur_Origine/{$Resolution_H+$Resolution_H}}
couleur_pixel=${-at_ancien[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Variation_Couleur}}
Rayon_Scintillement={$Rayon_Scintillement_Origine*$Moyenne_couleur}
Angle_Variation_En_Cours=0
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-endif
Hauteur={$Hauteur+$Resolution_H+$Resolution_H}
-done
Largeur={$Largeur+$Resolution_L+$Resolution_L}
Hauteur=$Resolution_H
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
#@gui _
#@gui <i>Artistic</i>
#@gui Chalk It up [Fr] : samj_chalkitup, samj_chalkitup_preview
#@gui : note = note("Inspir\303\251 du didacticiel propos\303\251 par Lylejk")
#@gui : note = note("Inspired by the tutorial proposed by Lylejk")
#@gui : note = link("http://justpaste.it/chalk_it_up","http://justpaste.it/chalk_it_up")
#@gui : sep = separator(), note = note("<small>Param\303\250tres peinturage / Painting parameters</small>")
#@gui : Abstraction = int(5,0,10)
#@gui : Pr\303\251cision Details / Details Scale = float(2.5,0,10)
#@gui : Couleur / Color = float(1.5,0,5)
#@gui : Douceur / Smoothness = float(50,0,200)
#@gui : Accentuation Nuances / Sharpen Shades = bool(1)
#@gui : sep = separator(), note = note("<small>Param\303\250tres filtre Morpho / Morpho parameters</small>")
#@gui : Action = choice(5,"Erosion","Dilation","Opening","Closing","Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gui : Taille / Size = int(5,0,32)
#@gui : Inversion Couleurs / Invert Colors = bool(0)
#@gui : Modeler / Shape = int(0,0,1)
#@gui : Canaux / Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator(), note = note("<small>Param\303\250tres filtre Spread / Spread parameters</small>")
#@gui : X-Variations = float(0.8,-5,5)
#@gui : Y-Variations = float(1.9,-5,5)
#@gui : Canaux / Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Auteurs / Authors : <i>Lylejk/samj/Ronounours</i>.      Derni\303\250re mise \303\240 jour : <i>2015/03/31</i>.</small>")
samj_chalkitup :
#gimp_painting
Abstraction=$1
Details_scale=$2
Color=$3
Smoothness=$4
Sharpen_shades=$5
#gimp_morpho
Action=$6
Size=$7
Invert_colors=$8
Shape=$9
Channel_morpho=$10
#gimp_spread
X_variations=$11
Y_variations=$12
Channel_spread=$13
-repeat $! -l[$>]
-remove_opacity[-1]
-fx_painting[-1] $Abstraction,$Details_scale,$Color,$Smoothness,$Sharpen_shades
-ancien_gimp_morpho[-1] $Action,$Size,$Invert_colors,$Shape,$Channel_morpho,0
-fx_spread[-1] $X_variations,$Y_variations,$Channel_spread,0
-endl -done
samj_chalkitup_preview :
-gui_split_preview "-samj_chalkitup ${1--2}",$-1
#@gui Colored Engraving : Engrave_colore_en, Engrave_colore_en(1)
#@gui : note = note("<small>Adaptation of the filter created by Lyle Kroll and David Tschumperl&#233;</small>")
#@gui : note = note("<small>Colored Engraving - samj 20150322</small>")
#@gui : sep = separator()
#@gui : Examples = choice(0,"None","A","B","C","D ***","E","F","G")
#@gui : sep = separator()
#@gui : note = note("<small><b>Engraving</b></small>")
#@gui : Radius = float(0.5,0,2)
#@gui : Density = float(4,0,10)
#@gui : Edges = float(0,0,10)
#@gui : Coherence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal Area = int(0,-256,256)
#@gui : Repetition = int(25,0,50)
#@gui : sep = separator()
#@gui : note = note("<small><b>Anti-aliasing</b></small>")
#@gui : Anti-Aliasing = choice(1,"Disabled","A","B","C")
#@gui : sep = separator()
#@gui : note = note("<small><b>Colors</b></small>")
#@gui : Engraving = choice(2,"Foreground Color","Image - With Contours Of Colors 8","Image - With Contours Of Colors 16","Image - With Contours Of Colors 32","Image - With Contours Of Colors 64","Image - Without Contours Of Colors 8","Image - Without Contours Of Colors 16","Image - Without Contours Of Colors 32","Image - Without Contours Of Colors 64","Image - Without Contours Of Colors 8/3 Layers","Image - Without Contours Of Colors 16/3 Layers","Image - Without Contours Of Colors 32/3 Layers","Image - Without Contours Of Colors 64/3 Layers")
#@gui : Foreground Color = color(0,0,0)
#@gui : Background Color = color(255,255,255)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i>David Tschumperl&#233; </i>.      Latest update: <i>2015/03/23</i>.</small>")
Engrave_colore_en :
-Engrave_colore $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
#@gui Contour Drawings : samj_Contour_Drawings_en , samj_Contour_Drawings_en (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Contour</b></span>")
#@gui : Isophotes = int(5,3,16)
#@gui : Smoothness = float(0,0,5)
#@gui : Dilate = int(2,0,5)
#@gui : Color Autoindex = int(0,0,64)
#@gui : To Gray = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Amplitude = float(5,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Background = bool(0)
#@gui : Color = float(1.1,0,1.2)
#@gui : Variation = int(10,2,200)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Chalk</b></span>")
#@gui : Chalk = bool(0)
#@gui : Spread = float(1,0,4)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/11/18</i>.</small>")
samj_Contour_Drawings_en  :
V_Isophotes=$1
Flou=$2
V_Dilate=$3
V_Color_Autoindex=$4
V_To_Gray=$5
V_Amplitude=$6
V_Edge_Threshold=$7
V_Smoothness=$8
BG=$9
BG_Color=$10
BG_Variation=$11
Chalk=$12
V_Spread=$13
Largeur={w}
Hauteur={h}
-to_rgba[-1]
-if {$BG==1}
--Je_passe_l_hiver_en_Floride[-1]
-endif
-blur[-1] $Flou
-isophotes[-1] $V_Isophotes
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-shift[-1] 1,1,0,0,0
-shift[-2] 0,1,0,0,0
-shift[-3] 1,0,0,0,0
-crop[-1,-2,-3] 0,0,{$Largeur-1},{$Hauteur-1}
-blend[-1,-2,-3,-4] alpha
-dilate[-1] $V_Dilate
-if {$V_Color_Autoindex>0}
-autoindex[-1] {$V_Color_Autoindex+1},1,1
-to_rgba[-1]
-endif
-fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness
-if {$V_To_Gray==1}
-to_graya[-1]
-n[-1] 64,255
-to_rgba[-1]
-endif
-if {$Chalk==1}
-spread[-1] $V_Spread
BG_Color=0
-endif
-if {$BG==1}
-if {$BG_Color<1}
-to_gray[-2]
-endif
-blur[-2] {{{w}+{h}}/$BG_Variation}
-pow[-2] $BG_Color
-blend[-1,-2] alpha
-endif
#@gui Edges And LIC : samj_Edges_And_LIC, samj_Edges_And_LIC(1)
#@gui : sep = separator(), note = note("<span foreground="orangered">samj_Edges_And_LIC</span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background [Step 1]</b></span>")
#@gui : Rendering = choice(0,"A","B","C")
#@gui : Lic = int(200,10,1000)
#@gui : Dilate = int(0,0,2)
#@gui : Sharpen = int(0,0,5000)
#@gui : Blur = float(0,0,5)
#@gui : sep = separator()
#@gui : Edges % = float(15,0,100)
#@gui : Pow = float(8,0.2,8)
#@gui : N Min = int(127,0,255)
#@gui : N Max = int(255,0,255)
#@gui : Gray = choice(0,"A","B","C","D","E","F","G")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Abstraction [Optional Step 2]</b></span>")
#@gui : Abstraction = bool(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Levels = int(20,2,100)
#@gui : Contrast = float(0.2,0.01,1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend [Optional Step 3]</b></span>")
#@gui : Blend = bool(0)
#@gui : Mode = choice{14,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape area max","Shape area max0","Shape area min","Shape area min0","Shape average","Shape average0","Shape min","Shape min0","Shape max","Shape max0",
#@gui : "Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value","Vivid light","Xor"}
#@gui : Reverse = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2017/01/09</i>.</small>")
samj_Edges_And_LIC :
Rendu=$1
Val_Lic=$2
Val_Dilate_Circ=$3
Val_Sharpen=$4
Val_Blur=$5
Val_Edges=$6
Val_Pow=$7
N_min=$8
N_max=$9
Gray=$10
Valider_Abstraction=$11
Smoothness_Abstraction=$12
Levels_Abstraction=$13
Contrast_Abstraction=$14
Valider_Blend=$15
mode=${-arg\ 1+$16,add,alpha,and,average,blue,burn,darken,difference,\
divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
shapeaverage,shapeaverage0,shapemin,shapemin0,shapemax,shapemax0,\
softburn,softdodge,softlight,screen,stamp,subtract,value,\
vividlight,xor}
Inverser_Blend=$17
-to_rgb[-1]
-samj_Wavelet_Sharpen_Test_en[-1] 1,0
-if {$Valider_Blend==1}
--Je_passe_l_hiver_en_Floride[-1]
-endif
--Je_passe_l_hiver_en_Floride[-1]
-edges[-1] $Val_Edges%
-pow[-1] $Val_Pow
-n[-1] $N_min,$N_max
-reverse[-1,-2]
-if {$Rendu==0}
-lic[-1] $Val_Lic,3
-if {$Val_Dilate_Circ>0} -dilate_circ[-1] {$Val_Dilate_Circ+1} -endif
-if {$Val_Sharpen>0} -sharpen[-1] $Val_Sharpen -endif
-if {$Val_Blur>0} -blur[-1] $Val_Blur -endif
-endif
-if {$Rendu==1}
-mirror[-1] x
-lic[-1] $Val_Lic,3
-if {$Val_Dilate_Circ>0} -dilate_circ[-1] {$Val_Dilate_Circ+1} -endif
-if {$Val_Sharpen>0} -sharpen[-1] $Val_Sharpen -endif
-if {$Val_Blur>0} -blur[-1] $Val_Blur -endif
-mirror[-1] x
-endif
-if {$Rendu==2}
--Je_passe_l_hiver_en_Floride[-1]
-lic[-1] $Val_Lic,3
-if {$Val_Dilate_Circ>0} -dilate_circ[-1] {$Val_Dilate_Circ+1} -endif
-if {$Val_Sharpen>0} -sharpen[-1] $Val_Sharpen -endif
-if {$Val_Blur>0} -blur[-1] $Val_Blur -endif
-reverse[-1,-2]
-mirror[-1] x
-lic[-1] $Val_Lic,3
-if {$Val_Dilate_Circ>0} -dilate_circ[-1] {$Val_Dilate_Circ+1} -endif
-if {$Val_Sharpen>0} -sharpen[-1] $Val_Sharpen -endif
-if {$Val_Blur>0} -blur[-1] $Val_Blur -endif
-mirror[-1] x
-blend[-1,-2] average
-endif
-if {$Gray==0}
-fx_decompose_channels[-1] 7,0,1,0
-remove[-1,-2]
-elif {$Gray==1}
-fx_decompose_channels[-1] 2,0,1,0
-remove[-3,-2]
-elif {$Gray==2}
-fx_decompose_channels[-1] 7,0,1,0
-remove[-3,-2]
-elif {$Gray==3}
-fx_decompose_channels[-1] 2,0,1,0
-remove[-3,-1]
-elif {$Gray==4}
-fx_decompose_channels[-1] 7,0,1,0
-remove[-1,-3]
-elif {$Gray==5}
-fx_decompose_channels[-1] 2,0,1,0
-remove[-1,-2]
-elif {$Gray==6}
-to_gray[-1]
-endif
-n[-1] 0,255
-to_rgb[-1]
-blend[-1,-2] average
-n[-1] 0,255
-if {$Valider_Abstraction==1}
-fx_color_abstraction[-1] $Smoothness_Abstraction,$Levels_Abstraction,$Contrast_Abstraction
-endif
-if {$Valider_Blend==1}
-if {$Inverser_Blend==1} -reverse[-1,-2] -endif
-blend[-1,-2] $mode
-endif
#@gui Flamboyance Test : samj_Flamboyance_Test, samj_Flamboyance_Test_preview
#@gui : sep = separator(), url = link("GMIC Adaptation of the tutorial written by Lyle Kroll","http://gimpchat.com/viewtopic.php?f=10&t=14999")
#@gui : note = note("<span foreground="blue"><i>Thank you for this beautiful and interesting effect</i></span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Hard Sketch</u></b></span>")
#@gui : Amplitude = float(65,0,4000)
#@gui : Density = float(28,0,100)
#@gui : Smoothness = float(9.25,0,10)
#@gui : Opacity = float(0.3,0,1)
#@gui : Edge = float(0,0,100)
#@gui : Fast Approximation = bool(1)
#@gui : Color Variation = float(1.1,0.5,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Smooth Bilateral</u></b></span>")
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(12,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Blend</u></b></span>")
#@gui : Grain Type = choice(0,"A","B","C","D")
#@gui : Iterations = int(0,0,10)
#@gui : Blend Proportion = float(1,0,1)
#@gui : Interruption Flamboyance = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Smooth</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(7.83,0,10)
#@gui : Spatial Precision = float(0.68,0.1,2)
#@gui : Angular Precision = float(19,1,180)
#@gui : Value Precision = float(2.65,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Color Variation = float(1,0.5,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Cartoon</u></b></span>")
#@gui : Smoothness = float(3,0,10)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge Threshold = float(20,1,30)
#@gui : Edge Thickness = float(0.1,0,1)
#@gui : Color Strength = float(1.5,0,3)
#@gui : Color Quantization = int(8,2,256)
#@gui : Color Variation = float(1,0.5,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Blend GMIC</u></b></span>")
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : Reverse = bool(0)
#@gui : Sharpen = float(20,0,500)
#@gui : Noise = float(0,0,40)
#@gui : Spread X = float(0,0,20)
#@gui : Spread Y = float(0,0,20)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i>samj</i>.      Latest update: <i>2016/12/06</i>.</small>")
samj_Flamboyance_Test:
-repeat $! -l[$>]
HS_Amplitude=$1
HS_Density=$2
Flou_HS=$3
HS_Opacity=$4
HS_Edge=$5
HS_Fast_Approximation=$6
Couleur_HS=$7
SB_Spatial_Variance=$8
SB_Value_Variance=$9
SB_Iterations=$10
Blend_Grain_Type=$11
Iterations_Blend_Grain=$12
Blend_Grain_Proportion=$13
Interruption_Flamboyance=$14
S_Amplitude=$15
S_Sharpness=$16
S_Anisotropy=$17
S_Gradient_smoothness=$18
S_Tensor_smoothness=$19
S_Spatial_precision=$20
S_Angular_precision=$21
S_Value_precision=$22
S_Interpolation=$23
S_Fast_approximation=$24
S_Color_Variation=$25
C_Smoothness=$26
C_Sharpening=$27
C_Edge_threshold=$28
C_Edge_thickness=$29
C_Color_strength=$30
C_Color_quantization=$31
C_Color_Variation=$32
Blend_Mode=$33
Blend_Opacity=$34
Blend_Reverse=$35
Sharpen_Origine=$36
Bruit=$37
Spread_X=$38
Spread_Y=$39
-to_rgba[-1]
-spread[-1] $Spread_X,$Spread_Y,0
-if {$Bruit>0} --Je_passe_l_hiver_en_Floride[-1] -noise_hurl[-1] {$Bruit+1} -blend[-1,-2] alpha -endif
-sharpen[-1] $Sharpen_Origine
--Je_passe_l_hiver_en_Floride[-1]
#partie1
-blur[-1] $Flou_HS
--hardsketchbw[-1] $HS_Amplitude,$HS_Density,$HS_Opacity,$HS_Edge,$HS_Fast_Approximation
-blend[-1,-2] hardlight
-to_rgb[-1]
-negate[-1]
-n[-1] 0,255
-to_graya[-1]
-mul[-1] $Couleur_HS
-c[-1] 0,255
-to_rgba[-1]
#partie2
-repeat $SB_Iterations
-bilateral[-2] $SB_Spatial_Variance,$SB_Value_Variance
-done
-to_rgba[-2]
#partie3
-if {$Blend_Grain_Type==0}
--Je_passe_l_hiver_en_Floride[-1,-2]
-blend[-1,-2]  grainextract,$Blend_Grain_Proportion,1
-repeat $Iterations_Blend_Grain
--Je_passe_l_hiver_en_Floride[-2]
-blend[-1,-2]  grainextract,$Blend_Grain_Proportion,1
-done
-elif {$Blend_Grain_Type==1}
--Je_passe_l_hiver_en_Floride[-1,-2]
-blend[-1,-2]  grainextract,$Blend_Grain_Proportion,1
-repeat $Iterations_Blend_Grain
--Je_passe_l_hiver_en_Floride[-2]
-blend[-1,-3]  grainextract,$Blend_Grain_Proportion,1
-done
-elif {$Blend_Grain_Type==2}
--Je_passe_l_hiver_en_Floride[-1,-2]
-blend[-1,-2]  grainmerge,$Blend_Grain_Proportion,1
-repeat $Iterations_Blend_Grain
--Je_passe_l_hiver_en_Floride[-2]
-blend[-1,-2]  grainmerge,$Blend_Grain_Proportion,1
-done
-elif {$Blend_Grain_Type==3}
--Je_passe_l_hiver_en_Floride[-1,-2]
-blend[-1,-2]  grainmerge,$Blend_Grain_Proportion,1
-repeat $Iterations_Blend_Grain
--Je_passe_l_hiver_en_Floride[-2]
-blend[-1,-3]  grainmerge,$Blend_Grain_Proportion,1
-done
-endif
-if {$Interruption_Flamboyance==1}
-rm[-2,-3]
-else
-rm[-2]
#partie4
-smooth[-1] $S_Amplitude,$S_Sharpness,$S_Anisotropy,$S_Gradient_smoothness,$S_Tensor_smoothness,$S_Spatial_precision,$S_Angular_precision,$S_Value_precision,$S_Interpolation,$S_Fast_approximation
-mul[-1] $S_Color_Variation
-c[-1] 0,255
#partie5
-cartoon[-1] $C_Smoothness,$C_Sharpening,$C_Edge_threshold,$C_Edge_thickness,$C_Color_strength,$C_Color_quantization
-mul[-1] $C_Color_Variation
#partie6
-if {$Blend_Reverse==0} -reverse[-1,-2] -endif
-gimp_blend_1651[-2,-1] $Blend_Mode,2,$Blend_Opacity,0
-endif
-endl -done
samj_Flamboyance_Test_preview :
-gui_split_preview "-samj_Flamboyance_Test $*",$-1
#@gui Granular Texture : samj_Texture_Granuleuse, samj_Texture_Granuleuse_preview(0)
#@gui : note = note("<small>Texture Granuleuse / Granular Texture</small>")
#@gui : sep = separator()
#@gui : Douceur / Smoothness Gradient RGB = float(0,0.5,2)
#@gui : Maximum Seuil D\303\251grad\303\251 / Max Threshold Gradient RGB = float(20,10,50)
#@gui : sep = separator()
#@gui : Amplitude Bruit / Noise = float(80.0,40,200)
#@gui : sep = separator()
#@gui : Couleurs / Colors = float(0,-20,20)
#@gui : Balance Des Couleurs Automatique / Automatic Color Balance = bool(0)
#@gui : sep = separator()
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/31</i>.</small>")
samj_Texture_Granuleuse :
-repeat $! -l[$>]
Smoothness_Gradient_RGB=$1
Max_threshold_Gradient_RGB=$2
Amplitude_Noise=$3
Colors=$4
Automatic_color_balance=$5
--Je_passe_l_hiver_en_Floride[-1]
-fx_gradient2rgb[-1] $Smoothness_Gradient_RGB,0,$Max_threshold_Gradient_RGB,0,0
{w},{h},1,3
-fill_color[-1] 255,255,255
-to_rgb[-1]
-fx_noise[-1] $Amplitude_Noise,0,2,0
-blend[-1,-2] negation,1,1
-ancien_Tom_Keil_Colortemp[-1] $Colors,$Automatic_color_balance
-fx_local_orientation[-1] 0,0,100,0,11
-fx_normalize_local[-1] 0,6,5,20,1,2
-blend[0,-1] grainmerge,1,1
-endl -done
samj_Texture_Granuleuse_preview :
-gui_split_preview "-samj_Texture_Granuleuse $*",$-1
samj_rien_black_and_white :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Granular Texture : samj_en_Texture_Granuleuse, samj_en_Texture_Granuleuse_preview(0)
#@gui : note = note("<small>Granular Texture</small>")
#@gui : sep = separator()
#@gui : Smoothness Gradient RGB = float(0,0.5,2)
#@gui : Max Threshold Gradient RGB = float(20,10,50)
#@gui : sep = separator()
#@gui : Noise = float(80.0,40,200)
#@gui : sep = separator()
#@gui : Colors = float(0,-20,20)
#@gui : Automatic Color Balance = bool(0)
#@gui : sep = separator()
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/31</i>.</small>")
samj_en_Texture_Granuleuse :
-samj_Texture_Granuleuse $1,$2,$3,$4,$5
samj_en_Texture_Granuleuse_preview :
-gui_split_preview "-samj_en_Texture_Granuleuse $*",$-1
#@gui Plasmic : samj_Plasmic, samj_Plasmic(1)
#@gui : note = note("Plasmic filter is based on a composition of Lylejk")
#@gui : note = link("https://www.flickr.com/photos/34520999@N05/24513476052/sizes/o/","https://www.flickr.com/photos/34520999@N05/24513476052/sizes/o/")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blur</b></span>")
#@gui : Blur = float(0,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Pow = float(1.1,0.2,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Segment</b></span>")
#@gui : Edge Threshold = float(2,0,15)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Cut</b></span>")
#@gui : Cut = int(40,0,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate Contours = int(0,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Plasma</b></span>")
#@gui : Plasmic = int(0,0,20)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Degradation Deform</b></span>")
#@gui : Deform = float(0,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Degradation Spread</b></span>")
#@gui : Spread = float(0,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/02/03</i>.</small>")
samj_Plasmic :
Flou=$1
Puissance=$2
Edge_threshold=$3
Couper_Cut=$4
Dilate_Contours=$5
Valeur_Plasma=$6
Deformation=$7
Degradation_Spread=$8
Largeur_Origine={w}
Hauteur_Origine={h}
-if {$Flou>0} -blur[-1] $Flou -endif
-if {$Valeur_Plasma>0}
$Largeur_Origine,$Hauteur_Origine,1,3
-plasma[-1] $Valeur_Plasma,$Valeur_Plasma
-n[-1] 0,255
-rv[-1,-2]
-else
--Je_passe_l_hiver_en_Floride[0]
-endif
-to_rgb[-1,-2]
-pow[-1] $Puissance
-c[-1] 0,255
-fx_segment_watershed[-1] $2,1,0,2,0
-fx_gradient_norm[-1] 0,0.5,0,100,0,0
-c[-1] $Couper_Cut,255
-n[-1] 0,255
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Dilate_Contours>1} -dilate_circ[-1,-2] $Dilate_Contours -endif
-if {$Degradation_Spread>1} -spread[-1,-2] $Degradation_Spread -endif
-blend[-2,-1] darken,1,0
#@gui Plasmic V2 : samj_Plasmic_V2, samj_Plasmic_V2(0)
#@gui : note = note("samj_Plasmic_V2")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Plasma</b></span>")
#@gui : Plasmic = int(2,-20,20)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Lines</b></span>")
#@gui : Thickness = int(4,1,32)
#@gui : Accuracy = int(10,1,32)
#@gui : Coeff. Accuracy = float(2,0.1,8)
#@gui : Coeff. Blur = float(0.02,0,1)
#@gui : Isophotes = int(8,2,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Degradation Deform</b></span>")
#@gui : Deform = float(0,-200,200)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate Contours = int(0,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Degradation Spread</b></span>")
#@gui : Spread = float(0,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/29</i>.</small>")
samj_Plasmic_V2 :
Valeur_Plasma=$1
Epaisseur=$2
Precision=$3
Coeff_Precision_Pixelise=$4
Coeff_Precision_Flou=$5
Nb_Isophotes=$6
Deformation=$7
Dilate_Contours=$8
Degradation_Spread=$9
R_a=$10
V_a=$11
B_a=$12
A_a=$13
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_Boucles=0
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
-repeat $Epaisseur
-pixelize[-1] {1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)},{1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)}
-blur[-1]  {{$Precision+$Epaisseur+$Nb_Boucles}*$Coeff_Precision_Flou}
-isophotes[-1] $Nb_Isophotes
-if {$Nb_Boucles>0} -blend[-1,-2] alpha -endif
Nb_Boucles={$Nb_Boucles+1}
--Je_passe_l_hiver_en_Floride[-2]
-done
-rm[-1,-3]
-if {{abs($Valeur_Plasma)}>0}
$Largeur_Origine,$Hauteur_Origine,1,3
-plasma[-1] {abs($Valeur_Plasma)},{abs($Valeur_Plasma)}
-n[-1] 0,255
-else
--Je_passe_l_hiver_en_Floride[-1]
-endif
-rv[-1,-2]
-if {$Deformation>0} -samj_Random_Small_Deformations[-1,-2] $Deformation,5,3 -endif
-if {$Dilate_Contours>1} -dilate_circ[-1,-2] $Dilate_Contours -endif
-if {$Degradation_Spread>1} -spread[-1,-2] $Degradation_Spread -endif
-if {$Deformation<0} -samj_Random_Small_Deformations[-1,-2] {abs($Deformation)/10},5,3 -endif
-if {$Valeur_Plasma<0}
-samj_Texture_Granuleuse[-1,-2] 0.5,20,80,0,0
-endif
-reverse[-1,-2]
-blend[-2,-1] alpha
{w},{h},1,4
-fill_color[-1] $R_a,$V_a,$B_a,$A_a
-reverse[-1,-2]
-blend[-1,-2] alpha
#@gui Samj Angoisse : samj_Angoisse, samj_Angoisse(1)
#@gui : sep = separator(), note = note("<small>It\303\251rations</small>")
#@gui : It\303\251rations = int(1,1,3)
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre dog</small>")
#@gui : Sigma 1 = float(5,0,10)
#@gui : Sigma 2 = float(0,0,10)
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre segment_watershed</small>")
#@gui : Threshold = float(5,0,10)
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre smooth</small>")
#@gui : Amplitude = float(100,0,200)
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre noise</small>")
#@gui : Amplitude = float(2,0,10)
#@gui : Type = choice(4,"Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre blend</small>")
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre sharpen</small>")
#@gui : Amplitude = int(250,0,500)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.      Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_Angoisse :
iterations=$1
dog_sigma1=$2
dog_sigma2={$3/10}
sw_threshold=$4
smooth_amplitude=$5
noise_amplitude=$6
noise_type=$7
opacite=$8
sharpen_amplitude=$9
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-repeat $iterations
-dog[-1] $dog_sigma1%,$dog_sigma2%
-segment_watershed[-1] $sw_threshold,1
-smooth[-1] $smooth_amplitude,0,1,1,3
-n[-1] 0,255
-if {$noise_amplitude>0} -noise[-1] $noise_amplitude,$noise_type -endif
-to_rgb[-1]
-fx_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-done
-to_rgb[-1]
-gimp_blend_1651[-1,-2] 28,0,$opacite,0,1
-if {$sharpen_amplitude>0} -sharpen[-1] $sharpen_amplitude -endif
#@gui Samj Barbouillage Paint Daub : samj_Barbouillage_Paint_Daub, samj_Barbouillage_Paint_Daub(0)
#@gui : note = note("<span foreground="blue">Barbouillage Paint Daub</span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Gradient Norm</small></span>")
#@gui : It\303\251rations = int(2,1,3)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Smooth</small></span>")
#@gui : Amplitude = int(2,1,5)
#@gui : Sharpness = int(100,0,500)
#@gui : Anisotropy = float(0.2,0,0.5)
#@gui : Sigma = float(1,0,10)
#@gui : Dl = float(4,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Equalize</small></span>")
#@gui : Equalize = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Plasma Al\303\251atoire</small></span>")
#@gui : Plasma = choice(0,"Non","Couleurs A","Couleurs B")
#@gui : Scale Plasma = int(8,1,30)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.      Derni\303\250re mise \303\240 jour : <i>2015/04/17</i>.</small>")
samj_Barbouillage_Paint_Daub :
iterations=$1
amplitude=$2
sharpness=$3
anisotropy=$4
sigma=$5
dl=$6
egaliser=$7
Couleurs_Plasma=$8
Scale_Plasma=$9
-to_rgb[-1]
-if {$Couleurs_Plasma>0}
{w},{h},1,3
-fill_color[-1] 0,0,0
-plasma[-1] 1,1,$Scale_Plasma
-n[-1] 0,255
-if {$Couleurs_Plasma==1}
-fx_decompose_channels[-1,-2] 2,0,1,0 -remove[-2,-3,-4] -fx_decompose_channels 2,1,1,0
-elif {$Couleurs_Plasma==2}
-fx_decompose_channels[-1,-2] 2,0,1,0 -remove[-1,-5,-6] -fx_decompose_channels[-3,-2,-1] 2,1,1,0
-endif
-n[-1] 0,255
-to_rgb[-1]
-endif
--Je_passe_l_hiver_en_Floride[-1]
-repeat $iterations
-gradient_norm[-1]
-n[-1] 0,255
-equalize[-1]
-done
-engrave_modifie[-1] 4,0.5,4,0,8,40,0,25,1
-blend[-1,-2] add
-repeat $amplitude
-smooth[-1] $sharpness,$anisotropy,1,$sigma,$dl
-done
-n[-1] 0,255
-if {$egaliser==1} -equalize[-1] -endif
#@gui Samj Color EdgesO Engrave : samj_Color_EdgesO_Engrave, samj_Color_EdgesO_Engrave(0)
#@gui : note = note("samj_Color_EdgesO_Engrave")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Edges offsets</b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(50,0,100)
#@gui : Scale = int(9,0,32)
#@gui : Thickness = int(1,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Engrave</b></span>")
#@gui : Radius = float(2,0,4)
#@gui : Density = float(50,0,200)
#@gui : Edges = float(0,0,10)
#@gui : Coherence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal Area = int(0,-256,256)
#@gui : Flat Regions Removal = float(0,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Variations</b></span>")
#@gui : Areas = float(1,0.8,1.2)
#@gui : Invert Areas = bool(0)
#@gui : Segment = int(0,0,15)
#@gui : Add = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/25</i>.</small>")
samj_Color_EdgesO_Engrave :
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-pow[-2]  $12
-fx_edge_offsets[-2] $1,$2,$3,$4,0
-fx_engrave[-1,-2] $5,$6,$7,$8,$9,$10,$11,0,10,1,0,0,0,1
-blend[-1,-2] multiply,1,1
-if {$13==1} -negate[-1] -endif
-if {$14>0} -fx_segment_watershed[-2] $14,1,16,0,0 -endif
-blend[-1,-2] multiply,1,1
-if {$15==1} --Je_passe_l_hiver_en_Floride[-1] -blend[-1,-2] add,1,1 -endif
#@gui Samj Contour Epais : samj_Contour_Epais , samj_Contour_Epais (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Edges</b></span>")
#@gui : Iterations = int(1,1,5)
#@gui : Flou/Blur = float(0,0,5)
#@gui : Edges % = float(5,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Isophotes</b></span>")
#@gui : Validation = bool(1)
#@gui : Isophotes = int(5,4,7)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Amplitude = float(5,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Rendu</b></span>")
#@gui : Epaisseur = int(2,0,10)
#@gui : Type Rendu = int(1,1,6)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/20</i>.</small>")
samj_Contour_Epais  :
Iterations=$1
Flou=$2
V_Edges=$3
Valider_Isophotes=$4
V_Isophotes=$5
V_Amplitude=$6
V_Edge_Threshold=$7
V_Smoothness=$8
Epaisseur=$9
Type_Rendu=$10
Largeur={w}
Hauteur={h}
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
-repeat $Iterations
-blur[-1] $Flou
-edges[-1] $V_Edges%
-n[-1] 0,255
-if {$Valider_Isophotes==0}
-to_rgba[-1]
-replace_color[-1] 100%,0,255,255,255,255,0,0,0,0
-endif
-done
-if {$Valider_Isophotes==0}
-to_rgba[-1]
-c[-1] 0,{$Epaisseur+1}
Epaisseur={abs({$Epaisseur-2})}
-else
-isophotes $V_Isophotes
-endif
-n[-1] 0,255
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-shift[-1] 0,1,0,0,0
-shift[-2] 1,0,0,0,0
-shift[-3] 1,1,0,0,0
-crop[-1,-2,-3] 0,0,{$Largeur-1},{$Hauteur-1}
-blend[-1,-2,-3,-4] alpha
-blur[-1] 1
-sharpen[-1] 10
-if {$Valider_Isophotes==0}
-reverse[-1,-2]
-blend[-1,-2] edges
-pixelize[-1] {$Largeur/4},{$Hauteur/4}
-else
-blend[-1,-2] edges
-endif
-repeat $Epaisseur
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-if {$Type_Rendu==1}
-shift[-1] 0,1,0,0,0
-shift[-2] 1,0,0,0,0
-shift[-3] 1,1,0,0,0
-elif {$Type_Rendu==2}
-shift[-1] 0,1,0,0,0
-shift[-2] 1,1,0,0,0
-shift[-3] 1,0,0,0,0
-elif {$Type_Rendu==3}
-shift[-1] 1,0,0,0,0
-shift[-2] 0,1,0,0,0
-shift[-3] 1,1,0,0,0
-elif {$Type_Rendu==4}
-shift[-1] 1,0,0,0,0
-shift[-2] 1,1,0,0,0
-shift[-3] 0,1,0,0,0
-elif {$Type_Rendu==5}
-shift[-1] 1,1,0,0,0
-shift[-2] 1,0,0,0,0
-shift[-3] 0,1,0,0,0
-elif {$Type_Rendu==6}
-shift[-1] 1,1,0,0,0
-shift[-2] 0,1,0,0,0
-shift[-3] 1,0,0,0,0
-endif
-crop[-1,-2,-3] 0,0,{$Largeur-1},{$Hauteur-1}
-blend[-1,-2,-3,-4] alpha
-done
-fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness
#@gui Samj Couleurs Rayees : samj_Couleurs_Rayees , samj_Couleurs_Rayees (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Lumin = bool(0)
#@gui : Pixelisation = int(30,8,100)
#@gui : Flou = float(0,0,10)
#@gui : PA = int(100,1,255)
#@gui : DeformA = int(4,-16,16)
#@gui : DeformB = int(4,-16,16)
#@gui : Couleur = int(0,0,255)
#@gui : It\303\251rations = int(2,1,4)
#@gui : Puissance = float(0.7,0.1,2)
#@gui : Equalize = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/30</i>.</small>")
samj_Couleurs_Rayees :
Lumin=$1
Pixelisation=$2
Flou=$3
PA=$4
DeformA=$5
DeformB=$6
Couleur=$7
Iterations=$8
Puissance=$9
Egaliser=$10
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
-if {$Lumin==1}
-luminance[-1]
-n[-1] 0,255
-equalize[-1]
-endif
-to_rgb[-1]
-ditheredbw[-1]
-pixelize[-1] $Pixelisation
-blur[-1] $Flou
-ditheredbw[-1]
-to_rgba[-1]
-replace_color[-1] 100%,0,255,255,255,255,0,0,0,0
-replace_color[-1] 100%,0,0,0,0,255,$Couleur,$Couleur,$Couleur,255
-blend[-1,-2] alpha
-repeat $Iterations
-smooth[-1] $PA,0.2,1,$DeformA,$DeformB
-done
-pow[-1] $Puissance
-n[-1] 0,255
-if {$Egaliser==1} -equalize[-1] -endif
#@gui Samj Couleurs Rayees 2 : samj_Couleurs_Rayees_2 , samj_Couleurs_Rayees_2 (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Lumin = bool(0)
#@gui : Pixelisation = int(30,8,100)
#@gui : Flou = float(0,0,10)
#@gui : PA = int(100,1,255)
#@gui : DeformA = int(4,-16,16)
#@gui : DeformB = int(4,-16,16)
#@gui : Limite = int(255,1,255)
#@gui : It\303\251rations = int(1,1,4)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/07</i>.</small>")
samj_Couleurs_Rayees_2 :
--Je_passe_l_hiver_en_Floride[-1]
-samj_Gris_Raye[-1] $1,$2,$3,$4,$5,$6,$7,$8
-blend[-1,-2] luminance
#@gui Samj Diff Tensors Blend : samj_Diff_Tensors_Blend, samj_Diff_Tensors_Blend(1)
#@gui : note = note("samj_Diff_Tensors_Blend")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Diffusion Tensors</b></span>")
#@gui : Resolution (%) = float(10,1,20)
#@gui : Size = float(5,0,16)
#@gui : Outline = int(1,0,16)
#@gui : Sharpness = float(0.15,0,1)
#@gui : Anisotropy = float(1,0,1)
#@gui : Gradient Smoothness = float(0,0,10)
#@gui : Tensor Smoothness = float(3,0,10)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Flou-Blur</b></span>")
#@gui : Flou/Blur = int(0,0,50)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/10/30</i>.</small>")
samj_Diff_Tensors_Blend :
DT_Resolution=$1
DT_Size=$2
DT_Colormode=1
DT_Outline=$3
DT_Sharpness=$4
DT_Anisotropy=$5
DT_Gradientsmoothness=$6
DT_Tensorsmoothness=$7
Iterations=$8
Flou=$9
Mode_blend=$10
Opacity_blend=$11
--Je_passe_l_hiver_en_Floride[-1]
-to_rgba[-1,-2]
-repeat $Iterations
-fx_diffusiontensors[-1] $DT_Resolution,$DT_Size,$DT_Colormode,$DT_Outline,$DT_Sharpness,$DT_Anisotropy,$DT_Gradientsmoothness,$DT_Tensorsmoothness
-done
-blur[-2] $Flou
-gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0
#@gui Samj Fond Broderie : samj_fond_broderie, samj_fond_broderie(1)
#@gui : note = note("samj_fond_broderie")
#@gui : note = note("<span foreground="orangered"><small>topographic_map</small></span>")
#@gui : Levels = int(8,1,32)
#@gui : Smoothness = float(2,0,5)
#@gui : note = note("<span foreground="orangered"><small>gimp_skeleton</small></span>")
#@gui : Curviness = float(0,0,2)
#@gui : note = note("<span foreground="orangered"><small>fx_LCE</small></span>")
#@gui : Activer Fx LCE = bool(1)
#@gui : note = note("<span foreground="orangered"><small>gimp_frame_blur</small></span>")
#@gui : Activer Gimp Frame Blur = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_fond_broderie :
Levels_topographic_map=$1
Smoothness_topographic_map=$2
Curviness_gimp_skeleton=$3
Activer_fx_LCE=$4
Activer_gimp_frame_blur=$5
-topographic_map[0] $Levels_topographic_map,$Smoothness_topographic_map
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-fx_local_orientation[-1] 0,0,100,0,0,0
-fx_color_abstraction[-1] 2,10,0.5,0
-fx_skeleton[-1] 0,$3,0,0,0
-fx_skeleton[-2] 0,$3,0,0,0
-blend[-2,-1] add,1,0
-blend[-2,-1] and,1,0
-if {$Activer_fx_LCE==1}
-fx_LCE[-1] 80,0.5,1,1,3,0
-endif
-if {$Activer_gimp_frame_blur==1}
-fx_frame_blur[-1] 30,30,0,5,0,0,128,128,128,0,5,255,255,255,2,2,1,0,0.5,0.5,0
-endif
#@gui Samj Fond Brosse : samj_Fond_Brosse, samj_Fond_Brosse(1)
#@gui : note = note("samj_Fond_Brosse")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Brosse</b></span>")
#@gui : Brosse = int(3,2,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Couleur</b></span>")
#@gui : Couleur = float(1,0.8,1.2)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/27</i>.</small>")
samj_Fond_Brosse :
Brosse=$1
Couleur=$2
-repeat $Brosse
-fx_local_orientation[-1] 0,0,100,0,25,0
-pow[-1]  $Couleur
-done
-fx_smooth_anisotropic[-1] 60,0.7,0.3,4,10,2,180,2,1,1,1,2,0
-fx_normalize_local[-1] 2,6,5,20,1,11,0
#@gui Samj Fx Sketchbw Modifie : samj_fx_sketchbw_modifie, samj_fx_sketchbw_modifie_preview(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Sketch</small></span>")
#@gui : Number of Orientations = int(3,1,16)
#@gui : Starting Angle = float(45,0,180)
#@gui : Angle Range = float(180,0,180)
#@gui : Stroke Length = float(30,0,1000)
#@gui : Contour Threshold = float(1.75,0,10)
#@gui : Opacity = float(0.02,0,0.3)
#@gui : Background Intensity = float(0.5,0,2)
#@gui : Density = float(0.75,0,5)
#@gui : Sharpness = float(0.1,0,1)
#@gui : Anisotropy = float(0.7,0,1)
#@gui : Smoothness = float(3,0,10)
#@gui : Coherence = float(6,0,10)
#@gui : Boost Stroke = bool(0)
#@gui : Curved Stroke = bool(1)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : Forme Aleatoire = bool(0)
#@gui : Forme = int(1234,1,111111)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Smooth</small></span>")
#@gui : Smooth = bool(0)
#@gui : Amplitude = int(2,1,5)
#@gui : Sharpness = int(100,0,500)
#@gui : Anisotropy = float(0.2,0,0.5)
#@gui : Sigma = float(1,0,10)
#@gui : Dl = float(4,0,10)
#@gui : Equalize = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233; / <span color="#FF6060">&#x2764;&#x2764;</span></a> modifications : samj</i>.      Latest update: <i>2018/05/15</i>.</small>")
samj_fx_sketchbw_modifie :
samj_fonction_fx_sketchbw_modifie $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
-if $18
-repeat $19
-smooth $20,$21,1,$22,$23
-done
-n 0,255
-if {$24==1} -equalize -endif
-endif
samj_fx_sketchbw_modifie_preview :
gui_split_preview "samj_fx_sketchbw_modifie $*",$-1
samj_fonction_fx_sketchbw_modifie :
-if {$16==0} srand $17 -endif
if {$15==4} repeat $! l[$>] +sketchbw ${1-14} blend hardlight endl done return fi
sketchbw ${1-14}
if {$15&1} negate fi
if {$15==2} r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
elif {$15==3} r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
fi
#@gui Samj Gris Raye : samj_Gris_Raye , samj_Gris_Raye (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Lumin = bool(0)
#@gui : Pixelisation = int(30,8,100)
#@gui : Flou = float(0,0,10)
#@gui : PA = int(100,1,255)
#@gui : DeformA = int(4,-16,16)
#@gui : DeformB = int(4,-16,16)
#@gui : Limite = int(255,1,255)
#@gui : It\303\251rations = int(1,1,4)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/29</i>.</small>")
samj_Gris_Raye :
Lumin=$1
Pixelisation=$2
Flou=$3
PA=$4
DeformA=$5
DeformB=$6
Limite=$7
Iterations=$8
-if {$Lumin==1}
-luminance[-1]
-n[-1] 0,255
-equalize[-1]
-endif
-to_rgb[-1]
-ditheredbw[-1]
-pixelize[-1] $Pixelisation
-blur[-1] $Flou
-ditheredbw[-1]
-repeat $Iterations
-smooth[-1] $PA,0.2,1,$DeformA,$DeformB
-done
-n[-1] 0,255
-c[-1] 0,$Limite
-n[-1] 0,255
-c[-1] {255-$Limite},255
-n[-1] 0,255
#@gui Samj Impressions : samj_Impressions, samj_Impressions(1)
#@gui : note = note("<span foreground="orangered"><small>Spread</small></span>")
#@gui : Spread = float(10,0,50)
#@gui : note = note("<span foreground="orangered"><small>Textured Glass</small></span>")
#@gui : X-Amplitude = float(5,0,400)
#@gui : Y-Amplitude = float(5,0,400)
#@gui : X-Smoothness = float(1,0,5)
#@gui : Y-Smoothness = float(1,0,5)
#@gui : Edge Attenuation = float(0,0,1)
#@gui : Edge Influence = float(2,0,10)
#@gui : Noise Scale = int(0,0,16)
#@gui : note = note("<span foreground="orangered"><small>Abstraction</small></span>")
#@gui : It\303\251rations = int(1,1,3)
#@gui : note = note("<span foreground="orangered"><small>Abstraction Dog</small></span>")
#@gui : Sigma 1 = float(5,0,10)
#@gui : Sigma 2 = float(0,0,10)
#@gui : note = note("<span foreground="orangered"><small>Abstraction Segment Watershed</small></span>")
#@gui : Threshold = float(5,0,10)
#@gui : note = note("<span foreground="orangered"><small>Abstraction Smooth</small></span>")
#@gui : Amplitude = float(100,0,200)
#@gui : note = note("<span foreground="orangered"><small>Abstraction Noise</small></span>")
#@gui : Amplitude = float(2,0,10)
#@gui : Type = choice(4,"Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : note = note("<span foreground="orangered"><small>Sharpen</small></span>")
#@gui : Amplitude = int(250,0,500)
#@gui : note = note("<span foreground="orangered"><small>Couleurs</small></span>")
#@gui : Couleurs = float(1.2,0.1,5)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.      Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_Impressions :
Spread_fond=$1
X_amplitude=$2
Y_amplitude=$3
X_smoothness=$4
Y_smoothness=$5
Edge_attenuation=$6
Edge_influence=$7
Noise_scale=$8
iterations=$9
dog_sigma1=$10
dog_sigma2={$11/10}
sw_threshold=$12
smooth_amplitude=$13
noise_amplitude=$14
noise_type=$15
opacite=$16
sharpen_amplitude=$17
Couleurs=$18
-spread[-1] $Spread_fond
-fx_textured_glass[-1] $X_amplitude,$Y_amplitude,$X_smoothness,$Y_smoothness,$Edge_attenuation,$Edge_influence,$Noise_scale
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-repeat $iterations
-dog[-1] $dog_sigma1%,$dog_sigma2%
-segment_watershed[-1] $sw_threshold,1
-smooth[-1] $smooth_amplitude,0,1,1,3
-n[-1] 0,255
-if {$noise_amplitude>0} -noise[-1] $noise_amplitude,$noise_type -endif
-to_rgb[-1]
-fx_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-done
-to_rgb[-1]
-gimp_blend_1651[-1,-2] 28,0,$opacite,0,1
-if {$sharpen_amplitude>0} -sharpen[-1] $sharpen_amplitude -endif
-fx_custom_transform[-1] "i",i*$Couleurs,"i","i","i","i",0
#@gui Samj Isophotes Vers Aquarelle : samj_Isophotes_Vers_Aquarelle , samj_Isophotes_Vers_Aquarelle (1)
#@gui : note = note("<span foreground="orangered"><b><u>Isophotes</u></b></span>")
#@gui : Nb Decomposition Couleurs = int(16,2,32)
#@gui : Variation Flou = Float(0.5,0.1,2)
#@gui : Isophotes = int(4,3,16)
#@gui : Dilate = int(0,0,8)
#@gui : note = note("<span foreground="orangered"><b><u>Segmentation</u></b></span>")
#@gui : Segmentation = bool(1)
#@gui : Edge Threshold = float(10,0,30)
#@gui : Smoothness = float(1,0,5)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : note = note("<span foreground="orangered"><b><u>Contours</u></b></span>")
#@gui : Flou = Float(0,0,2)
#@gui : Couleurs = Float(0,-2,2)
#@gui : note = note("<span foreground="orangered"><b><u>Fond</u></b></span>")
#@gui : Fond = bool(1)
#@gui : Amplitude Noise = float(10,5,200)
#@gui : Density Hardsketchbw = float(10,5,100)
#@gui : Spread Variations = float(4,3,20)
#@gui : Amplitude Water = float(3,2,10)
#@gui : Couleur / Color = color(251,237,206)
#@gui : Opacit\303\251 / Opacity = float(1,-1,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2017/01/20</i>.</small>")
samj_Isophotes_Vers_Aquarelle :
Nb_Decomposition_Couleurs=$1
Variation_Flou=$2
Nb_Isophotes=$3
Dilatation=$4
Segmentation=$5
S_E=$6
S_S=$7
S_C=$8
S_V=$9
Flou=$10
Couleurs=$11
Fond=$12
F_A_N=$13
F_D_H=$14
F_S_V=$15
F_A_W=$16
F_R=$17
F_V=$18
F_B=$19
F_O=$20
Nb_Boucles=0
-n[-1] 0,255
--Je_passe_l_hiver_en_Floride[-1]
-repeat $Nb_Decomposition_Couleurs
-if {$Nb_Boucles>0}
-blur[-1] {$Nb_Boucles*$Variation_Flou}
-equalize[-1] {$Nb_Boucles+4},0,100
-endif
-isophotes[-1] $Nb_Isophotes
-if {$Nb_Boucles>0}
-if {$Dilatation>0} -dilate_circ[-1] {$Dilatation+1} -endif
-blend[-1,-2] alpha
-endif
Nb_Boucles={$Nb_Boucles+1}
--Je_passe_l_hiver_en_Floride[-2]
-done
-rm[-1,-3]
-if {$Segmentation>0} -fx_segment_watershed[-1] $S_E,$S_S,$S_C,$S_V -endif
-if {$Flou>0} -blur[-1] $Flou -endif
-if {$Couleurs>0}
-mul[-1] $Couleurs
-elif {$Couleurs<0}
-pow[-1] {abs($Couleurs)}
-endif
-if {$Fond==1}
{w},{h},1,3
-samj_Texture_Aquarelle_1[-1] $F_A_N,$F_D_H,$F_S_V,$F_A_W,$F_R,$F_V,$F_B,$F_O
-reverse[-1,-2]
-blend[-1,-2] alpha
-endif
#@gui Samj Pointillisme : samj_Pointillisme , samj_Pointillisme (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Points</b></span>")
#@gui : Intensite = int(10,1,100)
#@gui : Densite = float(2,0,100)
#@gui : Dimension = int(5,2,20)
#@gui : Rond Vs Carre = bool(1)
#@gui : Variation = float(1,0.2,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Arriere plan</b></span>")
#@gui : Fond Transparent = bool(1)
#@gui : Couleur = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/08</i>.</small>")
samj_Pointillisme :
Intensite=$1
Densite=$2
Dimension=$3
Rond=$4
Variation=$5
Fond_Transparent=$6
R_a=$7
V_a=$8
B_a=$9
A_a=$10
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
-mul[-1] $Variation
-sharpen[-1] {2000*$Intensite}
-noise[-1] {1+$Densite}
-warp[-2] [-1],1,0,0
-rm[-1]
-if {$Rond==1}
-dilate_circ[-1] $Dimension
-else
-dilate[-1] $Dimension
-endif
-if {$Fond_Transparent==0}
{w},{h},1,4
-fill_color[-1] $R_a,$V_a,$B_a,$A_a
-reverse[-1,-2]
-blend[-1,-2] alpha
-endif
#@gui Samj Pointillisme B : samj_Pointillisme_B , samj_Pointillisme_B (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Couleurs</b></span>")
#@gui : Variation = float(1,0.2,2)
#@gui : Dilatation = int(0,0,16)
#@gui : Pixels = float(90,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Points</b></span>")
#@gui : Dimension = int(3,0,20)
#@gui : Rond Vs Carre = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Arriere plan</b></span>")
#@gui : Fond Transparent = bool(1)
#@gui : Couleur = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2017/01/27</i>.</small>")
samj_Pointillisme_B :
Variation=$1
Dilatation=$2
Pixels=$3
Dimension=$4
Rond=$5
Fond_Transparent=$6
R_a=$7
V_a=$8
B_a=$9
A_a=$10
-mul[-1] $Variation
-if {$Dilatation>0} -dilate[-1] {$Dilatation+1} -endif
-remove_pixels[-1] 90%
-to_rgba[-1]
-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
-if {$Dimension>0}
-if {$Rond==1}
-dilate_circ[-1] {$Dimension+1}
-else
-dilate[-1] {$Dimension+1}
-endif
-endif
-if {$Fond_Transparent==0}
{w},{h},1,4
-fill_color[-1] $R_a,$V_a,$B_a,$A_a
-reverse[-1,-2]
-blend[-1,-2] alpha
-endif
#@gui Samj TensorTest : samj_TensorTest, samj_TensorTest(1)
#@gui : note = note("Tensor Test")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>diffusiontensors</b></span>")
#@gui : Sharpness = float(0.3,0,1)
#@gui : Anisotropy = float(0.9,0,1)
#@gui : Alpha = float(0.6,0,100)
#@gui : Sigma = float(1.1,0,100)
#@gui : Is Sqrt = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>ABS</b></span>")
#@gui : Abs = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>resize2dx</b></span>")
#@gui : SizeX = int(20,8,64)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>display tensors</b></span>")
#@gui : Size Factor = int(32,16,128)
#@gui : Ellipse Size = float(20,0,100)
#@gui : Color Mode = choice{2,"Monochrome","Grayscale","Color"}
#@gui : Outline = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Couleur</b></span>")
#@gui : Couleur = float(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Resize</b></span>")
#@gui : Resize = choice{2,"Non RVBA","Oui RVB","Oui RVBA"}
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/01</i>.</small>")
samj_TensorTest :
DT_Sharpness=$1
DT_Anisotropy=$2
DT_Alpha=$3
DT_Sigma=$4
DT_Is_Sqrt=$5
Absolu=$6
SizeX=$7
Size_Factor=$8
Ellipse_Size=$9
Color_Mode=$10
Outline=$11
Couleur=$12
Type_Resize=$13
Largeur_Origine={w}
Hauteur_Origine={h}
-to_rgb[-1]
-diffusiontensors[-1] $DT_Sharpness,$DT_Anisotropy,$DT_Alpha,$DT_Sigma,$DT_Is_Sqrt
-if {$Absolu==1}
-abs
-endif
-resize2dx[-1] $SizeX
-display_tensors[-1] $Size_Factor,{$Ellipse_Size/10},$Color_Mode,$Outline
-if {$Couleur>0}
-pow[-1] $Couleur
-endif
-n[-1] 0,255
-if {$Type_Resize==0}
-to_rgba[-1]
-elif {$Type_Resize==1}
-to_rgb[-1]
-resize[-1] $Largeur_Origine,$Hauteur_Origine,5,3,3
-elif {$Type_Resize==2}
-to_rgba[-1]
-resize[-1] $Largeur_Origine,$Hauteur_Origine,5,4,3
-endif
#@gui Samj Texture Coloree : samj_texture_coloree, samj_texture_coloree(1)
#@gui : note = note("samj_texture_coloree")
#@gui : note = note("<span foreground="orangered"><small>diffusiontensors</small></span>")
#@gui : Type = choice{"A","B","C","D","E","F"}
#@gui : Sharpness = float(0.7,0.2,2)
#@gui : note = note("<span foreground="orangered"><small>Color</small></span>")
#@gui : Fond / Background Color = color(200,125,50)
#@gui : note = note("<span foreground="orangered"><small>Blur Linear</small></span>")
#@gui : Amplitude A = float(5,0,10)
#@gui : Amplitude B = float(5,0,100)
#@gui : Angle = float(45,0,360)
#@gui : note = note("<span foreground="orangered"><small>Sharpen</small></span>")
#@gui : Amplitude S = int(200,50,1000)
#@gui : note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : It\303\251rations = int(4,1,8)
#@gui : Opacit\303\251 / Opacity = float(0.2,0,0.3)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/04/05</i>.</small>")
samj_texture_coloree :
Type=$1
sharpness=$2
rf=$3
vf=$4
bf=$5
AmplitudeA=$6
AmplitudeB=$7
Angle=$8
AmplitudeS=$9
Iterations_Blend=$10
Opacite_Blend=$11
-if {$Type==0}
anisotropy=0
alpha=0
sigma=0
is_sqrt=1
-elif {$Type==1}
anisotropy=0
alpha=4
sigma=0
is_sqrt=1
-elif {$Type==2}
sharpness=0.5
anisotropy=0.3
alpha=4
sigma=2
is_sqrt=1
-elif {$Type==3}
anisotropy=0
alpha=0
sigma=0
is_sqrt=0
-elif {$Type==4}
anisotropy=0
alpha=4
sigma=0
is_sqrt=0
-elif {$Type==5}
sharpness=0.5
anisotropy=0.3
alpha=4
sigma=2
is_sqrt=0
-endif
-diffusiontensors[-1] $sharpness,$anisotropy,$alpha,$sigma,$is_sqrt
-n[-1] 0,255
-equalize[-1]
-fx_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-to_rgb[-1]
-fx_8bits[-1] 100,10000,256
{w},{h},1,3
-fill_color[-1] $rf,$vf,$bf
-blend[-1,-2] add
-to_rgb[-1]
-repeat $Iterations_Blend
--Je_passe_l_hiver_en_Floride[-1]
-done
-blur_linear[-1] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},$Angle,1
-sharpen[-1] $AmplitudeS
-to_rgb[-1]
-repeat $Iterations_Blend
-fx_blend_edges[-1,-2] $Opacite_Blend,5,0
-done
#@gui Skeletik : samj_Test_Skeletik, samj_Test_Skeletik(0)
#@gui : note = note("samj_Test_Skeletik")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Lines - Cobweb</b></span>")
#@gui : Iterations = int(10,1,50)
#@gui : Skeleton = int(1,1,20)
#@gui : Deform = float(0,0,200)
#@gui : Dilate = int(0,0,16)
#@gui : Spread = float(0,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape area max","Shape area max0","Shape area min","Shape area min0","Shape average","Shape average0","Shape min","Shape min0","Shape max","Shape max0",
#@gui : "Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value","Vivid light","Xor"}
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Colors</b></span>")
#@gui : Lines = float(1,0.75,1.25)
#@gui : Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/29</i>.</small>")
samj_Test_Skeletik:
Iterations=$1
Val_Skeleton=$2
Deformation=$3
Dilate_Contours=$4
Degradation_Spread=$5
mode=${-arg\ 1+$6,add,alpha,and,average,blue,burn,darken,difference,\
divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
shapeaverage,shapeaverage0,shapemin,shapemin0,shapemax,shapemax0,\
softburn,softdodge,softlight,screen,stamp,subtract,value,\
vividlight,xor}
Couleur=$7
R_a=$8
V_a=$9
B_a=$10
A_a=$11
Nb_Boucles=0
--Je_passe_l_hiver_en_Floride[-1]
-if {$Deformation>0} -samj_Random_Small_Deformations[-1] $Deformation,5,3 -endif
-to_rgb[-1]
-repeat $Iterations
-skeleton[-1] {$Val_Skeleton+$Nb_Boucles}
-n[-1] 0,255
-to_rgba[-1]
-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
-if {$Nb_Boucles>0} -blend[-1,-2] alpha -endif
Nb_Boucles={$Nb_Boucles+1}
--Je_passe_l_hiver_en_Floride[-2]
-done
-rm[-1]
-if {$Degradation_Spread>1} -spread[-1] $Degradation_Spread -endif
-if {$Dilate_Contours>1} -dilate_circ[-1] $Dilate_Contours -endif
-to_graya[-1]
-reverse[-1,-2]
-blend[-1,-2] $mode
-mul[-1] $Couleur
{w},{h},1,4
-fill_color[-1] $R_a,$V_a,$B_a,$A_a
-reverse[-1,-2]
-blend[-1,-2] alpha
#@gui Variations on a Single Color : samj_texture_coloree_en, samj_texture_coloree_en(1)
#@gui : note = note("Variations On A Single Color")
#@gui : note = note("<span foreground="orangered"><small>Diffusion Tensors</small></span>")
#@gui : Type = choice{"A","B","C","D","E","F"}
#@gui : Sharpness = float(0.7,0.2,1)
#@gui : note = note("<span foreground="orangered"><small>Color</small></span>")
#@gui : Single Color = color(200,125,50)
#@gui : note = note("<span foreground="orangered"><small>Blur Linear</small></span>")
#@gui : Amplitude A = float(5,0,10)
#@gui : Amplitude B = float(5,0,100)
#@gui : Angle = float(45,0,360)
#@gui : note = note("<span foreground="orangered"><small>Sharpen</small></span>")
#@gui : Amplitude S = int(200,50,1000)
#@gui : note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Iterations = int(4,1,8)
#@gui : Opacity = float(0.2,0,0.3)
#@gui : note = note("<span foreground="orangered"><small>Richardson Lucy</small></span>")
#@gui : Sigma = float(1,0.5,10)
#@gui : Iterations = int(10,0,100)
#@gui : Blur = choice(1,"Exponential","Gaussian")
#@gui : Cut = bool(true)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/04/13</i>.</small>")
samj_texture_coloree_en :
-samj_texture_coloree $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11
-if {$13>0}
-deblur_richardsonlucy[-1] $12,$13,$14
-if $15 -c[-1] 0,255 -else -n[-1] 0,255 -endif
-endif
#@gui _
#@gui <i>Black &amp; White</i>
#@gui Engrave Colore : Engrave_colore, Engrave_colore(1)
#@gui : note = note("<small>Modification du Filtre de Lyle Kroll et David Tschumperl&#233;</small>")
#@gui : note = note("<small>pour obtenir des gravures color&#233;es - samj 20150321</small>")
#@gui : sep = separator()
#@gui : Exemples / Examples = choice(0,"Non / None","A","B","C","D ***","E","F","G")
#@gui : note = note("<small><b>Gravure / Engraving</b></small>")
#@gui : Radius = float(0.5,0,2)
#@gui : Densite A = float(4,0,10)
#@gui : Edges = float(0,0,10)
#@gui : Coherence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal Area = int(0,-256,256)
#@gui : Repetition = int(25,0,50)
#@gui : note = note("<small><b>Anti-aliasing</b></small>")
#@gui : Anti-Aliasing = choice(1,"Disabled","A","B","C")
#@gui : note = note("<small><b>Couleurs / Colors</b></small>")
#@gui : Gravure / Engraving = choice(2,"Avant Plan","Image Avec Contours Des Couleurs 8","Image Avec Contours Des Couleurs 16","Image Avec Contours Des Couleurs 32","Image Avec Contours Des Couleurs 64","Image Sans Contours Des Couleurs 8","Image Sans Contours Des Couleurs 16","Image Sans Contours Des Couleurs 32","Image Sans Contours Des Couleurs 64","3 calques - Image Sans Contours Des Couleurs 8","3 calques - Image Sans Contours Des Couleurs 16","3 calques - Image Sans Contours Des Couleurs 32","3 calques - Image Sans Contours Des Couleurs 64")
#@gui : Avant Plan = color(0,0,0)
#@gui : Fond / Background Color = color(255,255,255)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i>David Tschumperl&#233; </i>.      Latest update: <i>2015/03/23</i>.</small>")
Engrave_colore :
Examples=$1
Radius=$2
Densite_A=$3
Edges=$4
Coherence=$5
Threshold=$6
Minimal_Area=$7
Repetition=$8
Anti_Aliasing=$9
Choix_Couleur=$10
R_C1=$11
V_C1=$12
B_C1=$13
R_C2=$14
V_C2=$15
B_C2=$16
-if {$Examples==1}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==2}
Radius={0.275+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==3}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={7-{$Coherence/20}}
Threshold={48+{$Threshold/20}}
Minimal_Area=-100
Repetition={20-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==4}
Radius={0.175+{$Radius/20}}
Densite_A={12-{$Densite_A/2}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={30-{$Repetition/10}}
Anti_Aliasing=3
-elif {$Examples==5}
Radius={1.975+{$Radius/20}}
Densite_A={1.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={2-{$Coherence/20}}
Threshold={18+{$Threshold/20}}
Minimal_Area=-100
Repetition={55-{$Repetition/10}}
Anti_Aliasing=2
-elif {$Examples==6}
Radius={0.975+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={28+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==7}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={-5+{$Repetition/10}}
Anti_Aliasing=1
-endif
f={arg(1+$Anti_Aliasing,1,1.5,2,3)}
r={$f*$Radius}
nm=${-gui_layer_name}
pos=${-gui_layer_pos}
C1_blanc=0
Blend_final=0
-to_rgb[-1]
-if {$Choix_Couleur==0}
Blend_final=0
-elif {$Choix_Couleur==1}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 8,2
Blend_final=1
-elif {$Choix_Couleur==2}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 16,2
Blend_final=1
-elif {$Choix_Couleur==3}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 32,2
Blend_final=1
-elif {$Choix_Couleur==4}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 64,2
Blend_final=1
-elif {$Choix_Couleur==5}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 8,2
-dilate_circ[-2] 2
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==6}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 16,2
-dilate_circ[-2] 4
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==7}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 32,2
-dilate_circ[-2] 8
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==8}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 64,2
-dilate_circ[-2] 16
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==9}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 8,2
-dilate_circ[-2] 2
-blur[-2] 2
Blend_final=2
-elif {$Choix_Couleur==10}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 16,2
-dilate_circ[-2] 4
-blur[-2] 2
Blend_final=2
-elif {$Choix_Couleur==11}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 32,2
-dilate_circ[-2] 8
-blur[-2] 2
Blend_final=2
-elif {$Choix_Couleur==12}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 64,2
-dilate_circ[-2] 16
-blur[-2] 2
Blend_final=2
-endif
-if {{$R_C1+$V_C1+$B_C1}==765}
C1_blanc=1
B_C1=254
-endif
-l[-1]
-split_opacity[-1]
-l[-1]
wh={w},{h}
-norm[-1]
-if $Anti_Aliasing
-r[-1] {100*$f}%,{100*$f}%,1,1,3
-endif
-l[-1]
-repeat $Repetition
-b[-1] $r
-unsharp[-1] $r,{$Densite_A}
-c[-1] 0,255
-done
-smooth[-1] 100,0.1,1,{$f*$Edges},{$f*$Coherence}
->=[-1] {100-$Threshold}%
-endl
-if {$Minimal_Area<0}
-area_fg[-1] 0,0
-gt[-1] {$f*$Minimal_Area*$Minimal_Area}
-elif {$Minimal_Area>0}
-==[-1] 0
-area_fg[-1] 0,0
-gt[-1] {$f*$Minimal_Area*$Minimal_Area}
-==[-1] 0
-endif
-n[-1] 0,255
-to_rgb[-1]
-if {$Blend_final==0}
-replace_color[-1] 0,0,0,0,0,$R_C1,$V_C1,$B_C1
-replace_color[-1] 0,0,255,255,255,$R_C2,$V_C2,$B_C2
-if {$C1_blanc==1}
-replace_color[-1] 0,0,255,255,254,255,255,255
-endif
-endif
-if $Anti_Aliasing
-r[-1] $wh,1,3,2
-else
-r[-1] $wh
-endif
-endl
-a[-1] c
-endl
-if {$Blend_final==1}
-blend[-1,-2] add
-replace_color[-1] 0,0,255,255,255,$R_C2,$V_C2,$B_C2
-elif {$Blend_final==2}
$wh,1,3
-to_rgb[-1]
-replace_color[-1] 0,0,0,0,0,$R_C2,$V_C2,$B_C2
-nm[-3] mode(add),name($nm" [couleurs]"),pos($pos)
-nm[-2] name($nm" [gravure]"),pos($pos)
-endif
#@gui Engrave Modifie : engrave_modifie, engrave_modifie(1)
#@gui : note = note("<small>Aussi pour obtenir des contours</small>")
#@gui : Exemples / Examples = choice(0,"Non / None","A","B","C","D ***","E","F","G")
#@gui : note = note("<small><b>Black &amp; White foreground:</b></small>")
#@gui : Radius = float(0.5,0,2)
#@gui : Densite A = float(4,0,10)
#@gui : Edges = float(0,0,10)
#@gui : Coherence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal Area = int(0,-256,256)
#@gui : R E P E T I T I O N = int(25,0,50)
#@gui : sep = separator()
#@gui : Anti-Aliasing = choice(1,"Disabled","x1.5","x2","x3")
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>samj 2015/03/20</i>.</small>")
engrave_modifie :
Examples=$1
Radius=$2
Densite_A=$3
Edges=$4
Coherence=$5
Threshold=$6
Minimal_Area=$7
Repetition=$8
Anti_Aliasing=$9
-if {$Examples==1}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==2}
Radius={0.275+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==3}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={7-{$Coherence/20}}
Threshold={48+{$Threshold/20}}
Minimal_Area=-100
Repetition={20-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==4}
Radius={0.175+{$Radius/20}}
Densite_A={12-{$Densite_A/2}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={30-{$Repetition/10}}
Anti_Aliasing=3
-elif {$Examples==5}
Radius={1.975+{$Radius/20}}
Densite_A={1.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={2-{$Coherence/20}}
Threshold={18+{$Threshold/20}}
Minimal_Area=-100
Repetition={55-{$Repetition/10}}
Anti_Aliasing=2
-elif {$Examples==6}
Radius={0.975+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={28+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==7}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={-5+{$Repetition/10}}
Anti_Aliasing=1
-endif
f={arg(1+$Anti_Aliasing,1,1.5,2,3)}
r={$f*$Radius}
nm=${-gui_layer_name}
pos=${-gui_layer_pos}
-l[0]
-split_opacity
-l[0]
wh={w},{h}
-norm
-if $Anti_Aliasing
-r {100*$f}%,{100*$f}%,1,1,3
-endif
-l[0]
-repeat $Repetition
-b $r
-unsharp $r,{$Densite_A}
-c 0,255
-done
-smooth 100,0.1,1,{$f*$Edges},{$f*$Coherence}
->= {100-$Threshold}%
-endl
-if {$Minimal_Area<0}
-area_fg 0,0
-gt {$f*$Minimal_Area*$Minimal_Area}
-elif {$Minimal_Area>0}
-== 0
-area_fg 0,0
-gt {$f*$Minimal_Area*$Minimal_Area}
-== 0
-endif
-* 255
-if $Anti_Aliasing
-r $wh,1,1,2
-endif
-endl
-a c
-endl
#@gui Hard Sketch XY : XY_hardsketchbw_samj, XY_hardsketchbw_samj(0)
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre Hard Sketch BW</small>")
#@gui : XY = float(0.2,0,1)
#@gui : Densit\303\251 / Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Douceur / Smoothness = float(1,0,10)
#@gui : Opacit\303\251 / Opacity = float(0.1,0,1)
#@gui : Bordure / Edge = float(20,0,100)
#@gui : Approximation Rapide / Fast Approximation = bool(0)
#@gui : Color Model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), note = note("<small>Calques / Layers</small>")
#@gui : Nb. = choice(0,"1 : XY","2 : XY + Hard Sketch BW Normal")
#@gui : sep = separator(), note = note("<small>Nettet\303\251 / Sharpen</small>")
#@gui : Filtre Octave Sharpening = bool(0)
#@gui : sep = separator(), note = note("<small>XY_hardsketch Color</small>")
#@gui : Couleur / Color = color(180,40,160,255)
#@gui : Remplir / Fill = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.      Derni\303\250re mise \303\240 jour : <i>2015/03/10</i>.</small>")
XY_hardsketchbw_samj :
XY=$1
Amplitude=$2
Density=$3
Smoothness=$4
Opacity=$5
Edge=$6
Fast_approximation=$7
Negative=$8
Calques=$9
Octave_Sharpening=$10
R_Transparence=$11
V_Transparence=$12
B_Transparence=$13
A_Transparence=$14
Remplir=$15
Largeur={w}
Hauteur={h}
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
-if {$Calques==1} --Je_passe_l_hiver_en_Floride[-1] -endif
-if {$Largeur>$Hauteur}
Grande_dimension={$Largeur*1.5}
-else
Grande_dimension={$Hauteur*1.5}
-endif
Origine_X={round({{{$Grande_dimension}-$Largeur}/2})}
Origine_Y={round({{{$Grande_dimension}-$Hauteur}/2})}
-expand_x[-1] $Origine_X,2
-expand_y[-1] $Origine_Y,2
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-1] $XY,0.5,0.5,1
-fx_hardsketchbw[-1] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-1] -$XY,0.5,0.5,1
-expand_x[-2] $Origine_X,2
-expand_y[-2] $Origine_Y,2
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-2] -$XY,0.5,0.5,1
-fx_hardsketchbw[-2] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-2] $XY,0.5,0.5,1
#average
-blend[-1,-2] average,1,0
-crop[-1] $Origine_X,$Origine_Y,{$Largeur+$Origine_X-1},{$Hauteur+$Origine_Y-1}
-if {$Octave_Sharpening==1}
-fx_unsharp_octave 4,5,3,0,0,0,24,0
-endif
-if {$Calques==1}
-fx_hardsketchbw[-2] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
-reverse[-1,-2]
-endif
-if {$Remplir==1}
$Largeur,$Hauteur,1,4
-fill_color[-1] $R_Transparence,$V_Transparence,$B_Transparence,$A_Transparence
-if {$Calques==1}
-reverse[-1,-2]
-endif
-blend[-1,-2] screen,1,1
-if {$Calques==1}
-reverse[-1,-2]
-endif
-endif
samj_rien_colors :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Hard Sketch XY : XY_hardsketchbw_samj_en, XY_hardsketchbw_samj_en(0)
#@gui : sep = separator(), note = note("<small>Parameters - Hard Sketch BW</small>")
#@gui : XY = float(0.2,0,1)
#@gui : Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(1,0,10)
#@gui : Opacity = float(0.1,0,1)
#@gui : Edge = float(20,0,100)
#@gui : Fast Approximation = bool(0)
#@gui : Color Model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), note = note("<small>Layers</small>")
#@gui : Nb. = choice(0,"1 : XY","2 : XY + Hard Sketch BW Normal")
#@gui : sep = separator(), note = note("<small>Sharpen</small>")
#@gui : Octave Sharpening = bool(0)
#@gui : sep = separator(), note = note("<small>XY_hardsketch Color</small>")
#@gui : Color = color(180,40,160,255)
#@gui : Fill = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.        Latest Update: <i>2015/03/10</i>.</small>")
XY_hardsketchbw_samj_en :
-XY_hardsketchbw_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15
#@gui Samj NB EdgesO Engrave : samj_NB_EdgesO_Engrave, samj_NB_EdgesO_Engrave(0)
#@gui : note = note("samj_NB_EdgesO_Engrave")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Edges offsets</b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(50,0,100)
#@gui : Scale = int(9,0,32)
#@gui : Thickness = int(1,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Engrave</b></span>")
#@gui : Radius = float(2,0,4)
#@gui : Density = float(50,0,200)
#@gui : Edges = float(0,0,10)
#@gui : Coherence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal Area = int(0,-256,256)
#@gui : Flat Regions Removal = float(0,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Variation</b></span>")
#@gui : Variation = float(1,0.8,1.2)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/24</i>.</small>")
samj_NB_EdgesO_Engrave :
--Je_passe_l_hiver_en_Floride[-1]
-pow[-2]  $12
-fx_edge_offsets[-2] $1,$2,$3,$4,0
-fx_engrave[-1,-2] $5,$6,$7,$8,$9,$10,$11,0,10,1,0,0,0,1
-blend[-1,-2] multiply,1,1
#@gui Samj Scintillements : samj_scintillements, samj_scintillements(1)
#@gui : note = note("samj_scintillements")
#@gui : Exemples = choice{"Non","A","B","C","D Image Noire","E Image Noire - Scintillements","F Image Noire - Stars"}
#@gui : note = note("<span foreground="orangered"><small>Dog</small></span>")
#@gui : Sigma 1 = float(5,0,10)
#@gui : Sigma 2 = float(0,0,10)
#@gui : It\303\251rations = int(1,1,8)
#@gui : note = note("<span foreground="orangered"><small>Noise</small></span>")
#@gui : Variation = int(20,0,100)
#@gui : Type = choice{2,"Gaussian","Uniform","Salt and Pepper","Poisson","Rice"}
#@gui : note = note("<span foreground="orangered"><small>Circle</small></span>")
#@gui : Amplitude = int(6,3,20)
#@gui : note = note("<span foreground="orangered"><small>Blur Linear</small></span>")
#@gui : Amplitude A = float(20,0,100)
#@gui : Amplitude B = float(5,0,100)
#@gui : Angle = float(45,0,120)
#@gui : note = note("<span foreground="orangered"><small>Local normalization</small></span>")
#@gui : Amplitude = float(2,0,60)
#@gui : Radius = int(6,1,64)
#@gui : Neighborhood Smoothness = float(5,0,40)
#@gui : Average Smoothness = float(20,0,40)
#@gui : Constrain Values = bool(1)
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : note = note("<span foreground="orangered"><small>Couleurs</small></span>")
#@gui : Inverser Couleur = bool(0)
#@gui : D\303\251gradation = float(0,-50,50)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_scintillements :
Exemple=$1
dog_sigma1=$2
dog_sigma2={$3/10}
dog_Iterations=$4
Variation_noise=$5
Type_noise=$6
Amplitude_circle=$7
AmplitudeA=$8
AmplitudeB=$9
Angle=$10
Amplitude_ln=$11
Radius_ln=$12
Neighborhood_smoothness_ln=$13
Average_smoothness_ln=$14
Constrain_values_ln=$15
Channel_ln=$16
Inverser_couleur=$17
Degradation_pow={1+{$18/100}}
-to_rgb[-1]
-if {$Exemple==1}
Variation_noise=70
Amplitude_circle=3
Angle=0
-elif {$Exemple==2}
Variation_noise=70
Amplitude_circle=3
Angle=40
-elif {$Exemple==3}
Variation_noise=70
Amplitude_circle=3
Angle=80
-elif {$Exemple==4}
-fill_color[-1] 0,0,0
-noise[-1] $Variation_noise,$Type_noise
-norm[-1]
-elif {$Exemple==5}
Variation_noise=2
-fill_color[-1] 0,0,0
-noise[-1] $Variation_noise,$Type_noise
-norm[-1]
-elif {$Exemple==6}
-fill_color[-1] 0,0,0
-noise[-1] $Variation_noise,$Type_noise
-norm[-1]
Amplitude_circle={$Amplitude_circle+25}
-endif
-repeat $dog_Iterations
-dog[-1] $dog_sigma1%,$dog_sigma2%
-done
#filtre sponge (par David Tschumperl) adapt
{w},{h},1
-noise[-1] $Variation_noise,$Type_noise
-r[-1] [-2]
-n[-1] 0,1
-*[-1,-2]
-_circle_1610 $Amplitude_circle
-dilate[-2] [-1]
-rm[-1]
#fin filtre sponge adapt
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-blur_linear[-1] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},$Angle,1
-blur_linear[-2] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},{$Angle+120},1
-blur_linear[-3] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},{$Angle+240},1
-n[-1,-2,-3] 0,255
-fx_blend_average_all[-1,-2,-3] 2
-fx_normalize_local[-1] $Amplitude_ln,$Radius_ln,$Neighborhood_smoothness_ln,$Average_smoothness_ln,$Constrain_values_ln,$Channel_ln
-if {$Degradation_pow!=1}
-pow[-1] $Degradation_pow
-n[-1] 0,255
-endif
-if {$Inverser_couleur==1} -negate[-1] -endif
_circle_1610 :
-if {$1%2==0}
-i 2,2
-else
-i 1
-endif
-+[-1] 1
-r[-1] $1,$1,1,1,0,0,0.5,0.5
-distance[-1] 1
-n[-1] 0,1
-sqrt[-1]
-c[-1] 0.85,0.86
-*[-1] -1
-n[-1] 0,1
#@gui _
#@gui <i>Colors</i>
#@gui Color Harmonies : samj_Color_Palettes, samj_Color_Palettes(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_Color_Palettes</b></span>")
#@gui : sep = separator(), note = note("<small>Geometry</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Tilt Angle = float(0,0,360)
#@gui : Radius Center Circle = float(6,0,100)
#@gui : Number Of Shades Per Circle = int(24,16,90)
#@gui : Angle Offset Rings = float(0,0,360)
#@gui : Variation Dimension = float(0,-100,200)
#@gui : sep = separator(), note = note("<small>Color - Palettes</small>")
#@gui : Reference Color = color(180,90,45)
#@gui : Fill Color = bool(1)
#@gui : RGB XYZ Matrices = int(3,0,15)
#@gui : XYZ Tristimulus = int(2,0,18)
#@gui : Outline Reference Color = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/25</i>.</small>")
samj_Color_Palettes :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Angle_inclinaison=$3
Rayon_Cercle_Centre={round({{w}*$4/{100}})}
Nb_Circles_Surrounding=$5
Angle_Decalage=$6
Variation_Increment_Anneaux=$7
R_val=$8
G_val=$9
B_val=$10
Remplir_Couleur_Base=$11
# Conversions
Matrices_RGB=$12
XYZ_Tristimulus=$13
Choix=0
Outline_Reference_Color=$14
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_Anneaux={2*4}
R_val_comp={255-$R_val}
G_val_comp={255-$G_val}
B_val_comp={255-$B_val}
L_origine=${"-samj_RGB_to_LCH_or_Lab[] 1,"{/$R_val}","{/$G_val}","{/$B_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
C_origine=${"-samj_RGB_to_LCH_or_Lab[] 2,"{/$R_val}","{/$G_val}","{/$B_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
H_origine=${"-samj_RGB_to_LCH_or_Lab[] 3,"{/$R_val}","{/$G_val}","{/$B_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
L_origine25={$L_origine+25}
-if {$L_origine25>100} L_origine25={$L_origine25-100} -endif
L_origine50={$L_origine+50}
-if {$L_origine50>100} L_origine50={$L_origine50-100} -endif
L_origine75={$L_origine+75}
-if {$L_origine75>100} L_origine75={$L_origine75-100} -endif
L_origine_comp=${"-samj_RGB_to_LCH_or_Lab[] 1,"{/$R_val_comp}","{/$G_val_comp}","{/$B_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
C_origine_comp=${"-samj_RGB_to_LCH_or_Lab[] 2,"{/$R_val_comp}","{/$G_val_comp}","{/$B_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
H_origine_comp=${"-samj_RGB_to_LCH_or_Lab[] 3,"{/$R_val_comp}","{/$G_val_comp}","{/$B_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
L_origine_comp25={$L_origine_comp+25}
-if {$L_origine_comp25>100} L_origine_comp25={$L_origine_comp25-100} -endif
L_origine_comp50={$L_origine_comp+50}
-if {$L_origine_comp50>100} L_origine_comp50={$L_origine_comp50-100} -endif
L_origine_comp75={$L_origine_comp+75}
-if {$L_origine_comp75>100} L_origine_comp75={$L_origine_comp75-100} -endif
-to_rgba[-1]
-if {$Remplir_Couleur_Base==1} -fill_color[-1] $R_val,$G_val,$B_val,255 -endif
Angle_Theta={pi/$Nb_Circles_Surrounding}
-if {$Rayon_Cercle_Centre<10}
Rayon_Cercle_Centre=10
-endif
Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Angle_Decalage_En_Cours=0
Nb_boucles_anneaux=0
Rayon_Cercle_Centre_En_Cours=0
R_en_cours=0
G_en_cours=0
B_en_cours=0
A_en_cours=255
L_val=0
L_val_comp=0
-repeat $Nb_Anneaux
Nb_boucles=0
Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage*$Nb_boucles_anneaux}
-if {$Nb_boucles_anneaux==0}
Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
-else
Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
-endif
Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
-repeat $Nb_Circles_Surrounding
Erreur_Couleur=0
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
-if {{$Nb_boucles_anneaux%2}==0}
H_val={$H_origine+$Angle}
-if {$Nb_boucles_anneaux==0}
L_val=$L_origine75
-elif {$Nb_boucles_anneaux==2}
L_val=$L_origine50
-elif {$Nb_boucles_anneaux==4}
L_val=$L_origine25
-elif {$Nb_boucles_anneaux==6}
L_val=$L_origine
-endif
R_en_cours={int(${"-samj_LCH_or_Lab_to_RGB[] 1,"{/$L_val}","{/$C_origine}","{/$H_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
G_en_cours={int(${"-samj_LCH_or_Lab_to_RGB[] 2,"{/$L_val}","{/$C_origine}","{/$H_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
B_en_cours={int(${"-samj_LCH_or_Lab_to_RGB[] 3,"{/$L_val}","{/$C_origine}","{/$H_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
-else
H_val_comp={$H_origine_comp+$Angle}
-if {$Nb_boucles_anneaux==1}
L_val_comp=$L_origine_comp75
-elif {$Nb_boucles_anneaux==3}
L_val_comp=$L_origine_comp50
-elif {$Nb_boucles_anneaux==5}
L_val_comp=$L_origine_comp25
-elif {$Nb_boucles_anneaux==7}
L_val_comp=$L_origine_comp
-endif
R_en_cours={int(${"-samj_LCH_or_Lab_to_RGB[] 1,"{/$L_val_comp}","{/$C_origine_comp}","{/$H_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
G_en_cours={int(${"-samj_LCH_or_Lab_to_RGB[] 2,"{/$L_val_comp}","{/$C_origine_comp}","{/$H_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
B_en_cours={int(${"-samj_LCH_or_Lab_to_RGB[] 3,"{/$L_val_comp}","{/$C_origine_comp}","{/$H_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
-endif
-if {$R_en_cours<0} Erreur_Couleur=1 -endif
-if {$R_en_cours>255} Erreur_Couleur=1 -endif
-if {$G_en_cours<0} Erreur_Couleur=1 -endif
-if {$G_en_cours>255} Erreur_Couleur=1 -endif
-if {$B_en_cours<0} Erreur_Couleur=1 -endif
-if {$B_en_cours>255} Erreur_Couleur=1 -endif
-if {$Erreur_Couleur==0} -circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,$R_en_cours,$G_en_cours,$B_en_cours,$A_en_cours -endif
-if {{$Nb_boucles==0}&&{$Nb_boucles_anneaux==6}&&{$Outline_Reference_Color==1}}
-circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,0xFFFFFFFF,0,0,0,255
-circle[-1] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/2},1,$R_val,$G_val,$B_val,$A_en_cours
-circle[-1] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/2},1,0xFFFFFFFF,255,255,255,255
-endif
Nb_boucles={$Nb_boucles+1}
-done
Nb_boucles_anneaux={$Nb_boucles_anneaux+1}
-done
#@gui Couleurs Metalliques : Couleurs_Metalliques_samj_en, Couleurs_Metalliques_samj_en_preview
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Transparence / Transparency = choice(0,"Preserve","Remove")
#@gui : Rendering = choice("YCbCr [luminance]","Lab [lightness]","HSV [value]","HSL [lightness]","Linear RGB [all]","RGB [all]","RGB [all]")
#@gui : sep = separator(), note = note("<small>Noise parameters</small>")
#@gui : Amplitude = float(22,0,200)
#@gui : Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : Value Range = choice("Cut","Normalize")
#@gui : sep = separator(), note = note("<small>Local normalization parameters</small>")
#@gui : Effect X 2 = bool(0)
#@gui : Amplitude = float(0,0,60)
#@gui : Radius = int(6,1,64)
#@gui : Neighborhood Smoothness = float(5,0,40)
#@gui : Average Smoothness = float(20,0,40)
#@gui : Constrain Values = bool(1)
#@gui : Channel(s) = choice(0,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator(), note = note("<small>Boost-Fade parameters : If Amplitude Sup. 0</small>")
#@gui : Amplitude = float(0,0,10)
#@gui : sep = separator(), note = note("<small>PhotoComix Options</small>")
#@gui : Use PC Options = bool(0)
#@gui : Pencilbw Size = float(0.3,0,5)
#@gui : Pencilbw Amplitude = float(60,0,200)
#@gui : Blend Opacity = float(1,0,1)
#@gui : Blend Revert Layers = bool(1)
#@gui : sep = separator()
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.        Latest Update: <i>2015/03/31</i>.</small>")
Couleurs_Metalliques_samj_en :
-Couleurs_Metalliques $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18
Couleurs_Metalliques_samj_en_preview :
-gui_split_preview "-Couleurs_Metalliques_samj_en ${1--2}",$-1
#@gui Couleurs Metalliques : Couleurs_Metalliques, Couleurs_Metalliques_preview
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Transparence / Transparency = choice(0,"Conserver / Preserve","Supprimer / Remove")
#@gui : Rendu / Rendering = choice("YCbCr [luminance]","Lab [lightness]","HSV [value]","HSL [lightness]","Linear RGB [all]","RGB [all]","RGB [all]")
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre Noise - Noise parameters</small>")
#@gui : Amplitude = float(22,0,200)
#@gui : Type De Bruit / Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : \303\211tendue / Value Range = choice("Cut","Normalize")
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre Local normalization - Local normalization parameters</small>")
#@gui : Double Effet = bool(0)
#@gui : Amplitude = float(0,0,60)
#@gui : Rayon / Radius = int(6,1,64)
#@gui : Lissage Voisinage / Neighborhood Smoothness = float(5,0,40)
#@gui : Lissage Moyenne / Average Smoothness = float(20,0,40)
#@gui : Imposer Valeurs / Constrain Values = bool(1)
#@gui : Canaux / Channel(s) = choice(0,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator(), note = note("<small>Param\303\250tres Filtre Boost-Fade - Boost-Fade parameters : Si-If Amplitude Sup. 0</small>")
#@gui : Amplitude = float(0,0,10)
#@gui : sep = separator(), note = note("<small>PhotoComix Options</small>")
#@gui : Utiliser / Use PC Options = bool(0)
#@gui : Filtre Pencilbw Taille / Size = float(0.3,0,5)
#@gui : Filtre Pencilbw Amplitude = float(60,0,200)
#@gui : Opacit\303\251 M\303\251lange / Blend Opacity = float(1,0,1)
#@gui : M\303\251lange Permuter Calques / Blend Revert Layers = bool(1)
#@gui : sep = separator()
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.      Derni\303\250re mise \303\240 jour : <i>2015/03/31</i>.</small>")
Couleurs_Metalliques :
Transparence=$1
Rendu=$2
Amplitude=$3
Noise_type=$4
Noise_Channel=7
Value_range=$5
Double_effet=$6
Local_normalization_Amplitude=$7
Radius=$8
Neighborhood_smoothness=$9
Average_smoothness=$10
Constrain_values=$11
Local_normalization_Channel=$12
boost_fade_Amplitude=$13
Utiliser_Photocomix_Options=$14
Pencilbw_Size=$15
Pencilbw_Amplitude=$16
Blend_soft_light_Opacity=$17
Blend_soft_light_Revert_layers=$18
-repeat $! -l[$>]
-if {$Rendu==0}
Rendu_local_orientation_channels=11
-elif {$Rendu==1}
Rendu_local_orientation_channels=16
-elif {$Rendu==2}
Rendu_local_orientation_channels=25
-elif {$Rendu==3}
Rendu_local_orientation_channels=27
-elif {$Rendu==4}
Rendu_local_orientation_channels=7
-elif {$Rendu==5}
Rendu_local_orientation_channels=2
-elif {$Rendu==6}
Rendu_local_orientation_channels=2
-endif
-if {$Transparence==1}
-remove_opacity[-1]
-endif
-if {$Utiliser_Photocomix_Options==1}
--pencilbw[-1] $Pencilbw_Size,$Pencilbw_Amplitude
-if {$Double_effet==1}
-fx_normalize_local[-2] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-endif
-fx_noise[-2] $Amplitude,$Noise_type,$Noise_Channel,$Value_range
-fx_local_orientation[-2] 0,0,100,0,$Rendu_local_orientation_channels
-fx_normalize_local[-2] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-if {$boost_fade_Amplitude>0}
-fx_boost_fade[-2] $boost_fade_Amplitude
-endif
-blend[-2,-1] softlight,$Blend_soft_light_Opacity,$Blend_soft_light_Revert_layers
-else
-if {$Double_effet==1}
-fx_normalize_local[-1] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-endif
-fx_noise[-1] $Amplitude,$Noise_type,$Noise_Channel,$Value_range
-fx_local_orientation[-1] 0,0,100,0,$Rendu_local_orientation_channels
-fx_normalize_local[-1] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-if {$boost_fade_Amplitude>0}
-fx_boost_fade[-1] $boost_fade_Amplitude
-endif
-endif
-endl -done
Couleurs_Metalliques_preview :
-gui_split_preview "-Couleurs_Metalliques ${1--2}",$-1
samj_rien_contours :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Samj At06A 2017 VarCouleurs : samj_At06A_2017_VarCouleurs, samj_At06A_2017_VarCouleurs(1)
#@gui : sep = separator(), note = note("<span foreground="orangered">samj_At06A_2017_VarCouleurs</span>")
#@gui : Puissance = float(1,0,8)
#@gui : Couper A % = float(0,0,100)
#@gui : Couper B % = float(100,0,100)
#@gui : Noir Et Blanc = choice(0,"Non","To Gray","Lightness - Lab")
#@gui : Normaliser = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2017/02/27</i>.</small>")
samj_At06A_2017_VarCouleurs :
-to_rgba[-1]
-pow[-1] $1
-n[-1] 0,{{iM}-{im}}
-c[-1] {{iM}/100*$2},{iM}
-n[-1] 0,{iM}
-c[-1] 0,{{iM}/100*$3}
-n[-1] 0,255
-if {$4==1}
-to_graya[-1]
-elif {$4==2}
--Je_passe_l_hiver_en_Floride[-1]
-fx_decompose_channels[-1] 7,0,1,0
-remove[-1,-2]
-blend[-1,-2] alpha
-endif
-if {$5==1} -n[-1] 0,255 -endif
-to_rgba[-1]
#@gui Samj Variations RVB : samj_Variations_RVB, samj_Variations_RVB(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_Variations_RVB</b></span>")
#@gui : sep = separator(), note = note("<small>Geometry</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Tilt Angle = float(0,0,360)
#@gui : Radius Center Circle = float(6,0,100)
#@gui : Angle Offset Rings = float(0,0,360)
#@gui : Variation Dimension = float(0,-100,200)
#@gui : sep = separator(), note = note("<small>Variations RVB</small>")
#@gui : Reference Color = color(180,90,45)
#@gui : Fill Color = bool(0)
#@gui : Outline Reference Color = bool(1)
#@gui : Type Variation = int(0,0,20)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/26</i>.</small>")
samj_Variations_RVB :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Angle_inclinaison=$3
Rayon_Cercle_Centre={round({{w}*$4/{100}})}
Angle_Decalage=$5
Variation_Increment_Anneaux=$6
R_val=$7
G_val=$8
B_val=$9
Remplir_Couleur_Base=$10
Outline_Reference_Color=$11
Type_Variation=$12
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_Circles_Surrounding=32
Nb_Anneaux=8
-to_rgba[-1]
-if {$Remplir_Couleur_Base==1} -fill_color[-1] $R_val,$G_val,$B_val,255 -endif
Angle_Theta={pi/$Nb_Circles_Surrounding}
-if {$Rayon_Cercle_Centre<10}
Rayon_Cercle_Centre=10
-endif
Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Angle_Decalage_En_Cours=0
Nb_boucles_anneaux=0
Rayon_Cercle_Centre_En_Cours=0
R_en_cours=$R_val
G_en_cours=$G_val
B_en_cours=$B_val
A_en_cours=255
Variation_RVB=0
-repeat $Nb_Anneaux
Nb_boucles=0
Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage*$Nb_boucles_anneaux}
-if {$Nb_boucles_anneaux==0}
Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
-else
Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
-endif
Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
-repeat $Nb_Circles_Surrounding
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
-if {$Type_Variation==0}
R_en_cours={abs({$R_val-$Variation_RVB})}
G_en_cours={abs({$G_val-$Variation_RVB})}
B_en_cours={abs({$B_val-$Variation_RVB})}
-elif {$Type_Variation==1}
R_en_cours={abs({$R_val-$Variation_RVB})}
-elif {$Type_Variation==2}
B_en_cours={abs({$G_val-$Variation_RVB})}
-elif {$Type_Variation==3}
B_en_cours={abs({$B_val-$Variation_RVB})}
-elif {$Type_Variation==4}
R_en_cours={abs({$R_val-$Variation_RVB})}
G_en_cours={abs({$G_val-$Variation_RVB})}
-elif {$Type_Variation==5}
R_en_cours={abs({$R_val-$Variation_RVB})}
B_en_cours={abs({$B_val-$Variation_RVB})}
-elif {$Type_Variation==6}
G_en_cours={abs({$G_val-$Variation_RVB})}
B_en_cours={abs({$B_val-$Variation_RVB})}
-elif {$Type_Variation==7}
R_en_cours={$R_val-$Variation_RVB}
G_en_cours={$G_val-$Variation_RVB}
B_en_cours={$B_val-$Variation_RVB}
-elif {$Type_Variation==8}
R_en_cours={$R_val-$Variation_RVB}
-elif {$Type_Variation==9}
B_en_cours={$G_val-$Variation_RVB}
-elif {$Type_Variation==10}
B_en_cours={$B_val-$Variation_RVB}
-elif {$Type_Variation==11}
R_en_cours={$R_val-$Variation_RVB}
G_en_cours={$G_val-$Variation_RVB}
-elif {$Type_Variation==12}
R_en_cours={$R_val-$Variation_RVB}
B_en_cours={$B_val-$Variation_RVB}
-elif {$Type_Variation==13}
G_en_cours={$G_val-$Variation_RVB}
B_en_cours={$B_val-$Variation_RVB}
-elif {$Type_Variation==14}
R_en_cours={$R_val+$Variation_RVB}
G_en_cours={$G_val+$Variation_RVB}
B_en_cours={$B_val+$Variation_RVB}
-elif {$Type_Variation==15}
R_en_cours={$R_val+$Variation_RVB}
-elif {$Type_Variation==16}
B_en_cours={$G_val+$Variation_RVB}
-elif {$Type_Variation==17}
B_en_cours={$B_val+$Variation_RVB}
-elif {$Type_Variation==18}
R_en_cours={$R_val+$Variation_RVB}
G_en_cours={$G_val+$Variation_RVB}
-elif {$Type_Variation==19}
R_en_cours={$R_val+$Variation_RVB}
B_en_cours={$B_val+$Variation_RVB}
-elif {$Type_Variation==20}
G_en_cours={$G_val+$Variation_RVB}
B_en_cours={$B_val+$Variation_RVB}
-endif
-if {$R_en_cours<0} R_en_cours=0 -endif
-if {$R_en_cours>255} R_en_cours=255 -endif
-if {$G_en_cours<0} G_en_cours=0 -endif
-if {$G_en_cours>255} G_en_cours=255 -endif
-if {$B_en_cours<0} B_en_cours=0 -endif
-if {$B_en_cours>255} B_en_cours=255 -endif
-circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,$R_en_cours,$G_en_cours,$B_en_cours,$A_en_cours
-if {{$Nb_boucles==0}&&{$Nb_boucles_anneaux==0}&&{$Outline_Reference_Color==1}}
-circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,0xFFFFFFFF,0,0,0,255
-circle[-1] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/2},1,0xFFFFFFFF,255,255,255,255
-endif
Nb_boucles={$Nb_boucles+1}
Variation_RVB={$Variation_RVB+1}
-done
Nb_boucles_anneaux={$Nb_boucles_anneaux+1}
-done
#@gui _
#@gui <i>Contours</i>
#@gui Samj Colored Outlines : samj_Colored_Outlines, samj_Colored_Outlines(1)
#@gui : note = note("samj_Colored_Outlines")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blur</b></span>")
#@gui : Axes = choice(0,"XY","X","Y")
#@gui : Blur = float(2,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Isophote</b></span>")
#@gui : Isophote = float(8,6,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth</b></span>")
#@gui : Smooth = int(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate = int(0,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/29</i>.</small>")
samj_Colored_Outlines :
Axe_blur=$1
Valeur_blur=$2
Valeur_isophotes=$3
Iterations_smooth=$4
Valeur_dilate=$5
Couleur_Fond_r=$6
Couleur_Fond_v=$7
Couleur_Fond_b=$8
Couleur_Fond_a=$9
Largeur_Origine={w}
Hauteur_Origine={h}
-to_rgba[-1]
-if {$Axe_blur==0}
-blur[-1] xy,{$Valeur_blur}
-elif {$Axe_blur==1}
-blur[-1] x,{$Valeur_blur}
-elif {$Axe_blur==2}
-blur[-1] y,{$Valeur_blur}
-endif
-isophotes[-1] $Valeur_isophotes
-if {$Iterations_smooth>0} -fx_smooth_diffusion[-1] 0.7,0.3,0.6,1.1,15,$Iterations_smooth,2,0,24 -endif
-dilate_circ[-1] $Valeur_dilate
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-gimp_blend_1651[-2,-1] 1,0,1,0,1
#@gui Samj Coloriage : samj_Coloriage, samj_Coloriage_preview
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Filtre Lent</u></b></span>")
#@gui : note = note("<span foreground="orangered"><b><u>Pour obtenir un contour de 1 couleur</u></b></span>")
#@gui : sep = separator(),
#@gui : Dimension Max Echantillon = int(612,256,800)
#@gui : Limites = int(255,1,255)
#@gui : Flou Lissage = float(2,0,10)
#@gui : Isophotes Nb Levels = int(6,4,16)
#@gui : Dilatation = int(2,1,16)
#@gui : Couleur Contour = color(0,0,0,255)
#@gui : Dimensions Origine = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/04</i>.</small>")
samj_Coloriage:
Dimension_Max=$1
Limite=$2
Flou_Lissage=$3
Isophotes_Nb_Levels=$4
Dilatation=$5
R_a=$6
V_a=$7
B_a=$8
A_a=$9
Dimensions_Origine=$10
Largeur_Origine={w}
Hauteur_Origine={h}
OrigineH=0
OrigineV=-1
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0
-if {$Hauteur_Origine>$Largeur_Origine}
Largeur_A={round({$Largeur_Origine/$Hauteur_Origine*$Dimension_Max})}
Hauteur_A=$Dimension_Max
-else
Largeur_A=$Dimension_Max
Hauteur_A={round({$Hauteur_Origine/$Largeur_Origine*$Dimension_Max})}
-endif
-resize[-1] $Largeur_A,$Hauteur_A
-n[-1] 0,255
-c[-1] 0,$Limite
-n[-1] 0,255
-c[-1] {255-$Limite},255
-n[-1] 0,255
-blur[-1] $Flou_Lissage
-isophotes[-1] $Isophotes_Nb_Levels
-dilate[-1] $Dilatation
-repeat $Hauteur_A
OrigineH=0
OrigineV={$OrigineV+1}
-repeat $Largeur_A
couleur_pixel={I($OrigineH,$OrigineV)}
alpha_pixel={arg(4,$couleur_pixel)}
-if {$alpha_pixel>0}
-point[-1] $OrigineH,$OrigineV,0,1,$R_a,$V_a,$B_a,$A_a
-endif
OrigineH={$OrigineH+1}
-done
-done
-if {$Dimensions_Origine==1} -resize[-1] $Largeur_Origine,$Hauteur_Origine -endif
samj_Coloriage_preview :
-samj_Coloriage[-1] 256,$2,$3,$4,$5,$6,$7,$8,$9,0
#@gui Samj Contours Arrondis : samj_Contours_Arrondis, samj_Contours_Arrondis(1)
#@gui : note = note("samj_Contours_Arrondis")
#@gui : note = note("<span foreground="orangered"><small>Lissage</small></span>")
#@gui : It\303\251rations = int(1,1,25)
#@gui : Quantize = int(3,2,25)
#@gui : Blur = int(5,5,50)
#@gui : note = note("<span foreground="orangered"><small>Traits</small></span>")
#@gui : Isophotes = int(10,2,50)
#@gui : RGBA = bool(0)
#@gui : Dilate Circ = int(0,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/04/06</i>.</small>")
samj_Contours_Arrondis :
Iterations=$1
Val_Quantize=$2
Val_Blur=$3
Val_Isophotes=$4
RGBA=$5
Val_Dilate_Circ=$6
-to_rgb[-1]
-repeat $Iterations
-quantize[-1] $Val_Quantize
-blur[-1] {$Val_Blur/10}
-n[-1] 0,255
-done
-isophotes[-1] $Val_Isophotes
-if {$RGBA==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Val_Dilate_Circ>1} -dilate_circ[-1] $Val_Dilate_Circ -endif
samj_rien_deformations :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Samj Contours Blancs : samj_Contours_Blancs , samj_Contours_Blancs_preview(0)
#@gui : sep = separator()
#@gui : note = note("<b><u>Option Quantize</u></b>")
#@gui : Quantize = choice(1,"No","A","B","A + B")
#@gui : Levels = int(16,2,256)
#@gui : Blur = float(2,0,100)
#@gui : note = note("<span foreground="orangered"><b><u>Gradient Norm</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b><u>Blanc Contours</u></b></span>")
#@gui : White Level Contour = int(3,0,12)
#@gui : note = note("<span foreground="orangered"><b><u>Segment Watershed</u></b></span>")
#@gui : Edge Threshold = float(2,0,15)
#@gui : Smoothness = float(1,0,5)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : note = note("<span foreground="orangered"><b><u>Edges Offsets</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Scale = int(4,0,32)
#@gui : Thickness = int(1,0,16)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>samj</i>.      Latest update: <i>2018/04/09</i>.</small>")
samj_Contours_Blancs :
-i [-1]
-if {$1==1}
-blur[-1,-2] $3
-quantize[-1] $2,1,1
-elif {$1==2}
-blur[-1,-2] $3
-quantize[-2] $2,1,1
-elif {$1==3}
-blur[-1,-2] $3
-quantize[-1,-2] $2,1,1
-endif
-fx_gradient_norm[-1] $4,$5,$6,$7,$8
-isophotes[-1] 8
-to_graya[-1]
-repeat $9
-i [-1]
-blend[-1,-2] add
-done
-fx_segment_watershed[-2] $10,$11,$12,$13
-fx_edge_offsets[-2] $14,$15,$16,$17,1
-to_rgba[-1,-2]
-replace_color[-1,-2] 100%,0,0,0,0,255,0,0,0,0
-blend[-1,-2] alpha
samj_Contours_Blancs_preview :
gui_split_preview "samj_Contours_Blancs $*",$-1
#@gui Samj Contours Colores : samj_Contours_Colores, samj_Contours_Colores(1)
#@gui : note = note("samj_Contours_Colores")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Puissance / Pow = float(1.1,1,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Segment</b></span>")
#@gui : Edge Threshold = float(2,0,15)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Cut</b></span>")
#@gui : Couper / Cut = int(40,0,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate Contours = int(0,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Degradation Spread</b></span>")
#@gui : Spread = float(0,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/25</i>.</small>")
samj_Contours_Colores :
Puissance=$1
Edge_threshold=$2
Couper_Cut=$3
Dilate_Contours=$4
Degradation_Spread=$5
-pow[-1] $Puissance
-c[-1] 0,255
-fx_segment_watershed[-1] $2,1,0,2,0
--Je_passe_l_hiver_en_Floride[-1]
-fx_gradient_norm[-1] 0,0.5,0,100,0,0
-c[-1] $Couper_Cut,255
-n[-1] 0,255
-if {$Dilate_Contours>1} -dilate_circ[-1,-2] $Dilate_Contours -endif
-if {$Degradation_Spread>1} -spread[-1,-2] $Degradation_Spread -endif
-blend[-2,-1] darken,1,0
#@gui Samj Quelques Isophotes : samj_Quelques_Isophotes , samj_Quelques_Isophotes (1)
#@gui : \303\211paisseur = int(10,1,32)
#@gui : Pr\303\251cision = int(10,1,32)
#@gui : Coeff Pr\303\251cision = float(1,0.1,8)
#@gui : Coeff Flou = float(0.02,0,1)
#@gui : Isophotes = int(8,2,32)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/23</i>.</small>")
samj_Quelques_Isophotes :
Epaisseur=$1
Precision=$2
Coeff_Precision_Pixelise=$3
Coeff_Precision_Flou=$4
Nb_Isophotes=$5
Nb_Boucles=0
--Je_passe_l_hiver_en_Floride[-1]
-repeat $Epaisseur
-pixelize[-1] {1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)},{1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)}
-blur[-1]  {{$Precision+$Epaisseur+$Nb_Boucles}*$Coeff_Precision_Flou}
-isophotes[-1] $Nb_Isophotes
-if {$Nb_Boucles>0} -blend[-1,-2] alpha -endif
Nb_Boucles={$Nb_Boucles+1}
--Je_passe_l_hiver_en_Floride[-2]
-done
-rm[-1,-3]
#@gui Samj Quelques Isophotes B : samj_Quelques_Isophotes_B , samj_Quelques_Isophotes_B (1)
#@gui : Nb Decomposition Couleurs = int(16,2,32)
#@gui : Variation Couleurs % = Float(100,25,100)
#@gui : Type Variation Couleurs = choice(0,"Min","Max","Min Max")
#@gui : Dilate = int(0,0,8)
#@gui : Isophotes = int(4,2,16)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2017/01/14</i>.</small>")
samj_Quelques_Isophotes_B :
-if {$3==2}
--Je_passe_l_hiver_en_Floride[-1]
-samj_Fonction_Quelques_Isophotes_B[-1] $1,$2,0,$4,$5
-reverse[-1,-2]
-samj_Fonction_Quelques_Isophotes_B[-1] $1,$2,1,$4,$5
-blend[-1,-2] alpha
-else
-samj_Fonction_Quelques_Isophotes_B $1,$2,$3,$4,$5
-endif
samj_Fonction_Quelques_Isophotes_B :
Nb_Decomposition_Couleurs=$1
Variation_Couleurs=$2
Type_Variation_Couleurs=$3
Dilatation=$4
Nb_Isophotes=$5
Val_min={im}
Val_max={iM}
Variation_Par_Boucle={{{iM}-{im}}/{$Nb_Decomposition_Couleurs*$Variation_Couleurs}}
Nb_Boucles=0
--Je_passe_l_hiver_en_Floride[-1]
-repeat $Nb_Decomposition_Couleurs
-if {$Type_Variation_Couleurs==0}
-c {$Val_min+{$Variation_Par_Boucle*$Nb_Boucles}},$Val_max
-elif {$Type_Variation_Couleurs==1}
-c $Val_min,{$Val_max-{$Variation_Par_Boucle*$Nb_Boucles}}
-endif
-n 0,255
-isophotes[-1] $Nb_Isophotes
-if {$Nb_Boucles>0}
-if {$Dilatation>0} -dilate_circ[-1] {$Dilatation+1} -endif
-blend[-1,-2] alpha
-endif
Nb_Boucles={$Nb_Boucles+1}
--Je_passe_l_hiver_en_Floride[-2]
-done
-rm[-1,-3]
#@gui Samj Scintillements Colores Contours : samj_Scintillements_Colores_Contours, samj_Scintillements_Colores_Contours(1)
#@gui : note = note("samj_Scintillements_Colores_Contours")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limites via Isophote</b></span>")
#@gui : Flou = int(0,0,10)
#@gui : Isophotes = int(8,6,16)
#@gui : Dilate = int(0,0,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Scintillement</b></span>")
#@gui : Resolution L = int(8,1,32)
#@gui : Resolution H = int(8,1,32)
#@gui : Dimension Variation = float(1,0.3,3)
#@gui : Variation Couleur = int(768,1,768)
#@gui : Scintillement = int(12,3,24)
#@gui : Angle Decalage = float(0,0,120)
#@gui : Variation Aleatoire = int(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Flou</b></span>")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Overlay</b></span>")
#@gui : Overlay = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/04</i>.</small>")
samj_Scintillements_Colores_Contours :
Val_Flou=$1
Val_Isophotes=$2
Val_Dilate=$3
Resolution_L=$4
Resolution_H=$5
Dimension_Variation=$6
Variation_Couleur=$7
Scintillement=$8
Angle_Decalage=$9
Variation_Aleatoire=$10
Flou_Contours=$11
Mode_Overlay=$12
Couleur_Fond_r=$13
Couleur_Fond_v=$14
Couleur_Fond_b=$15
Couleur_Fond_a=$16
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0
Hauteur=$Resolution_H
Largeur=$Resolution_L
Rayon_Scintillement_Origine={{$Resolution_H+$Resolution_L}*$Dimension_Variation}
Rayon_Scintillement=0
Angle_Variation={360/$Scintillement}
Angle_Variation_En_Cours=0
Coeff_Variation_Aleatoire=0
-blur[-1] $Val_Flou
-to_rgba[-1]
-isophotes[-1] $Val_Isophotes
-dilate_circ[-1] $Val_Dilate
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution_L+$Resolution_L}}
-repeat {$Hauteur_Origine/{$Resolution_H+$Resolution_H}}
couleur_pixel=${-at_ancien[-2]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
alpha_pixel=${-arg\ 4,$couleur_pixel}
Moyenne_couleur={1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Variation_Couleur}}
Rayon_Scintillement={$Rayon_Scintillement_Origine*$Moyenne_couleur}
Angle_Variation_En_Cours=0
-if {$alpha_pixel>1}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
Hauteur={$Hauteur+$Resolution_H+$Resolution_H}
-done
Largeur={$Largeur+$Resolution_L+$Resolution_L}
Hauteur=$Resolution_H
-done
-rm[-2]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
-if {$Mode_Overlay==1}
--Je_passe_l_hiver_en_Floride[-1]
-blend[-2,-1] overlay,1,0
-endif
#@gui Samj Skeletation : samj_Skeletation, samj_Skeletation(1)
#@gui : note = note("samj_Skeletation")
#@gui : note = note("<span foreground="orangered"><small>Skeleton</small></span>")
#@gui : Skeletation = int(2,2,10)
#@gui : Smoothness A % = int(100,10,100)
#@gui : Smoothness B % = int(100,10,100)
#@gui : note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Blend = bool(0)
#@gui : Mode = choice{0,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/20</i>.</small>")
samj_Skeletation :
Skeletation=$1
Variation_SmoothnessA={$2/$Skeletation/100}
Variation_SmoothnessB={$3/$Skeletation/100}
Valider_Blend=$4
Mode_blend=$5
Opacity_blend=$6
Smoothness=0
index=0
--Je_passe_l_hiver_en_Floride[-1]
-repeat $Skeletation
--Je_passe_l_hiver_en_Floride[0]
-fx_skeleton[-1] 0,$Smoothness,0,0,0
-if {$index>0} -blend[-2,-1] add,1,0 -endif
Smoothness={$Smoothness+$Variation_SmoothnessA}
index={$index+1}
-done
-fx_local_orientation[-2] 0,0,100,0,0,0
Smoothness=0
index=0
-repeat $Skeletation
--Je_passe_l_hiver_en_Floride[1]
-fx_skeleton[-1] 0,$Smoothness,0,0,0
-if {$index>0} -blend[-2,-1] add,1,0 -endif
Smoothness={$Smoothness+$Variation_SmoothnessB}
index={$index+1}
-done
-blend[-2,-1] add,1,0
-rm[-2]
-if {$Valider_Blend==0}
-rm[0]
-else
-gimp_blend_1651[0,-1] $Mode_blend,2,$Opacity_blend,0
-endif
#@gui Samj Test Mauvais Contours : samj_Test_Mauvais_Contours, samj_Test_Mauvais_Contours(0)
#@gui : note = note("samj_Test_Mauvais_Contours")
#@gui : Spread -  Watershed + = float(0,-30,30)
#@gui : Deformation A = int(0,0,20)
#@gui : Deformation B = int(0,0,20)
#@gui : Iterations = int(2,1,10)
#@gui : Pow = float(1,0.1,3)
#@gui : Na = int(0,0,255)
#@gui : Nb = int(255,0,255)
#@gui : Ca = int(0,0,255)
#@gui : Cb = int(255,0,255)
#@gui : Negate = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Blend = bool(0)
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape area max","Shape area max0","Shape area min","Shape area min0","Shape average","Shape average0","Shape min","Shape min0","Shape max","Shape max0",
#@gui : "Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value","Vivid light","Xor"}
#@gui : Reverse = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/30</i>.</small>")
samj_Test_Mauvais_Contours:
mode=${-arg\ 1+$12,add,alpha,and,average,blue,burn,darken,difference,\
divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
shapeaverage,shapeaverage0,shapemin,shapemin0,shapemax,shapemax0,\
softburn,softdodge,softlight,screen,stamp,subtract,value,\
vividlight,xor}
-if {$11==1} --Je_passe_l_hiver_en_Floride[-1] -endif
--Je_passe_l_hiver_en_Floride[-1]
-if {$1<0} -spread[-1] {abs($1/4)},{abs($1/4)} -endif
-if {$1>0} -segment_watershed[-1] {int($1)} -endif
-if {$2>0} -samj_Random_Small_Deformations[-1] $2,5,3 -endif
-if {$3>0} -samj_Random_Small_Deformations[-2] $3,5,3 -endif
-blend[-1,-2] edges
-gradient_norm[-1]
-n[-1] 0,255
-repeat $4
--Je_passe_l_hiver_en_Floride[-1]
-blend[-1,-2] add
-pow[-1] $5
-n[-1] $6,$7
-c[-1] $8,$9
-done
-n[-1] 0,255
-if {$10>0} -negate[-1] -endif
-if {$11==1}
-if {$13==1} -reverse[-1,-2] -endif
-blend[-1,-2] $mode
-endif
#@gui _
#@gui <i>Deformations</i>
#@gui Random Small Deformations : samj_Random_Small_Deformations, samj_Random_Small_Deformations(0)
#@gui : sep = separator(), note = note("<span foreground="orangered">samj_Random_Small_Deformations</span>")
#@gui : Noise Amplitude = float(10,0,200)
#@gui : Dilate = int(5,1,20)
#@gui : Blur = float(3,0,20)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/12/07</i>.</small>")
samj_Random_Small_Deformations :
Val_Bruit=$1
Val_Dilate=$2
Val_Flou=$3
Val_Expand={round({$Val_Bruit+$Val_Dilate+$Val_Flou})*2}
-to_rgba[-1]
-expand_xy[-1] $Val_Expand,0
100%,100%,1,2
-noise[-1] $Val_Bruit
-dilate[-1] $Val_Dilate
-blur[-1] $Val_Flou
-warp[-2] [-1],1,0,0
-rm[-1]
-autocrop[-1]
#@gui Samj Cercle Polaire : samj_Cercle_Polaire, samj_Cercle_Polaire(1)
#@gui : note = note("samj_Cercle_Polaire")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Rendu</b></span>")
#@gui : Repetitions = int(1,1,4)
#@gui : Rotation = float(0,0,360)
#@gui : Type Raccord = choice(0,"Sans","A","B","A+B","C")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Array [mirrored]</b></span>")
#@gui : Iterations = int(1,1,4)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Array Mode = choice(2,"x-axis","y-axis","xy-axes","2xy-axes")
#@gui : Initialization = choice(0,"Original","Mirror X","Mirror Y","Rotate 90 deg.","Rotate 180 deg.","Rotate 270 deg.")
#@gui : Expand Size = bool(0)
#@gui : Crop (%) = int(0,0,100)
#@gui : note = note("<span foreground="orangered"><b>Polar To Euclidean</b></span>")
#@gui : X-Center (%) = float(50,0,100)
#@gui : Y-Center (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/05/11</i>.</small>")
samj_Cercle_Polaire:
Repetitions=$1
Angle_Rotation=$2
Type_Raccord=$3
Iterations_AM=$4
X_offset_AM=$5
Y_offse_AM=$6
Array_mode_AM=$7
Initialization_AM=$8
Expand_size_AM=$9
Crop_AM=$10
X_center_PTE=$11
Y_center_PTE=$12
Expension=0
Securite=4000
-to_rgba[-1]
-repeat $Repetitions
-if {{$Type_Raccord==1}||{$Type_Raccord==3}}
-if {{w}>{h}}
Expension={round({{{w}-{h}}/2})}
-expand_y[-1] $Expension,1
-elif {{w}<{h}}
Expension={round({{{h}-{w}}/2})}
-expand_x[-1] $Expension,1
-endif
-endif
-repeat $Iterations_AM
-if {{{w}>$Securite}||{{h}>$Securite}}
-if {{w}>{h}}
-resize[-1] $Securite,{$Securite/{w}*{h}}
-else
-resize[-1] {$Securite/{h}*{w}},$Securite
-endif
-endif
-fx_array_mirror[-1] 1,$X_offset_AM,$Y_offse_AM,$Array_mode_AM,$Initialization_AM,$Expand_size_AM,$Crop_AM
-done
-if {{{w}>$Securite}||{{h}>$Securite}}
-if {{w}>{h}}
-resize[-1] $Securite,{$Securite/{w}*{h}}
-else
-resize[-1] {$Securite/{h}*{w}},$Securite
-endif
-endif
-polar2euclidean[-1] $X_center_PTE%,$Y_center_PTE%,1,1
-if {{$Type_Raccord==2}||{$Type_Raccord==3}}
-if {{w}>{h}}
Expension={round({{{w}-{h}}/2})}
-expand_y[-1] $Expension,1
-elif {{w}<{h}}
Expension={round({{{h}-{w}}/2})}
-expand_x[-1] $Expension,1
-endif
-endif
-if {$Angle_Rotation>0}
-if {{$Type_Raccord==2}||{$Type_Raccord==3}||{$Type_Raccord==4}}
-rotate[-1] $Angle_Rotation,0,1
-endif
-if {{$Type_Raccord==0}||{$Type_Raccord==1}}
-rotate[-1] $Angle_Rotation,0,0
-endif
-endif
-autocrop[-1] 0
-if {{{w}>$Securite}||{{h}>$Securite}}
-if {{w}>{h}}
-resize[-1] $Securite,{$Securite/{w}*{h}}
-else
-resize[-1] {$Securite/{h}*{w}},$Securite
-endif
-endif
-done
samj_rien_degradations :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Samj Ecraser Etirer : samj_Ecraser_Etirer , samj_Ecraser_Etirer_preview(0)
#@gui : note = note("<span foreground="orangered"><b><u>samj_Ecraser_Etirer</u></b></span>")
#@gui : Decoupage = int(12,2,32)
#@gui : Effet = choice(0,"Ecraser le Bas","Ecraser le Haut","Etirer le haut","Etirer le bas")
#@gui : Taille Origine = bool(0)
#@gui : Pivoter Image Origine 90 = bool(0)
#@gui : Pourcentage Step = float(100,1,300)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>samj</i>.      Latest update: <i>2018/04/25</i>.</small>")
samj_Ecraser_Etirer :
NbSplit=$1
Effet=$2
Step={$5/$NbSplit}
Loop=1
Largeur_Origine={w}
Hauteur_Origine={h}
-if {$4==1} permute yxzc -endif
split y,$NbSplit
repeat $NbSplit
-if {$Effet==0}
resize[-$Loop] 100%,{$Step*$Loop}%
-elif {$Effet==1}
resize[-{$NbSplit+1-$Loop}] 100%,{$Step*$Loop}%
-elif {$Effet==2}
resize[-$Loop] 100%,{100+{$Step*$Loop}}%
-elif {$Effet==3}
resize[-{$NbSplit+1-$Loop}] 100%,{100+{$Step*$Loop}}%
-endif
Loop={$Loop+1}
done
append y
-if {$3==1} resize $Largeur_Origine,$Hauteur_Origine -endif
-if {$4==1} permute yxzc -endif
samj_Ecraser_Etirer_preview :
gui_split_preview "samj_Ecraser_Etirer $*",$-1
#@gui Samj Ecraser Etirer V2 : samj_Ecraser_Etirer_V2 , samj_Ecraser_Etirer_V2_preview(0)
#@gui : note = note("<span foreground="orangered"><b><u>samj_Ecraser_Etirer_V2</u></b></span>")
#@gui : Decoupage = int(12,2,32)
#@gui : Effet = choice(0,"A","B","C","D")
#@gui : Taille Origine = bool(0)
#@gui : Pourcentage Step = float(100,1,300)
#@gui : Pourcentage Decoupe = float(50,25,75)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>samj</i>.      Latest update: <i>2018/04/25</i>.</small>")
samj_Ecraser_Etirer_V2 :
Pourcentage_Decoupe=$5
Largeur_Origine={w}
Hauteur_Origine={h}
-if {{$2==0}||{$2==1}}
--Je_passe_l_hiver_en_Floride[-1]
crop[-1] 100%,$Pourcentage_Decoupe%
mirror[-2] x
crop[-2] 100%,{100-$Pourcentage_Decoupe}%
mirror[-2] x
-if {$2==1} mirror[-1,-2] x -endif
samj_Ecraser_Etirer[-1] $1,0,0,1,$4
samj_Ecraser_Etirer[-2] $1,1,0,1,$4
-if {$2==1} mirror[-1,-2] x -endif
append[-1,-2] x
-elif {{$2==2}||{$2==3}}
permute[-1] yxzc
--Je_passe_l_hiver_en_Floride[-1]
crop[-1] 100%,$Pourcentage_Decoupe%
mirror[-2] x
crop[-2] 100%,{100-$Pourcentage_Decoupe}%
mirror[-2] x
-if {$2==3} mirror[-1,-2] x -endif
samj_Ecraser_Etirer[-1] $1,0,0,1,$4
samj_Ecraser_Etirer[-2] $1,1,0,1,$4
-if {$2==3} mirror[-1,-2] x -endif
append[-1,-2] x
permute[-1] yxzc
-endif
-if {$3==1} resize $Largeur_Origine,$Hauteur_Origine -endif
samj_Ecraser_Etirer_V2_preview :
gui_split_preview "samj_Ecraser_Etirer_V2 $*",$-1
#@gui _
#@gui <i>Degradations</i>
#@gui Deteriorated Areas : samj_Zones_Grises_en, samj_Zones_Grises_en(1)
#@gui : note = note("<span foreground="orangered"><small>Contours</small></span>")
#@gui : Iterations = int(3,1,10)
#@gui : Type = choice(0,"A","B","C")
#@gui : Variations = float(3,1,10)
#@gui : note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Iterations = int(4,1,8)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.        Latest Update: <i>2015/04/04</i>.</small>")
samj_Zones_Grises_en :
-samj_Zones_Grises $1,$2,$3,$4,$5
#@gui Path Et Solidify : samj_Degradations_Path_Solidify , samj_Degradations_Path_Solidify (1)
#@gui : sep = separator(), note = note("<span foreground="orangered">samj_Degradations_Path_Solidify</span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Degradations Image Origine</b></span>")
#@gui : Pixelise = int(0,0,32)
#@gui : Spread = int(0,0,32)
#@gui : Deform = int(0,0,10)
#@gui : Isophotes = int(0,0,15)
#@gui : Blur = float(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Path</b></span>")
#@gui : Patch Type = choice(2,"Max Patch","Min Patch","Max et Min Path")
#@gui : Valeur Patch = int(10,1,50)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Degradations Apres Path</b></span>")
#@gui : Dilate Type = choice(1,"Dilate Circ","Dilate")
#@gui : Valeur Dilate = int(0,0,16)
#@gui : sep = separator()
#@gui : Valeur Erode = int(0,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Solidify</b></span>")
#@gui : Valider Solidify = bool(1)
#@gui : Smoothness % = float(75,0,100)
#@gui : Diffusion Type = choice(0,"Isotropic","Delaunay Oriented","Edge Oriented")
#@gui : Diffusion Iter = int(20,1,200)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2017/01/06</i>.</small>")
samj_Degradations_Path_Solidify :
Val_Pixelise=$1
Val_Spread=$2
Val_Deform=$3
Val_Isophotes=$4
Val_Blur=$5
Patch_Type=$6
Valeur_Patch=$7
Dilate_Type=$8
Valeur_Dilate=$9
Valeur_Erode=$10
Valider_Solidify=$11
smoothness=$12
diffusion_type=$13
diffusion_iter=$14
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-if {$Val_Pixelise>0} -pixelize[-1] {$Val_Pixelise+1},{$Val_Pixelise+1} -endif
-if {$Val_Spread>0} -spread[-1] $Val_Spread -endif
-if {$Val_Deform>0} -deform[-1] $Val_Deform -endif
-if {$Val_Isophotes>0} -isophotes[-1] {$Val_Isophotes+2} -replace_color[-1] 100%,0,0,0,0,0,0,0,0,255 -endif
-if {$Val_Blur>0} -blur[-1] $Val_Blur -endif
-to_rgb[-1]
-if {$Patch_Type==2}
--Je_passe_l_hiver_en_Floride[-1]
-max_patch[-1] $Valeur_Patch
-min_patch[-2] $Valeur_Patch
-blend[-1,-2] add
-elif {$Patch_Type==1}
-min_patch[-1] $Valeur_Patch
-elif {$Patch_Type==0}
-max_patch[-1] $Valeur_Patch
-endif
-n[-1] 0,255
-to_rgba[-1]
-if {$Valeur_Dilate>0}
-if {$Dilate_Type==0}
-dilate_circ[-1] {$Valeur_Dilate+1}
-elif {$Dilate_Type==1}
-dilate[-1] {$Valeur_Dilate+1}
-endif
-endif
-if {$Valeur_Erode>0} -erode[-1] $Valeur_Erode -endif
-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
-reverse[-1,-2]
-blend[-1,-2] alpha
-if {$Valider_Solidify==1} -solidify[-1] $smoothness,$diffusion_type,$diffusion_iter -endif
#@gui Random Plasma : samj_Random_Plasma, samj_Random_Plasma(1)
#@gui : note = note("samj_Random_Plasma")
#@gui : Random Colors = int(0,0,4)
#@gui : Blur = int(80,20,120)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/11/05</i>.</small>")
samj_Random_Plasma :
Melange=$1
Flou=$2
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-blur[-1] {{{w}+{h}}/$Flou}
--Je_passe_l_hiver_en_Floride[-1]
-plasma[-1] 1,1,10
-blur[-1] {{{w}+{h}}/$Flou}
#gimp_blend_seamless
-blend_seamless[-2,-1] 1,0,25%
-if {$Melange==0}
-_gb_bwd_version_1_7_8[-1] 1
-elif {$Melange==1}
-_gb_bwd_version_1_7_8[-1] 2
-elif {$Melange==2}
-_gb_bwd_version_1_7_8[-1,-2] 1
-elif {$Melange==3}
-_gb_bwd_version_1_7_8[-1,-2] 2
-endif
#-fx_blend_edges[-2,-1] 1,5,0
-blend_edges[-2,-1] 5
-blend[-1,-2] alpha
_gb_bwd_version_1_7_8 :
-to_color
-if {$1==1} -repeat $! -l[$>] -sh 0,2 -rgb2srgb. -rm. -endl -done
-elif {$1==2} -repeat $! -l[$>] -sh 0,2 -lab2rgb. -rgb2srgb. -rm. -endl -done
-endif
#@gui Samj Ellipses Inpaint : samj_Ellipses_Inpaint, samj_Ellipses_Inpaint(1)
#@gui : note = note("samj_Ellipses_Inpaint")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite = color(0,0,0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ellipse</b></span>")
#@gui : Rayon L = int(8,1,32)
#@gui : Rayon H = int(8,1,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(2,"A","Inverser","A + Inverser")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Random Degradation</b></span>")
#@gui : Degradation = bool(0)
#@gui : Sponge = int(10,1,16)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/11</i>.</small>")
samj_Ellipses_Inpaint :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Rayon_L=$4
Rayon_H=$5
Rendu=$6
Flou_Effet_Sponge=$7
Valeur_Effet_Sponge=$8
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
Hauteur=$Rayon_H
Largeur=$Rayon_L
-to_rgba[-1]
$Largeur_Origine,$Hauteur_Origine,1,4
-repeat {$Largeur_Origine/{$Rayon_L+$Rayon_L}}
-repeat {$Hauteur_Origine/{$Rayon_H+$Rayon_H}}
couleur_pixel=${-at_ancien[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
-endif
-endif
Hauteur={$Hauteur+$Rayon_H+$Rayon_H}
-done
Largeur={$Largeur+$Rayon_L+$Rayon_L}
Hauteur=$Rayon_H
-done
-if {$Flou_Effet_Sponge==1} -sponge[-1] $Valeur_Effet_Sponge -endif
-inpaint[-2] [-1]
-rm[-1]
-samj_Wavelet_Sharpen_Test[-1] 1
#@gui Samj Zones Grises : samj_Zones_Grises, samj_Zones_Grises(1)
#@gui : note = note("samj_Zones_Grises / Deteriorated Areas")
#@gui : note = note("<span foreground="orangered"><small>Contours</small></span>")
#@gui : It\303\251rations = int(3,1,10)
#@gui : Type = choice(0,"A","B","C")
#@gui : Variations = float(3,1,10)
#@gui : note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : It\303\251rations = int(4,1,8)
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>.      Derni\303\250re mise \303\240 jour : <i>2015/04/04</i>.</small>")
samj_Zones_Grises :
Iterations_Contours=$1
Choice_Contours=$2
Variations_Contours=$3
Iterations_Blend=$4
Opacite_Blend=$5
-to_rgb[-1]
-repeat $Iterations_Blend
--Je_passe_l_hiver_en_Floride[-1]
-done
-repeat $Iterations_Contours
-if {$Choice_Contours==0}
-fx_curvature[-1] $Variations_Contours,0,100,0,0,0
-elif {$Choice_Contours==1}
-dog[-1] {5000/$Variations_Contours},0
-elif {$Choice_Contours==2}
-fx_edges[-1] 0,{2*$Variations_Contours},0,0
-endif
-done
-equalize[-1]
-fx_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-to_rgb[-1]
-repeat $Iterations_Blend
-fx_blend_edges[-1,-2] $Opacite_Blend,5,0
-done
samj_rien_details :
-Je_passe_l_hiver_en_Floride[-1]
#@gui _
#@gui <i>Details</i>
#@gui Samj Antialias Wavelet : samj_Antialias_Wavelet , samj_Antialias_Wavelet (0)
#@gui : note = note("<span foreground="orangered"><small>Pour dessins avec crenelage</small></span>")
#@gui : Flou = int(40,0,255)
#@gui : Trait = int(0,0,255)
#@gui : Cut Bas = int(127,0,255)
#@gui : Cut Haut = int(255,0,255)
#@gui : Dilate Circle W = int(1,1,3)
#@gui : Nettete = int(60,0,128)
#@gui : Dilate Circle R = int(1,1,3)
#@gui : Normaliser = bool(1)
#@gui : It\303\251rations = int(1,1,3)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/17</i>.</small>")
samj_Antialias_Wavelet  :
Flou=$1
Trait=$2
Cut_Bas=$3
Cut_Haut=$4
Dilate_Circle_W=$5
Nettete=$6
Dilate_Circle_R=$7
Normaliser=$8
Iterations_Contours=$9
-repeat $Iterations_Contours
-fx_split_details_wavelets[-1] 2,0,0
-blur[-2] $Flou
-if {$Trait>0} -add[-2] $Trait -endif
-c[-2] $Cut_Bas,$Cut_Haut
-if {$Dilate_Circle_W>1} -dilate_circ[-1] $Dilate_Circle_W -endif
-blend[-1,-2] grainmerge
-sharpen[-1] $Nettete
-done
-if {$Dilate_Circle_R>1} -dilate_circ[-1] $Dilate_Circle_R -endif
-if {$Normaliser==1} -n[-1] 0,255 -endif
-gui_set_layer_mode[-1] normal
#@gui Sharpen [Wavelet] : samj_Wavelet_Sharpen_Test_en, samj_Wavelet_Sharpen_Test_en(1)
#@gui : note = note("Test")
#@gui : Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Iterations = int(0,0,2)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/11/07</i>.</small>")
samj_Wavelet_Sharpen_Test_en :
-repeat {$2+1}
-if {$1==0}
-fx_split_details_wavelets[-1] 2,0,0
--Je_passe_l_hiver_en_Floride[-2]
-blend[-1,-3] grainmerge
-blend[-1,-2] grainmerge
-elif {$1==1}
-fx_split_details_wavelets[-1] 6,0,0
--Je_passe_l_hiver_en_Floride[-6]
-blend[-1,-7] grainmerge
-blend[-6,-5] grainmerge
--Je_passe_l_hiver_en_Floride[-3]
-blend[-1,-6] grainmerge
-blend[-5,-4] grainmerge
-blend[-4,-3] grainmerge
-blend[-3,-2] grainmerge
-blend[-1,-2] grainmerge
-endif
-done
-gui_set_layer_mode[-1] normal
#@gui Wavelet Sharpen Test : samj_Wavelet_Sharpen_Test, samj_Wavelet_Sharpen_Test(1)
#@gui : note = note("samj_Wavelet_Sharpen_Test")
#@gui : note = note("gimp_split_details_wavelets 2,0,0")
#@gui : Iterations = int(1,1,4)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/11/06</i>.</small>")
samj_Wavelet_Sharpen_Test :
Repetition=$1
-repeat $Repetition
-fx_split_details_wavelets[-1] 2,0,0
--Je_passe_l_hiver_en_Floride[-2]
-blend[-1,-3] grainmerge
-blend[-1,-2] grainmerge
-done
-gui_set_layer_mode[-1] normal
samj_rien_frames :
-Je_passe_l_hiver_en_Floride[-1]
#@gui _
#@gui <i>Frames</i>
#@gui Samj At06B 2017 Frame Painting : samj_At06A_2017_frame_painting, samj_At06A_2017_frame_painting(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Frame</b></span>")
#@gui : Size (%) = float(10,0,100)
#@gui : Contrast = float(0.4,0,1)
#@gui : Smoothness = float(6,0,30)
#@gui : Color = color(127,127,127)
#@gui : Vignette Size = float(2,0,50)
#@gui : Vignette Contrast = float(400,0,1000)
#@gui : Defects Contrast = float(50,0,512)
#@gui : Defects Density = float(10,0,100)
#@gui : Defects Size = float(1,0,10)
#@gui : Defects Smoothness = float(0.5,0,20)
#@gui : Serial Number = int(123456,0,1000000)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend GMIC</b></span>")
#@gui : Mode = choice{35,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : Reverse = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Frame Color Variation</b></span>")
#@gui : Pow = float(1,0,8)
#@gui : Cut A % = float(0,0,100)
#@gui : Cut B % = float(100,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233; + modification samj</i>.      Latest update: <i>2017/02/23</i>.</small>")
samj_At06A_2017_frame_painting:
Blend_Mode=$14
Blend_Opacity=$15
Blend_Reverse=$16
Largeur={w}
Hauteur={h}
-to_rgba[-1]
$Largeur,$Hauteur,1,4
-frame_painting[-1] $1%,$2,$3%,${4-6},$7%,${8-13}
-resize[-1] $Largeur,$Hauteur
-pow[-1] $17
-n[-1] 0,{{iM}-{im}}
-c[-1] {{iM}/100*$18},{iM}
-n[-1] 0,{iM}
-c[-1] 0,{{iM}/100*$19}
-n[-1] 0,255
-if {$Blend_Reverse==0} -reverse[-1,-2] -endif
-gimp_blend_1651[-2,-1] $Blend_Mode,2,$Blend_Opacity,0
samj_rien_layers :
-Je_passe_l_hiver_en_Floride[-1]
samj_rien_lights_and_shadows :
-Je_passe_l_hiver_en_Floride[-1]
#@gui _
#@gui <i>Lights &amp; Shadows</i>
#@gui Samj Ombre Portee : samj_Ombre_Portee , samj_Ombre_Portee (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : QuA = int(0,0,100)
#@gui : FlA = float(0,0,10)
#@gui : InvC = bool(0)
#@gui : Limite D\303\251tails = int(128,1,255)
#@gui : Dilate = int(0,0,8)
#@gui : Couleur Avant = color(0,0,0,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Couleur Ombre = color(127,127,127,255)
#@gui : D\303\251calage Ombre = int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Flou</b></span>")
#@gui : Flou/Blur = float(0.1,0,2)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/28</i>.</small>")
samj_Ombre_Portee :
QuA=$1
FlA=$2
InvC=$3
Limite=$4
Dilatation=$5
R_a=$6
V_a=$7
B_a=$8
A_a=$9
R_b=$10
V_b=$11
B_b=$12
A_b=$13
VA=$14
Type_Rendu=$15
R_c=$16
V_c=$17
B_c=$18
A_c=$19
Flou=$20
Largeur_Origine={w}
Hauteur_Origine={h}
-if {$QuA>0} -quantize[-1] {$QuA+7},1,1 -endif
-blur[-1] $FlA
-if {$InvC==1} -negate[-1] -endif
-to_rgba[-1]
-luminance[-1]
-to_rgba[-1]
-n[-1] 0,255
-c[-1] 0,$Limite
-n[-1] 0,255
-c[-1] {255-$Limite},255
-n[-1] 0,255
-ditheredbw[-1]
-dilate[-1] {$Dilatation+1}
-to_rgba[-1]
-replace_color[-1] 100%,0,255,255,255,255,0,0,0,0
--Je_passe_l_hiver_en_Floride[-1]
-replace_color[-1] 100%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a
-replace_color[-2] 100%,0,0,0,0,255,$R_b,$V_b,$B_b,$A_b
-if {$Type_Rendu==1}
-shift[-2] 0,0,0,0,0
-elif {$Type_Rendu==2}
-shift[-2] $VA,0,0,0,0
-elif {$Type_Rendu==3}
-shift[-2] 0,$VA,0,0,0
-elif {$Type_Rendu==4}
-shift[-2] $VA,$VA,0,0,0
-elif {$Type_Rendu==5}
-shift[-2] {-$VA},0,0,0,0
-elif {$Type_Rendu==6}
-shift[-2] 0,{-$VA},0,0,0
-elif {$Type_Rendu==7}
-shift[-2] {-$VA},{-$VA},0,0,0
-endif
-crop[-2] 0,0,{{w}-1},{{h}-1}
-if {$Flou>0} -blur[-1] $Flou -blur[-2] {$Flou+1} -endif
-blend[-1,-2] alpha
{w},{h},1,4
-fill_color[-1] $R_c,$V_c,$B_c,$A_c
-reverse[-1,-2]
-blend[-1,-2] alpha
samj_rien_patterns :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Samj Ombre Portee B : samj_Ombre_Portee_B , samj_Ombre_Portee_B (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Resolution = int(16,4,64)
#@gui : Limite D\303\251tails = int(128,1,255)
#@gui : Supprimer Noir = bool(0)
#@gui : Contour = bool(1)
#@gui : Variation Contour = int(16,-127,127)
#@gui : Clair Fonc\303\251 = float(1,0,2)
#@gui : Pr\303\251cision Blanc = float(0,0,1)
#@gui : Pr\303\251cision Noir = float(0,0,1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Couleur Ombre = color(127,127,127,255)
#@gui : Dilate = int(2,0,16)
#@gui : Flou/Blur = float(2,0,10)
#@gui : D\303\251calage Ombre = int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/01</i>.</small>")
samj_Ombre_Portee_B :
Resolution=$1
Limite=$2
Supprimer_Noir=$3
Contour=$4
Variation_Contour=$5
Clair_Fonce=$6
Precision_Blanc=$7
Precision_Noir=$8
R_a=$9
V_a=$10
B_a=$11
A_a=$12
Dilatation=$13
Flou=$14
VA=$15
Type_Rendu=$16
R_b=$17
V_b=$18
B_b=$19
A_b=$20
Largeur_A={round({{w}/$Resolution})}
Hauteur_A={round({{h}/$Resolution})}
OrigineH=0
OrigineV={-$Resolution}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0
-to_rgba[-1]
-resize[-1] $Largeur_A,$Hauteur_A
-resize[-1] {$Largeur_A*$Resolution},{$Hauteur_A*$Resolution}
-luminance[-1]
-to_rgba[-1]
-n[-1] 0,255
-c[-1] 0,$Limite
-n[-1] 0,255
-c[-1] {255-$Limite},255
-n[-1] 0,255
-replace_color[-1] 100,$Precision_Blanc,255,255,255,255,0,0,0,0
-if {$Supprimer_Noir==1}
-replace_color[-1] 100,$Precision_Noir,0,0,0,255,0,0,0,0
-endif
-mul[-1] $Clair_Fonce
{$Largeur_A*$Resolution},{$Hauteur_A*$Resolution},1,4
-reverse[-1,-2]
-repeat $Hauteur_A
OrigineH=0
OrigineV={$OrigineV+$Resolution}
-repeat $Largeur_A
couleur_pixel={I($OrigineH,$OrigineV)}
rouge_pixel={arg(1,$couleur_pixel)}
vert_pixel={arg(2,$couleur_pixel)}
bleu_pixel={arg(3,$couleur_pixel)}
alpha_pixel={arg(4,$couleur_pixel)}
-if {$alpha_pixel>0}
-rectangle[-2] $OrigineH,$OrigineV,{$OrigineH+$Resolution},{$OrigineV+$Resolution},1,$R_a,$V_a,$B_a,$A_a
-if {$Contour==1}
-rectangle[-1] $OrigineH,$OrigineV,{$OrigineH+$Resolution-1},{$OrigineV+$Resolution-1},1,0xFFFFFFFF,{{$rouge_pixel/2}+$Variation_Contour},{{$vert_pixel/2}+$Variation_Contour},{{$bleu_pixel/2}+$Variation_Contour},255
-endif
-endif
OrigineH={$OrigineH+$Resolution}
-done
-done
-dilate[-2] $Dilatation
-blur[-2] $Flou
-if {$Type_Rendu==1}
-shift[-2] 0,0,0,0,0
-elif {$Type_Rendu==2}
-shift[-2] $VA,0,0,0,0
-elif {$Type_Rendu==3}
-shift[-2] 0,$VA,0,0,0
-elif {$Type_Rendu==4}
-shift[-2] $VA,$VA,0,0,0
-elif {$Type_Rendu==5}
-shift[-2] {-$VA},0,0,0,0
-elif {$Type_Rendu==6}
-shift[-2] 0,{-$VA},0,0,0
-elif {$Type_Rendu==7}
-shift[-2] {-$VA},{-$VA},0,0,0
-endif
-crop[-2] 0,0,{{w}-1},{{h}-1}
-blend[-1,-2] alpha
{$Largeur_A*$Resolution},{$Hauteur_A*$Resolution},1,4
-fill_color[-1] $R_b,$V_b,$B_b,$A_b
-reverse[-1,-2]
-blend[-1,-2] alpha
#@gui Samj Ombre Portee C : samj_Ombre_Portee_C , samj_Ombre_Portee_C (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Isophotes = int(32,4,64)
#@gui : Dilatation = int(8,1,64)
#@gui : note = note("<span foreground="blue"><small><i><b>samj_Ombre_Portee_B</b></i></small></span>")
#@gui : Resolution = int(16,4,64)
#@gui : Limite D\303\251tails = int(192,1,255)
#@gui : Supprimer Noir = bool(0)
#@gui : Contour = bool(1)
#@gui : Variation Contour = int(16,-127,127)
#@gui : Clair Fonc\303\251 = float(1,0,2)
#@gui : Pr\303\251cision Blanc = float(0,0,1)
#@gui : Pr\303\251cision Noir = float(0,0,1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Couleur Ombre = color(96,96,96,255)
#@gui : Dilate = int(2,0,16)
#@gui : Flou/Blur = float(2,0,10)
#@gui : D\303\251calage Ombre = int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/01</i>.</small>")
samj_Ombre_Portee_C :
-isophotes[-1] $1
-dilate_circ[-1] $2
-samj_Ombre_Portee_B[-1] $3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22
#@gui Samj Ombre Portee D : samj_Ombre_Portee_D , samj_Ombre_Portee_D (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Avant Plan</b></span>")
#@gui : R\303\251solution = int(16,4,64)
#@gui : D\303\251tection A = int(64,0,255)
#@gui : D\303\251tection B = int(64,0,255)
#@gui : Flou Lissage = float(2,0,10)
#@gui : Couleur = float(1,0,4)
#@gui : Isophotes AP = int(16,4,64)
#@gui : Dilate AP = int(5,0,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Contours Avant Plan</b></span>")
#@gui : Contour = bool(1)
#@gui : Variation Contour = int(-32,-127,127)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Dilate = int(4,0,16)
#@gui : Couleur Ombre = float(1,0,4)
#@gui : Flou/Blur = float(2,0,10)
#@gui : D\303\251calage Ombre = int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/03</i>.</small>")
samj_Ombre_Portee_D :
Resolution=$1
Detection_A=$2
Detection_B=$3
Flou_Lissage=$4
Couleur=$5
Isophotes_AP=$6
Dilate_AP=$7
Contour=$8
Variation_Contour=$9
Dilatation_ombre=$10
Couleur_Ombre=$11
Flou_Ombre=$12
VA=$13
Type_Rendu=$14
R_a=$15
V_a=$16
B_a=$17
A_a=$18
Largeur_A={round({{w}/$Resolution})}
Hauteur_A={round({{h}/$Resolution})}
OrigineH=0
OrigineV={-$Resolution}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0
-blur $Flou_Lissage
-c[-1] 0,255
-n[-1] 0,255
-c[-1] $Detection_A,{255-$Detection_B}
-n[-1] 0,255
-mul[-1] $Couleur
-isophotes[-1] $Isophotes_AP
-dilate[-1] $Dilate_AP
-resize[-1] $Largeur_A,$Hauteur_A
-resize[-1] {$Largeur_A*$Resolution},{$Hauteur_A*$Resolution}
-repeat $Hauteur_A
OrigineH=0
OrigineV={$OrigineV+$Resolution}
-repeat $Largeur_A
couleur_pixel={I($OrigineH,$OrigineV)}
rouge_pixel={arg(1,$couleur_pixel)}
vert_pixel={arg(2,$couleur_pixel)}
bleu_pixel={arg(3,$couleur_pixel)}
alpha_pixel={arg(4,$couleur_pixel)}
-if {$alpha_pixel>0}
-rectangle[-1] $OrigineH,$OrigineV,{$OrigineH+$Resolution-1},{$OrigineV+$Resolution-1},1,$rouge_pixel,$vert_pixel,$bleu_pixel,255
-if {$Contour==1}
-rectangle[-1] $OrigineH,$OrigineV,{$OrigineH+$Resolution-1},{$OrigineV+$Resolution-1},1,0xFFFFFFFF,{{$rouge_pixel/2}+$Variation_Contour},{{$vert_pixel/2}+$Variation_Contour},{{$bleu_pixel/2}+$Variation_Contour},255
-endif
-endif
OrigineH={$OrigineH+$Resolution}
-done
-done
--Je_passe_l_hiver_en_Floride[-1]
-to_graya[-1]
-dilate[-1] $Dilatation_ombre
-mul[-1] $Couleur_Ombre
-blur[-1] $Flou_Ombre
-if {$Type_Rendu==1}
-shift[-1] 0,0,0,0,0
-elif {$Type_Rendu==2}
-shift[-1] $VA,0,0,0,0
-elif {$Type_Rendu==3}
-shift[-1] 0,$VA,0,0,0
-elif {$Type_Rendu==4}
-shift[-1] $VA,$VA,0,0,0
-elif {$Type_Rendu==5}
-shift[-1] {-$VA},0,0,0,0
-elif {$Type_Rendu==6}
-shift[-1] 0,{-$VA},0,0,0
-elif {$Type_Rendu==7}
-shift[-1] {-$VA},{-$VA},0,0,0
-endif
-crop[-1] 0,0,{{w}-1},{{h}-1}
-reverse[-1,-2]
-blend[-1,-2] alpha
{$Largeur_A*$Resolution},{$Hauteur_A*$Resolution},1,4
-fill_color[-1] $R_a,$V_a,$B_a,$A_a
-reverse[-1,-2]
-blend[-1,-2] alpha
#@gui _
#@gui <i>Patterns</i>
#@gui Degrades HSL TSL : samj_Degrades_HSL_TSL, samj_Degrades_HSL_TSL(1)
#@gui : sep = separator(), note = note("<small>Rendu</small>")
#@gui : Type D\303\251grad\303\251 = choice(4,"V Couleur A","H Couleur A","V Couleur B","H Couleur B","V Couleurs A/B","H Couleurs A/B","V Couleurs A/B Inv.","H Couleurs A/B Inv.")
#@gui : Dimensions Image = int(800,128,2048)
#@gui : Couleur A = color(240,240,40,255)
#@gui : Couleur B = color(120,40,240,255)
#@gui : D\303\251calage H = float(0,0,360)
#@gui : D\303\251calage S = float(0,0,100)
#@gui : D\303\251calage L = float(0,0,100)
#@gui : Variation H = float(360,1,360)
#@gui : Variation S = float(100,1,100)
#@gui : Variation L = float(100,1,100)
#@gui : Valider Variations Canal Alpha = bool(0)
#@gui : D\303\251grad\303\251s Al\303\251atoires = bool(0)
#@gui : H Min. Ded. Al\303\251a. = float(0,0,718)
#@gui : H Max. Ded. Al\303\251a. = float(718,0,718)
#@gui : S Min. Ded. Al\303\251a. = float(75,0,100)
#@gui : S Max. Ded. Al\303\251a. = float(100,0,100)
#@gui : L Min. Ded. Al\303\251a. = float(0,0,100)
#@gui : L Max. Ded. Al\303\251a. = float(100,0,100)
#@gui : Inverser D\303\251grad\303\251 = bool(0)
#@gui : Formes = choice(0,"Non","Sinus V - Param A B","Sinus H - Param A B","Cercles - Param A B","Rayons - Param A B","Lignes V Norm - Param A B","Lignes H Norm - Param A B","Plaid","Carre","Croix","Perspective - Param A","Sphere A","Sphere B")
#@gui : Param\303\250tre Forme A = int(0,0,100)
#@gui : Param\303\250tre Forme B = int(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/15</i>.</small>")
samj_Degrades_HSL_TSL :
Type_Degrade=$1
Dimensions=$2
Ra=$3
Ga=$4
Ba=$5
Aa=$6
Rb=$7
Gb=$8
Bb=$9
Ab=$10
Decalage_H=$11
Decalage_S=$12
Decalage_L=$13
Variation_H=$14
Variation_S=$15
Variation_L=$16
Valider_Variations_Canal_A=$17
Degrades_aleatoires=$18
H_Min_Ded_Alea=$19
H_Max_Ded_Alea=$20
S_Min_Ded_Alea=$21
S_Max_Ded_Alea=$22
L_Min_Ded_Alea=$23
L_Max_Ded_Alea=$24
Inverser_Degrade=$25
Variations_Formes=$26
Parametre_Forme_A=$27
Parametre_Forme_B=$28
Nb_Boucles=0
Inc_H=0
Inc_S=0
Inc_L=0
Inc_A=0
Diff=0
Temp=0
-if {$Variations_Formes==1}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==2}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==3}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
Valider_Variations_Canal_A=0
-elif {$Variations_Formes==4}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
Valider_Variations_Canal_A=0
-elif {$Variations_Formes==5}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==6}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==7}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==8}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==9}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==10}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==11}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==12}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-endif
# Conversions RGB > HSL   http://www.rapidtables.com/convert/color/rgb-to-hsl.htm
# couleur a
var_Ra={$Ra/255}
var_Ga={$Ga/255}
var_Ba={$Ba/255}
var_Mina={min($var_Ra,$var_Ga,$var_Ba)}
var_Maxa={max($var_Ra,$var_Ga,$var_Ba)}
var_diffa={$var_Maxa-$var_Mina}
-if {{$var_Maxa}=={$var_Mina}}
Ha=0
-elif {{$var_Maxa}=={$var_Ra}}
Ha={{{$var_Ga-$var_Ba}/$var_diffa}%6}
-elif {{$var_Maxa}=={$var_Ga}}
Ha={{$var_Ba-$var_Ra}/$var_diffa+2}
-else
Ha={{$var_Ra-$var_Ga}/$var_diffa+4}
-endif
Ha={$Ha*60}
-if {$Ha<0}
Ha={$Ha+360}
-endif
La={{$var_Maxa+$var_Mina}/2}
-if {$var_diffa==0}
Sa=0
-else
Sa={$var_diffa/{1-{abs({2*$La-1})}}}
-endif
Sa={$Sa*100}
La={$La*100}
# couleur b
var_Rb={$Rb/255}
var_Gb={$Gb/255}
var_Bb={$Bb/255}
var_Minb={min($var_Rb,$var_Gb,$var_Bb)}
var_Maxb={max($var_Rb,$var_Gb,$var_Bb)}
var_diffb={$var_Maxb-$var_Minb}
-if {{$var_Maxb}=={$var_Minb}}
Hb=0
-elif {{$var_Maxb}=={$var_Rb}}
Hb={{{$var_Gb-$var_Bb}/$var_diffb}%6}
-elif {{$var_Maxb}=={$var_Gb}}
Hb={{$var_Bb-$var_Rb}/$var_diffb+2}
-else
Hb={{$var_Rb-$var_Gb}/$var_diffb+4}
-endif
Hb={$Hb*60}
-if {$Hb<0}
Hb={$Hb+360}
-endif
Lb={{$var_Maxb+$var_Minb}/2}
-if {$var_diffb==0}
Sb=0
-else
Sb={$var_diffb/{1-{abs({2*$Lb-1})}}}
-endif
Sb={$Sb*100}
Lb={$Lb*100}
# FIN Conversions RGB > HSL
-rm[-1]
-if {{$Type_Degrade==0}||{$Type_Degrade==1}||{$Type_Degrade==2}||{$Type_Degrade==3}}
-if {{$Type_Degrade==2}||{$Type_Degrade==3}}
Ha=$Hb
Sa=$Sb
La=$Lb
Aa=$Ab
-endif
Nb_Boucles=0
Inc_H={$Variation_H/$Dimensions}
Sa={$Sa+$Decalage_S}
-if {$Sa>100}  Sa={$Sa-100} -endif
La={$La+$Decalage_L}
-if {$La>100}  La={$La-100} -endif
$Dimensions,$Dimensions,1,4
-repeat $Dimensions
-if {$Degrades_aleatoires==1}
-if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0}
-if {{$H_Max_Ded_Alea}>{$H_Min_Ded_Alea}} Ha={round(u($H_Min_Ded_Alea,$H_Max_Ded_Alea))} -else Ha={round(u($H_Max_Ded_Alea,$H_Min_Ded_Alea))} -endif
-if {{$S_Max_Ded_Alea}>{$S_Min_Ded_Alea}} Sa={round(u($S_Min_Ded_Alea,$S_Max_Ded_Alea))} -else Sa={round(u($S_Max_Ded_Alea,$S_Min_Ded_Alea))} -endif
-if {{$L_Max_Ded_Alea}>{$L_Min_Ded_Alea}} La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} -else La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} -endif
-endif
-endif
-if {$Inverser_Degrade==0}
Ha_c={$Ha+$Decalage_H+{$Nb_Boucles*$Inc_H}}
-else
Ha_c={$Ha+$Decalage_H-{$Nb_Boucles*$Inc_H}}
-endif
-if {$Ha_c>359} Ha_c={$Ha_c-359} -endif
-if {$Ha_c<0} Ha_c={$Ha_c+359} -endif
Sa_c=$Sa
La_c=$La
-if {{$Ha_c}>=360} Ha_c=359 -endif
-if {{$Sa_c}>100} Sa_c=100 -endif
-if {{$La_c}>100} La_c=100 -endif
-if {{$Ha_c}<0} Ha_c=0 -endif
-if {{$Sa_c}<0} Sa_c=0 -endif
-if {{$La_c}<0} La_c=0 -endif
Sa_c={$Sa_c/100}
La_c={$La_c/100}
Ca={{1-{abs({2*$La_c-1})}}*$Sa_c}
hha={$Ha_c/60}
Xa={$Ca*{1-{abs({$hha%2-1})}}}
Ra_c=0
Ga_c=0
Ba_c=0
-if {{$hha>=0}&&{$hha<1}}
Ra_c=$Ca
Ga_c=$Xa
-elif {{$hha>=1}&&{$hha<2}}
Ra_c=$Xa
Ga_c=$Ca
-elif {{$hha>=2}&&{$hha<3}}
Ga_c=$Ca
Ba_c=$Xa
-elif {{$hha>=3}&&{$hha<4}}
Ga_c=$Xa
Ba_c=$Ca
-elif {{$hha>=4}&&{$hha<5}}
Ra_c=$Xa
Ba_c=$Ca
-else
Ra_c=$Ca
Ba_c=$Xa
-endif
ma={$La_c-$Ca/2}
Ra_c={{$Ra_c+$ma}*255}
Ga_c={{$Ga_c+$ma}*255}
Ba_c={{$Ba_c+$ma}*255}
-if {{$Type_Degrade==0}||{$Type_Degrade==2}}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Ra_c,$Ga_c,$Ba_c,$Aa
-elif {{$Type_Degrade==1}||{$Type_Degrade==3}}
-line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Ra_c,$Ga_c,$Ba_c,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
-endif
-if {{$Type_Degrade==4}||{$Type_Degrade==5}||{$Type_Degrade==6}||{$Type_Degrade==7}}
Nb_Boucles=0
-if {{$Type_Degrade==4}||{$Type_Degrade==5}}
-if {$Inverser_Degrade==0}
Inc_H={{$Ha-$Hb}/$Dimensions}
Inc_S={{$Sa-$Sb}/$Dimensions}
Inc_L={{$La-$Lb}/$Dimensions}
Inc_A={{$Aa-$Ab}/$Dimensions}
-else
Inc_H={-1*{{$Ha-$Hb}/$Dimensions}}
Inc_S={-1*{{$Sa-$Sb}/$Dimensions}}
Inc_L={-1*{{$La-$Lb}/$Dimensions}}
Inc_A={-1*{{$Aa-$Ab}/$Dimensions}}
-endif
-else
-if {$Inverser_Degrade==0}
Inc_H={-1*{{$Ha-$Hb}/$Dimensions}}
Inc_S={-1*{{$Sa-$Sb}/$Dimensions}}
Inc_L={-1*{{$La-$Lb}/$Dimensions}}
Inc_A={-1*{{$Aa-$Ab}/$Dimensions}}
-else
Inc_H={{$Ha-$Hb}/$Dimensions}
Inc_S={{$Sa-$Sb}/$Dimensions}
Inc_L={{$La-$Lb}/$Dimensions}
Inc_A={{$Aa-$Ab}/$Dimensions}
-endif
-endif
$Dimensions,$Dimensions,1,4
-repeat $Dimensions
-if {$Degrades_aleatoires==1}
-if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/10}))}}==0}
-if {{$H_Max_Ded_Alea}>{$H_Min_Ded_Alea}} Ha={round(u($H_Min_Ded_Alea,$H_Max_Ded_Alea))} -else Ha={round(u($H_Max_Ded_Alea,$H_Min_Ded_Alea))} -endif
-if {{$S_Max_Ded_Alea}>{$S_Min_Ded_Alea}} Sa={round(u($S_Min_Ded_Alea,$S_Max_Ded_Alea))} -else Sa={round(u($S_Max_Ded_Alea,$S_Min_Ded_Alea))} -endif
-if {{$L_Max_Ded_Alea}>{$L_Min_Ded_Alea}} La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} -else La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} -endif
-endif
-endif
-if {$Valider_Variations_Canal_A==1}
Aa={$Aa+$Inc_A}
-if {$Aa>255} Aa=255 Inc_A={-1*$Inc_A} -endif
-if {$Aa<0} Aa=0 Inc_A={-1*$Inc_A} -endif
-endif
Ha_c={$Ha+$Decalage_H+{$Nb_Boucles*$Inc_H}}
-if {$Ha_c>359} Ha_c={$Ha_c-359} -endif
-if {$Ha_c<0} Ha_c={$Ha_c+359} -endif
Sa_c={$Sa+$Decalage_S+{$Nb_Boucles*$Inc_S}}
-if {$Sa_c>100} Sa_c={$Sa_c-100} -endif
-if {$Sa_c<0} Sa_c={$Sa_c+100} -endif
La_c={$La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
-if {$La_c>100} La_c={$La_c-100} -endif
-if {$La_c<0} La_c={$La_c+100} -endif
-if {{$Ha_c}>=360} Ha_c=359 -endif
-if {{$Sa_c}>100} Sa_c=100 -endif
-if {{$La_c}>100} La_c=100 -endif
-if {{$Ha_c}<0} Ha_c=0 -endif
-if {{$Sa_c}<0} Sa_c=0 -endif
-if {{$La_c}<0} La_c=0 -endif
Sa_c={$Sa_c/100}
La_c={$La_c/100}
Ca={{1-{abs({2*$La_c-1})}}*$Sa_c}
hha={$Ha_c/60}
Xa={$Ca*{1-{abs({$hha%2-1})}}}
Ra_c=0
Ga_c=0
Ba_c=0
-if {{$hha>=0}&&{$hha<1}}
Ra_c=$Ca
Ga_c=$Xa
-elif {{$hha>=1}&&{$hha<2}}
Ra_c=$Xa
Ga_c=$Ca
-elif {{$hha>=2}&&{$hha<3}}
Ga_c=$Ca
Ba_c=$Xa
-elif {{$hha>=3}&&{$hha<4}}
Ga_c=$Xa
Ba_c=$Ca
-elif {{$hha>=4}&&{$hha<5}}
Ra_c=$Xa
Ba_c=$Ca
-else
Ra_c=$Ca
Ba_c=$Xa
-endif
ma={$La_c-$Ca/2}
Ra_c={{$Ra_c+$ma}*255}
Ga_c={{$Ga_c+$ma}*255}
Ba_c={{$Ba_c+$ma}*255}
-if {{$Type_Degrade==4}||{$Type_Degrade==6}}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Ra_c,$Ga_c,$Ba_c,$Aa
-elif {{$Type_Degrade==5}||{$Type_Degrade==7}}
-line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Ra_c,$Ga_c,$Ba_c,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
-endif
-if {$Variations_Formes==1}
-fx_custom_deformation[-1] "(w+h)/"{20+$Parametre_Forme_A}" * cos(y*"{10+$Parametre_Forme_B}"/h)","1",1,1,1
-elif {$Variations_Formes==2}
-fx_custom_deformation[-1] "1","(w+h)/"{20+$Parametre_Forme_A}" * sin(x*"{10+$Parametre_Forme_B}"/w)",1,1,1
-elif {$Variations_Formes==3}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==4}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==5}
-fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==6}
-fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==7}
-fx_plaid_texture[-1] 50,2,0,90,0,300
-elif {$Variations_Formes==8}
-fx_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==9}
-fx_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==10}
-fx_warp_perspective[-1] 1.73,0,1,50,50,$Parametre_Forme_A,0,2
-elif {$Variations_Formes==11}
-fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
-elif {$Variations_Formes==12}
-fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
-endif
#@gui Denim Texture : Denim_samj, Denim_samj(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Texture</small></span>")
#@gui : Dimension Motif Base = int(5,2,30)
#@gui : Dilatation Motif = int(2,0,5)
#@gui : Retourner Motif = bool(0)
#@gui : D\303\251formation 1 = int(40,0,200)
#@gui : D\303\251formation 2 = int(40,0,200)
#@gui : Denim [Bruit] = int(25,0,100)
#@gui : Usure [Bruit] = int(50,0,100)
#@gui : Nettet\303\251 = float(0,0,500)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Couleur</small></span>")
#@gui : Couleur Denim = color(43,108,126,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Version : <i>2015/03/31</i>.</small>")
Denim_samj :
Dimension_Motif=$1
Dilatation=$2
Retourner_motif=$3
Deformation_1=$4
Deformation_2=$5
Amplitude_Bruit=$6
Amplitude_Bruit_2=$7
Nettete=$8
R_Couleur_Denim=$9
V_Couleur_Denim=$10
B_Couleur_Denim=$11
A_Couleur_Denim=$12
Largeur={w}
Hauteur={h}
$Largeur,$Hauteur,1,4
-fill_color[-1] $R_Couleur_Denim,$V_Couleur_Denim,$B_Couleur_Denim,$A_Couleur_Denim
-to_rgba[-1]
-fx_noise[-1] $Amplitude_Bruit,0,11,0
$Dimension_Motif,$Dimension_Motif,1,4
-if {$Retourner_motif==0}
-line[-1] 0,$Dimension_Motif,$Dimension_Motif,0,1,0,0,0,255
-else
-line[-1] 0,0,$Dimension_Motif,$Dimension_Motif,1,0,0,0,255
-endif
-resize[-1] [-2],[-2],1,100%,0,2
-dilate_circ[-1] $Dilatation
#alpha
-blend[-1,-2] alpha,1,1
-water[-1] {$Deformation_1/1000},{$Deformation_2/100}
-fx_noise[-1] $Amplitude_Bruit_2,0,26,0
-sharpen[-1] $Nettete
-reverse[-2,-1]
-rm[-1]
#@gui Formes Couleurs Variees Dans Image : samj_Formes_Couleurs_Variees_Dans_Image, samj_Formes_Couleurs_Variees_Dans_Image(1)
#@gui : Formes = choice(0,"Sinus V - Param A B","Sinus H - Param A B","Cercles - Param A B","Rayons - Param A B","Lignes V","Lignes H","Tiled V - Param A B C D","Tiled H - Param A B C D","Lignes V Norm - Param A B","Lignes H Norm - Param A B","Plaid","Carre","Croix","Perspective - Param A","Sphere A","Sphere B")
#@gui : Param\303\250tre Forme A = int(0,0,100)
#@gui : Param\303\250tre Forme B = int(0,0,100)
#@gui : Param\303\250tre Forme C = int(0,0,100)
#@gui : Param\303\250tre Forme D = int(0,0,100)
#@gui : Canal R = int(192,0,255)
#@gui : Canal V = int(128,0,255)
#@gui : Canal B = int(64,0,255)
#@gui : Canal Alpha = int(255,0,255)
#@gui : Valider Variations Canal R = bool(1)
#@gui : Valider Variations Canal V = bool(1)
#@gui : Valider Variations Canal B = bool(1)
#@gui : Valider Variations Canal Alpha = bool(0)
#@gui : Type Variations =  choice(0,"A","B","C","D","E","F")
#@gui : D\303\251calage = int(127,0,255)
#@gui : Etendue = int(255,1,255)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Flou / Blur = float(0,0,5)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,200)
#@gui : Canal Alpha = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/15</i>.</small>")
samj_Formes_Couleurs_Variees_Dans_Image :
Variations_Formes=$1
Parametre_Forme_A=$2
Parametre_Forme_B=$3
Parametre_Forme_C=$4
Parametre_Forme_D=$5
Canal_R=$6
Canal_V=$7
Canal_B=$8
Canal_A=$9
Valider_Variations_Canal_R=$10
Valider_Variations_Canal_V=$11
Valider_Variations_Canal_B=$12
Valider_Variations_Canal_A=$13
Type_Variations=$14
Decalage=$15
Etendue=$16
Couleurs_aleatoires=$17
Flou=$18
Deformation=$19
Bruit=$20
Canal_Alpha=$21
Largeur_Origine={w}
Hauteur_Origine={h}
Total_Boucles=0
Nb_Boucle=0
Val_R=$Canal_R
Val_V=$Canal_V
Val_B=$Canal_B
Val_A=$Canal_A
R_imp=0
V_imp=0
B_imp=0
A_imp=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] 0,0,0,255
-if {{$Variations_Formes==0}||{$Variations_Formes==2}||{$Variations_Formes==4}||{$Variations_Formes==6}||{$Variations_Formes==8}||{$Variations_Formes==10}||{$Variations_Formes==11}||{$Variations_Formes==13}||{$Variations_Formes==14}}
Total_Boucles=$Largeur_Origine
-elif {{$Variations_Formes==1}||{$Variations_Formes==3}||{$Variations_Formes==5}||{$Variations_Formes==7}||{$Variations_Formes==9}||{$Variations_Formes==12}||{$Variations_Formes==15}}
Total_Boucles=$Hauteur_Origine
-endif
-repeat $Total_Boucles
-if {$Couleurs_aleatoires==1}
-if {$Decalage==0}
-if {{$Nb_Boucle%{round(u(1,255))}}==0}
Canal_R={round(u(0,255))}
Canal_V={round(u(0,255))}
Canal_B={round(u(0,255))}
Val_R=$Canal_R
Val_V=$Canal_V
Val_B=$Canal_B
-endif
-else
-if {{$Nb_Boucle%$Decalage}==0}
Canal_R={round(u(0,255))}
Canal_V={round(u(0,255))}
Canal_B={round(u(0,255))}
Val_R=$Canal_R
Val_V=$Canal_V
Val_B=$Canal_B
-endif
-endif
-endif
-if {$Valider_Variations_Canal_R==1}
-if {$Type_Variations==0}
Val_R={$Val_R+1}
-if {$Val_R>{$Canal_R+$Decalage} Val_R=$Canal_R -endif
R_imp={{$Val_R+$Decalage}%$Etendue}
-elif {$Type_Variations==1}
Val_R={$Val_R-1}
-if {$Val_R<{$Canal_R-$Decalage} Val_R=$Canal_R -endif
R_imp={{$Val_R-$Decalage}%$Etendue}
-elif {$Type_Variations==2}
Val_R={$Val_R+1}
-if {$Val_R>255 Val_R=$Canal_R -endif
R_imp={{$Val_R+$Decalage}%$Etendue}
-elif {$Type_Variations==3}
Val_R={$Val_R-1}
-if {$Val_R<0 Val_R=$Canal_R -endif
R_imp={{$Val_R-$Decalage}%$Etendue}
-elif {$Type_Variations==4}
Val_R={$Val_R+{round(u(0,3))}}
-if {$Val_R>255 Val_R=$Canal_R -endif
R_imp={{$Val_R+$Decalage}%$Etendue}
-elif {$Type_Variations==5}
Val_R={$Val_R-{round(u(0,3))}}
-if {$Val_R<0 Val_R=$Canal_R -endif
R_imp={{$Val_R-$Decalage}%$Etendue}
-endif
-else
R_imp=$Canal_R
-endif
-if {$Valider_Variations_Canal_V==1}
-if {$Type_Variations==0}
Val_V={$Val_V+1}
-if {$Val_V>{$Canal_V+$Decalage} Val_V=$Canal_V -endif
V_imp={{$Val_V+$Decalage}%$Etendue}
-elif {$Type_Variations==1}
Val_V={$Val_V-1}
-if {$Val_V<{$Canal_V-$Decalage} Val_V=$Canal_V -endif
V_imp={{$Val_V-$Decalage}%$Etendue}
-elif {$Type_Variations==2}
Val_V={$Val_V+1}
-if {$Val_V>255 Val_V=$Canal_V -endif
V_imp={{$Val_V+$Decalage}%$Etendue}
-elif {$Type_Variations==3}
Val_V={$Val_V-1}
-if {$Val_V<0 Val_V=$Canal_V -endif
V_imp={{$Val_V-$Decalage}%$Etendue}
-elif {$Type_Variations==4}
Val_V={$Val_V+{round(u(0,3))}}
-if {$Val_V>255 Val_V=$Canal_V -endif
V_imp={{$Val_V+$Decalage}%$Etendue}
-elif {$Type_Variations==5}
Val_V={$Val_V-{round(u(0,3))}}
-if {$Val_V<0 Val_V=$Canal_V -endif
V_imp={{$Val_V-$Decalage}%$Etendue}
-endif
-else
V_imp=$Canal_V
-endif
-if {$Valider_Variations_Canal_B==1}
-if {$Type_Variations==0}
Val_B={$Val_B+1}
-if {$Val_B>{$Canal_B+$Decalage} Val_B=$Canal_B -endif
B_imp={{$Val_B+$Decalage}%$Etendue}
-elif {$Type_Variations==1}
Val_B={$Val_B-1}
-if {$Val_B<{$Canal_B-$Decalage} Val_V=$Canal_B -endif
B_imp={{$Val_B-$Decalage}%$Etendue}
-elif {$Type_Variations==2}
Val_B={$Val_B+1}
-if {$Val_B>255 Val_B=$Canal_B -endif
B_imp={{$Val_B+$Decalage}%$Etendue}
-elif {$Type_Variations==3}
Val_B={$Val_B-1}
-if {$Val_B<0 Val_V=$Canal_B -endif
B_imp={{$Val_B-$Decalage}%$Etendue}
-elif {$Type_Variations==4}
Val_B={$Val_B+{round(u(0,3))}}
-if {$Val_B>255 Val_B=$Canal_B -endif
B_imp={{$Val_B+$Decalage}%$Etendue}
-elif {$Type_Variations==5}
Val_B={$Val_B-{round(u(0,3))}}
-if {$Val_B<0 Val_V=$Canal_B -endif
B_imp={{$Val_B-$Decalage}%$Etendue}
-endif
-else
B_imp=$Canal_B
-endif
-if {$Valider_Variations_Canal_A==1}
-if {$Type_Variations==0}
Val_A={$Val_A+1}
-if {$Val_A>{$Canal_A+$Decalage} Val_A=$Canal_A -endif
A_imp={{$Val_A+$Decalage}%$Etendue}
-elif {$Type_Variations==1}
Val_A={$Val_A-1}
-if {$Val_A<{$Canal_A-$Decalage} Val_A=$Canal_A -endif
A_imp={{$Val_A-$Decalage}%$Etendue}
-elif {$Type_Variations==2}
Val_A={$Val_A+1}
-if {$Val_A>255 Val_A=$Canal_A -endif
A_imp={{$Val_A+$Decalage}%$Etendue}
-elif {$Type_Variations==3}
Val_A={$Val_A-1}
-if {$Val_A<0 Val_A=$Canal_A -endif
A_imp={{$Val_A-$Decalage}%$Etendue}
-elif {$Type_Variations==4}
Val_A={$Val_A+{round(u(0,3))}}
-if {$Val_A>255 Val_A=$Canal_A -endif
A_imp={{$Val_A+$Decalage}%$Etendue}
-elif {$Type_Variations==5}
Val_A={$Val_A-{round(u(0,3))}}
-if {$Val_A<0 Val_A=$Canal_A -endif
A_imp={{$Val_A-$Decalage}%$Etendue}
-endif
-else
A_imp=$Canal_A
-endif
-if {{$Variations_Formes==0}||{$Variations_Formes==2}||{$Variations_Formes==4}||{$Variations_Formes==6}||{$Variations_Formes==8}||{$Variations_Formes==10}||{$Variations_Formes==11}||{$Variations_Formes==13}||{$Variations_Formes==14}}
-line[-1] $Nb_Boucle,0,$Nb_Boucle,{$Hauteur_Origine-1},1,$R_imp,$V_imp,$B_imp,$A_imp
-elif {{$Variations_Formes==1}||{$Variations_Formes==3}||{$Variations_Formes==5}||{$Variations_Formes==7}||{$Variations_Formes==9}||{$Variations_Formes==12}||{$Variations_Formes==15}}
-line[-1] 0,$Nb_Boucle,{$Largeur_Origine-1},$Nb_Boucle,1,$R_imp,$V_imp,$B_imp,$A_imp
-endif
Nb_Boucle={$Nb_Boucle+1}
-done
-if {$Variations_Formes==0}
-fx_custom_deformation[-1] "(w+h)/"{20+$Parametre_Forme_A}" * cos(y*"{10+$Parametre_Forme_B}"/h)","1",1,1,1
-elif {$Variations_Formes==1}
-fx_custom_deformation[-1] "1","(w+h)/"{20+$Parametre_Forme_A}" * sin(x*"{10+$Parametre_Forme_B}"/w)",1,1,1
-elif {$Variations_Formes==2}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==3}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==6}
-fx_normalize_tiles[-1] {$Parametre_Forme_A+4},1,{$Parametre_Forme_B/100*255},{{$Parametre_Forme_C-100}/100*-255},{{$Parametre_Forme_D+3}%22}
-elif {$Variations_Formes==7}
-fx_normalize_tiles[-1] 1,{$Parametre_Forme_A+4},{$Parametre_Forme_B/100*255},{{$Parametre_Forme_C-100}/100*-255},{{$Parametre_Forme_D+3}%22}
-elif {$Variations_Formes==8}
-fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==9}
-fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==10}
-fx_plaid_texture[-1] 50,2,0,90,0,300
-elif {$Variations_Formes==11}
-fx_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==12}
-fx_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==13}
-fx_warp_perspective[-1] 1.73,0,1,50,50,$Parametre_Forme_A,0,2
-elif {$Variations_Formes==14}
-fill_color[-2] 0,0,0,0
-fx_map_sphere[-1] {min($Largeur_Origine,$Hauteur_Origine)},{min($Largeur_Origine,$Hauteur_Origine)},90,0.5,0,0,20,0,0,0,0.5
-autocrop[-1]
-elif {$Variations_Formes==15}
-fill_color[-2] 0,0,0,0
-fx_map_sphere[-1] {min($Largeur_Origine,$Hauteur_Origine)},{min($Largeur_Origine,$Hauteur_Origine)},90,0.5,0,0,20,0,0,0,0.5
-endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -apply_channels[-1] "-fx_noise "$Bruit",0,22,1",1 -endif
-blend[-2,-1] alpha,1,0
#@gui Marble Blend : samj_Marbre_en, samj_Marbre_en(1)
#@gui : note = note("Marble Blend")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Plasma</b></span>")
#@gui : Alpha = float(1,0,5)
#@gui : Beta = float(1,0,100)
#@gui : Scale = int(8,2,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blur</b></span>")
#@gui : Blur = float(5,2,20)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Grayscale</b></span>")
#@gui : Gray = float(0.2,0.1,0.6)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Noise</b></span>")
#@gui : Spread = int(0,0,10)
#@gui : Attenuation = float(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Color</b></span>")
#@gui : Colorization = bool(0)
#@gui : Color = color(140,120,220)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend Image</b></span>")
#@gui : Blend Image = bool(0)
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/10/31</i>.</small>")
samj_Marbre_en :
-samj_Marbre $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14
#@gui Motifs Aleatoires Symetriques Degrades : samj_Motifs_Aleatoires_Symetriques_Degrades, samj_Motifs_Aleatoires_Symetriques_Degrades(1)
#@gui : sep = separator(), note = note("<small>Rendu</small>")
#@gui : Type D\303\251grad\303\251 = choice(0,"Degrades_XYZ_CIE A","Degrades_XYZ_CIE B","Degrades_HSL_TSL","Formes_Couleurs_Variees_Dans_Image")
#@gui : Dimensions Motif = int(400,128,2048)
#@gui : Forme = int(4,3,12)
#@gui : Limite / Boundary = int(1,0,2)
#@gui : Sym\303\251trie = int(1,0,2)
#@gui : Utiliser GIMP Feltpen = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/15</i>.</small>")
samj_Motifs_Aleatoires_Symetriques_Degrades :
Type_Degrade=$1
Dimensions=$2
Forme=$3
Boundary=$4
Symetrie=$5
Utiliser_Gimp_Feltpen=$6
Angle={180/$Forme}
Inc_Angle=$Angle
-if {$Type_Degrade==0}
-samj_Degrades_XYZ_CIE[-1] 6,$Dimensions,240,240,40,255,120,40,240,255,0,0,0,100,64,64,0,0,1,0,100,-128,128,-128,128,0,5,0,0
-elif {$Type_Degrade==1}
-samj_Degrades_XYZ_CIE[-1] 0,$Dimensions,0,0,0,255,0,0,0,255,0,0,0,100,64,64,0,{round(u(0,2))},1,0,100,-128,128,-128,128,0,{round(u(0,2))},0,0
-elif {$Type_Degrade==2}
-samj_Degrades_HSL_TSL[-1] 4,$Dimensions,240,240,40,255,120,40,240,255,0,0,0,360,100,100,0,1,0,718,75,100,0,100,0,0,0,0
-elif {$Type_Degrade==3}
-rm[-1]
$Dimensions,$Dimensions,1,4
-samj_Formes_Couleurs_Variees_Dans_Image 4,0,0,0,0,192,128,64,255,1,1,1,0,3,127,255,1,0,0,0,1
-endif
-fx_euclidean2polar[-1] 0.5,0.5,1,1,0
-repeat $Forme
-symmetrize[-1] 50%,50%,$Angle,$Boundary,0,0
Angle={$Angle+$Inc_Angle}
-done
-if {$Utiliser_Gimp_Feltpen==1}
-fx_feltpen[-1] 1000,50,1,0.1,1,2
-endif
-if {$Symetrie==1}
-symmetrize[-1] 50%,50%,180,1,0,0
-elif {$Symetrie==2}
-symmetrize[-1] 50%,50%,180,1,0,0
-symmetrize[-1] 50%,50%,90,1,0,0
-endif
#@gui Motifs Degrades Cie : samj_Degrades_XYZ_CIE, samj_Degrades_XYZ_CIE(0)
#@gui : sep = separator(), note = note("<small>D\303\251grad\303\251 Rendu CIE Lab</small>")
#@gui : Type D\303\251grad\303\251 = choice(6,"V Couleur A","H Couleur A","V Couleur B","H Couleur B","V Couleurs A/B Inv.","H Couleurs A/B Inv.","V Couleurs A/B","H Couleurs A/B")
#@gui : Dimensions Image = int(800,128,2048)
#@gui : Couleur A = color(240,240,40,255)
#@gui : Couleur B = color(120,40,240,255)
#@gui : D\303\251calage L = float(0,0,100)
#@gui : D\303\251calage A = float(0,-128,127)
#@gui : D\303\251calage B = float(0,-128,127)
#@gui : Variation L = float(100,0,100)
#@gui : Variation A = float(64,0,255)
#@gui : Variation B = float(64,0,255)
#@gui : Valider Variations Canal Alpha = bool(0)
#@gui : Trou Noir = choice(0,"Non","Mode A","Mode B")
#@gui : D\303\251grad\303\251s Al\303\251atoires = bool(1)
#@gui : L Min. Ded. Al\303\251a. = float(0,0,100)
#@gui : L Max. Ded. Al\303\251a. = float(100,0,100)
#@gui : A Min. Ded. Al\303\251a. = float(-128,-128,127)
#@gui : A Max. Ded. Al\303\251a. = float(128,-128,127)
#@gui : B Min. Ded. Al\303\251a. = float(-128,-128,127)
#@gui : B Max. Ded. Al\303\251a. = float(128,-128,127)
#@gui : Inverser D\303\251grad\303\251 = bool(0)
#@gui : Formes = choice(11,"Non","Sinus V - Param A B","Sinus H - Param A B","Cercles - Param A B","Rayons - Param A B","Lignes V Norm - Param A B","Lignes H Norm - Param A B","Plaid","Carre","Croix","Perspective - Param A","Sphere A","Sphere B")
#@gui : Param\303\250tre Forme A = int(0,0,100)
#@gui : Param\303\250tre Forme B = int(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_Degrades_XYZ_CIE :
Type_Degrade=$1
Dimensions=$2
Ra=$3
Ga=$4
Ba=$5
Aa=$6
Rb=$7
Gb=$8
Bb=$9
Ab=$10
Decalage_L=$11
Decalage_a=$12
Decalage_b=$13
Variation_L=$14
Variation_a=$15
Variation_b=$16
Valider_Variations_Canal_A=$17
Trou_Noir=$18
Degrades_aleatoires=$19
L_Min_Ded_Alea=$20
L_Max_Ded_Alea=$21
a_Min_Ded_Alea=$22
a_Max_Ded_Alea=$23
b_Min_Ded_Alea=$24
b_Max_Ded_Alea=$25
Inverser_Degrade=$26
Variations_Formes=$27
Parametre_Forme_A=$28
Parametre_Forme_B=$29
Nb_Boucles=0
Inc_L=0
Inc_a=0
Inc_b=0
Inc_Alpha=0
# Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
nt_Ra={$Ra/255}
nt_Ga={$Ga/255}
nt_Ba={$Ba/255}
-if {$nt_Ra>0.04045}
nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2? Illuminant = D65 sRGB
Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xa
Yca=$Ya
Zca=$Za
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={($nt_Xa)^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={($nt_Ya)^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={($nt_Za)^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_La={{116*$nt_Ya}-16}
CIE_aa={500*{$nt_Xa-$nt_Ya}}
CIE_ba={200*{$nt_Ya-$nt_Za}}
nt_Ra={$Rb/255}
nt_Ga={$Gb/255}
nt_Ba={$Bb/255}
-if {$nt_Ra>0.04045}
nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2? Illuminant = D65 sRGB
Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xb
Yca=$Yb
Zca=$Zb
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={($nt_Xa)^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={($nt_Ya)^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={($nt_Za)^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_Lb={{116*$nt_Ya}-16}
CIE_ab={500*{$nt_Xa-$nt_Ya}}
CIE_bb={200*{$nt_Ya-$nt_Za}}
-if {$Variations_Formes==1}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==2}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==3}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
Valider_Variations_Canal_A=0
-elif {$Variations_Formes==4}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
Valider_Variations_Canal_A=0
-elif {$Variations_Formes==5}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==6}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==7}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==8}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==9}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==10}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==11}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==12}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-endif
-rm[-1]
######
-if {{$Type_Degrade==0}||{$Type_Degrade==1}||{$Type_Degrade==2}||{$Type_Degrade==3}}
-if {{$Type_Degrade==2}||{$Type_Degrade==3}}
CIE_La=$CIE_Lb
CIE_aa=$CIE_ab
CIE_ba=$CIE_bb
Aa=$Ab
-endif
Nb_Boucles=0
Inc_L={$Variation_L/$Dimensions}
Inc_a={$Variation_a/$Dimensions}
Inc_b={$Variation_b/$Dimensions}
$Dimensions,$Dimensions,1,4
-repeat $Dimensions
-if {$Degrades_aleatoires==1}
-if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0}
-if {{$L_Max_Ded_Alea}>{$L_Min_Ded_Alea}} CIE_La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} -else CIE_La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} -endif
-if {{$a_Max_Ded_Alea}>{$a_Min_Ded_Alea}} CIE_aa={round(u($a_Min_Ded_Alea,$a_Max_Ded_Alea))} -else CIE_aa={round(u($a_Max_Ded_Alea,$a_Min_Ded_Alea))} -endif
-if {{$b_Max_Ded_Alea}>{$b_Min_Ded_Alea}} CIE_ba={round(u($b_Min_Ded_Alea,$b_Max_Ded_Alea))} -else CIE_ba={round(u($b_Max_Ded_Alea,$b_Min_Ded_Alea))} -endif
-endif
-endif
-if {$Inverser_Degrade==0}
CIE_Lca={$CIE_La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a+{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b+{$Nb_Boucles*$Inc_b}}
-else
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-endif
-if {$Trou_Noir==0}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
-elif {$Trou_Noir==1}
-if {$CIE_Lca>100} Inc_L={-1*$Inc_L} CIE_Lca=100  -endif
-if {$CIE_Lca<0} Inc_L={-1*$Inc_L} CIE_Lca=0 -endif
-if {$CIE_aca>127} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_aca<-128} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_bca>127} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-if {$CIE_bca<-128} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-elif {$Trou_Noir==2}
-if {$CIE_Lca>100} CIE_Lca={$CIE_Lca-100} -endif
-if {$CIE_Lca<0} CIE_Lca={$CIE_Lca+100} -endif
-if {$CIE_aca>127} CIE_aca={$CIE_aca-255} -endif
-if {$CIE_aca<-128} CIE_aca={$CIE_aca+255} -endif
-if {$CIE_bca>127} CIE_bca={$CIE_bca-255} -endif
-if {$CIE_bca<-128} CIE_bca={$CIE_bca+255} -endif
-endif
# Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{($nt_Yca)^3}>0.008856}
nt_Yca={($nt_Yca)^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{($nt_Xca)^3}>0.008856}
nt_Xca={($nt_Xca)^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{($nt_Zca)^3}>0.008856}
nt_Zca={($nt_Zca)^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
# Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {{$Type_Degrade==0}||{$Type_Degrade==2}}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {{$Type_Degrade==1}||{$Type_Degrade==3}}
-line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
-endif
######
-if {{$Type_Degrade==4}||{$Type_Degrade==5}||{$Type_Degrade==6}||{$Type_Degrade==7}}
Nb_Boucles=0
Inc_L={{$CIE_La-$CIE_Lb}/$Dimensions}
Inc_a={{$CIE_aa-$CIE_ab}/$Dimensions}
Inc_b={{$CIE_ba-$CIE_bb}/$Dimensions}
Inc_Alpha={{$Ab-$Aa}/$Dimensions}
$Dimensions,$Dimensions,1,4
-repeat $Dimensions
-if {$Degrades_aleatoires==1}
-if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0}
-if {{$L_Max_Ded_Alea}>{$L_Min_Ded_Alea}} CIE_La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} -else CIE_La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} -endif
-if {{$a_Max_Ded_Alea}>{$a_Min_Ded_Alea}} CIE_aa={round(u($a_Min_Ded_Alea,$a_Max_Ded_Alea))} -else CIE_aa={round(u($a_Max_Ded_Alea,$a_Min_Ded_Alea))} -endif
-if {{$b_Max_Ded_Alea}>{$b_Min_Ded_Alea}} CIE_ba={round(u($b_Min_Ded_Alea,$b_Max_Ded_Alea))} -else CIE_ba={round(u($b_Max_Ded_Alea,$b_Min_Ded_Alea))} -endif
-endif
-endif
-if {$Inverser_Degrade==0}
CIE_Lca={$CIE_La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a+{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b+{$Nb_Boucles*$Inc_b}}
-endif
-if {$Inverser_Degrade==1||{$Type_Degrade==6}||{$Type_Degrade==7}}
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-endif
-if {$Valider_Variations_Canal_A==1}
Aa={$Aa+$Inc_Alpha}
-if {$Aa>255} Aa=255 -endif
-if {$Aa<0} Aa=0 -endif
-endif
-if {$Trou_Noir==0}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
-elif {$Trou_Noir==1}
-if {$CIE_Lca>100} Inc_L={-1*$Inc_L} CIE_Lca=$CIE_Lb  -endif
-if {$CIE_Lca<0} Inc_L={-1*$Inc_L} CIE_Lca=$CIE_La -endif
-if {$CIE_aca>127} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_aca<-128} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_bca>127} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-if {$CIE_bca<-128} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-elif {$Trou_Noir==2}
-if {$CIE_Lca>100} CIE_Lca={$CIE_Lca-100} -endif
-if {$CIE_Lca<0} CIE_Lca={$CIE_Lca+100} -endif
-if {$CIE_aca>127} CIE_aca={$CIE_aca-255} -endif
-if {$CIE_aca<-128} CIE_aca={$CIE_aca+255} -endif
-if {$CIE_bca>127} CIE_bca={$CIE_bca-255} -endif
-if {$CIE_bca<-128} CIE_bca={$CIE_bca+255} -endif
-endif
# Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{($nt_Yca)^3}>0.008856}
nt_Yca={($nt_Yca)^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{($nt_Xca)^3}>0.008856}
nt_Xca={($nt_Xca)^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{($nt_Zca)^3}>0.008856}
nt_Zca={($nt_Zca)^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
# Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {{$Type_Degrade==4}||{$Type_Degrade==6}}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {{$Type_Degrade==5}||{$Type_Degrade==7}}
-line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
-endif
#####
-if {$Variations_Formes==1}
-fx_custom_deformation[-1] "(w+h)/"{20+$Parametre_Forme_A}" * cos(y*"{10+$Parametre_Forme_B}"/h)","1",1,1,1
-elif {$Variations_Formes==2}
-fx_custom_deformation[-1] "1","(w+h)/"{20+$Parametre_Forme_A}" * sin(x*"{10+$Parametre_Forme_B}"/w)",1,1,1
-elif {$Variations_Formes==3}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==4}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==5}
-fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==6}
-fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==7}
-fx_plaid_texture[-1] 50,2,0,90,0,300
-elif {$Variations_Formes==8}
-fx_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==9}
-fx_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==10}
-fx_warp_perspective[-1] 1.73,0,1,50,50,$Parametre_Forme_A,0,2
-elif {$Variations_Formes==11}
-fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
-elif {$Variations_Formes==12}
-fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
-endif
samj_rien_rendering :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Points Aleatoires 001 : samj_Points_Aleatoires_001, gui_no_preview
#@gui : sep = separator()
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Points</small></span>")
#@gui : It\303\251rations = int(10,1,200)
#@gui : Couleur Point = color(255,255,0,255)
#@gui : Mode = choice(3,"XY Aleatoire","X Aleatoire","Y Aleatoire","Cavalier","Fou","Tour","Reine")
#@gui : Couleurs Al\303\251atoires = bool(0)
#@gui : Continuit\303\251 Entre It\303\251rations = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_Points_Aleatoires_001 :
Iterations=$1
R_Point=$2
V_Point=$3
B_Point=$4
A_Point=$5
Mode=$6
Couleurs_Aleatoires=$7
Continuite=$8
Choix=0
Cavalier=0
Largeur_Origine={w}
Hauteur_Origine={h}
Position_X={round(u(0,{$Largeur_Origine-1}))}
Position_Y={round(u(0,{$Hauteur_Origine-1}))}
{w},{h},1,4
-fill_color[-1] 0,0,0,0
-rm[-2]
-repeat $Iterations
-if {$Couleurs_Aleatoires==1}
R_Point={round(u(0,255))}
V_Point={round(u(0,255))}
B_Point={round(u(0,255))}
A_Point=255
-endif
-if {$Continuite==0}
Position_X={round(u(0,{$Largeur_Origine-1}))}
Position_Y={round(u(0,{$Hauteur_Origine-1}))}
-endif
-repeat {$Largeur_Origine+$Hauteur_Origine}
Choix={round(u(0,1))}
-if {$Mode==0}
Inc_X={{round(u(0,2))}-1}
Inc_Y={{round(u(0,2))}-1}
-elif {$Mode==1}
Inc_X={{round(u(0,2))}-1}
Inc_Y={{round(u(0,{$|}))%3}-1}
-elif {$Mode==2}
Inc_X={{round(u(0,{$|}))%3}-1}
Inc_Y={{round(u(0,2))}-1}
-elif {$Mode==3}
-if {$Choix==0}
Cavalier={round(u(0,7))}
-else
Cavalier={round(u(0,4095)%8)}
-endif
-if {$Cavalier==0}
Inc_X=-1
Inc_Y=2
-elif {$Cavalier==1}
Inc_X=1
Inc_Y=2
-elif {$Cavalier==2}
Inc_X=2
Inc_Y=1
-elif {$Cavalier==3}
Inc_X=2
Inc_Y=-1
-elif {$Cavalier==4}
Inc_X=1
Inc_Y=-2
-elif {$Cavalier==5}
Inc_X=-1
Inc_Y=-2
-elif {$Cavalier==6}
Inc_X=-2
Inc_Y=-1
-elif {$Cavalier==7}
Inc_X=-2
Inc_Y=1
-endif
-elif {$Mode==4}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
-if {$Choix==0}
Inc_Y=$Inc_X
-else
Inc_Y={0-$Inc_X}
-endif
-elif {$Mode==5}
-if {$Choix==0}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=0
-else
Inc_X=0
Inc_Y={{round(u(0,8))}-{round(u(0,8))}}
-endif
-elif {$Mode==6}
Choix={round(u(0,3))}
-if {$Choix==0}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=$Inc_X
-elif {$Choix==1}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=0
-elif {$Choix==2}
Inc_X=0
Inc_Y={{round(u(0,8))}-{round(u(0,8))}}
-elif {$Choix==3}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y={0-$Inc_X}
-endif
-endif
Position_X={$Position_X+$Inc_X}
-if {$Position_X<0}
Position_X={$Largeur_Origine-1}
-endif
-if {$Position_X>{$Largeur_Origine-1}}
Position_X=0
-endif
Position_Y={$Position_Y+$Inc_Y}
-if {$Position_Y<0}
Position_Y={$Hauteur_Origine-1}
-endif
-if {$Position_Y>{$Hauteur_Origine-1}}
Position_Y=0
-endif
-point[-1] $Position_X,$Position_Y,0,1,$R_Point,$V_Point,$B_Point,$A_Point
-done
-done
#@gui Random Pattern Courtepointe : samj_en_Courtepointe, gui_no_preview
#@gui : note = note("Random Pattern")
#@gui : sep = separator()
#@gui : Parameter 1 = int(20,1,100)
#@gui : Parameter 2 = bool(0)
#@gui : Repeat = int(1,1,5)
#@gui : Cross = bool(0)
#@gui : Texture = bool(1)
#@gui : Color Curves = choice("RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/07</i>.</small>")
samj_en_Courtepointe :
-samj_Courtepointe $1,$2,$3,$4,$5,$6
#@gui Random Pattern Courtepointe : samj_Courtepointe, gui_no_preview
#@gui : note = note("Motif au rendu al\303\251atoire / Random Pattern")
#@gui : sep = separator()
#@gui : Cossin 1 / Parameter 1 = int(20,1,100)
#@gui : Cossin 2 / Parameter 2 = bool(0)
#@gui : R\303\251petition / Repeat = int(1,1,5)
#@gui : Croix / Cross = bool(0)
#@gui : Texture = bool(1)
#@gui : Courbes Des Couleurs /  Color Curves = choice("RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/07</i>.</small>")
samj_Courtepointe :
Cossin=$1
Cossin_Deux=$2
Repetition=$3
Croix=$4
Texture=$5
Courbes_Interactives_Couleurs=$6
-rorschach[-1] {$Cossin}%,1
-if {$Cossin_Deux==1}
-n[-1] 64,192
-endif
-n[-1] 0,255
-repeat $Repetition
-fx_array_mirror[-1] 1,0,0,2,0,0
-done
-if {$Croix==1}
-fx_symmetrizoscope[-1] 5,0,1,0
-endif
-if {$Texture==1}
-samj_Texture_Granuleuse[-1] 0.5,20,80,0,0
-endif
-if {$Courbes_Interactives_Couleurs==0}
-x_color_curves[-1] rgb
-elif {$Courbes_Interactives_Couleurs==1}
-x_color_curves[-1] cmy
-elif {$Courbes_Interactives_Couleurs==2}
-x_color_curves[-1] cmyk
-elif {$Courbes_Interactives_Couleurs==3}
-x_color_curves[-1] hsi
-elif {$Courbes_Interactives_Couleurs==4}
-x_color_curves[-1] hsl
-elif {$Courbes_Interactives_Couleurs==5}
-x_color_curves[-1] hsv
-elif {$Courbes_Interactives_Couleurs==6}
-x_color_curves[-1] lab
-elif {$Courbes_Interactives_Couleurs==7}
-x_color_curves[-1] lch
-elif {$Courbes_Interactives_Couleurs==8}
-x_color_curves[-1] ycbcr
-endif
#@gui Rays Of Colors : samj_Rays_Of_Colors, samj_Rays_Of_Colors(0)
#@gui : Color Intensity = int(300,1,1600)
#@gui : Color Density = int(12,2,40)
#@gui : Radius = float(40,0,400)
#@gui : Border Smoothness = float(16,0,200)
#@gui : Border Width = float(38,0,100)
#@gui : Merge Layers = bool(1)
#@gui : Background Color = color(0,0,0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2013/11/05</i>.</small>")
samj_Rays_Of_Colors :
Color_Intensity=$1
Color_Density=($2/512*{w})
Radius=$3
Border_smoothness=$4
Border_width=$5
Merge_Layers=$6
R_a=$7
V_a=$8
B_a=$9
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-fill_color[-1] $R_a,$V_a,$B_a
-repeat $Color_Intensity
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
X_point={round((u)*{w})}
Y_point={round((u)*{h})}
-polygon[-1] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
-done
-fx_textured_glass[-1] 40,40,1,1,0,2,0
-fx_map_sphere[-1] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
#####
-fill_color[-2] $R_a,$V_a,$B_a
-repeat $Color_Intensity
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
X_point={round((u)*{w})}
Y_point={round((u)*{h})}
-polygon[-2] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
-done
-fx_textured_glass[-2] 40,40,1,1,0,2,0
-fx_map_sphere[-2] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
-if {$Merge_Layers==1}
-blend[-2,-1] add
-endif
#@gui Samj Contours Gros Pixels : samj_Contours_Gros_Pixels, samj_Contours_Gros_Pixels(1)
#@gui : note = note("Contours GrosPixels")
#@gui : Flou/Blur = float(1,0,5)
#@gui : Isophotes Nb Levels = int(8,1,256)
#@gui : Dilatation = int(0,0,10)
#@gui : Gros Pixels X = int(20,5,90)
#@gui : Gros Pixels Y = int(20,5,90)
#@gui : Quantize Levels = int(16,1,256)
#@gui : Couleur = float(1.1,0.8,4)
#@gui : Alpha = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Edges</b></span>")
#@gui : VALIDATION EDGES = bool(0)
#@gui : Threshold = float(15,0.5,50)
#@gui : Colorization = bool(0)
#@gui : Alpha Colorization = bool(0)
#@gui : Colorization Mode = choice{0,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Colorization Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/04</i>.</small>")
samj_Contours_Gros_Pixels :
Flou=$1
Isophotes_Nb_Levels=$2
Dilatation=$3
Gros_Pixels_X=$4
Gros_Pixels_Y=$5
Quantize_Levels=$6
Couleur=$7
Transparence=$8
Valider_Edges=$9
Threshold_Edges=$10
Colorisation=$11
Alpha_Colorisation=$12
Mode_blend=$13
Opacity_blend=$14
-to_rgb[-1]
-blur[-1] $Flou
-isophotes[-1] $Isophotes_Nb_Levels
-if {$Dilatation>0}
-dilate_circ[-1] $Dilatation
-endif
-if {$Valider_Edges==1}
-if {$Colorisation==1}
--Je_passe_l_hiver_en_Floride[-1]
-pow[-2] $Couleur
-dilate_circ[-2] $Dilatation
-endif
-endif
# Partie code filtre Tetris
wh={w},{h},1,{s} -r $Gros_Pixels_X%,$Gros_Pixels_Y%,10%,100%,2 -n[-1] 0,255 -quantize[-1] $Quantize_Levels,1,0 -r $wh
-pow[-1] $Couleur
-if {$Transparence==1}
-to_rgba[-1]
-else
-to_rgb[-1]
-endif
-if {$Valider_Edges==1}
-edges[-1] $Threshold_Edges%
-n[-1] 0,255
-to_rgb[-1]
-if {$Colorisation==1}
-n[-2] 0,255
-if {$Alpha_Colorisation==0}
-to_rgb[-2]
-endif
-gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0
-endif
-endif
#@gui Samj EPPE Transform : samj_EPPE_Transform, samj_EPPE_Transform(1)
#@gui : note = note("samj_EPPE_Transform")
#@gui : X Centre = float(50,0,100)
#@gui : Y Centre = float(50,0,100)
#@gui : Rendu = choice(0,"Imagegrid","Imagegrid Hexagonal","Imagegrid Triangular","BoxFitting")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Imagegrid</b></span>")
#@gui : X-Size = int(10,2,100)
#@gui : Y-Size = int(10,2,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Imagegrid Hexagonal</b></span>")
#@gui : Resolution = int(32,1,128)
#@gui : Outline = float(0.1,0,0.5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Imagegrid Triangular</b></span>")
#@gui : Pattern Width = int(10,8,128)
#@gui : Pattern Height = int(18,8,128)
#@gui : Pattern Type = choice(0,"Horizontal","Vertical","Crossed","Cube","Decreasing","Increasing")
#@gui : Outline Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>BoxFitting</b></span>")
#@gui : Minimal Size = int(3,1,32)
#@gui : Maximal Size = int(0,0,32)
#@gui : Initial Density = float(0.1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/04</i>.</small>")
samj_EPPE_Transform :
X_Centre=$1
Y_Centre=$2
Rendu=$3
-euclidean2polar[-1] $X_Centre%,$Y_Centre%,1,1
-if {$Rendu==0}
-imagegrid[-1] $4,$5
-elif {$Rendu==1}
-imagegrid_hexagonal[-1] $6,$7
-elif {$Rendu==2}
-imagegrid_triangular[-1] $8,$9,$10,{1-($14/255)},$11,$12,$13
-elif {$Rendu==3}
-boxfitting[-1] $15,$16,$17,3
-endif
-polar2euclidean[-1] $X_Centre%,$Y_Centre%,1,1
#@gui Samj Lignes H Ou V Colorees : samj_Lignes_H_ou_V_Colorees, samj_Lignes_H_ou_V_Colorees(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_Lignes_H_ou_V_Colorees - Colored Lines</b></span>")
#@gui : Couleur - Color A = color(159,190,195)
#@gui : Couleur - Color B = color(55,67,140)
#@gui : Couleur - Color C = color(54,40,39)
#@gui : Couleur - Color D = color(140,81,88)
#@gui : Couleur - Color E = color(207,175,190)
#@gui : Couleur - Color F = color(220,202,196)
#@gui : Couleur - Color G = color(170,186,192)
#@gui : Couleur - Color H = color(130,149,139)
#@gui : Couleur - Color I = color(112,96,96)
#@gui : Couleur - Color J = color(237,168,138)
#@gui : Couleur - Color K = color(220,199,205)
#@gui : Couleur - Color L = color(234,217,219)
#@gui : Alpha = int(255,1,255)
#@gui : Largeur - Width = int(256,2,1024)
#@gui : Nombre De Lignes - Number Of Lines = int(256,2,1024)
#@gui : Hauteur De Une Ligne - Height Of One Line = int(1,1,20)
#@gui : Rotation 90 Degres - Vertical Lines = bool(0)
#@gui : Origine - First Color = choice(0,"A","B","C","D","E","F","G","H","I","J","K","L")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2018/02/20</i>.</small>")
samj_Lignes_H_ou_V_Colorees :
R_a=$1
V_a=$2
B_a=$3
R_b=$4
V_b=$5
B_b=$6
R_c=$7
V_c=$8
B_c=$9
R_d=$10
V_d=$11
B_d=$12
R_e=$13
V_e=$14
B_e=$15
R_f=$16
V_f=$17
B_f=$16
R_g=$19
V_g=$20
B_g=$21
R_h=$22
V_h=$23
B_h=$25
R_i=$25
V_i=$26
B_i=$27
R_j=$28
V_j=$29
B_j=$30
R_k=$31
V_k=$32
B_k=$33
R_l=$34
V_l=$35
B_l=$36
Transparence=$37
Largeur=$38
Nombre_De_Lignes=$39
Hauteur_De_Une_Ligne=$40
Rotation=$41
Boucles=$42
Position_H=0
$Largeur,{$Nombre_De_Lignes*$Hauteur_De_Une_Ligne},1,4
-repeat $Nombre_De_Lignes
-repeat $Hauteur_De_Une_Ligne
-if {{($Boucles%12)}==0}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_a,$V_a,$B_a,$Transparence
-endif
-if {{($Boucles%12)}==1}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_b,$V_b,$B_b,$Transparence
-endif
-if {{($Boucles%12)}==2}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_c,$V_c,$B_c,$Transparence
-endif
-if {{($Boucles%12)}==3}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_d,$V_d,$B_d,$Transparence
-endif
-if {{($Boucles%12)}==4}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_e,$V_e,$B_e,$Transparence
-endif
-if {{($Boucles%12)}==5}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_f,$V_f,$B_f,$Transparence
-endif
-if {{($Boucles%12)}==6}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_g,$V_g,$B_g,$Transparence
-endif
-if {{($Boucles%12)}==7}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_h,$V_h,$B_h,$Transparence
-endif
-if {{($Boucles%12)}==8}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_i,$V_i,$B_i,$Transparence
-endif
-if {{($Boucles%12)}==9}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_j,$V_j,$B_j,$Transparence
-endif
-if {{($Boucles%12)}==10}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_k,$V_k,$B_k,$Transparence
-endif
-if {{($Boucles%12)}==11}
-line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_l,$V_l,$B_l,$Transparence
-endif
Position_H={$Position_H+1}
-done
Boucles={$Boucles+1}
-done
-if {$Rotation==1} -permute[1] yxzc -endif
-rv[-2,-1]
#@gui Samj Marbre : samj_Marbre, samj_Marbre(1)
#@gui : note = note("samj_Marbre")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Plasma</b></span>")
#@gui : Alpha = float(1,0,5)
#@gui : Beta = float(1,0,100)
#@gui : Scale = int(8,2,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Flou-Blur</b></span>")
#@gui : Flou/Blur = float(5,2,20)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Gris-Gray</b></span>")
#@gui : Gris/Gray = float(0.2,0.1,0.6)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Bruit-Noise</b></span>")
#@gui : Spread = int(0,0,10)
#@gui : Attenuation = float(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Couleur-Color</b></span>")
#@gui : Colorisation = bool(0)
#@gui : Couleur / Color = color(140,120,220)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Blend Image</b></span>")
#@gui : Blend Image = bool(0)
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/10/31</i>.</small>")
samj_Marbre :
Plasma_alpha=$1
Plasma_beta=$2
Plasma_scale=$3
Flou=$4
Gris=$5
Bruit_Spread=$6
Attenuation=$7
Colorisation=$8
R_a=$9
V_a=$10
B_a=$11
Blend_Image=$12
Mode_blend=$13
Opacity_blend=$14
-if {$Blend_Image==1}
--Je_passe_l_hiver_en_Floride[-1]
-endif
-plasma[-1] $Plasma_alpha,$Plasma_beta,$Plasma_scale
-blur[-1] $Flou
-structuretensors[-1]
-abs[-1]
-spread[-1] $Bruit_Spread
-pow[-1] $Gris
-to_gray[-1]
-blur[-1] $Attenuation
-n[-1] 0,255
-to_rgb[-1]
-if {$Colorisation==1}
{w},{h},1,3
-fill_color[-1] $R_a,$V_a,$B_a
-blend_median[-1,-2]
-endif
-if {$Blend_Image==1}
-to_rgb[-2]
-gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0
-endif
#@gui Samj Steps V2 : samj_Steps_V2, samj_Steps_V2(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Pixelise X = int(10,1,256)
#@gui : Pixelise X = int(10,1,256)
#@gui : Area = int(4,1,16)
#@gui : Area IHC = bool(1)
#@gui : Isophotes = int(10,1,127)
#@gui : Dilate Circle = int(2,1,5)
#@gui : Smoothness = float(60,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Background = bool(0)
#@gui : Color = float(1.1,1,1.2)
#@gui : Variation = int(10,5,200)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/11/14</i>.</small>")
samj_Steps_V2 :
Pixelise_X=$1
Pixelise_Y=$2
Area_Valeur=$3
Area_is_high_connectivity=$4
Isophotes_Valeur=$5
Dilate_Circle_Valeur=$6
Smoothness=$7
BG=$8
BG_Color=$9
BG_Variation=$10
--Je_passe_l_hiver_en_Floride[-1]
-to_rgba[-1]
-if {$BG==1}
--Je_passe_l_hiver_en_Floride[-1]
-endif
-pixelize[-1,-2] $Pixelise_X,$Pixelise_Y
-area[-1] $Area_Valeur,$Area_is_high_connectivity
-c[-1] 0,255
-n[-1] 0,255
-isophotes[-1] $Isophotes_Valeur
-dilate_circ[-1] $Dilate_Circle_Valeur
-to_graya[-1]
-fx_blend_edges[-1,-2] 1,$Smoothness,0
-if {$BG==1}
-blur[-2] {{{w}+{h}}/$BG_Variation}
-pow[-2] $BG_Color
-pixelize[-2] $Pixelise_X,$Pixelise_Y
-blend[-1,-2] alpha
-endif
#@gui Samj Tissu Fond Flou : samj_Tissu_Fond_Flou , samj_Tissu_Fond_Flou_preview(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Capture Ligne</b></span>")
#@gui : X Origine = float(0,0,100)
#@gui : Y Origine = float(0,0,100)
#@gui : X Fin = float(100,0,100)
#@gui : Y Fin = float(100,0,100)
#@gui : Deplacement A = float(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Tissu</b></span>")
#@gui : Tissu = bool(1)
#@gui : Forme = choice(0,"A","B","C","D")
#@gui : Blend 0pacity = float(1,0,1)
#@gui : Inversion Calques Blend = bool(0)
#@gui : Angle Rotation = float(0,0,360)
#@gui : Deplacement B = float(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Flou/Blur</b></span>")
#@gui : Flou/Blur = float(0,0,1)
#@gui : Coeff. Flou = choice(0,"Flou/Blur *1","Flou/Blur *10","Flou/Blur *100","Flou/Blur *1000")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/02</i>.</small>")
samj_Tissu_Fond_Flou :
X_Origine={round({{w}/100*$1})}
Y_Origine={round({{h}/100*$2})}
X_Fin={round({{w}/100*$3})}
Y_Fin={round({{h}/100*$4})}
Deplacement_A=$5
Tissu=$6
Forme=$7
Blend_0pacity=$8
Inversion=$9
Angle_Rotation=$10
Deplacement_B=$11
Flou=$12
Coeff_Flou=$13
Largeur={w}
Hauteur={h}
-at_line[-1] $X_Origine,$Y_Origine,0,$X_Fin,$X_Fin,0
-resize[-1] $Largeur,$Hauteur
-to_rgb[-1]
-if {$Tissu==1}
--Je_passe_l_hiver_en_Floride[-1]
-if {$Forme==0}
-permute[-1] yxzc
-elif {$Forme==1}
-permute[-1] yxzc
-mirror[-1] y
-elif {$Forme==2}
-mirror[-2] x
-permute[-1] yxzc
-mirror[-1] y
-elif {$Forme==3}
-mirror[-2] x
-permute[-1] yxzc
-endif
-resize[-1] $Largeur,$Hauteur
-if {$Deplacement_B>0} -shift[-1] 0,$Deplacement_B%,0,0,2 -endif
-if {$Deplacement_A>0} -shift[-2] $Deplacement_A%,0,0,0,2 -endif
-if {$Inversion==1} -reverse[-2,-1] -endif
-blend[-1,-2] average,$Blend_0pacity,0
-else
-if {$Deplacement_A>0} -shift[-1] $Deplacement_A%,0,0,0,2 -endif
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,2,50%,50% -endif
-if {$Flou>0} -blur[-1] {$Flou*{10^$Coeff_Flou}} -endif
samj_Tissu_Fond_Flou_preview :
-repeat $! -l[$>]
-samj_Tissu_Fond_Flou[-1] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13
-to_rgba
-l[0]
-line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,255,255,255,255
-line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,0,0,0,255
-circle $1%,$2%,4,1,255,0,0,255
-circle $3%,$4%,4,1,0,0,255,255
-circle $1%,$2%,4,1,0xFFFFFFFF,0,0,0,255
-circle $3%,$4%,4,1,0xFFFFFFFF,0,0,0,255
-endl
-endl -done
#@gui Samj Variation Stained Glass : samj_Variation_Stained_Glass, samj_Variation_Stained_Glass(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Colored Outlines</b></span>")
#@gui : Axes = choice(0,"XY","X","Y")
#@gui : Blur = float(2,0,10)
#@gui : Isophote = float(8,6,16)
#@gui : Smooth = int(0,0,100)
#@gui : Dilate = int(3,1,16)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Stained Glass</b></span>")
#@gui : Edges = float(40,0,100)
#@gui : Shading = int(100,0,200)
#@gui : Is Precise = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Color = float(1.1,1,1.2)
#@gui : Variation = int(20,10,200)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/13</i>.</small>")
samj_Variation_Stained_Glass :
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-stained_glass[-1] $6,{$7/1000},$8
-to_rgba[-1]
-n[-1,-2] 0,255
-samj_Colored_Outlines[-2] $1,$2,$3,$4,$5,0,0,0,0
-blend[-1,-2] alpha
-blur[-2] {{{w}+{h}}/$10}
-pow[-2] $9
-blend[-1,-2] alpha
#@gui Steps : samj_en_Contours_Gros_Pixels, samj_en_Contours_Gros_Pixels(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Blur = float(1,0,5)
#@gui : Isophotes Nb Levels = int(8,1,256)
#@gui : Dilatation = int(2,0,10)
#@gui : Steps A = int(20,5,90)
#@gui : Steps B = int(20,5,90)
#@gui : Quantize Levels = int(16,1,256)
#@gui : Color = float(1.1,0.8,4)
#@gui : Alpha = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Steps - Foreground</b></span>")
#@gui : STEPS = bool(1)
#@gui : Threshold = float(15,0.5,50)
#@gui : Colorization = bool(1)
#@gui : Alpha Colorization = bool(0)
#@gui : Colorization Mode = choice{0,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Colorization Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/11/04</i>.</small>")
samj_en_Contours_Gros_Pixels :
-samj_Contours_Gros_Pixels $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14
#@gui _
#@gui <i>Rendering</i>
#@gui Adjacent Annular Steiner Chains : samj_Adjacent_Annular_Steiner_Chains, samj_Adjacent_Annular_Steiner_Chains(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Cercles</small>")
#@gui : Rayon Cercle Centre / Radius Center Circle A = float(6,-100,100)
#@gui : Nb Cercles Ext\303\251rieurs / Circles Surrounding = int(56,7,360)
#@gui : sep = separator(), note = note("<small>Anneaux</small>")
#@gui : Nb Anneaux = int(20,1,100)
#@gui : Angle Decalage % = float(50,-100,100)
#@gui : Variation Increment Anneaux % = float(0,-100,200)
#@gui : sep = separator(), note = note("<small>Couleurs Cercles</small>")
#@gui : Couleur / Color A = color(255,0,221,127)
#@gui : Couleur / Color B = color(72,0,255,127)
#@gui : Couleur / Color C = color(0,145,255,127)
#@gui : Couleur / Color D = color(0,255,144,127)
#@gui : Couleur / Color E = color(72,255,0,127)
#@gui : Couleur / Color F = color(255,217,0,127)
#@gui : Couleur / Color G = color(255,0,0,127)
#@gui : Choix Des Couleurs / Choice Of Colors = choice(5,"Couleurs / Colors AB","Couleurs / Colors ABC","Couleurs / Colors ABCD","Couleurs / Colors ABCDE","Couleurs / Colors ABCDEF","Couleurs / Colors ABCDEFG","Ordre ABCDEFG")
#@gui : Variations Des Couleurs = float(0,-2,2)
#@gui : Couleurs Al\303\251atoires / Random Colors = choice(0,"Non / No","A","B","C")
#@gui : sep = separator(), note = note("<small>Contours</small>")
#@gui : Affichage / Display Contours = choice(2,"Non / No","A","B","C","D","E")
#@gui : Contours = color(0,0,0,255)
#@gui : Dilate Contours = int(0,0,16)
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : Sharpen = int(0,0,600)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Adjacent_Annular_Steiner_Chains :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Angle_inclinaison=$3
Canal_Alpha=$4
-if {$5>0}
Rayon_Cercle_Centre={round({{w}*$5/{100}})}
-else
Rayon_Cercle_Centre={round({-{h}*$5/{100}})}
-endif
Nb_Circles_Surrounding=$6
Nb_Anneaux=$7
Angle_Decalage=$8
Variation_Increment_Anneaux=$9
R_a=$10
V_a=$11
B_a=$12
A_a=$13
R_b=$14
V_b=$15
B_b=$16
A_b=$17
R_c=$18
V_c=$19
B_c=$20
A_c=$21
R_d=$22
V_d=$23
B_d=$24
A_d=$25
R_e=$26
V_e=$27
B_e=$28
A_e=$29
R_f=$30
V_f=$31
B_f=$32
A_f=$33
R_g=$34
V_g=$35
B_g=$36
A_g=$37
#Choix_Des_Couleurs
Rendu=$38
Variations_Des_Couleurs=$39
Couleurs_aleatoires=$40
Affichage_Contours=$41
R_Contours=$42
V_Contours=$43
B_Contours=$44
A_Contours=$45
Dilate_Contours=$46
Flou_Contours=$47
Sharpen_Contours=$48
Largeur_Origine={w}
Hauteur_Origine={h}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
# 1 nouvelle image contours
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] 0,0,0,0
# 1 nouvelle image couleurs
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] 0,0,0,0
Angle_Theta={pi/$Nb_Circles_Surrounding}
-if {$Rayon_Cercle_Centre<1}
Rayon_Cercle_Centre=1
-endif
Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Angle_Decalage_En_Cours=0
Nb_boucles_anneaux=0
Rayon_Cercle_Centre_En_Cours=0
Ra_en_cours=0
Va_en_cours=0
Ba_en_cours=0
Aa_en_cours=0
Suite_Couleurs=0
-if {$Couleurs_aleatoires==1}
R_CE={round(u)*255}
V_CE={round(u)*255}
B_CE={round(u)*255}
R_PC={round(u)*255}
V_PC={round(u)*255}
B_PC={round(u)*255}
-endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-repeat $Nb_Anneaux
Nb_boucles=0
Suite_Couleurs=0
-if {$Couleurs_aleatoires==2}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage/100*$Nb_boucles_anneaux}
-if {$Nb_boucles_anneaux==0}
Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
-else
Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
-endif
Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
-repeat $Nb_Circles_Surrounding
-if {$Couleurs_aleatoires==3}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-if {$Rendu==6}
-if {{{($Nb_boucles%7)}==0}&&{$Suite_Couleurs==0}}
Ra_en_cours=$R_a
Va_en_cours=$V_a
Ba_en_cours=$B_a
Aa_en_cours=$A_a
Suite_Couleurs=1
-endif
-if {{{($Nb_boucles%7)}==1}&&{$Suite_Couleurs==1}}
Ra_en_cours=$R_b
Va_en_cours=$V_b
Ba_en_cours=$B_b
Aa_en_cours=$A_b
Suite_Couleurs=2
-endif
-if {{{($Nb_boucles%7)}==2}&&{$Suite_Couleurs==2}}
Ra_en_cours=$R_c
Va_en_cours=$V_c
Ba_en_cours=$B_c
Aa_en_cours=$A_c
Suite_Couleurs=3
-endif
-if {{{($Nb_boucles%7)}==3}&&{$Suite_Couleurs==3}}
Ra_en_cours=$R_d
Va_en_cours=$V_d
Ba_en_cours=$B_d
Aa_en_cours=$A_d
Suite_Couleurs=4
-endif
-if {{{($Nb_boucles%7)}==4}&&{$Suite_Couleurs==4}}
Ra_en_cours=$R_e
Va_en_cours=$V_e
Ba_en_cours=$B_e
Aa_en_cours=$A_e
Suite_Couleurs=5
-endif
-if {{{($Nb_boucles%7)}==5}&&{$Suite_Couleurs==5}}
Ra_en_cours=$R_f
Va_en_cours=$V_f
Ba_en_cours=$B_f
Aa_en_cours=$A_f
Suite_Couleurs=6
-endif
-if {{{($Nb_boucles%7)}==6}&&{$Suite_Couleurs==6}}
Ra_en_cours=$R_g
Va_en_cours=$V_g
Ba_en_cours=$B_g
Aa_en_cours=$A_g
Suite_Couleurs=0
-endif
-endif
-if {$Rendu<6}
-if {{($Nb_boucles%2)}==0}
Ra_en_cours=$R_a
Va_en_cours=$V_a
Ba_en_cours=$B_a
Aa_en_cours=$A_a
-endif
-if {{($Nb_boucles%2)}==1}
Ra_en_cours=$R_b
Va_en_cours=$V_b
Ba_en_cours=$B_b
Aa_en_cours=$A_b
-endif
-if {{{($Nb_boucles%3)}==2}&&{$Rendu>0}}
Ra_en_cours=$R_c
Va_en_cours=$V_c
Ba_en_cours=$B_c
Aa_en_cours=$A_c
-endif
-if {{{($Nb_boucles%4)}==3}&&{$Rendu>1}}
Ra_en_cours=$R_d
Va_en_cours=$V_d
Ba_en_cours=$B_d
Aa_en_cours=$A_d
-endif
-if {{{($Nb_boucles%5)}==4}&&{$Rendu>2}}
Ra_en_cours=$R_e
Va_en_cours=$V_e
Ba_en_cours=$B_e
Aa_en_cours=$A_e
-endif
-if {{{($Nb_boucles%6)}==5}&&{$Rendu>3}}
Ra_en_cours=$R_f
Va_en_cours=$V_f
Ba_en_cours=$B_f
Aa_en_cours=$A_f
-endif
-if {{{($Nb_boucles%7)}==6}&&{$Rendu>4}}
Ra_en_cours=$R_g
Va_en_cours=$V_g
Ba_en_cours=$B_g
Aa_en_cours=$A_g
-endif
-endif
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Nb_boucles={$Nb_boucles+1}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Aa_en_cours
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{{$Affichage_Contours==4}||{$Affichage_Contours==5}}&&{{($Nb_boucles%2)}==1}}
-ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-done
Nb_boucles_anneaux={$Nb_boucles_anneaux+1}
-done
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==5}}
-ellipse[-2] $X,$Y,{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilate_Contours>1} -dilate_circ[-2] $Dilate_Contours -endif
-if {$Flou_Contours>0} -blur[-2] $Flou_Contours,0 -endif
-if {$Sharpen_Contours>0} -sharpen[-2] $Sharpen_Contours -endif
-if {$Variations_Des_Couleurs<0} -*[-1] {abs($Variations_Des_Couleurs)} -c[-1] 0,255 -endif
-blend[-2,-1] alpha,1,1
-if {$Variations_Des_Couleurs>0} -*[-1] $Variations_Des_Couleurs -c[-1] 0,255 -endif
-blend[-1,-2] alpha,1,0
#@gui Adjacent Annular Steiner Chains : samj_Adjacent_Annular_Steiner_Chains_en, samj_Adjacent_Annular_Steiner_Chains_en(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><small>Rendering</small></b></span>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle Tilt = float(0,0,360)
#@gui : Alpha Channel = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><small>Circles</small></b></span>")
#@gui : Radius Center Circle = float(6,-100,100)
#@gui : Nb Circles Surrounding = int(56,7,360)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><small>Rings</small></b></span>")
#@gui : Nb Rings = int(20,1,100)
#@gui : Offset Angle % = float(50,-100,100)
#@gui : Change Increment % = float(0,-100,200)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><small>Color Circles</small></b></span>")
#@gui : Color A = color(255,0,221,127)
#@gui : Color B = color(72,0,255,127)
#@gui : Color C = color(0,145,255,127)
#@gui : Color D = color(0,255,144,127)
#@gui : Color E = color(72,255,0,127)
#@gui : Color F = color(255,217,0,127)
#@gui : Color G = color(255,0,0,127)
#@gui : Choice Of Colors = choice(5,"Colors AB","Colors ABC","Colors ABCD","Colors ABCDE","Colors ABCDEF","Colors ABCDEFG","Chronological Order ABCDEFG")
#@gui : Variations Of Colors = float(0,-2,2)
#@gui : Random Colors = choice(0,"No","A","B","C")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><small>Contours</small></b></span>")
#@gui : Display Contours = choice(2,"No","A","B","C","D","E")
#@gui : Contours = color(0,0,0,255)
#@gui : Dilate = int(0,0,16)
#@gui : Blur = float(0,0,5)
#@gui : Sharpen = int(0,0,600)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/05/02</i>.</small>")
samj_Adjacent_Annular_Steiner_Chains_en :
-samj_Adjacent_Annular_Steiner_Chains $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48
#@gui Adjacent Rectangles : samj_en_Rectangles_Adjacents, samj_en_Rectangles_Adjacents(1)
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : X Top Left = float(10,-100,100)
#@gui : Y Top Left = float(10,-100,100)
#@gui : X Down Right = float(80,0,100)
#@gui : Y Down Right = float(80,0,100)
#@gui : Type / Location Contact = choice(0,"Haut - Top","Bas - Down","Gauche - Left","Droite - Right")
#@gui : Position Contact = float(50,0,100)
#@gui : Nb Rectangles = int(6,2,25)
#@gui : Type N = choice(0,"Inc 1","Lin 0.1","Lin 0.2","Lin 0.3","Rand","M1","M2")
#@gui : Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Display Contours = bool(1)
#@gui : Rectangle A = color(255,255,0,127)
#@gui : Rectangle B = color(0,0,255,127)
#@gui : Random Colors = bool(0)
#@gui : Mirror = choice(0,"Sans - Wihout"," X "," Y "," X Y ")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Shadow = bool(0)
#@gui : X-Shadow = float(0.5,-5,5)
#@gui : Y-Shadow = float(0.5,-5,5)
#@gui : Smoothness Shadow = float(1.8,0,5)
#@gui : Curvature Shadow = float(0,0,1)
#@gui : Shadow Offset X = float(0,-20,20)
#@gui : Shadow Offset Y = float(0,-20,20)
#@gui : Alpha Channel = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/06</i>.</small>")
samj_en_Rectangles_Adjacents :
-samj_Rectangles_Adjacents $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36
#@gui Adjacent Rectangles : samj_Rectangles_Adjacents, samj_Rectangles_Adjacents(1)
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X Haut Gauche / Top Left = float(10,-100,100)
#@gui : Position Y Haut Gauche / Top Left = float(10,-100,100)
#@gui : Position X Bas Droite / Down Right = float(80,0,100)
#@gui : Position Y Bas Droite / Down Right = float(80,0,100)
#@gui : Type / Location Contact = choice(0,"Haut - Top","Bas - Down","Gauche - Left","Droite - Right")
#@gui : Position Contact = float(50,0,100)
#@gui : Nb Rectangles = int(6,2,25)
#@gui : Type N = choice(0,"Inc 1","Lin 0.1","Lin 0.2","Lin 0.3","Rand","M1","M2")
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(1)
#@gui : Rectangle A = color(255,255,0,127)
#@gui : Rectangle B = color(0,0,255,127)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Miroir /  Mirror = choice(0,"Sans - Wihout"," X "," Y "," X Y ")
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Rectangles_Adjacents :
X_Haut_Gauche=$1
Y_Haut_Gauche=$2
X_Bas_Droite=$3
Y_Bas_Droite=$4
Type_Contact=$5
Position_Contact=$6
Nb_Rectangles=$7
Type_n=$8
Angle_inclinaison=$9
R_Contours=$10
V_Contours=$11
B_Contours=$12
A_Contours=$13
Affichage_Contours=$14
R_a=$15
V_a=$16
B_a=$17
A_a=$18
R_b=$19
V_b=$20
B_b=$21
A_b=$22
Couleurs_aleatoires=$23
Inversions=$24
Flou=$25
Dilatation=$26
Deformation=$27
Bruit=$28
Ombre=$29
X_Ombre=$30
Y_Ombre=$31
Smoothness_Ombre=$32
Curvature_Ombre=$33
Compensation_Decalage_Ombre_X=$34
Compensation_Decalage_Ombre_Y=$35
Canal_Alpha=$36
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Dimension_Image_Rotation={round({{{{$Largeur_Origine*$Largeur_Origine}+{$Hauteur_Origine*$Hauteur_Origine}}^0.5}+2})}
Decalage_X={round({{$Dimension_Image_Rotation-$Largeur_Origine}/2})}
Decalage_Y={round({{$Dimension_Image_Rotation-$Hauteur_Origine}/2})}
X_H_G_origine={$Decalage_X+{round({$Largeur_Origine*{$X_Haut_Gauche/100}})}}
Y_H_G_origine={$Decalage_Y+{round({$Hauteur_Origine*{$Y_Haut_Gauche/100}})}}
Largeur_Rectangle_origine={round({$Largeur_Origine*{$X_Bas_Droite/100}})}
Hauteur_Rectangle_origine={round({$Hauteur_Origine*{$Y_Bas_Droite/100}})}
Largeur_A_Imprimer=$Largeur_Rectangle_origine
Hauteur_A_Imprimer=$Hauteur_Rectangle_origine
-if {$Type_Contact==0}
X_Contact={$X_H_G_origine+{round({$Largeur_Rectangle_origine*{$Position_Contact/100}})}}
Y_Contact=$Y_H_G_origine
-elif {$Type_Contact==1}
X_Contact={$X_H_G_origine+{round({$Largeur_Rectangle_origine*{$Position_Contact/100}})}}
Y_Contact={$Y_H_G_origine+$Hauteur_Rectangle_origine}
-elif {$Type_Contact==2}
X_Contact=$X_H_G_origine
Y_Contact={$Y_H_G_origine+{round({$Hauteur_Rectangle_origine*{$Position_Contact/100}})}}
-elif {$Type_Contact==3}
X_Contact={$X_H_G_origine+$Largeur_Rectangle_origine}
Y_Contact={$Y_H_G_origine+{round({$Hauteur_Rectangle_origine*{$Position_Contact/100}})}}
-endif
X_H_G_A_Imprimer=$X_H_G_origine
Y_H_G_A_Imprimer=$Y_H_G_origine
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours==1}
$Dimension_Image_Rotation,$Dimension_Image_Rotation,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Dimension_Image_Rotation,$Dimension_Image_Rotation,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},1,0xFFFFFFFF,0,0,0,1 -endif
-repeat $Nb_Rectangles
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
-endif
-if {{($Nb_boucles%2)}==0}
-polygon[-1] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,$R_a,$V_a,$B_a,$A_a
-else
-polygon[-1] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,$R_b,$V_b,$B_b,$A_b
-endif
-if {$Affichage_Contours==1}
-polygon[-2] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Type_n==0}
Largeur_A_Imprimer={$Largeur_Rectangle_origine/{$Nb_boucles+1}}
Hauteur_A_Imprimer={$Hauteur_Rectangle_origine/{$Nb_boucles+1}}
-elif {$Type_n==1}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.9}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.9}
-elif {$Type_n==2}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.8}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.8}
-elif {$Type_n==3}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.7}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.7}
-elif {$Type_n==4}
Largeur_A_Imprimer={$Largeur_A_Imprimer*{?(0.7,0.9)}}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*{?(0.7,0.9)}}
-elif {$Type_n==5}
Largeur_A_Imprimer={$Largeur_Rectangle_origine/{$Nb_boucles+1}}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.9}
-elif {$Type_n==6}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.9}
Hauteur_A_Imprimer={$Hauteur_Rectangle_origine/{$Nb_boucles+1}}
-endif
-if {$Type_Contact==0}
X_H_G_A_Imprimer={$X_Contact-{$Largeur_A_Imprimer/2}}
Y_H_G_A_Imprimer=$Y_Contact
-elif {$Type_Contact==1}
X_H_G_A_Imprimer={$X_Contact-{$Largeur_A_Imprimer/2}}
Y_H_G_A_Imprimer={$Y_Contact-$Hauteur_A_Imprimer}
-elif {$Type_Contact==2}
X_H_G_A_Imprimer=$X_Contact
Y_H_G_A_Imprimer={$Y_Contact-{$Hauteur_A_Imprimer/2}}
-elif {$Type_Contact==3}
X_H_G_A_Imprimer={$X_Contact-$Largeur_A_Imprimer}
Y_H_G_A_Imprimer={$Y_Contact-{$Hauteur_A_Imprimer/2}}
-endif
-done
-if {$Affichage_Contours==1}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_inclinaison>0} -rotate[-1] $Angle_inclinaison,1,0,{{w}/2},{{h}/2} -endif
-crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{$Largeur_Origine+{{{w}-$Largeur_Origine-1}/2}-1},{$Hauteur_Origine+{{{h}-$Hauteur_Origine-1}/2}-1}
-blend[-1,-2] alpha,1,0
#@gui Annular Steiner Chains : samj_en_Annular_Steiner_Chains, samj_en_Annular_Steiner_Chains(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Nb Circles Surrounding = int(6,3,360)
#@gui : Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Display Contours = choice(1,"Sans","CE CI CA","CE CI CA CC","CE CI CA CC CT","CE CI CA CT","CE CA","CI CA","CA")
#@gui : Exterior Circle A = color(255,255,0,127)
#@gui : Centre Circle B = color(64,192,128,127)
#@gui : Circle C = color(0,255,0,127)
#@gui : Circle D = color(0,0,255,127)
#@gui : Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Shadow = bool(0)
#@gui : X-Shadow = float(0.5,-5,5)
#@gui : Y-Shadow = float(0.5,-5,5)
#@gui : Smoothness Shadow = float(1.8,0,5)
#@gui : Curvature Shadow = float(0,0,1)
#@gui : Shadow Offset X = float(0,-20,20)
#@gui : Shadow Offset Y = float(0,-20,20)
#@gui : Alpha Channel = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/08</i>.</small>")
samj_en_Annular_Steiner_Chains :
-samj_Annular_Steiner_Chains $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40
#@gui Annular Steiner Chains : samj_Annular_Steiner_Chains, samj_Annular_Steiner_Chains(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Cercle Ext\303\251rieur / Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Nb Cercles Ext\303\251rieurs / Circles Surrounding = int(6,3,360)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = choice(1,"Sans","CE CI CA","CE CI CA CC","CE CI CA CC CT","CE CI CA CT","CE CA","CI CA","CA")
#@gui : Cercle Ext\303\251rieur / Exterior Circle A = color(255,255,0,127)
#@gui : Cercle Centre  / Centre Circle B = color(64,192,128,127)
#@gui : Cercle / Circle C = color(0,255,0,127)
#@gui : Cercle / Circle D = color(0,0,255,127)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/20</i>.</small>")
samj_Annular_Steiner_Chains :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
-if {$3>0}
Rayon_Cercle_Exterieur={round({{w}*$3/{100}})}
-else
Rayon_Cercle_Exterieur={round({-{h}*$3/{100}})}
-endif
Nb_Circles_Surrounding=$4
Angle_inclinaison=$5
R_Contours=$6
V_Contours=$7
B_Contours=$8
A_Contours=$9
Affichage_Contours=$10
R_CE=$11
V_CE=$12
B_CE=$13
A_CE=$14
R_PC=$15
V_PC=$16
B_PC=$17
A_PC=$18
R_c=$19
V_c=$20
B_c=$21
A_c=$22
R_d=$23
V_d=$24
B_d=$25
A_d=$26
Couleurs_aleatoires=$27
Inversions=$28
Flou=$29
Dilatation=$30
Deformation=$31
Bruit=$32
Ombre=$33
X_Ombre=$34
Y_Ombre=$35
Smoothness_Ombre=$36
Curvature_Ombre=$37
Compensation_Decalage_Ombre_X=$38
Compensation_Decalage_Ombre_Y=$39
Canal_Alpha=$40
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Theta={pi/$Nb_Circles_Surrounding}
Rayon_Cercle_Centre={{$Rayon_Cercle_Exterieur*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Couleurs_aleatoires==1}
R_CE={round(u)*255}
V_CE={round(u)*255}
B_CE={round(u)*255}
R_PC={round(u)*255}
V_PC={round(u)*255}
B_PC={round(u)*255}
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-ellipse[-1] $X,$Y,$Rayon_Cercle_Centre,$Rayon_Cercle_Centre,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==2}||{$Affichage_Contours==3}}
-ellipse[-1] $X,$Y,$Rayon_Centres_C_Ext,$Rayon_Centres_C_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==3}||{$Affichage_Contours==4}}
-ellipse[-1] $X,$Y,$Rayon_Tang,$Rayon_Tang,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,$R_CE,$V_CE,$B_CE,$A_CE
-ellipse[-1] $X,$Y,$Rayon_Cercle_Centre,$Rayon_Cercle_Centre,0,1,$R_PC,$V_PC,$B_PC,$A_PC
-repeat $Nb_Circles_Surrounding
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison}})}}}
Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison}})}}}
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
-endif
-if {{($Nb_Circles_Surrounding%2)}==0}
-if {{($Nb_boucles%2)}==0}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_c,$V_c,$B_c,$A_c
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_d,$V_d,$B_d,$A_d
-endif
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_c,$V_c,$B_c,$A_c
-endif
-if {$Affichage_Contours>0}
-ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#-text_outline[-1] {2*$Rayon_Cercle_Exterieur},10,10,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercles_Ext},10,60,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Centres_C_Ext},10,110,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Tang},10,160,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercle_Centre},10,210,64,1,1,255,255,255
#@gui Christmas Balls : samj_Noel_2016 , samj_Noel_2016(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_Noel_2016</b></span>")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(50,0,100)
#@gui : Ellipse / Circle A = Float(100,1,500)
#@gui : Ellipse B = Float(150,1,500)
#@gui : Depth Max = int(7,1,13)
#@gui : Line = bool(0)
#@gui : Color = color(240,45,15,255)
#@gui : Color Variation = int(-15,-255,255)
#@gui : Spacing = Float(2.5,0,8)
#@gui : Rendering = choice(2,"Ellipse A","Ellipse B","Ball A","Ball B")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Ball [light]</b></span>")
#@gui : Specular Light = float(0.8,0,8)
#@gui : Specular Size = float(1,0,8)
#@gui : Shadow = float(1.5,0,4)
#@gui : Angle = float(0,-180,180)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Rotation</b></span>")
#@gui : Rotate = Float(0,-180,180)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [Antialias] = bool(0)
#@gui : Amplitude = float(0.25,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/20</i>.</small>")
samj_Noel_2016 :
x={round({{w}/100*$1})}
y={round({{h}/100*$2})}
rayonA={{w}/1000*$3}
rayonB={{w}/1000*$4}
depth_max=$5
fil=$6
R_DT=$7
V_DT=$8
B_DT=$9
A_DT=$10
Variation_Couleur=$11
K_espacement=$12
Type_Rendu=$13
Ball_Specular_light=$14
Ball_Specular_size=$15
Ball_Shadow=$16
Ball_Angle=$17
Rotation=$18
Validation_Smooth_Antialias=$19
V_Amplitude=$20
V_Edge_Threshold=$21
V_Smoothness=$22
depth=0
L_Origine={w}
H_Origine={h}
-to_rgba[-1]
$L_Origine,$H_Origine,1,4
-samj_guirlande[-1] $x,$y,$rayonA,$rayonB,$depth,$depth_max,$fil,$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$K_espacement,$L_Origine,$H_Origine,$Type_Rendu,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow,$Ball_Angle
-if {$Rotation!=0} -rotate[-1] $Rotation -endif
-if {$Validation_Smooth_Antialias==1} -fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness -endif
-blend[-1,-2] alpha
samj_guirlande :
x=$1
y=$2
rayonA=$3
rayonB=$4
depth=$5
depth_max=$6
fil=$7
R_DT=$8
V_DT=$9
B_DT=$10
A_DT=$11
Variation_Couleur=$12
K_espacement=$13
L_Origine=$14
H_Origine=$15
Type_Rendu=$16
Ball_Specular_light=$17
Ball_Specular_size=$18
Ball_Shadow=$19
Ball_Angle=$20
-if {{$depth<$depth_max}&&{$rayonA>1}&&{$rayonB>1}}
-if {$Type_Rendu==0}
-ellipse[-1] $x,$y,$rayonA,$rayonB,1,1,$R_DT,$V_DT,$B_DT,$A_DT
-elif {$Type_Rendu==1}
$L_Origine,$H_Origine,1,4
-ellipse[-1] $x,$y,$rayonA,$rayonB,1,1,$R_DT,$V_DT,$B_DT,$A_DT
-reverse[-1,-2]
-blend[-1,-2] alpha
-elif {$Type_Rendu==2}
$L_Origine,$H_Origine,1,4
-ball {$rayonA*2},$R_DT,$V_DT,$B_DT,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow
-rotate[-1] $Ball_Angle
-autocrop[-1] 0
-blend[-1,-2] alpha
-shift[-1] {-1*{{$L_Origine/2}-$x}},{$y-{$H_Origine/2}},0,0,0
-blend[-1,-2] alpha
-elif {$Type_Rendu==3}
$L_Origine,$H_Origine,1,4
$L_Origine,$H_Origine,1,4
-ball {$rayonA*2},$R_DT,$V_DT,$B_DT,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow
-rotate[-1] $Ball_Angle
-autocrop[-1] 0
-blend[-1,-2] alpha
-shift[-1] {-1*{{$L_Origine/2}-$x}},{$y-{$H_Origine/2}},0,0,0
-blend[-1,-2] alpha
-reverse[-1,-2]
-blend[-1,-2] alpha
-endif
R_DT={$R_DT+$Variation_Couleur}
V_DT={$V_DT+$Variation_Couleur}
B_DT={$B_DT+$Variation_Couleur}
-if {$R_DT>255}
R_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-if {$V_DT>255}
V_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-if {$B_DT>255}
B_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-if {$R_DT<0}
R_DT={$R_DT+$Variation_Couleur+{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-if {$V_DT<0}
V_DT={$V_DT+$Variation_Couleur+{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-if {$B_DT<0}
B_BT={$B_DT+$Variation_Couleur+{$Variation_Couleur*{$depth_max-$depth}}}
-endif
-samj_guirlande[-1] {$x+{$rayonA*$K_espacement}},$y,{$rayonA/2},{$rayonB/2},{$depth+1},$depth_max,$fil,$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$K_espacement,$L_Origine,$H_Origine,$Type_Rendu,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow,$Ball_Angle
-samj_guirlande[-1] {$x-{$rayonA*$K_espacement}},$y,{$rayonA/2},{$rayonB/2},{$depth+1},$depth_max,$fil,$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$K_espacement,$L_Origine,$H_Origine,$Type_Rendu,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow,$Ball_Angle
-if {$fil==1}
$L_Origine,$H_Origine,1,4
-line[-1] {$x+{$rayonA*$K_espacement}},$y,{$x-{$rayonA*2.5}},$y,1,$R_DT,$V_DT,$B_DT,$A_DT
-reverse[-1,-2]
-blend[-1,-2] alpha
-endif
-endif
#@gui Chryzodes : samj_en_Chryzodes, samj_en_Chryzodes(1)
#@gui : note = link("http://www.chryzode.org/fr/ligne.htm","http://www.chryzode.org/fr/ligne.htm")
#@gui : sep = separator(), note = note("<small><b><span foreground="red">New Image</span></b></small>")
#@gui : Image Dimensions = float(100,30,400)
#@gui : Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Rendering</span></b></small>")
#@gui : Examples = choice(0,"None","431/7/VC=0","353/3/VC=0","619/4/VC=0","691/12/VC=0","613/20/VC=0","358/13/VC=1","118/20/VC=1","699/6/VC=0")
#@gui : X Position (%) = float(50,0,100)
#@gui : Y Position (%) = float(50,0,100)
#@gui : External Circle Radius = float(45,10,200)
#@gui : Number of Points - Module = int(79,10,1080)
#@gui : Multiplier = int(3,3,33)
#@gui : First Point = int(1,1,1080)
#@gui : Color Straight Lines = color(240,128,64,255)
#@gui : Tilt Angle = float(0,-360,360)
#@gui : Type Straight Lines = choice(0,"Lines Inside The Circle","Over The Entire Image")
#@gui : Random Colors = choice(0,"None","Variations","Lines")
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Variations Rendering Image Filter</span></b></small>")
#@gui : Variations A = int(0,0,1080)
#@gui : Variations B = int(0,0,3)
#@gui : Variation C = bool(0)
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Changes Rendering Image Filter</span></b></small>")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Draw The Circle = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2015/03/03</i>.</small>")
samj_en_Chryzodes :
-samj_Chryzodes $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27
#@gui Chryzodes : samj_Chryzodes, samj_Chryzodes(1)
#@gui : note = link("http://www.chryzode.org/fr/ligne.htm","http://www.chryzode.org/fr/ligne.htm")
#@gui : sep = separator(), note = note("<small><b><span foreground="red">New Image</span></b></small>")
#@gui : Image Dimensions = float(100,30,400)
#@gui : Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Rendering</span></b></small>")
#@gui : Examples = choice(0,"None","431/7/VC=0","353/3/VC=0","619/4/VC=0","691/12/VC=0","613/20/VC=0","358/13/VC=1","118/20/VC=1","699/6/VC=0")
#@gui : X Position (%) = float(50,0,100)
#@gui : Y Position (%) = float(50,0,100)
#@gui : External Circle Radius = float(45,10,200)
#@gui : Number of Points - Module = int(79,10,1080)
#@gui : Multiplier = int(3,3,33)
#@gui : First Point = int(1,1,1080)
#@gui : Color Straight Lines = color(240,128,64,255)
#@gui : Tilt Angle = float(0,-360,360)
#@gui : Type Straight Lines = choice(0,"Lines Inside The Circle","Over The Entire Image")
#@gui : Random Colors = choice(0,"None","Variations","Lines")
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Variations Rendering Image Filter</span></b></small>")
#@gui : Variations A = int(0,0,1080)
#@gui : Variations B = int(0,0,3)
#@gui : Variation C = bool(0)
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Changes Rendering Image Filter</span></b></small>")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Draw The Circle = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/12/20</i>.</small>")
samj_Chryzodes :
Dimension={round({{max({w},{h})}*$1/100})}
R_fond=$2
V_fond=$3
B_fond=$4
A_fond=$5
Demo=$6
X={round({$Dimension*{$7/100}})}
Y={round({$Dimension*{$8/100}})}
Rayon_Cercle={round({$Dimension*$9/100})}
Nb_Points=$10
Multiplicateur=$11
Premier_Point=$12
R_l=$13
V_l=$14
B_l=$15
A_l=$16
Angle_Inclinaison=$17
Type_De_Lignes=$18
Couleurs_aleatoires=$19
Variations_A=$20
Variations_B=$21
Variations_C=$22
Flou=$23
Dilatation=$24
Deformation=$25
Bruit=$26
Tracer_Cercle=$27
-if {$Demo==1}
Nb_Points=431
Multiplicateur=7
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==2}
Nb_Points=353
Multiplicateur=3
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==3}
Nb_Points=619
Multiplicateur=4
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==4}
Nb_Points=691
Multiplicateur=12
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==5}
Nb_Points=613
Multiplicateur=20
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==6}
Nb_Points=358
Multiplicateur=13
Variations_A=0
Variations_B=0
Variations_C=1
-elif {$Demo==7}
Nb_Points=118
Multiplicateur=20
Variations_A=0
Variations_B=0
Variations_C=1
-elif {$Demo==8}
Nb_Points=699
Multiplicateur=6
Variations_A=0
Variations_B=0
Variations_C=0
Demo=8
-endif
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Base={360/$Nb_Points}
Point_Origine=0
Sortie_Boucle_Lignes=0
Nb_Boucle_Lignes=0
Nb_Boucle_Points=0
Point_A=0
Angle_A=0
X_Imp_A=0
Y_Imp_A=0
Point_B=0
Angle_B=0
X_Imp_B=0
Y_Imp_B=0
a_Ligne=0
b_Ligne=0
X_Ex_a=0
Y_Ex_a=0
X_Ex_b=0
Y_Ex_b=0
-if {$Variations_A==0}
Boucles_Rendu=1
Variations_A=1
-else
Boucles_Rendu=2
-endif
-rm[-1]
$Dimension,$Dimension,1,4
-fill_color[-1] 0,0,0,0
Point_A=$Premier_Point
Angle_A={$Angle_Base*$Point_A}
X_Imp_A={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Y_Imp_A={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Point_Origine=$Point_A
test=0
-repeat {$Boucles_Rendu+$Variations_B}
-if {$Couleurs_aleatoires==1}
R_l={round(u)*255}
V_l={round(u)*255}
B_l={round(u)*255}
-endif
-do
-if {$Couleurs_aleatoires==2}
R_l={round(u)*255}
V_l={round(u)*255}
B_l={round(u)*255}
-endif
-if {$Variations_C==0}
Point_B={{$Point_A*$Multiplicateur}%$Nb_Points}
-else
Point_B={{$Point_A*$Multiplicateur*2}%$Nb_Points}
-endif
Angle_B={$Angle_Base*$Point_B}
X_Imp_B={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_B+$Angle_Inclinaison}})}}}
Y_Imp_B={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_B+$Angle_Inclinaison}})}}}
-if {$Type_De_Lignes==1}
-if {{round({$X_Imp_A*1000000000000})}=={round({$X_Imp_B*1000000000000})}}
X_Ex_a=$X_Imp_A
Y_Ex_a=0
X_Ex_b=$X_Imp_B
Y_Ex_b={$Dimension-1}
-line[-1] $X_Ex_a,$Y_Ex_a,$X_Ex_b,$Y_Ex_b,1,$R_l,$V_l,$B_l,$A_l
-else
a_Ligne={{$Y_Imp_B-$Y_Imp_A}/{$X_Imp_B-$X_Imp_A}}
b_Ligne={$Y_Imp_B-{$a_Ligne*$X_Imp_B}}
X_Ex_a=0
Y_Ex_a=$b_Ligne
X_Ex_b={$Dimension-1}
Y_Ex_b={{$a_Ligne*$X_Ex_b}+$b_Ligne}
-line[-1] $X_Ex_a,$Y_Ex_a,$X_Ex_b,$Y_Ex_b,1,$R_l,$V_l,$B_l,$A_l
-endif
-else
-line[-1] $X_Imp_A,$Y_Imp_A,$X_Imp_B,$Y_Imp_B,1,$R_l,$V_l,$B_l,$A_l
-endif
-if {{$Point_B}=={$Point_Origine}} Sortie_Boucle_Lignes=1 -endif
-if {{$Nb_Boucle_Lignes}>{$Nb_Points*$Multiplicateur}} Sortie_Boucle_Lignes=1 -endif
-if {$Variations_C==1}
-if {{$Nb_Boucle_Lignes}>{$Nb_Points}} Sortie_Boucle_Lignes=1 -endif
-endif
Point_A=$Point_B
X_Imp_A=$X_Imp_B
Y_Imp_A=$Y_Imp_B
Nb_Boucle_Lignes={$Nb_Boucle_Lignes+1}
-while {$Sortie_Boucle_Lignes==0}
Nb_Boucle_Points={$Nb_Boucle_Points+1}
Point_A={$Premier_Point+{1/$Nb_Points*$Nb_Boucle_Points/$Variations_A}}
Angle_A={$Angle_Base*$Point_A}
X_Imp_A={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Y_Imp_A={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Point_Origine=$Point_A
Sortie_Boucle_Lignes=0
Nb_Boucle_Lignes=0
-done
-if {$Tracer_Cercle==1}
-ellipse[-1] $X,$Y,$Rayon_Cercle,$Rayon_Cercle,0,1,0xFFFFFFFF,$R_l,$V_l,$B_l,$A_l
-endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
$Dimension,$Dimension,1,4
-fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond
-gimp_blend_1651[-2,-1] 1,0,1,0,1
#@gui Dessiner Un Polygone - Draw a Polygon : samj_dessiner_un_polygone, samj_dessiner_un_polygone(1)
#@gui : sep = separator(), note = note("<small>Polygone / Polygone</small>")
#@gui : Nombre De C\303\264t\303\251s / Number of Sides = int(5,3,90)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle Inclinaison = float(0,0,120)
#@gui : Rayon Cercle Circonscrit / Circumcircle Radius (>0 W%) (<0 H%) = float(40,-400,400)
#@gui : Rayon Cercle Int\303\251rieur / Inner Circle Radius (%) = float(50,0,100)
#@gui : Remplir Polygone Ext\303\251rieur / Fill = bool(1)
#@gui : Couleur Polygone Ext\303\251rieur = color(255,255,0)
#@gui : Contour Polygone Ext\303\251rieur = bool(0)
#@gui : Couleur Contour Polygone Ext\303\251rieur = color(0,0,0)
#@gui : Remplir Polygone Int\303\251rieur / Fill = bool(1)
#@gui : Couleur Polygone Int\303\251rieur = color(0,0,255)
#@gui : Contour Polygone Int\303\251rieur = bool(0)
#@gui : Couleur Contour Polygone Int\303\251rieur = color(0,255,0)
#@gui : Variation De Couleur / Color Variation = choice("Pas de variation / No change","Couleurs aleatoires / Random colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : sep = separator(), note = note("<small>cercles / circles</small>")
#@gui : Remplir Cercle Int\303\251rieur / Fill = bool(0)
#@gui : Couleur Cercle Int\303\251rieur = color(127,127,127)
#@gui : Contour Cercle Int\303\251rieur = bool(0)
#@gui : Couleur Contour Cercle Int\303\251rieur = color(0,0,0)
#@gui : Remplir Cercle Ext\303\251rieur / Fill = bool(0)
#@gui : Couleur Cercle Ext\303\251rieur = color(255,255,255)
#@gui : Contour Cercle Ext\303\251rieur = bool(0)
#@gui : Couleur Contour Cercle Ext\303\251rieur = color(0,0,0)
#@gui : Dilatation (\303\251paisseur) = int(1,1,48)
#@gui : sep = separator(), note = note("<small>Transparence / Transparency</small>")
#@gui : Transparence Des Couleurs / Color Transparency = int(255,0,255)
#@gui : sep = separator(), note = note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : D\303\251formation = float(0,0,25)
#@gui : sep = separator(), note = note("<small>M\303\251lange / Blend</small>")
#@gui : Mode = choice(1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_dessiner_un_polygone:
Nombre_de_cotes=$1
X_centre_cercle_circonscrit={$2/100*w}
Y_centre_cercle_circonscrit={$3/100*h}
Angle_inclinaison=$4
-if {$5>0}
Rayon_cercle_circonscrit={round({{w}*$5/{100}})}
-else
Rayon_cercle_circonscrit={round({-{h}*$5/{100}})}
-endif
Rayon_cercle_interieur={round({$Rayon_cercle_circonscrit/100*$6})}
Remplir_polygone_exterieur=$7
## ATTENTION variables $8,$9,$10 utilises + loin dans le script
R_Couleur_polygone_exterieur=$8
V_Couleur_polygone_exterieur=$9
B_Couleur_polygone_exterieur=$10
Contour_polygone_exterieur=$11
R_Couleur_contour_polygone_exterieur=$12
V_Couleur_contour_polygone_exterieur=$13
B_Couleur_contour_polygone_exterieur=$14
Remplir_polygone_interieur=$15
## ATTENTION variables $16,$17,$18 utilises + loin dans le script
R_Couleur_polygone_interieur=$16
V_Couleur_polygone_interieur=$17
B_Couleur_polygone_interieur=$18
Contour_polygone_interieur=$19
R_Couleur_contour_polygone_interieur=$20
V_Couleur_contour_polygone_interieur=$21
B_Couleur_contour_polygone_interieur=$22
Variation_de_couleur=$23
Remplir_cercle_interieur=$24
R_CI_plein=$25
V_CI_plein=$26
B_CI_plein=$27
Contour_cercle_interieur=$28
R_CI_contour=$29
V_CI_contour=$30
B_CI_contour=$31
Remplir_cercle_exterieur=$32
R_CE_plein=$33
V_CE_plein=$34
B_CE_plein=$35
Contour_cercle_exterieur=$36
R_CE_contour=$37
V_CE_contour=$38
B_CE_contour=$39
Valeur_dilate_circ=$40
Transparence_des_couleurs=$41
Flou_polygone=$42
Spread_polygone=$43
Deform_polygone=$44
blend=$45
{w},{h},1,4
-fill_color[-1] 0,0,0,0
#
-if {$Remplir_cercle_exterieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_circonscrit,$Rayon_cercle_circonscrit,0,1,$R_CE_plein,$V_CE_plein,$B_CE_plein,$Transparence_des_couleurs
-endif
#
-if {$Contour_cercle_exterieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_circonscrit,$Rayon_cercle_circonscrit,0,1,0xFFFFFF,$R_CE_contour,$V_CE_contour,$B_CE_contour,$Transparence_des_couleurs
-endif
#
Increment_angle={360/$Nombre_de_cotes}
Nb_boucle=$Nombre_de_cotes
-do
-if {$Variation_de_couleur==0}
X_point_exterieur={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
Y_point_exterieur={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
X_point_interieur={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
Y_point_interieur={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
-if {$Nb_boucle==$Nombre_de_cotes}
Points_polygone_exterieur=$X_point_exterieur,$Y_point_exterieur
Points_polygone_interieur=$X_point_interieur,$Y_point_interieur
-else
Points_polygone_exterieur=$Points_polygone_exterieur,$X_point_exterieur,$Y_point_exterieur
Points_polygone_interieur=$Points_polygone_interieur,$X_point_interieur,$Y_point_interieur
-endif
-if {$Nb_boucle==1}
-if {$Remplir_polygone_exterieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_exterieur,1,$R_Couleur_polygone_exterieur,$V_Couleur_polygone_exterieur,$B_Couleur_polygone_exterieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_exterieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_exterieur,1,0xFFFFFF,$R_Couleur_contour_polygone_exterieur,$V_Couleur_contour_polygone_exterieur,$B_Couleur_contour_polygone_exterieur,$Transparence_des_couleurs
-endif
-if {$Remplir_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
-endif
-if {$Contour_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
-endif
-if {$Remplir_polygone_interieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_interieur,1,$R_Couleur_polygone_interieur,$V_Couleur_polygone_interieur,$B_Couleur_polygone_interieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_interieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_interieur,1,0xFFFFFF,$R_Couleur_contour_polygone_interieur,$V_Couleur_contour_polygone_interieur,$B_Couleur_contour_polygone_interieur,$Transparence_des_couleurs
-endif
-endif
-endif
-if {$Variation_de_couleur==1}
X_point_exterieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_exterieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
-if {$Contour_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,0xFFFFFF,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
X_point_interieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_interieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
-if {$Contour_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,0xFFFFFF,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
-if {$Nb_boucle==1}
-if {$Remplir_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
-endif
-if {$Contour_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
-endif
-endif
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_polygone_exterieur={round({$8+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_polygone_exterieur>255}
R_Couleur_polygone_exterieur=$8
-endif
-if {$R_Couleur_polygone_exterieur<0}
R_Couleur_polygone_exterieur=$8
-endif
V_Couleur_polygone_exterieur={round({$9+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_polygone_exterieur>255}
V_Couleur_polygone_exterieur=$9
-endif
-if {$V_Couleur_polygone_exterieur<0}
V_Couleur_polygone_exterieur=$9
-endif
B_Couleur_polygone_exterieur={round({$10+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_polygone_exterieur>255}
B_Couleur_polygone_exterieur=$10
-endif
-if {$B_Couleur_polygone_exterieur<0}
B_Couleur_polygone_exterieur=$10
-endif
R_Couleur_polygone_interieur={round({$16+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_polygone_interieur>255}
R_Couleur_polygone_interieur=$16
-endif
-if {$R_Couleur_polygone_interieur<0}
R_Couleur_polygone_interieur=$16
-endif
V_Couleur_polygone_interieur={round({$17+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_polygone_interieur>255}
V_Couleur_polygone_interieur=$17
-endif
-if {$V_Couleur_polygone_interieur<0}
V_Couleur_polygone_interieur=$17
-endif
B_Couleur_polygone_interieur={round({$18+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_polygone_interieur>255}
B_Couleur_polygone_interieur=$18
-endif
-if {$B_Couleur_polygone_interieur<0}
B_Couleur_polygone_interieur=$18
-endif
X_point_exterieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_exterieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,$R_Couleur_polygone_exterieur,$V_Couleur_polygone_exterieur,$B_Couleur_polygone_exterieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,0xFFFFFF,$R_Couleur_contour_polygone_exterieur,$V_Couleur_contour_polygone_exterieur,$B_Couleur_contour_polygone_exterieur,$Transparence_des_couleurs
-endif
X_point_interieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_interieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,$R_Couleur_polygone_interieur,$V_Couleur_polygone_interieur,$B_Couleur_polygone_interieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,0xFFFFFF,$R_Couleur_contour_polygone_interieur,$V_Couleur_contour_polygone_interieur,$B_Couleur_contour_polygone_interieur,$Transparence_des_couleurs
-endif
-if {$Nb_boucle==1}
-if {$Remplir_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
-endif
-if {$Contour_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
-endif
-endif
-endif
Increment_angle={$Increment_angle+{360/$Nombre_de_cotes}}
Nb_boucle={$Nb_boucle-1}
-while {$Nb_boucle>0}
-if {$Valeur_dilate_circ>1}
-dilate_circ[-1] $Valeur_dilate_circ
-endif
-blur[-1] $Flou_polygone
-spread[-1] $Spread_polygone
-deform[-1] $Deform_polygone
-gimp_blend_1651[-2,-1] $blend,1,1,1
#@gui Egg Oeuf Granville : samj_Egg_Oeuf_Granville, samj_Egg_Oeuf_Granville(1)
#@gui : note = link("http://en.wikipedia.org/wiki/William_Anthony_Granville","http://en.wikipedia.org/wiki/William_Anthony_Granville")
#@gui : note = link("http://www.mathcurve.com/courbes2d/oeuf/oeufgranville.shtml","http://www.mathcurve.com/courbes2d/oeuf/oeufgranville.shtml")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : D\303\251calage X = float(0,-100,100)
#@gui : Valeur A Forme = float(20,0,100)
#@gui : Valeur B Forme = float(30,1,100)
#@gui : Valeur R Forme = float(10,0.1,99)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Egg Oeuf","Egg Oeuf CA CB CR")
#@gui : Couleur = color(255,255,0,127)
#@gui : Couleur Al\303\251atoire / Random Color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation D\303\251calage Ombre X = float(0,-50,50)
#@gui : Compensation D\303\251calage Ombre Y = float(0,-50,50)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Egg_Oeuf_Granville :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Decalage_X={round({{min({w},{h})}*$3/100})}
Valeur_A={round({{min({w},{h})}*$4/40})}
Valeur_B={round({{min({w},{h})}*$5/40})}
Valeur_R={round({{min({w},{h})}*$6/40})}
Angle_Rotation=$7
R_Contours=$8
V_Contours=$9
B_Contours=$10
A_Contours=$11
Affichage_Contours=$12
R_a=$13
V_a=$14
B_a=$15
A_a=$16
Couleurs_aleatoires=$17
Inversions=$18
Flou=$19
Dilatation=$20
Deformation=$21
Bruit=$22
Ombre=$23
X_Ombre=$24
Y_Ombre=$25
Smoothness_Ombre=$26
Curvature_Ombre=$27
Compensation_Decalage_Ombre_X=$28
Compensation_Decalage_Ombre_Y=$29
Canal_Alpha=$30
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Oeuf_A_Imprimer=0
Y_Oeuf_A_Imprimer=0
# X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{     }}}
# Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{     }}}
X_Oeuf_A_Imprimer_Precedent={{$X-{$Valeur_B+{$Valeur_R/2}}}+{$Decalage_X+{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}
Y_Oeuf_A_Imprimer_Precedent={$Y+{{{$Valeur_A*$Valeur_R*{sin({pi/180*$Angle})}}/{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-if {$Affichage_Contours==2}
-ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_B,$Valeur_B,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_R,$Valeur_R,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Oeuf_A_Imprimer={{$X-{$Valeur_B+{$Valeur_R/2}}}+{$Decalage_X+{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}
Y_Oeuf_A_Imprimer={$Y+{{{$Valeur_A*$Valeur_R*{sin({pi/180*$Angle})}}/{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}}
-polygon[-1] 3,{$X+$Decalage_X},$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
#@gui Egg Oeuf Hugelschaffer : samj_Egg_Oeuf_Hugelschaffer, samj_Egg_Oeuf_Hugelschaffer(1)
#@gui : note = link("http://www.mathcurve.com/courbes2d/oeuf/oeuf.shtml","http://www.mathcurve.com/courbes2d/oeuf/oeuf.shtml")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Dimension = float(50,0,100)
#@gui : Valeur A Forme = float(6,0,10)
#@gui : Valeur B Forme = float(48,0,100)
#@gui : Valeur D Forme = float(0,0,24)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Egg Oeuf","Egg Oeuf CA CB")
#@gui : Couleur = color(255,255,0,127)
#@gui : Couleur Al\303\251atoire / Random Color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation D\303\251calage Ombre X = float(0,-20,20)
#@gui : Compensation D\303\251calage Ombre Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Egg_Oeuf_Hugelschaffer :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Dimension={round({{min({w},{h})}*$3/5000})}
Valeur_A=$4
Valeur_B=$5
Valeur_D=$6
Angle_Rotation=$7
R_Contours=$8
V_Contours=$9
B_Contours=$10
A_Contours=$11
Affichage_Contours=$12
R_a=$13
V_a=$14
B_a=$15
A_a=$16
Couleurs_aleatoires=$17
Inversions=$18
Flou=$19
Dilatation=$20
Deformation=$21
Bruit=$22
Ombre=$23
X_Ombre=$24
Y_Ombre=$25
Smoothness_Ombre=$26
Curvature_Ombre=$27
Compensation_Decalage_Ombre_X=$28
Compensation_Decalage_Ombre_Y=$29
Canal_Alpha=$30
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Oeuf_A_Imprimer=0
Y_Oeuf_A_Imprimer=0
X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{{{{$Valeur_A*$Valeur_A}-{$Valeur_D*$Valeur_D*{sin({pi/180*$Angle})}*{sin({pi/180*$Angle})}}^0.5}+{$Valeur_D*{cos({pi/180*$Angle})}}}*{cos({pi/180*$Angle})}}}}
Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{$Valeur_B*{sin({pi/180*$Angle})}}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-if {$Affichage_Contours==2}
-ellipse[-2] $X,$Y,{$Dimension*$Valeur_A},{$Dimension*$Valeur_A},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] $X,$Y,{$Dimension*$Valeur_B},{$Dimension*$Valeur_B},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Oeuf_A_Imprimer={$X+{$Dimension*{{{{$Valeur_A*$Valeur_A}-{$Valeur_D*$Valeur_D*{sin({pi/180*$Angle})}*{sin({pi/180*$Angle})}}^0.5}+{$Valeur_D*{cos({pi/180*$Angle})}}}*{cos({pi/180*$Angle})}}}}
Y_Oeuf_A_Imprimer={$Y+{$Dimension*{$Valeur_B*{sin({pi/180*$Angle})}}}}
-polygon[-1] 3,$X,$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
#@gui Egg Oeuf Rosillo : samj_Egg_Oeuf_Rosillo, samj_Egg_Oeuf_Rosillo(1)
#@gui : note = link("http://www.mathcurve.com/courbes2d/rosillo/rosillo.shtml","http://www.mathcurve.com/courbes2d/rosillo/rosillo.shtml")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Valeur A Dimension = float(40,0,100)
#@gui : Valeur B Forme 200%A = float(200,0,400)
#@gui : Valeur C Forme 300%A = float(300,0,400)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Egg Oeuf","Egg Oeuf CA CB CC")
#@gui : Couleur = color(255,255,0,127)
#@gui : Couleur Al\303\251atoire / Random Color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation D\303\251calage Ombre X = float(0,-50,50)
#@gui : Compensation D\303\251calage Ombre Y = float(0,-50,50)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Egg_Oeuf_Rosillo :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Valeur_A={round({{{w}+{h}}*$3/200})}
Valeur_B={$Valeur_A*$4/100}
Valeur_C={$Valeur_A*$5/100}
Angle_Rotation=$6
R_Contours=$7
V_Contours=$8
B_Contours=$9
A_Contours=$10
Affichage_Contours=$11
R_a=$12
V_a=$13
B_a=$14
A_a=$15
Couleurs_aleatoires=$16
Inversions=$17
Flou=$18
Dilatation=$19
Deformation=$20
Bruit=$21
Ombre=$22
X_Ombre=$23
Y_Ombre=$24
Smoothness_Ombre=$25
Curvature_Ombre=$26
Compensation_Decalage_Ombre_X=$27
Compensation_Decalage_Ombre_Y=$28
Canal_Alpha=$29
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Oeuf_A_Imprimer=0
Y_Oeuf_A_Imprimer=0
# X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{     }}}
# Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{     }}}
X_Oeuf_A_Imprimer_Precedent={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
Y_Oeuf_A_Imprimer_Precedent={$Y+{{$Valeur_B-{$Valeur_A*{cos({pi/180*$Angle})}}}/{$Valeur_C-{$Valeur_A*{cos({pi/180*$Angle})}}}*{$Valeur_A*{sin({pi/180*$Angle})}}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-if {$Affichage_Contours==2}
-ellipse[-2] $X,$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] $X,$Y,$Valeur_B,$Valeur_B,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] $X,$Y,$Valeur_C,$Valeur_C,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Oeuf_A_Imprimer={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
Y_Oeuf_A_Imprimer={$Y+{{$Valeur_B-{$Valeur_A*{cos({pi/180*$Angle})}}}/{$Valeur_C-{$Valeur_A*{cos({pi/180*$Angle})}}}*{$Valeur_A*{sin({pi/180*$Angle})}}}}
-polygon[-1] 3,$X,$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
#@gui Etoiles Remplies Triangles Sierpinski : samj_Etoiles_Remplies_Triangles_Sierpinski, samj_Etoiles_Remplies_Triangles_Sierpinski(1)
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Nombre De Sommets = int(6,2,18)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Cercle Ext\303\251rieur / Outer Circle Radius (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Rayon Cercle Int\303\251rieur / Inner Circle Radius (%) = float(40,0,100)
#@gui : Angle Inclinaison = float(30,0,60)
#@gui : Excentricit\303\251 / Eccentricity (%) = float(0,0,100)
#@gui : Angle Excentricit\303\251 / Eccentricity Angle = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage = choice(1,"Pas De Contours A","Pas De Contours B","Pas De Contours C","Pas De Contours D","Contours A","Contours B","Contours C","Contours D")
#@gui : Recursions Sierpinski = int(4,0,7)
#@gui : Centre A = color(255,0,0,127)
#@gui : Centre B = color(255,192,64,127)
#@gui : Sommets A = color(0,0,255,127)
#@gui : Sommets B = color(0,255,255,127)
#@gui : Cercle = color(255,255,0,127)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Etoiles_Remplies_Triangles_Sierpinski :
Nombre_de_sommets=$1
X={round({{w}*{$2/100}})}
Y={round({{h}*{$3/100}})}
-if {$4>0}
Rayon_cercle_exterieur={round({{w}*$4/{100}})}
-else
Rayon_cercle_exterieur={round({-{h}*$4/{100}})}
-endif
Rayon_cercle_interieur={round({$Rayon_cercle_exterieur*$5/100})}
Angle_inclinaison=$6
Pourcentage_excentricite=$7
Angle_excentricite=$8
R_Contours=$9
V_Contours=$10
B_Contours=$11
A_Contours=$12
Affichage=$13
Recursions_Sierpinski=$14
R_Centre=$15
V_Centre=$16
B_Centre=$17
A_Centre=$18
R_Centreb=$19
V_Centreb=$20
B_Centreb=$21
A_Centreb=$22
R_Sommet=$23
V_Sommet=$24
B_Sommet=$25
A_Sommet=$26
R_Sommetb=$27
V_Sommetb=$28
B_Sommetb=$29
A_Sommetb=$30
R_Cercle=$31
V_Cercle=$32
B_Cercle=$33
A_Cercle=$34
Couleurs_aleatoires=$35
Inversions=$36
Flou=$37
Dilatation=$38
Deformation=$39
Bruit=$40
Ombre=$41
X_Ombre=$42
Y_Ombre=$43
Smoothness_Ombre=$44
Curvature_Ombre=$45
Compensation_Decalage_Ombre_X=$46
Compensation_Decalage_Ombre_Y=$47
Canal_Alpha=$48
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_Boucle=0
Angle=0
Increment_angle={360/$Nombre_de_sommets}
Longueur_excentricite={$Pourcentage_excentricite/100*{$Rayon_cercle_exterieur-$Rayon_cercle_interieur}}
Decalage_X_excentricite={round({$Longueur_excentricite*{cos(pi/180*$Angle_excentricite)}})}
Decalage_Y_excentricite={round({$Longueur_excentricite*{sin(pi/180*$Angle_excentricite)}})}
X_centre_cercle_interieur={$X+$Decalage_X_excentricite}
Y_centre_cercle_interieur={$Y+$Decalage_Y_excentricite}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
#Couleurs alatoires
-if {$Couleurs_aleatoires==1}
R_Centre={round(u)*255}
V_Centre={round(u)*255}
B_Centre={round(u)*255}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Sommet={round(u)*255}
V_Sommet={round(u)*255}
B_Sommet={round(u)*255}
R_Sommetb={round(u)*255}
V_Sommetb={round(u)*255}
B_Sommetb={round(u)*255}
R_Sommetb_Deux={round(u)*255}
V_Sommetb_Deux={round(u)*255}
B_Sommetb_Deux={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
-if {$Affichage>3}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {{$Affichage==2}||{$Affichage==3}||{$Affichage==6}||{$Affichage==7}}
-ellipse[-1] $X,$Y,$Rayon_cercle_exterieur,$Rayon_cercle_exterieur,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-endif
-repeat $Nombre_de_sommets
-if {$Couleurs_aleatoires==1}
R_Centre={round(u)*255}
V_Centre={round(u)*255}
B_Centre={round(u)*255}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Sommet={round(u)*255}
V_Sommet={round(u)*255}
B_Sommet={round(u)*255}
R_Sommetb={round(u)*255}
V_Sommetb={round(u)*255}
B_Sommetb={round(u)*255}
R_Sommetb_Deux={round(u)*255}
V_Sommetb_Deux={round(u)*255}
B_Sommetb_Deux={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
Nb_Boucle={$Nb_Boucle+1}
X_point_exterieur={$X+{round({$Rayon_cercle_exterieur*{cos({pi/180*{$Angle+$Angle_inclinaison}})}})}}
Y_point_exterieur={$Y+{round({$Rayon_cercle_exterieur*{sin({pi/180*{$Angle+$Angle_inclinaison}})}})}}
X_point_interieur_a={$X_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Angle+$Angle_inclinaison+{180/$Nombre_de_sommets}}})}})}}
Y_point_interieur_a={$Y_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Angle+$Angle_inclinaison+{180/$Nombre_de_sommets}}})}})}}
X_point_interieur_b={$X_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Angle+$Angle_inclinaison-{180/$Nombre_de_sommets}}})}})}}
Y_point_interieur_b={$Y_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Angle+$Angle_inclinaison-{180/$Nombre_de_sommets}}})}})}}
-if {{($Nombre_de_sommets%2)}==0}
-if {{($Nb_Boucle%2)}==0}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-endif
-if {{($Affichage%2)}==1}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-endif
-endif
-else
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommetb,$V_Sommetb,$B_Sommetb,$A_Sommetb
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommetb,$V_Sommetb,$B_Sommetb,$A_Sommetb
-endif
-if {{($Affichage%2)}==1}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-endif
-endif
-endif
-else
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-endif
-if {{($Affichage%2)}==1}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-endif
-endif
-endif
-if {$Affichage>3}
-polygon[-2] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Angle={$Increment_angle*$Nb_Boucle}
-done
-if {$Affichage>5}
-ellipse[-2] $X,$Y,$Rayon_cercle_exterieur,$Rayon_cercle_exterieur,0,1,0xFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Affichage>3}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#@gui Etoile De Pompei Triangles Sierpinski : samj_Etoile_De_Pompei_Triangles_Sierpinski, samj_Etoile_De_Pompei_Triangles_Sierpinski(1)
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle Inclinaison = float(30,0,60)
#@gui : Dimension (>0 W%) (<0 H%) = float(100,-400,400)
#@gui : Cadre = color(0,0,0,255)
#@gui : Afficher Cadre = choice(0,"Pas Affichage","Affichage Contours Centre","Affichage Contours")
#@gui : R\303\251cursions Sierpinski = int(5,1,7)
#@gui : Centre A = color(255,0,0,127)
#@gui : Centre B = color(255,0,255,127)
#@gui : Triangle = color(0,0,255,127)
#@gui : Demi Losange A = color(0,255,255,127)
#@gui : Demi Losange B = color(255,255,0,127)
#@gui : Cercle = color(0,63,255,64)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Etoile_De_Pompei_Triangles_Sierpinski :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Angle_inclinaison=$3
-if {$4>0}
Dimension={round({{w}*$4/{400*{2^0.5}}})}
-else
Dimension={round({-{h}*$4/{400*{2^0.5}}})}
-endif
R_Cadre=$5
V_Cadre=$6
B_Cadre=$7
A_Cadre=$8
Afficher_Cadre=$9
Recursions_Sierpinski=$10
R_Centre=$11
V_Centre=$12
B_Centre=$13
A_Centre=$14
R_Centreb=$15
V_Centreb=$16
B_Centreb=$17
A_Centreb=$18
R_Triangle=$19
V_Triangle=$20
B_Triangle=$21
A_Triangle=$22
R_Demi_Losange=$23
V_Demi_Losange=$24
B_Demi_Losange=$25
A_Demi_Losange=$26
R_Demi_Losange_Deux=$27
V_Demi_Losange_Deux=$28
B_Demi_Losange_Deux=$29
A_Demi_Losange_Deux=$30
R_Cercle=$31
V_Cercle=$32
B_Cercle=$33
A_Cercle=$34
Couleurs_aleatoires=$35
Inversions=$36
Flou=$37
Dilatation=$38
Deformation=$39
Bruit=$40
Ombre=$41
X_Ombre=$42
Y_Ombre=$43
Smoothness_Ombre=$44
Curvature_Ombre=$45
Compensation_Decalage_Ombre_X=$46
Compensation_Decalage_Ombre_Y=$47
Canal_Alpha=$48
Largeur_Origine={w}
Hauteur_Origine={h}
Rayon_Cercle_1=$Dimension
Rayon_Cercle_2={{{2*$Dimension*$Dimension}-{2*$Dimension*$Dimension*{cos(pi/180*150)}}}^0.5}
Rayon_Cercle_3={$Dimension+{$Dimension*{3^0.5}}}
#angles degrs
dephasage_point1_carre={0+$Angle_inclinaison}
dephasage_point2_carre={60+$Angle_inclinaison}
dephasage_point3_carre={45+$Angle_inclinaison}
dephasage_point4_carre={15+$Angle_inclinaison}
dephasage_point5_triangle={30+$Angle_inclinaison}
Nb_Boucle=0
H_X_a=0
H_Y_a=0
H_X_b=0
H_Y_b=0
H_X_c=0
H_Y_c=0
H_X_d=0
H_Y_d=0
H_X_e=0
H_Y_e=0
H_X_f=0
H_Y_f=0
xca=0
yca=0
Angle_C=0
xcb=0
ycb=0
xcc=0
ycc=0
xcd=0
ycd=0
xce=0
yce=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
#Couleurs alatoires
-if {$Couleurs_aleatoires==1}
R_Centre={round(u)*255}
V_Centre={round(u)*255}
B_Centre={round(u)*255}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Triangle={round(u)*255}
V_Triangle={round(u)*255}
B_Triangle={round(u)*255}
R_Demi_Losange={round(u)*255}
V_Demi_Losange={round(u)*255}
B_Demi_Losange={round(u)*255}
R_Demi_Losange_Deux={round(u)*255}
V_Demi_Losange_Deux={round(u)*255}
B_Demi_Losange_Deux={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
-if {$Afficher_Cadre>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Afficher_Cadre==2}
-ellipse[-2] $X,$Y,$Rayon_Cercle_3,$Rayon_Cercle_3,0,1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-ellipse[-1] $X,$Y,$Rayon_Cercle_3,$Rayon_Cercle_3,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-endif
#-point[-1] 30,30,0,1,255,255,0,255
-repeat 6
Nb_Boucle={$Nb_Boucle+1}
-if {$Couleurs_aleatoires==1}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Triangle={round(u)*255}
V_Triangle={round(u)*255}
B_Triangle={round(u)*255}
R_Demi_Losange_Deux={round(u)*255}
V_Demi_Losange_Deux={round(u)*255}
B_Demi_Losange_Deux={round(u)*255}
-endif
point1_X={round({$Rayon_Cercle_1*{cos(pi/180*$dephasage_point1_carre)}})}
point1_Y={round({$Rayon_Cercle_1*{sin(pi/180*$dephasage_point1_carre)}})}
point2_X={round({$Rayon_Cercle_1*{cos(pi/180*{$dephasage_point2_carre})}})}
point2_Y={round({$Rayon_Cercle_1*{sin(pi/180*{$dephasage_point2_carre})}})}
point3_X={round({$Rayon_Cercle_2*{cos(pi/180*{$dephasage_point3_carre})}})}
point3_Y={round({$Rayon_Cercle_2*{sin(pi/180*{$dephasage_point3_carre})}})}
point4_X={round({$Rayon_Cercle_2*{cos(pi/180*{$dephasage_point4_carre})}})}
point4_Y={round({$Rayon_Cercle_2*{sin(pi/180*{$dephasage_point4_carre})}})}
-if {$Nb_Boucle==1}
H_X_a={$X+$point1_X}
H_Y_a={$Y+$point1_Y}
-elif {$Nb_Boucle==2}
H_X_b={$X+$point1_X}
H_Y_b={$Y+$point1_Y}
-elif {$Nb_Boucle==3}
H_X_c={$X+$point1_X}
H_Y_c={$Y+$point1_Y}
-elif {$Nb_Boucle==4}
H_X_d={$X+$point1_X}
H_Y_d={$Y+$point1_Y}
-elif {$Nb_Boucle==5}
H_X_e={$X+$point1_X}
H_Y_e={$Y+$point1_Y}
-elif {$Nb_Boucle==6}
H_X_f={$X+$point1_X}
H_Y_f={$Y+$point1_Y}
-endif
point5_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point5_triangle})}})}
point5_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point5_triangle})}})}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point5_X},{$Y+$point5_Y},$R_Triangle,$V_Triangle,$B_Triangle,$A_Triangle
point6_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point2_carre})}})}
point6_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point2_carre})}})}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point6_X},{$Y+$point6_Y},$R_Demi_Losange_Deux,$V_Demi_Losange_Deux,$B_Demi_Losange_Deux,$A_Demi_Losange_Deux
point7_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point1_carre})}})}
point7_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point1_carre})}})}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point1_X},{$Y+$point1_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point7_X},{$Y+$point7_Y},$R_Demi_Losange,$V_Demi_Losange,$B_Demi_Losange,$A_Demi_Losange
-if {$Afficher_Cadre>0}
-polygon[-2] 3,{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point5_X},{$Y+$point5_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-polygon[-2] 3,{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point6_X},{$Y+$point6_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-polygon[-2] 3,{$X+$point1_X},{$Y+$point1_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point7_X},{$Y+$point7_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-endif
-if {$Afficher_Cadre==2}
-polygon[-2] 4,{$X+$point1_X},{$Y+$point1_Y},{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-endif
dephasage_point1_carre={$dephasage_point1_carre+60}
dephasage_point2_carre={$dephasage_point2_carre+60}
dephasage_point3_carre={$dephasage_point3_carre+60}
dephasage_point4_carre={$dephasage_point4_carre+60}
dephasage_point5_triangle={$dephasage_point5_triangle+60}
-done
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_a,$H_Y_a,$H_X_b,$H_Y_b,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_b,$H_Y_b,$H_X_c,$H_Y_c,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_c,$H_Y_c,$H_X_d,$H_Y_d,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_d,$H_Y_d,$H_X_e,$H_Y_e,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_e,$H_Y_e,$H_X_f,$H_Y_f,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_f,$H_Y_f,$H_X_a,$H_Y_a,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-if {$Afficher_Cadre==0}
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-elif {$Afficher_Cadre==1}
-polygon[-2] 6,$H_X_a,$H_Y_a,$H_X_b,$H_Y_b,$H_X_c,$H_Y_c,$H_X_d,$H_Y_d,$H_X_e,$H_Y_e,$H_X_f,$H_Y_f,1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-endif
-if {$Afficher_Cadre>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#@gui Flocon De Neige : samj_Flocon_De_Neige, samj_Flocon_De_Neige(1)
#@gui : note = note("<small>Ah! comme la neige a neig&#233;! <i>Soir d'hiver / &#278;mile Nelligan</i></small>")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Nb Branches / Rays = int(6,3,12)
#@gui : Rayon Cercle Ext\303\251rieur / Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Rayon Cercle Milieu / Radius Middle Circle = float(40,1,100)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : R\303\251cursions Contours = int(3,0,5)
#@gui : Contours = color(192,192,192)
#@gui : Opacit\303\251 / Opacity Contours = float(1,0,1)
#@gui : Affichage / Display Contours = choice(0,"Non / No","Contours + Flocon/Snowflake","Contours")
#@gui : Recursions Flocon / Snowflake = int(3,0,5)
#@gui : Flocon / Snowflake = color(255,255,255)
#@gui : Opacit\303\251 Flocon / Opacity Snowflake = float(0.7,0,1)
#@gui : Type Flocon / Snowflake = choice(0,"A","B","C","A2","B2","C2")
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Flocon_De_Neige :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Nb_Branches=$3
-if {$4>0}
Rayon_cercle_exterieur_flocon={round({{w}*$4/{100}})}
-else
Rayon_cercle_exterieur_flocon={round({-{h}*$4/{100}})}
-endif
Rayon_Cercle_Milieu={round($Rayon_cercle_exterieur_flocon*2)}
Rayon_Cercle_Milieu={round($Rayon_cercle_exterieur_flocon*$5/100)}
Angle_inclinaison=$6
Recursions_Contours=$7
R_Contours=$8
V_Contours=$9
B_Contours=$10
Opacity_Contours=$11
Affichage_Contours=$12
Recursions_Flocon=$13
R_F=$14
V_F=$15
B_F=$16
Opacity_Flocon=$17
Type_Flocon=$18
Couleurs_aleatoires=$19
Inversions=$20
Flou=$21
Dilatation=$22
Deformation=$23
Bruit=$24
Ombre=$25
X_Ombre=$26
Y_Ombre=$27
Smoothness_Ombre=$28
Curvature_Ombre=$29
Compensation_Decalage_Ombre_X=$30
Compensation_Decalage_Ombre_Y=$31
Canal_Alpha=$32
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Theta={360/$Nb_Branches}
Nb_boucles=0
X_ext=0
Y_ext=0
X_exta=0
Y_exta=0
X_extb=0
Y_extb=0
X_mil=0
Y_mil=0
Angle=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-repeat $Nb_Branches
Angle={$Nb_boucles*$Angle_Theta}
X_ext={$X+{$Rayon_cercle_exterieur_flocon*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
Y_ext={$Y+{$Rayon_cercle_exterieur_flocon*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
X_exta={$X+{$Rayon_cercle_exterieur_flocon/3*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
Y_exta={$Y+{$Rayon_cercle_exterieur_flocon/3*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
X_extb={$X+{$Rayon_cercle_exterieur_flocon/3*2*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
Y_extb={$Y+{$Rayon_cercle_exterieur_flocon/3*2*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
X_mil={$X+{$Rayon_Cercle_Milieu*{cos({pi/180*{$Angle+$Angle_inclinaison+{$Angle_Theta/2}}})}}}
Y_mil={$Y+{$Rayon_Cercle_Milieu*{sin({pi/180*{$Angle+$Angle_inclinaison+{$Angle_Theta/2}}})}}}
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_F={round(u)*255}
V_F={round(u)*255}
B_F={round(u)*255}
-endif
-if {$Type_Flocon==0}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==1}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==2}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==3}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==4}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==5}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-endif
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#@gui Fractal Tree : samj_Fractal_Tree , samj_Fractal_Tree_preview
#@gui : sep = separator(), url = link("Source code from rosettacode.org","https://www.rosettacode.org/wiki/Fractal_tree")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(100,0,100)
#@gui : Angle Origine = Float(-90,-360,360)
#@gui : Depth = int(11,1,13)
#@gui : Variation Dimension = Float(10,1,500)
#@gui : Variation Angle = Float(20,-360,360)
#@gui : Color = color(255,0,0,255)
#@gui : Color Variation [Random -1] = int(20,-1,255)
#@gui : Rendering = choice("Lines","Circles A","Circles B")
#@gui : Circle Dimension = int(4,1,50)
#@gui : Dilatation = int(1,1,8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [Antialias] = bool(0)
#@gui : Amplitude = float(0.25,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/12/20</i>.</small>")
samj_Fractal_Tree :
-repeat $! -l[$>]
x1={round({{w}/100*$1})}
y1={round({{h}/100*$2})}
angle=$3
depth=$4
Variation_Dimension={{w}/1000*$5}
Variation_angle=$6
R_a=$7
V_a=$8
B_a=$9
A_a=$10
Variation_Couleur=$11
Motif=$12
Dimension_Motif=$13
Dilatation=$14
Validation_Smooth_Antialias=$15
V_Amplitude=$16
V_Edge_Threshold=$17
V_Smoothness=$18
-to_rgba[-1]
{w},{h},1,4
-samj_drawTree[-1] $x1,$y1,$angle,$depth,$Variation_Dimension,$Variation_angle,$R_a,$V_a,$B_a,$A_a,$Variation_Couleur,$Motif,$Dimension_Motif
-dilate[-1] $Dilatation
-if {$Validation_Smooth_Antialias==1} -fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness -endif
-blend[-1,-2] alpha
-endl -done
samj_Fractal_Tree_preview :
-gui_split_preview "-samj_Fractal_Tree $*",$-1
samj_drawTree :
-if {$4!=0}
R_DT=$7
V_DT=$8
B_DT=$9
A_DT=$10
-if {$11<0}
R_DT={round(u(0,255))}
V_DT={round(u(0,255))}
B_DT={round(u(0,255))}
-elif {$11>0}
R_DT={$11+$R_DT}
V_DT={$11+$V_DT}
B_DT={$11+$B_DT}
-if {$R_DT}>255}
R_DT={255-{$11*$4}}
-endif
-if {$V_DT}>255}
V_DT={255-{$11*$4}}
-endif
-if {$B_DT}>255}
B_DT={255-{$11*$4}}
-endif
-endif
x2={$1+{cos({$3*{pi/180}})*$4*$5}}
y2={$2+{sin({$3*{pi/180}})*$4*$5}}
-if {$12==0}
-line[-1] $1,$2,$x2,$y2,1,$7,$8,$9,$10
-elif {$12==1}
-line[-1] $1,$2,$x2,$y2,1,$7,$8,$9,$10
-circle[-1] $x2,$y2,$13,1,$R_DT,$V_DT,$B_DT,$A_DT
-elif {$12==2}
-line[-1] $1,$2,$x2,$y2,1,$7,$8,$9,$10
-circle[-1] $x2,$y2,$13,1,0xFFFFFFFF,$R_DT,$V_DT,$B_DT,$A_DT
-endif
-samj_drawTree[-1] $x2,$y2,{$3-$6},{$4-1},$5,$6,$R_DT,$V_DT,$B_DT,$A_DT,$11,$12,$13
-if {$11<0}
R_DT={round(u(0,255))}
V_DT={round(u(0,255))}
B_DT={round(u(0,255))}
-endif
-samj_drawTree[-1] $x2,$y2,{$3+$6},{$4-1},$5,$6,$R_DT,$V_DT,$B_DT,$A_DT,$11,$12,$13
-endif
#@gui Gradient CIE Lab [Linear] : samj_Linear_Gradient_CIE_Lab, samj_Linear_Gradient_CIE_Lab(1)
#@gui : note = link("http://samjcreations.blogspot.ca","http://samjcreations.blogspot.ca")
#@gui : sep = separator(), note = note("<small>D\303\251grad\303\251 / Gradient CIE Lab</small>")
#@gui : Type H / V = choice(0,"H","V")
#@gui : Swap Colors = bool(0)
#@gui : Starting Color A = color(240,40,160,255)
#@gui : Ending Color B = color(240,240,40,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2015/03/02</i>.</small>")
samj_Linear_Gradient_CIE_Lab :
Type_Degrade=$1
Swap_colors=$2
Ra=$3
Ga=$4
Ba=$5
Aa=$6
Rb=$7
Gb=$8
Bb=$9
Ab=$10
-if {$Swap_colors==1}
Ra=$7
Ga=$8
Ba=$9
Aa=$10
Rb=$3
Gb=$4
Bb=$5
Ab=$6
-endif
# Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
# couleur a Linear RGB
nt_Ra={$Ra/255}
nt_Ga={$Ga/255}
nt_Ba={$Ba/255}
-if {$nt_Ra>0.04045}
nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xa
Yca=$Ya
Zca=$Za
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={($nt_Xa)^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={($nt_Ya)^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={($nt_Za)^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_La={{116*$nt_Ya}-16}
CIE_aa={500*{$nt_Xa-$nt_Ya}}
CIE_ba={200*{$nt_Ya-$nt_Za}}
# couleur b Linear RGB
nt_Ra={$Rb/255}
nt_Ga={$Gb/255}
nt_Ba={$Bb/255}
-if {$nt_Ra>0.04045}
nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xb
Yca=$Yb
Zca=$Zb
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={($nt_Xa)^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={($nt_Ya)^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={($nt_Za)^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_Lb={{116*$nt_Ya}-16}
CIE_ab={500*{$nt_Xa-$nt_Ya}}
CIE_bb={200*{$nt_Ya-$nt_Za}}
######
{w},{h},1,4
-rm[-2]
Nb_Boucles=0
Decalage_L=0
Decalage_a=0
Decalage_b=0
-if {$Type_Degrade==0}
Dimensions={w}
Inc_L={{$CIE_La-$CIE_Lb}/{w}}
Inc_a={{$CIE_aa-$CIE_ab}/{w}}
Inc_b={{$CIE_ba-$CIE_bb}/{w}}
Inc_Alpha={{$Ab-$Aa}/{w}}
-elif {$Type_Degrade==1}
Dimensions={h}
Inc_L={{$CIE_La-$CIE_Lb}/{h}}
Inc_a={{$CIE_aa-$CIE_ab}/{h}}
Inc_b={{$CIE_ba-$CIE_bb}/{h}}
Inc_Alpha={{$Ab-$Aa}/{h}}
-endif
-repeat $Dimensions
Aa={$Aa+$Inc_Alpha}
-if {$Aa>255} Aa=255 -endif
-if {$Aa<0} Aa=0 -endif
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{($nt_Yca)^3}>0.008856}
nt_Yca={($nt_Yca)^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{($nt_Xca)^3}>0.008856}
nt_Xca={($nt_Xca)^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{($nt_Zca)^3}>0.008856}
nt_Zca={($nt_Zca)^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {$Type_Degrade==0}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{{h}-1},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==1}
-line[-1] 0,$Nb_Boucles,{{w}-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
#@gui Gradient CIE Lab [Linear] : samj_en_Linear_Gradient_CIE_Lab, samj_en_Linear_Gradient_CIE_Lab(1)
#@gui : sep = separator(), note = note("<small>Gradient CIE Lab</small>")
#@gui : Type H / V = choice(0,"H","V")
#@gui : Swap Colors = bool(0)
#@gui : Starting Color A = color(240,40,160,255)
#@gui : Ending Color B = color(240,240,40,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2015/03/02</i>.</small>")
samj_en_Linear_Gradient_CIE_Lab :
-samj_Linear_Gradient_CIE_Lab $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
#@gui Gradient CIE Lab [Shape] : samj_Shape_Linear_Gradient_CIE_Lab, samj_Shape_Linear_Gradient_CIE_Lab(1)
#@gui : note = link("http://samjcreations.blogspot.ca","http://samjcreations.blogspot.ca")
#@gui : note = note("D\303\251grad\303\251 / Gradient CIE Lab")
#@gui : sep = separator(), note = note("<small><b><span foreground="red">Starting Point / Diameter :</span></b></small>")
#@gui : X0 = float(10,0,100)
#@gui : Y0 = float(10,0,100)
#@gui : note = note("<small><b><span foreground="blue">Ending Point / Center :</span></b></small>")
#@gui : X1 = float(90,0,100)
#@gui : Y1 = float(90,0,100)
#@gui : note = note("<small><b><span foreground="black">Parameters :</span></b></small>")
#@gui : Shape = choice(2,"Linear H","Linear V","Square","Square Overflow","Circle X0","Circle X0+YO")
#@gui : Swap Colors = bool(0)
#@gui : Starting Color A = color(240,40,160,255)
#@gui : Ending Color B = color(240,240,40,255)
#@gui : Background = choice(0,"Image","Transparent","Color")
#@gui : Background Color = color(0,0,0,255)
#@gui : Examples = choice(0,"None","10 10 90 90 Linear H","10 10 90 90 Linear V","10 10 90 90 Square","10 10 90 90 Square Overflow","40 40 50 50 Circle X0","40 40 50 50 Circle X0+YO","71 71 100 100 Circle X0+YO")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2014/04/29</i>.</small>")
samj_Shape_Linear_Gradient_CIE_Lab :
Xo={round({{w}/100*$1})}
Yo={round({{h}/100*$2})}
Xf={round({{w}/100*$3})}
Yf={round({{h}/100*$4})}
Type_Degrade=$5
Swap_colors=$6
Ra=$7
Ga=$8
Ba=$9
Aa=$10
Rb=$11
Gb=$12
Bb=$13
Ab=$14
Background=$15
Rback=$16
Gback=$17
Bback=$18
Aback=$19
Examples=$20
-if {$Swap_colors==1}
Ra=$11
Ga=$12
Ba=$13
Aa=$14
Rb=$7
Gb=$8
Bb=$9
Ab=$10
-endif
-if {$Xo>$Xf}
Xo=$3
Xf=$1
-elif {$Xo==$Xf}
Xo={$Xf-1}
-endif
-if {$Yo>$Yf}
Yo=$4
Yf=$2
-elif {$Yo==$Yf}
Yo={$Yf-1}
-endif
-if {{$Type_Degrade==4}||{$Type_Degrade==5}}
Xo={round({{w}/100*$1})}
Yo={round({{h}/100*$2})}
Xf={round({{w}/100*$3})}
Yf={round({{h}/100*$4})}
-endif
-if {$Examples==1}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=0
-elif {$Examples==2}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=1
-elif {$Examples==3}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=2
-elif {$Examples==4}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=3
-elif {$Examples==5}
Xo={round({{w}*0.4})}
Yo={round({{h}*0.4})}
Xf={round({{w}*0.5})}
Yf={round({{h}*0.5})}
Type_Degrade=4
-elif {$Examples==6}
Xo={round({{w}*0.4})}
Yo={round({{h}*0.4})}
Xf={round({{w}*0.5})}
Yf={round({{h}*0.5})}
Type_Degrade=5
-elif {$Examples==7}
Xo={round({{w}*0.71})}
Yo={round({{h}*0.71})}
Xf={w}
Yf={h}
Type_Degrade=5
-endif
# Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
# couleur a Linear RGB
nt_Ra={$Ra/255}
nt_Ga={$Ga/255}
nt_Ba={$Ba/255}
-if {$nt_Ra>0.04045}
nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xa
Yca=$Ya
Zca=$Za
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={($nt_Xa)^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={($nt_Ya)^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={($nt_Za)^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_La={{116*$nt_Ya}-16}
CIE_aa={500*{$nt_Xa-$nt_Ya}}
CIE_ba={200*{$nt_Ya-$nt_Za}}
# couleur b Linear RGB
nt_Ra={$Rb/255}
nt_Ga={$Gb/255}
nt_Ba={$Bb/255}
-if {$nt_Ra>0.04045}
nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xb
Yca=$Yb
Zca=$Zb
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={($nt_Xa)^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={($nt_Ya)^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={($nt_Za)^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_Lb={{116*$nt_Ya}-16}
CIE_ab={500*{$nt_Xa-$nt_Ya}}
CIE_bb={200*{$nt_Ya-$nt_Za}}
######
-if {$Background==1}
{w},{h},1,4
-rm[-2]
-elif {$Background==2}
{w},{h},1,4
-fill_color[-1] $Rback,$Gback,$Bback,$Aback
-rm[-2]
-endif
Nb_Boucles=0
-if {$Type_Degrade==0}
Dimensions={$Xf-$Xo}
-elif {$Type_Degrade==1}
Dimensions={$Yf-$Yo}
-elif {$Type_Degrade==2}
-if {{$Xf-$Xo}>{$Yf-$Yo}}
Dimensions={round({{$Yf-$Yo+1}/2})}
-else
Dimensions={round({{$Xf-$Xo+1}/2})}
-endif
-elif {$Type_Degrade==3}
-if {{$Xf-$Xo}>{$Yf-$Yo}}
Dimensions={round({{$Xf-$Xo+1}/2})}
-else
Dimensions={round({{$Yf-$Yo+1}/2})}
-endif
-elif {$Type_Degrade==4}
Dimensions=$Xo
-elif {$Type_Degrade==5}
Dimensions={$Xo+$Yo}
-endif
Inc_L={{$CIE_La-$CIE_Lb}/$Dimensions}
Inc_a={{$CIE_aa-$CIE_ab}/$Dimensions}
Inc_b={{$CIE_ba-$CIE_bb}/$Dimensions}
Inc_Alpha={{$Ab-$Aa}/$Dimensions}
Decalage_L=0
Decalage_a=0
Decalage_b=0
-repeat $Dimensions
Aa={$Aa+$Inc_Alpha}
-if {$Aa>255} Aa=255 -endif
-if {$Aa<0} Aa=0 -endif
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{($nt_Yca)^3}>0.008856}
nt_Yca={($nt_Yca)^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{($nt_Xca)^3}>0.008856}
nt_Xca={($nt_Xca)^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{($nt_Zca)^3}>0.008856}
nt_Zca={($nt_Zca)^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {$Type_Degrade==0}
-line[-1] {$Xo+$Nb_Boucles},$Yo,{$Xo+$Nb_Boucles},$Yf,1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==1}
-line[-1] $Xo,{$Yo+$Nb_Boucles},$Xf,{$Yo+$Nb_Boucles},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==2}
-polygon[-1] 4,{$Xo+$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yf-$Nb_Boucles},{$Xo+$Nb_Boucles},{$Yf-$Nb_Boucles},1,0xFFFFFFFF,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==3}
-polygon[-1] 4,{$Xo+$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yf-$Nb_Boucles},{$Xo+$Nb_Boucles},{$Yf-$Nb_Boucles},1,0xFFFFFFFF,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==4}
-ellipse[-1] $Xf,$Yf,{$Dimensions-$Nb_Boucles},{$Dimensions-$Nb_Boucles},0,1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==5}
-ellipse[-1] $Xf,$Yf,{$Dimensions-$Nb_Boucles},{$Dimensions-$Nb_Boucles},0,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
#@gui Gradient CIE Lab [Shape] : samj_en_Shape_Linear_Gradient_CIE_Lab, samj_en_Shape_Linear_Gradient_CIE_Lab(1)
#@gui : note = note("Gradient CIE Lab")
#@gui : sep = separator(), note = note("<small><b><span foreground="red">Starting Point / Diameter :</span></b></small>")
#@gui : X0 = float(10,0,100)
#@gui : Y0 = float(10,0,100)
#@gui : note = note("<small><b><span foreground="blue">Ending Point / Center :</span></b></small>")
#@gui : X1 = float(90,0,100)
#@gui : Y1 = float(90,0,100)
#@gui : note = note("<small><b><span foreground="black">Parameters :</span></b></small>")
#@gui : Shape = choice(2,"Linear H","Linear V","Square","Square Overflow","Circle X0","Circle X0+YO")
#@gui : Swap Colors = bool(0)
#@gui : Starting Color A = color(240,40,160,255)
#@gui : Ending Color B = color(240,240,40,255)
#@gui : Background = choice(0,"Image","Transparent","Color")
#@gui : Background Color = color(0,0,0,255)
#@gui : Examples = choice(0,"None","10 10 90 90 Linear H","10 10 90 90 Linear V","10 10 90 90 Square","10 10 90 90 Square Overflow","40 40 50 50 Circle X0","40 40 50 50 Circle X0+YO","71 71 100 100 Circle X0+YO")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2014/04/29</i>.</small>")
samj_en_Shape_Linear_Gradient_CIE_Lab :
-samj_Shape_Linear_Gradient_CIE_Lab $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20
#@gui Harmonograph : Harmonograph_samj_en, Harmonograph_samj_en(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Harmonograph")
#@gui : sep = separator(), note = note("<small>Center</small>")
#@gui : Center X (%) = float(50,0,100)
#@gui : Center Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Harmonograph</small>")
#@gui : Pen (Color) = color(192,128,64,255)
#@gui : Pen (Color Variation) = choice("No change","Random colors","Poorly nuanced","Moderately nuanced","Highly nuanced")
#@gui : Pen (Dilate Pixels) = int(0,0,32)
#@gui : It\303\251rations = int(1000,2,30000)
#@gui : Iterations = choice(0,"Iterations * 1","Iterations * 5 SLOW","Iterations * 10 VERY SLOW")
#@gui : Time Increment [*10000] = float(400,10,500)
#@gui : sep = separator(), note = note("<small>Amplitude</small>")
#@gui : Amplitude 1 (>0 W) (<0 H) = float(150,-1000,1000)
#@gui : Amplitude 2 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 3 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 4 (>0 W) (<0 H) = float(100,-1000,1000)
#@gui : sep = separator(), note = note("<small>Frequency</small>")
#@gui : Frequency 1 = float(4,0,16)
#@gui : Frequency 2 = float(6,0,16)
#@gui : Frequency 3 = float(2,0,16)
#@gui : Frequency 4 = float(2,0,16)
#@gui : sep = separator(), note = note("<small>Phase</small>")
#@gui : Phase 1 = float(15,0,360)
#@gui : Phase 2 = float(270,0,360)
#@gui : Phase 3 = float(75,0,360)
#@gui : Phase 4 = float(60,0,360)
#@gui : sep = separator(), note = note("<small>Damping</small>")
#@gui : Damping 1 = float(0.04,0,1)
#@gui : Damping 2 = float(0.04,0,1)
#@gui : Damping 3 = float(0.05,0,1)
#@gui : Damping 4 = float(0.06,0,1)
#@gui : sep = separator(), note = note("<small>Distorsions</small>")
#@gui : Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Deform = float(0,0,25)
#@gui : sep = separator(), note = note("<small>Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/15</i>.</small>")
Harmonograph_samj_en :
-Harmonograph_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32
#@gui Harmonograph : Harmonograph_samj, Harmonograph_samj(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Harmonograph")
#@gui : sep = separator(), note = note("<small>Centre / Center</small>")
#@gui : Centre / Center X (%) = float(50,0,100)
#@gui : Centre / Center Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Harmonograph</small>")
#@gui : Stylo / Pen (Couleur/Color) = color(192,128,64,255)
#@gui : Stylo / Pen (Variation De Couleur/Color Variation) = choice("Pas de variation / No change","Couleurs aleatoires / Random colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : Stylo / Pen (Dilate Pixels) = int(0,0,32)
#@gui : It\303\251rations = int(1000,2,30000)
#@gui : Multiplier = choice(0,"Iterations * 1","Iterations * 5 LENT / SLOW","Iterations * 10 TRES LENT / VERY SLOW")
#@gui : Increment Temps / Time Increment [*10000] = float(400,10,500)
#@gui : sep = separator(), note = note("<small>Amplitude</small>")
#@gui : Amplitude 1 (>0 W) (<0 H) = float(150,-1000,1000)
#@gui : Amplitude 2 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 3 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 4 (>0 W) (<0 H) = float(100,-1000,1000)
#@gui : sep = separator(), note = note("<small>Fr\303\251quence / Frequency</small>")
#@gui : Fr\303\251quence 1 = float(4,0,16)
#@gui : Fr\303\251quence 2 = float(6,0,16)
#@gui : Fr\303\251quence 3 = float(2,0,16)
#@gui : Fr\303\251quence 4 = float(2,0,16)
#@gui : sep = separator(), note = note("<small>Phase</small>")
#@gui : Phase 1 = float(15,0,360)
#@gui : Phase 2 = float(270,0,360)
#@gui : Phase 3 = float(75,0,360)
#@gui : Phase 4 = float(60,0,360)
#@gui : sep = separator(), note = note("<small>Amortissement / Damping</small>")
#@gui : Amortissement 1 = float(0.04,0,1)
#@gui : Amortissement 2 = float(0.04,0,1)
#@gui : Amortissement 3 = float(0.05,0,1)
#@gui : Amortissement 4 = float(0.06,0,1)
#@gui : sep = separator(), note = note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : D\303\251formation = float(0,0,25)
#@gui : sep = separator(), note = note("<small>M\303\251lange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
Harmonograph_samj :
centre_origine_X={$1/100*w}
centre_origine_Y={$2/100*h}
R_Couleur_Stylo=$3
V_Couleur_Stylo=$4
B_Couleur_Stylo=$5
A_Couleur_Stylo=$6
Variation_de_couleur=$7
Dilate_Stylo=$8
Iterations=$9
Multiplier_Iterations=$10
Increment_temps=$11
-if {$12>0}
Amplitude1={{w}*$12/{1000}}
-else
Amplitude1={-{h}*$12/{1000}}
-endif
-if {$13>0}
Amplitude2={{w}*$13/{1000}}
-else
Amplitude2={-{h}*$13/{1000}}
-endif
-if {$14>0}
Amplitude3={{w}*$14/{1000}}
-else
Amplitude3={-{h}*$14/{1000}}
-endif
-if {$15>0}
Amplitude4={{w}*$15/{1000}}
-else
Amplitude4={-{h}*$15/{1000}}
-endif
Frequence1=$16
Frequence2=$17
Frequence3=$18
Frequence4=$19
Phase1=$20
Phase2=$21
Phase3=$22
Phase4=$23
Amort1=$24
Amort2=$25
Amort3=$26
Amort4=$27
Flou_Harmonograph=$28
Spread_Harmonograph=$29
Deform_Harmonograph=$30
blend=$31
opacite=$32
Revert_layers=0
-to_rgba
{w},{h},1,4
Nb_Boucle=1
temps=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
R_Couleur_origine=$R_Couleur_Stylo
V_Couleur_origine=$V_Couleur_Stylo
B_Couleur_origine=$B_Couleur_Stylo
A_Couleur_origine=$A_Couleur_Stylo
Increment_temps={$Increment_temps/10000}
Phase1={$Phase1/180*{pi}}
Phase2={$Phase2/180*{pi}}
Phase3={$Phase3/180*{pi}}
Phase4={$Phase4/180*{pi}}
-if {$Multiplier_Iterations>0}
Iterations={$Iterations*$Multiplier_Iterations*5}
-endif
-repeat $Iterations
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
Nouveau_point_X={$centre_origine_X+{{$Amplitude1*{sin({{$Frequence1*$temps}+$Phase1})}*{exp({-$Amort1*$temps})}}+{$Amplitude2*{sin({{$Frequence2*$temps}+$Phase2})}*{exp({-$Amort2*$temps})}}}}
Nouveau_point_Y={$centre_origine_Y+{{$Amplitude3*{sin({{$Frequence3*$temps}+$Phase3})}*{exp({-$Amort3*$temps})}}+{$Amplitude4*{sin({{$Frequence4*$temps}+$Phase4})}*{exp({-$Amort4*$temps})}}}}
-if {$Nb_Boucle>1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
temps={$temps+$Increment_temps}
Nb_Boucle={$Nb_Boucle+1}
-done
-if {$Dilate_Stylo>0} -dilate_circ[-1] $Dilate_Stylo -endif
-if {$Flou_Harmonograph>0} -blur[-1] $Flou_Harmonograph,0 -endif
-if {$Spread_Harmonograph>1} -spread[-1] $Spread_Harmonograph -endif
-if {$Deform_Harmonograph>0} -deform[-1] $Deform_Harmonograph -endif
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
#
#-text_outline[0] $Amplitude1,10,10,64,1,1,255,255,255
#@gui Hawaiian Earring : samj_Hawaiian_Earring, samj_Hawaiian_Earring(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Hawaiian_earring","http://en.wikipedia.org/wiki/Hawaiian_earring")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Cercle A / Circle A Radius (%) = float(40,1,200)
#@gui : Nb Cercles / Circles = int(6,2,25)
#@gui : Type N = choice(0,"Inc 1","Lin 0.1","Lin 0.2","Lin 0.3","Rand")
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(1)
#@gui : Cercle A / Circle A = color(255,255,0,127)
#@gui : Cercles B / Circles B = color(0,0,255,127)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Miroir /  Mirror = choice(0,"Sans - Wihout"," X "," Y "," X Y ")
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/20</i>.</small>")
samj_Hawaiian_Earring :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Rayon_Cercle_Exterieur={round({{{w}+{h}}*$3/200})}
Nb_Circles=$4
Type_n=$5
Angle_inclinaison=$6
R_Contours=$7
V_Contours=$8
B_Contours=$9
A_Contours=$10
Affichage_Contours=$11
R_a=$12
V_a=$13
B_a=$14
A_a=$15
R_b=$16
V_b=$17
B_b=$18
A_b=$19
Couleurs_aleatoires=$20
Inversions=$21
Flou=$22
Dilatation=$23
Deformation=$24
Bruit=$25
Ombre=$26
X_Ombre=$27
Y_Ombre=$28
Smoothness_Ombre=$29
Curvature_Ombre=$30
Compensation_Decalage_Ombre_X=$31
Compensation_Decalage_Ombre_Y=$32
Canal_Alpha=$33
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
X_Cercle_A_Imprimer=$X
Y_Cercle_A_Imprimer=$Y
Rayon_Centre_Cercle_A_Imprimer=0
Rayon_Cercle_A_Imprimer=$Rayon_Cercle_Exterieur
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours==1}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-repeat $Nb_Circles
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
-endif
-if {{($Nb_boucles%2)}==0}
-ellipse[-1] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,$R_a,$V_a,$B_a,$A_a
-else
-ellipse[-1] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,$R_b,$V_b,$B_b,$A_b
-endif
-if {$Affichage_Contours==1}
-ellipse[-2] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Type_n==0}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_Exterieur/{$Nb_boucles+1}}
-elif {$Type_n==1}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.1}}
-elif {$Type_n==2}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.2}}
-elif {$Type_n==3}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.3}}
-elif {$Type_n==4}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*{?(0.1,0.3)}}}
-endif
Rayon_Centre_Cercle_A_Imprimer={$Rayon_Cercle_Exterieur-$Rayon_Cercle_A_Imprimer}
X_Cercle_A_Imprimer={$X-{$Rayon_Centre_Cercle_A_Imprimer*{cos(pi/180*$Angle_inclinaison)}}}
Y_Cercle_A_Imprimer={$Y-{$Rayon_Centre_Cercle_A_Imprimer*{sin(pi/180*$Angle_inclinaison)}}}
-done
-if {$Affichage_Contours==1}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#@gui Hawaiian Earring : samj_en_Hawaiian_Earring, samj_en_Hawaiian_Earring(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Hawaiian_earring","http://en.wikipedia.org/wiki/Hawaiian_earring")
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Circle A Radius (%) = float(40,1,200)
#@gui : Nb  Circles = int(6,2,25)
#@gui : Type N = choice(0,"Inc 1","Lin 0.1","Lin 0.2","Lin 0.3","Rand")
#@gui : Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Display Contours = bool(1)
#@gui : Circle A = color(255,255,0,127)
#@gui : Circles B = color(0,0,255,127)
#@gui : Random Colors = bool(0)
#@gui : Mirror = choice(0,"Sans - Wihout"," X "," Y "," X Y ")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Shadow = bool(0)
#@gui : X-Shadow = float(0.5,-5,5)
#@gui : Y-Shadow = float(0.5,-5,5)
#@gui : Smoothness Shadow = float(1.8,0,5)
#@gui : Curvature Shadow = float(0,0,1)
#@gui : Shadow Offset X = float(0,-20,20)
#@gui : Shadow Offset Y = float(0,-20,20)
#@gui : Alpha Channel = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/06</i>.</small>")
samj_en_Hawaiian_Earring :
-samj_Hawaiian_Earring $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33
#@gui Lines Around a Point : Traits_Strokes_samj_en, Traits_Strokes_samj_en(1)
#@gui : sep = separator(), note = note("<small>Origine</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Lines</small>")
#@gui : Length (>0 %W) (<0 $H) = float(35,-400,400)
#@gui : Variations (Length) = choice(0,"No","A","B","C","D")
#@gui : Variations % (Length) = float(100,0,1000)
#@gui : Distance From The Center (>0 %W) (<0 $H) = float(0,-400,400)
#@gui : Number of Lines = int(30,1,2160)
#@gui : Angle (Start) = float(0,0,360)
#@gui : Angle (End) = float(360,0,360)
#@gui : Color = color(240,60,120,255)
#@gui : Color Variation = choice("No","Random colors","Poorly nuanced","Moderately nuanced","Highly nuanced")
#@gui : Thickness = int(0,0,32)
#@gui : sep = separator(), note = note("<small>Symmetry</small>")
#@gui : Symmetry = bool(0)
#@gui : Length (%) = float(20,0,100)
#@gui : sep = separator(), note = note("<small>Distorsions</small>")
#@gui : Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Deform = float(0,0,25)
#@gui : sep = separator(), note = note("<small>Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/15</i>.</small>")
Traits_Strokes_samj_en:
-Traits_Strokes_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22
#@gui Lines of Varying Thickness : samj_en_Lignes_Epaisseur_Variable, samj_en_Lignes_Epaisseur_Variable(1)
#@gui : note = note("Lines Of Varying Thickness")
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Lines = choice(0,"Vertical lines","Horizontal lines")
#@gui : Resolution Width = int(32,16,64)
#@gui : Line Thickness = int(3,1,7)
#@gui : Background = color(0,0,0,255)
#@gui : Line = color(255,255,255,255)
#@gui : Invert Background-Line = bool(0)
#@gui : Random Colors = bool(0)
#@gui : Resize = choice(1,"No","Dim. Origines")
#@gui : Blur = int(0,0,200)
#@gui : Deblur = int(0,0,48)
#@gui : Dilate = int(0,0,48)
#@gui : Deform / Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Shadow = bool(0)
#@gui : X-Shadow = float(0.5,-5,5)
#@gui : Y-Shadow = float(0.5,-5,5)
#@gui : Smoothness Shadow = float(1.8,0,5)
#@gui : Curvature Shadow = float(0,0,1)
#@gui : Alpha Channel = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/05</i>.</small>")
samj_en_Lignes_Epaisseur_Variable :
-samj_Lignes_Epaisseur_Variable $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25
#@gui Lines of Varying Thickness : samj_Lignes_Epaisseur_Variable, samj_Lignes_Epaisseur_Variable(1)
#@gui : note = note("Lignes \303\211paisseur Variable / Lines Of Varying Thickness")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Orientation Lignes / Lines = choice(0,"Vertical lines","Horizontal lines")
#@gui : R\303\251solution Largeur / Width = int(32,16,64)
#@gui : \303\211paisseur Ligne / Line Thickness = int(3,1,7)
#@gui : Fond / Background = color(0,0,0,255)
#@gui : Ligne / Line = color(255,255,255,255)
#@gui : Inverser Fond-Ligne / Invert Background-Line = bool(0)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Resize = choice(1,"Non / No","Dim. Origines")
#@gui : Flou / Blur = int(0,0,200)
#@gui : Deblur = int(0,0,48)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation / Deform = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Lignes_Epaisseur_Variable :
Motif_Sprite=$1
Resolution_Largeur=$2
Trait_Largeur=$3
R_fond=$4
V_fond=$5
B_fond=$6
A_fond=$7
R_a=$8
V_a=$9
B_a=$10
A_a=$11
Inverser_Fond_Trait=$12
Couleurs_aleatoires=$13
Resize_Image=$14
Antialiasing=$15
R_Deblur=$16
Dilatation=$17
Deformation=$18
Bruit=$19
Ombre=$20
X_Ombre=$21
Y_Ombre=$22
Smoothness_Ombre=$23
Curvature_Ombre=$24
Canal_Alpha=$25
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Nb_boucles_motif=0
Origine_Trait=0
-if {$Inverser_Fond_Trait==0}
R_F=$R_fond
V_F=$V_fond
B_F=$B_fond
A_F=$A_fond
R_M=$R_a
V_M=$V_a
B_M=$B_a
A_M=$A_a
-else
R_F=$R_a
V_F=$V_a
B_F=$B_a
A_F=$A_a
R_M=$R_fond
V_M=$V_fond
B_M=$B_fond
A_M=$A_fond
-endif
Largeur_Sprite={{7*2}+{7*$Trait_Largeur}}
Hauteur_Sprite=$Largeur_Sprite
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-resize[-1] $Resolution_Largeur,{round({$Hauteur_Origine/$Largeur_Origine*$Resolution_Largeur})}
-repeat 7
Nb_boucles={$Nb_boucles+1}
-if {$Nb_boucles==1}
-if {$Couleurs_aleatoires==1}
R_F={round(u)*255}
V_F={round(u)*255}
B_F={round(u)*255}
-endif
$Largeur_Sprite,$Hauteur_Sprite,1,4
-fill_color[-1] $R_F,$V_F,$B_F,$A_F
-endif
-if {$Couleurs_aleatoires==1}
R_F={round(u)*255}
V_F={round(u)*255}
B_F={round(u)*255}
R_M={round(u)*255}
V_M={round(u)*255}
B_M={round(u)*255}
-endif
$Largeur_Sprite,$Hauteur_Sprite,1,4
-fill_color[-1] $R_F,$V_F,$B_F,$A_F
Nb_boucles_motif=0
-if {{$Motif_Sprite==0}||{$Motif_Sprite==1}}
Origine_Trait={round({{$Largeur_Sprite-{$Trait_Largeur*$Nb_boucles}}/2})}
-repeat {$Trait_Largeur*$Nb_boucles}
-line[-1] {$Origine_Trait+$Nb_boucles_motif},0,{$Origine_Trait+$Nb_boucles_motif},{$Hauteur_Sprite-1},1,$R_M,$V_M,$B_M,$A_M
Nb_boucles_motif={$Nb_boucles_motif+1}
-done
-endif
-done
-if {$Motif_Sprite==1}
-rotate[-1,-2,-3,-4,-5,-6,-7,-8] 90,0,0
-endif
-map_sprites[-1,-2,-3,-4,-5,-6,-7,-8,-9] 8,0
-if {$Resize_Image==1}
-resize[-1] $Largeur_Origine,$Hauteur_Origine
-endif
-if {$Antialiasing>0} -apply_channels[-1] "-smooth "$Antialiasing",0.7,0.3,0.6,5,5,0",1 -endif
-if {$R_Deblur>0} -apply_channels[-1] "-deblur "$R_Deblur",10,20,0.1,1",1 -endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-endif
#@gui Orbites : samj_Orbites, samj_Orbites(1)
#@gui : note = link("https://youtu.be/_JgHQU1Fntg","https://youtu.be/_JgHQU1Fntg")
#@gui : sep = separator(), note = note("<small><b><span foreground="red">New Image</span></b></small>")
#@gui : Image Dimensions = float(100,30,400)
#@gui : Background Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Rendering</span></b></small>")
#@gui : X Position (%) = float(50,0,100)
#@gui : Y Position (%) = float(50,0,100)
#@gui : Circle A Radius = float(20,10,1000)
#@gui : Number of Points Circle A = int(79,10,1080)
#@gui : Circle B Radius = float(45,1,1000)
#@gui : Multiplier Number of Points Circle B = float(2,0.1,20)
#@gui : Color Straight Lines = color(240,128,64,255)
#@gui : Tilt Angle A = float(0,-360,360)
#@gui : Tilt Angle B = float(0,-360,360)
#@gui : Random Colors = bool(0)
#@gui : sep = separator(), note = note("<small><b><span foreground="blue">Changes Rendering Image Filter</span></b></small>")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Draw Circles = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2018/02/04</i>.</small>")
samj_Orbites :
Dimension={round({{max({w},{h})}*$1/100})}
R_fond=$2
V_fond=$3
B_fond=$4
A_fond=$5
X={round({$Dimension*{$6/100}})}
Y={round({$Dimension*{$7/100}})}
Rayon_Cercle_A={round({$Dimension*$8/100})}
Nb_Points_A=$9
Rayon_Cercle_B={round({$Dimension*$10/100})}
Multiplicateur=$11
R_a=$12
V_a=$13
B_a=$14
A_a=$15
Angle_Inclinaison_A=$16
Angle_Inclinaison_B=$17
Couleurs_aleatoires=$18
Flou=$19
Dilatation=$20
Deformation=$21
Bruit=$22
Tracer_Les_Cercles=$23
Largeur_Origine={w}
Hauteur_Origine={h}
Variation_Angle_A={360/$Nb_Points_A}
Variation_Angle_B={360/{$Nb_Points_A*$Multiplicateur}}
Sortie_Boucle_Lignes=0
Nb_Boucle_Lignes=0
Nb_Boucle_Points=0
Boucles_Rendu={round({{$Nb_Points_A*$Multiplicateur}+$Nb_Points_A}+1)}
-rm[-1]
$Dimension,$Dimension,1,4
-fill_color[-1] 0,0,0,0
Angle_A=0
X_Imp_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}
Y_Imp_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}
Angle_B=0
X_Imp_B={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}
Y_Imp_B={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}
-repeat $Boucles_Rendu
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-line[-1] $X_Imp_A,$Y_Imp_A,$X_Imp_B,$Y_Imp_B,1,$R_a,$V_a,$B_a,$A_a
Angle_A={$Variation_Angle_A+$Angle_A}
X_Imp_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}
Y_Imp_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}
Angle_B={$Variation_Angle_B+$Angle_B}
X_Imp_B={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}
Y_Imp_B={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}
-done
-if {$Tracer_Les_Cercles==1}
-ellipse[-1] $X,$Y,$Rayon_Cercle_A,$Rayon_Cercle_A,0,1,0xFFFFFFFF,$R_a,$V_a,$B_a,$A_a
-ellipse[-1] $X,$Y,$Rayon_Cercle_B,$Rayon_Cercle_B,0,1,0xFFFFFFFF,$R_a,$V_a,$B_a,$A_a
-endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
$Dimension,$Dimension,1,4
-fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond
-gimp_blend_1651[-2,-1] 1,0,1,0,1
#@gui Pappus Chain : samj_en_Cercles_Tangents_Dans_Cercle, samj_en_Cercles_Tangents_Dans_Cercle(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Pappus_chain","http://en.wikipedia.org/wiki/Pappus_chain")
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Radius First Circle B = float(40,0,99)
#@gui : Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Display Contours = bool(1)
#@gui : Outer Circle A = color(127,127,127,127)
#@gui : First Circle B = color(255,0,0,127)
#@gui : Circle C = color(0,255,0,127)
#@gui : Circle D = color(0,0,255,127)
#@gui : Circle E = color(255,0,255,127)
#@gui : Circle F = color(255,255,0,127)
#@gui : Circle G = color(0,255,255,127)
#@gui : Circle H = color(192,128,64,127)
#@gui : Circle I = color(64,192,128,127)
#@gui : Circle J = color(128,64,192,127)
#@gui : Circle K = color(192,64,128,127)
#@gui : Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Shadow = bool(0)
#@gui : X-Shadow = float(0.5,-5,5)
#@gui : Y-Shadow = float(0.5,-5,5)
#@gui : Smoothness Shadow = float(1.8,0,5)
#@gui : Curvature Shadow = float(0,0,1)
#@gui : Shadow Offset X = float(0,-20,20)
#@gui : Shadow Offset Y = float(0,-20,20)
#@gui : Alpha Channel = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/08</i>.</small>")
samj_en_Cercles_Tangents_Dans_Cercle :
-samj_Cercles_Tangents_Dans_Cercle $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$60,$61,$62,$63,$64,$65,$66,$67,$68
#@gui Pappus Chain : samj_Cercles_Tangents_Dans_Cercle, samj_Cercles_Tangents_Dans_Cercle(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Pappus_chain","http://en.wikipedia.org/wiki/Pappus_chain")
#@gui : note = link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Cercle Ext\303\251rieur / Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Rayon Premier Cercle B = float(40,0,99)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(1)
#@gui : Cercle Ext\303\251rieur / Outer Circle A = color(127,127,127,127)
#@gui : Premier Cercle / First Circle B = color(255,0,0,127)
#@gui : Cercle / Circle C = color(0,255,0,127)
#@gui : Cercle / Circle D = color(0,0,255,127)
#@gui : Cercle / Circle E = color(255,0,255,127)
#@gui : Cercle / Circle F = color(255,255,0,127)
#@gui : Cercle / Circle G = color(0,255,255,127)
#@gui : Cercle / Circle H = color(192,128,64,127)
#@gui : Cercle / Circle I = color(64,192,128,127)
#@gui : Cercle / Circle J = color(128,64,192,127)
#@gui : Cercle / Circle K = color(192,64,128,127)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/20</i>.</small>")
samj_Cercles_Tangents_Dans_Cercle :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
-if {$3>0}
Rayon_Cercle_Exterieur={round({{w}*$3/{100}})}
-else
Rayon_Cercle_Exterieur={round({-{h}*$3/{100}})}
-endif
Rayon_Premier_Cercle={round({$Rayon_Cercle_Exterieur*$4/100})}
Angle_inclinaison=$5
R_Contours=$6
V_Contours=$7
B_Contours=$8
A_Contours=$9
Affichage_Contours=$10
R_CE=$11
V_CE=$12
B_CE=$13
A_CE=$14
R_PC=$15
V_PC=$16
B_PC=$17
A_PC=$18
R_c=$19
V_c=$20
B_c=$21
A_c=$22
R_d=$23
V_d=$24
B_d=$25
A_d=$26
R_e=$27
V_e=$28
B_e=$29
A_e=$30
R_f=$31
V_f=$32
B_f=$33
A_f=$34
R_g=$35
V_g=$36
B_g=$37
A_g=$38
R_h=$39
V_h=$40
B_h=$41
A_h=$42
R_i=$43
V_i=$44
B_i=$45
A_i=$46
R_j=$47
V_j=$48
B_j=$49
A_j=$50
R_k=$51
V_k=$52
B_k=$53
A_k=$54
Couleurs_aleatoires=$55
Inversions=$56
Flou=$57
Dilatation=$58
Deformation=$59
Bruit=$60
Ombre=$61
X_Ombre=$62
Y_Ombre=$63
Smoothness_Ombre=$64
Curvature_Ombre=$65
Compensation_Decalage_Ombre_X=$66
Compensation_Decalage_Ombre_Y=$67
Canal_Alpha=$68
Largeur_Origine={w}
Hauteur_Origine={h}
X_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{cos({pi/180*$Angle_inclinaison})}}
Y_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{sin({pi/180*$Angle_inclinaison})}}
X_Cc={$Rayon_Premier_Cercle*{cos({pi/180*{$Angle_inclinaison+180}})}}
Y_Cc={$Rayon_Premier_Cercle*{sin({pi/180*{$Angle_inclinaison+180}})}}
R_Cc={$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}
#####
# Rayon Cercle rang 1 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=1
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_d={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Va={$R_Cc+$R_Cercle_d}
Vb={$Rayon_Premier_Cercle+$R_Cercle_d}
# Centres des 2 Cercles rang 1 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cb-$X_Cc}
d_y={$Y_Cb-$Y_Cc}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cc+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cc+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_da={$c_x2+$o_rx}
Y_Cercle_da={$c_y2+$o_ry}
X_Cercle_db={$c_x2-$o_rx}
Y_Cercle_db={$c_y2-$o_ry}
#####
# Rayon Cercle rang 4 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=4
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_e={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_e}
Va={$R_Cercle_d+$R_Cercle_e}
# Centres des 2 Cercles rang 4 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_da}
d_y={$Y_Cc-$Y_Cercle_da}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_da+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_da+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
## comp.  X_Cercle_ea={$c_x2+$o_rx}
## comp.  Y_Cercle_ea={$c_y2+$o_ry}
X_Cercle_eb={$c_x2-$o_rx}
Y_Cercle_eb={$c_y2-$o_ry}
# Centres des 2 Cercles rang 4 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_db}
d_y={$Y_Cc-$Y_Cercle_db}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_db+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_db+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_ea={$c_x2+$o_rx}
Y_Cercle_ea={$c_y2+$o_ry}
## comp.  X_Cercle_eb={$c_x2-$o_rx}
## comp.  Y_Cercle_eb={$c_y2-$o_ry}
#####
# Rayon Cercle rang 9 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=9
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_f={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_f}
Va={$R_Cercle_e+$R_Cercle_f}
# Centres des 2 Cercles rang 9 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_ea}
d_y={$Y_Cc-$Y_Cercle_ea}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_ea+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_ea+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_fa={$c_x2+$o_rx}
Y_Cercle_fa={$c_y2+$o_ry}
## comp.  X_Cercle_fb={$c_x2-$o_rx}
## comp.  Y_Cercle_fb={$c_y2-$o_ry}
# Centres des 2 Cercles rang 9 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_eb}
d_y={$Y_Cc-$Y_Cercle_eb}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_eb+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_eb+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
## comp.  X_Cercle_fa={$c_x2+$o_rx}
## comp.  Y_Cercle_fa={$c_y2+$o_ry}
X_Cercle_fb={$c_x2-$o_rx}
Y_Cercle_fb={$c_y2-$o_ry}
#####
# Rayon Cercle rang 16 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=16
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_g={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_g}
Va={$R_Cercle_f+$R_Cercle_g}
# Centres des 2 Cercles rang 16 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_fa}
d_y={$Y_Cc-$Y_Cercle_fa}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_fa+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_fa+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_ga={$c_x2+$o_rx}
Y_Cercle_ga={$c_y2+$o_ry}
## comp.  X_Cercle_gb={$c_x2-$o_rx}
## comp.  Y_Cercle_gb={$c_y2-$o_ry}
# Centres des 2 Cercles rang 16 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_fb}
d_y={$Y_Cc-$Y_Cercle_fb}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_fb+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_fb+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
## comp.  X_Cercle_ga={$c_x2+$o_rx}
## comp.  Y_Cercle_ga={$c_y2+$o_ry}
X_Cercle_gb={$c_x2-$o_rx}
Y_Cercle_gb={$c_y2-$o_ry}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Couleurs_aleatoires==1}
R_CE={round(u)*255}
V_CE={round(u)*255}
B_CE={round(u)*255}
R_PC={round(u)*255}
V_PC={round(u)*255}
B_PC={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
R_h={round(u)*255}
V_h={round(u)*255}
B_h={round(u)*255}
R_i={round(u)*255}
V_i={round(u)*255}
B_i={round(u)*255}
R_j={round(u)*255}
V_j={round(u)*255}
B_j={round(u)*255}
R_k={round(u)*255}
V_k={round(u)*255}
B_k={round(u)*255}
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cb},{$Y+$Y_Cb},$Rayon_Premier_Cercle,$Rayon_Premier_Cercle,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cc},{$Y+$Y_Cc},$R_Cc,$R_Cc,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_da},{$Y+$Y_Cercle_da},$R_Cercle_d,$R_Cercle_d,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_db},{$Y+$Y_Cercle_db},$R_Cercle_d,$R_Cercle_d,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_ea},{$Y+$Y_Cercle_ea},$R_Cercle_e,$R_Cercle_e,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_eb},{$Y+$Y_Cercle_eb},$R_Cercle_e,$R_Cercle_e,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_fa},{$Y+$Y_Cercle_fa},$R_Cercle_f,$R_Cercle_f,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_fb},{$Y+$Y_Cercle_fb},$R_Cercle_f,$R_Cercle_f,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_ga},{$Y+$Y_Cercle_ga},$R_Cercle_g,$R_Cercle_g,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_gb},{$Y+$Y_Cercle_gb},$R_Cercle_g,$R_Cercle_g,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,$R_CE,$V_CE,$B_CE,$A_CE
-ellipse[-1] {$X+$X_Cb},{$Y+$Y_Cb},$Rayon_Premier_Cercle,$Rayon_Premier_Cercle,0,1,$R_PC,$V_PC,$B_PC,$A_PC
-ellipse[-1] {$X+$X_Cc},{$Y+$Y_Cc},$R_Cc,$R_Cc,0,1,$R_c,$V_c,$B_c,$A_c
-ellipse[-1] {$X+$X_Cercle_da},{$Y+$Y_Cercle_da},$R_Cercle_d,$R_Cercle_d,0,1,$R_d,$V_d,$B_d,$A_d
-ellipse[-1] {$X+$X_Cercle_db},{$Y+$Y_Cercle_db},$R_Cercle_d,$R_Cercle_d,0,1,$R_e,$V_e,$B_e,$A_e
-ellipse[-1] {$X+$X_Cercle_ea},{$Y+$Y_Cercle_ea},$R_Cercle_e,$R_Cercle_e,0,1,$R_f,$V_f,$B_f,$A_f
-ellipse[-1] {$X+$X_Cercle_eb},{$Y+$Y_Cercle_eb},$R_Cercle_e,$R_Cercle_e,0,1,$R_g,$V_g,$B_g,$A_g
-ellipse[-1] {$X+$X_Cercle_fa},{$Y+$Y_Cercle_fa},$R_Cercle_f,$R_Cercle_f,0,1,$R_h,$V_h,$B_h,$A_h
-ellipse[-1] {$X+$X_Cercle_fb},{$Y+$Y_Cercle_fb},$R_Cercle_f,$R_Cercle_f,0,1,$R_i,$V_i,$B_i,$A_i
-ellipse[-1] {$X+$X_Cercle_ga},{$Y+$Y_Cercle_ga},$R_Cercle_g,$R_Cercle_g,0,1,$R_j,$V_j,$B_j,$A_j
-ellipse[-1] {$X+$X_Cercle_gb},{$Y+$Y_Cercle_gb},$R_Cercle_g,$R_Cercle_g,0,1,$R_k,$V_k,$B_k,$A_k
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#@gui Pintograph : Pintograph_samj_en, Pintograph_samj_en(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Pintograph")
#@gui : sep = separator(), note = note("<small>Center</small>")
#@gui : Center X (%) = float(50,0,100)
#@gui : Center Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Pintograph</small>")
#@gui : Pen (Color) = color(192,128,64,255)
#@gui : Pen (Color Variation) = choice("No change","Random colors","Poorly nuanced","Moderately nuanced","Highly nuanced")
#@gui : Pen (Dilate Pixels) = int(0,0,32)
#@gui : It\303\251rations = int(1000,2,30000)
#@gui : Iterations = choice(0,"Iterations * 1","Iterations * 5 SLOW","Iterations * 10 VERY SLOW")
#@gui : Time Increment [*10000] = float(400,10,500)
#@gui : sep = separator(), note = note("<small>Amplitude</small>")
#@gui : Amplitude 1 (>0 W) (<0 H) = float(150,-1000,1000)
#@gui : Amplitude 2 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 3 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 4 (>0 W) (<0 H) = float(100,-1000,1000)
#@gui : sep = separator(), note = note("<small>Frequency</small>")
#@gui : Frequency 1 = float(4.00,0,16)
#@gui : Frequency 2 = float(4.05,0,16)
#@gui : Frequency 3 = float(4.16,0,16)
#@gui : Frequency 4 = float(4.32,0,16)
#@gui : sep = separator(), note = note("<small>Phase</small>")
#@gui : Phase 1 = float(75,0,360)
#@gui : Phase 2 = float(150,0,360)
#@gui : Phase 3 = float(75,0,360)
#@gui : Phase 4 = float(60,0,360)
#@gui : sep = separator(), note = note("<small>Distorsions</small>")
#@gui : Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Deform = float(0,0,25)
#@gui : sep = separator(), note = note("<small>Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/15</i>.</small>")
Pintograph_samj_en :
-Pintograph_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28
#@gui Pintograph : Pintograph_samj, Pintograph_samj(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Pintograph")
#@gui : sep = separator(), note = note("<small>Centre / Center</small>")
#@gui : Centre / Center X (%) = float(50,0,100)
#@gui : Centre / Center Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Pintograph</small>")
#@gui : Stylo / Pen (Couleur/Color) = color(192,128,64,255)
#@gui : Stylo / Pen (Variation De Couleur/Color Variation) = choice("Pas de variation / No change","Couleurs aleatoires / Random colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : Stylo / Pen (Dilate Pixels) = int(0,0,32)
#@gui : It\303\251rations = int(1000,2,30000)
#@gui : Multiplier = choice(0,"Iterations * 1","Iterations * 5 LENT / SLOW","Iterations * 10 TRES LENT / VERY SLOW")
#@gui : Increment Temps / Time Increment [*10000] = float(400,10,500)
#@gui : sep = separator(), note = note("<small>Amplitude</small>")
#@gui : Amplitude 1 (>0 W) (<0 H) = float(150,-1000,1000)
#@gui : Amplitude 2 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 3 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 4 (>0 W) (<0 H) = float(100,-1000,1000)
#@gui : sep = separator(), note = note("<small>Fr\303\251quence / Frequency</small>")
#@gui : Fr\303\251quence 1 = float(4.00,0,16)
#@gui : Fr\303\251quence 2 = float(4.05,0,16)
#@gui : Fr\303\251quence 3 = float(4.16,0,16)
#@gui : Fr\303\251quence 4 = float(4.32,0,16)
#@gui : sep = separator(), note = note("<small>Phase</small>")
#@gui : Phase 1 = float(75,0,360)
#@gui : Phase 2 = float(150,0,360)
#@gui : Phase 3 = float(75,0,360)
#@gui : Phase 4 = float(60,0,360)
#@gui : sep = separator(), note = note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : D\303\251formation = float(0,0,25)
#@gui : sep = separator(), note = note("<small>M\303\251lange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
Pintograph_samj :
centre_origine_X={$1/100*w}
centre_origine_Y={$2/100*h}
R_Couleur_Stylo=$3
V_Couleur_Stylo=$4
B_Couleur_Stylo=$5
A_Couleur_Stylo=$6
Variation_de_couleur=$7
Dilate_Stylo=$8
Iterations=$9
Multiplier_Iterations=$10
Increment_temps=$11
-if {$12>0}
Amplitude1={{w}*$12/{1000}}
-else
Amplitude1={-{h}*$12/{1000}}
-endif
-if {$13>0}
Amplitude2={{w}*$13/{1000}}
-else
Amplitude2={-{h}*$13/{1000}}
-endif
-if {$14>0}
Amplitude3={{w}*$14/{1000}}
-else
Amplitude3={-{h}*$14/{1000}}
-endif
-if {$15>0}
Amplitude4={{w}*$15/{1000}}
-else
Amplitude4={-{h}*$15/{1000}}
-endif
Frequence1=$16
Frequence2=$17
Frequence3=$18
Frequence4=$19
Phase1=$20
Phase2=$21
Phase3=$22
Phase4=$23
Flou_Pintograph=$24
Spread_Pintograph=$25
Deform_Pintograph=$26
blend=$27
opacite=$28
Revert_layers=0
-to_rgba
{w},{h},1,4
Nb_Boucle=1
temps=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
R_Couleur_origine=$R_Couleur_Stylo
V_Couleur_origine=$V_Couleur_Stylo
B_Couleur_origine=$B_Couleur_Stylo
A_Couleur_origine=$A_Couleur_Stylo
Increment_temps={$Increment_temps/10000}
Phase1={$Phase1/180*{pi}}
Phase2={$Phase2/180*{pi}}
Phase3={$Phase3/180*{pi}}
Phase4={$Phase4/180*{pi}}
-if {$Multiplier_Iterations>0}
Iterations={$Iterations*$Multiplier_Iterations*5}
-endif
-repeat $Iterations
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
Nouveau_point_X={$centre_origine_X+{{$Amplitude1*{sin({{$Frequence1*$temps}+$Phase1})}}+{$Amplitude2*{sin({{$Frequence2*$temps}+$Phase2})}}}}
Nouveau_point_Y={$centre_origine_Y+{{$Amplitude3*{sin({{$Frequence3*$temps}+$Phase3})}}+{$Amplitude4*{sin({{$Frequence4*$temps}+$Phase4})}}}}
-if {$Nb_Boucle>1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
temps={$temps+$Increment_temps}
Nb_Boucle={$Nb_Boucle+1}
-done
-if {$Dilate_Stylo>0} -dilate_circ[-1] $Dilate_Stylo -endif
-if {$Flou_Pintograph>0} -blur[-1] $Flou_Pintograph,0 -endif
-if {$Spread_Pintograph>1} -spread[-1] $Spread_Pintograph -endif
-if {$Deform_Pintograph>0} -deform[-1] $Deform_Pintograph -endif
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
#@gui Poisson D Avril : samj_Poisson_D_Avril, samj_Poisson_D_Avril(1)
#@gui : note = link("http://www.mathcurve.com/courbes2d/poisson/poisson.shtml","http://www.mathcurve.com/courbes2d/poisson/poisson.shtml")
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Valeur A Dimension = float(40,1,100)
#@gui : Valeur K = float(2,0,4)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Poisson","Poisson CA")
#@gui : Couleur A = color(250,60,10,255)
#@gui : Couleur B = color(255,255,255,255)
#@gui : Couleur Al\303\251atoire / Random Color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation D\303\251calage Ombre X = float(0,-50,50)
#@gui : Compensation D\303\251calage Ombre Y = float(0,-50,50)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Poisson_D_Avril :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Valeur_A={round({{{w}+{h}}*$3/500})}
Valeur_K=$4
Angle_Rotation=$5
R_Contours=$6
V_Contours=$7
B_Contours=$8
A_Contours=$9
Affichage_Contours=$10
R_a=$11
V_a=$12
B_a=$13
A_a=$14
R_b=$15
V_b=$16
B_b=$17
A_b=$18
Couleurs_aleatoires=$19
Inversions=$20
Flou=$21
Dilatation=$22
Deformation=$23
Bruit=$24
Ombre=$25
X_Ombre=$26
Y_Ombre=$27
Smoothness_Ombre=$28
Curvature_Ombre=$29
Compensation_Decalage_Ombre_X=$30
Compensation_Decalage_Ombre_Y=$31
Canal_Alpha=$32
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Poisson_A_Imprimer=0
Y_Poisson_A_Imprimer=0
X_Poisson_A_Imprimer_Precedent={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer_Precedent={$Y+{$Valeur_A*{sin({pi/180*$Angle})}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Affichage_Contours==2}
-ellipse[-2] $X,$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Poisson_A_Imprimer={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer={$Y+{$Valeur_A*{sin({pi/180*$Angle})}}}
-polygon[-1] 3,{$X-{2*$Valeur_A}},$Y,$X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Poisson_A_Imprimer_Precedent=$X_Poisson_A_Imprimer
Y_Poisson_A_Imprimer_Precedent=$Y_Poisson_A_Imprimer
-done
Nb_boucles=0
Angle=0
X_Poisson_A_Imprimer_Precedent={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer_Precedent={$Y-{$Valeur_A*{sin({pi/180*$Angle})}}}
-if {$Couleurs_aleatoires==1}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Poisson_A_Imprimer={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer={$Y-{$Valeur_A*{sin({pi/180*$Angle})}}}
-polygon[-1] 3,{$X-{2*$Valeur_A}},$Y,$X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,$R_b,$V_b,$B_b,$A_b
-if {$Affichage_Contours>0}
-line[-2] $X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Poisson_A_Imprimer_Precedent=$X_Poisson_A_Imprimer
Y_Poisson_A_Imprimer_Precedent=$Y_Poisson_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
#@gui Rosace Triangles Sierpinski : samj_Rosace_Triangles_Sierpinski, samj_Rosace_Triangles_Sierpinski(1)
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Nombre De Zones = int(6,3,24)
#@gui : Nombre De Couches = int(6,1,50)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Premier Cercle (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : D\303\251calage Angle = float(-15,-30,30)
#@gui : Dimension Triangle = float(25,0,100)
#@gui : Recouvrement Triangle = float(5,0,100)
#@gui : Angle Inclinaison = float(30,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(0,"Sans","Triangle A et B","Triangle A","Triangle B","Triangle A et B et Cercle","Triangle A et Cercle","Triangle B et Cercle")
#@gui : Type Triangles A = choice(0,"JDH","JDE","JDB","JAH","JAE","JAB","Sans")
#@gui : Type Triangles B = choice(0,"HBI","HBF","HBC","Sans")
#@gui : Type Decalage = choice(0,"Couches","Cercles","Couches et Cercles")
#@gui : Recursions Sierpinski = int(3,0,7)
#@gui : Triangle A = color(0,0,255,127)
#@gui : Triangle Ab = color(255,255,0,127)
#@gui : Triangle B = color(128,64,192,127)
#@gui : Triangle Ba = color(64,128,192,127)
#@gui : Cercle = color(0,255,255,127)
#@gui : Afficher Cercle = bool(0)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Rosace_Triangles_Sierpinski :
Nombre_de_zones=$1
Nombre_de_couches=$2
X={round({{w}*{$3/100}})}
Y={round({{h}*{$4/100}})}
-if {$5>0}
Rayon_Premier_Cecle={round({{w}*$5/{400*{2^0.5}}})}
-else
Rayon_Premier_Cecle={round({-{h}*$5/{400*{2^0.5}}})}
-endif
Decalage_Angle=$6
Hauteur_Triangle={round({{{w}+{h}}*$7/2400})}
Recouvrement_Triangle={round({{{w}+{h}}*$8/4800})}
Angle_inclinaison=$9
R_Contours=$10
V_Contours=$11
B_Contours=$12
A_Contours=$13
Affichage_Contours=$14
Type_Triangles_A=$15
Type_Triangles_B=$16
Type_Decalage=$17
Recursions_Sierpinski=$18
R_Tr=$19
V_Tr=$20
B_Tr=$21
A_Tr=$22
R_Trb=$23
V_Trb=$24
B_Trb=$25
A_Trb=$26
R_Tr_B=$27
V_Tr_B=$28
B_Tr_B=$29
A_Tr_B=$30
R_Tr_Bb=$31
V_Tr_Bb=$32
B_Tr_Bb=$33
A_Tr_Bb=$34
R_Cercle=$35
V_Cercle=$36
B_Cercle=$37
A_Cercle=$38
Afficher_Cercle=$39
Couleurs_aleatoires=$40
Inversions=$41
Flou=$42
Dilatation=$43
Deformation=$44
Bruit=$45
Ombre=$46
X_Ombre=$47
Y_Ombre=$48
Smoothness_Ombre=$49
Curvature_Ombre=$50
Compensation_Decalage_Ombre_X=$51
Compensation_Decalage_Ombre_Y=$52
Canal_Alpha=$53
Largeur_Origine={w}
Hauteur_Origine={h}
Angle=$Angle_inclinaison
Increment_angle={360/$Nombre_de_zones}
Rayon_Cercle_Origine=$Rayon_Premier_Cecle
Rayon_Cercle_A=0
Rayon_Cercle_B=0
Rayon_Cercle_C=0
Rayon_Cercle_D=0
H_Tr_A=0
H_Tr_B=0
H_Tr_C=0
H_Tr_D=0
Nb_Cercles=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
Nb_boucles_couches=0
-repeat $Nombre_de_couches
Nb_boucles_couches={$Nb_boucles_couches+1}
H_Tr_A={$Hauteur_Triangle*$Nb_Cercles}
Nb_Cercles={$Nb_Cercles+1}
H_Tr_B={$Hauteur_Triangle*$Nb_Cercles}
Nb_Cercles={$Nb_Cercles+1}
H_Tr_C={$Hauteur_Triangle*$Nb_Cercles}
Nb_Cercles={$Nb_Cercles+1}
H_Tr_D={$Hauteur_Triangle*$Nb_Cercles}
Rayon_Cercle_A={$Rayon_Cercle_Origine+$H_Tr_A}
Rayon_Cercle_B={$Rayon_Cercle_Origine+$H_Tr_B}
Rayon_Cercle_C={$Rayon_Cercle_Origine+$H_Tr_C}
Rayon_Cercle_D={$Rayon_Cercle_Origine+$H_Tr_D}
Angle=$Angle_inclinaison
Nb_boucles_zones=0
-repeat $Nombre_de_zones
Nb_boucles_zones={$Nb_boucles_zones+1}
-if {$Couleurs_aleatoires==1}
R_Tr={round(u)*255}
V_Tr={round(u)*255}
B_Tr={round(u)*255}
R_Trb={round(u)*255}
V_Trb={round(u)*255}
B_Trb={round(u)*255}
R_Tr_B={round(u)*255}
V_Tr_B={round(u)*255}
B_Tr_B={round(u)*255}
R_Tr_Bb={round(u)*255}
V_Tr_Bb={round(u)*255}
B_Tr_Bb={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
-if {$Type_Decalage==0}
X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
-elif {$Type_Decalage==1}
X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}}})}}}
Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}}})}}}
X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}}})}}}
Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}}})}}}
X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}}})}}}
Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}}})}}}
X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
-elif {$Type_Decalage==2}
X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}}})}}}
Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}}})}}}
X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}}})}}}
Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}}})}}}
X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}}})}}}
Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}}})}}}
X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
-endif
-if {$Type_Triangles_A==0}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==1}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==2}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==3}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==4}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==5}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
-if {$Type_Triangles_B==0}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_B==1}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_B==2}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
Angle={$Angle_inclinaison+{$Increment_angle*$Nb_boucles_zones}}
-done
Nb_Cercles={$Nb_Cercles-3}
H_Tr=$H_Tr_C
Rayon_Cercle_Origine=$Rayon_Cercle_D
-done
-if {$Afficher_Cercle==1}
$Largeur_Origine,$Hauteur_Origine,1,4
-polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1
-ellipse[-1] $X,$Y,$Rayon_Cercle_D,$Rayon_Cercle_D,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-blend[-2,-1] alpha,1,1
-endif
-if {$Affichage_Contours>0}
-if {$Affichage_Contours>3}
-ellipse[-2,-3] $X,$Y,$Rayon_Cercle_D,$Rayon_Cercle_D,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
samj_rien_repair :
-Je_passe_l_hiver_en_Floride[-1]
#@gui Rotating Circles : samj_en_Cercles_Qui_Tournent, samj_en_Cercles_Qui_Tournent(1)
#@gui : note = note("Rotating Circles")
#@gui : sep = separator(), note = note("<small>New Image</small>")
#@gui : Dimension Image = int(800,2,32768)
#@gui : Background = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Examples</small>")
#@gui : Examples = choice(0,"No","A","B","C","D","E","F")
#@gui : sep = separator(), note = note("<small>Param. X</small>")
#@gui : Cax = float(1,0.5,2)
#@gui : Cbx = float(0.5,0.05,5)
#@gui : Ccx = float(0.33,0.05,5)
#@gui : Vbx = int(7,-50,50)
#@gui : Vcx = int(17,-50,50)
#@gui : sep = separator(), note = note("<small>Param. Y</small>")
#@gui : Cay = float(1,0.5,2)
#@gui : Cby = float(0.5,0.05,5)
#@gui : Ccy = float(0.33,0.05,5)
#@gui : Vby = int(7,-50,50)
#@gui : Vcy = int(17,-50,50)
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Equality : Param. X & Param. Y = bool(1)
#@gui : Theta = int(10,1,5000)
#@gui : Line = color(0,0,0,255)
#@gui : Tilt = float(0,-360,360)
#@gui : Random Colors = bool(0)
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,200)
#@gui : Shadow = bool(0)
#@gui : X-Shadow = float(0.5,-5,5)
#@gui : Y-Shadow = float(0.5,-5,5)
#@gui : Smoothness Shadow = float(1.8,0,5)
#@gui : Curvature Shadow = float(0,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/05</i>.</small>")
samj_en_Cercles_Qui_Tournent :
-samj_Cercles_Qui_Tournent $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33
#@gui Rotating Circles : samj_Cercles_Qui_Tournent, samj_Cercles_Qui_Tournent(1)
#@gui : note = note("Cercles Qui Tournent / Rotating Circles")
#@gui : note = link("http://rouxjeanbernard.ch/AM/html/amch57.html","http://rouxjeanbernard.ch/AM/html/amch57.html")
#@gui : sep = separator(), note = note("<small>Nouvelle New Image</small>")
#@gui : Dimension Image = int(800,2,32768)
#@gui : Fond / Background = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Exemples Examples</small>")
#@gui : Examples = choice(0,"Non No","A","B","C","D","E","F")
#@gui : sep = separator(), note = note("<small>Param. X</small>")
#@gui : Cax = float(1,0.5,2)
#@gui : Cbx = float(0.5,0.05,5)
#@gui : Ccx = float(0.33,0.05,5)
#@gui : Vbx = int(7,-50,50)
#@gui : Vcx = int(17,-50,50)
#@gui : sep = separator(), note = note("<small>Param. Y</small>")
#@gui : Cay = float(1,0.5,2)
#@gui : Cby = float(0.5,0.05,5)
#@gui : Ccy = float(0.33,0.05,5)
#@gui : Vby = int(7,-50,50)
#@gui : Vcy = int(17,-50,50)
#@gui : sep = separator(), note = note("<small>Rendu Rendering</small>")
#@gui : \303\211galite / Equality : Param. X & Param. Y = bool(1)
#@gui : Th\303\252ta = int(10,1,5000)
#@gui : Ligne / Line = color(0,0,0,255)
#@gui : Angle Inclinaison = float(0,-360,360)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,200)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Cercles_Qui_Tournent :
Dimension=$1
R_fond=$2
V_fond=$3
B_fond=$4
A_fond=$5
Exemples=$6
Cax=$7
Cbx=$8
Ccx=$9
Vbx=$10
Vcx=$11
Cay=$12
Cby=$13
Ccy=$14
Vby=$15
Vcy=$16
Egalite_Param_X_Y=$17
Theta=$18
R_a=$19
V_a=$20
B_a=$21
A_a=$22
Angle_Rotation=$23
Couleurs_aleatoires=$24
Flou=$25
Dilatation=$26
Deformation=$27
Bruit=$28
Ombre=$29
X_Ombre=$30
Y_Ombre=$31
Smoothness_Ombre=$32
Curvature_Ombre=$33
-if {$Exemples==1}
Egalite_Param_X_Y=1
Cax=1
Cbx=0.5
Ccx=0.25
Vbx=7
Vcx=21
Theta=1000
-elif {$Exemples==2}
Egalite_Param_X_Y=1
Cax=1
Cbx=5
Ccx=2
Vbx=3
Vcx=10
Theta=4693
-elif {$Exemples==3}
Egalite_Param_X_Y=0
Cax=1
Cbx=0.5
Ccx=0.33
Vbx=7
Vcx=17
Cay=1
Cby=0.5
Ccy=0.33
Vby=11
Vcy=17
Theta=4886
-elif {$Exemples==4}
Egalite_Param_X_Y=0
Cax=1
Cbx=0.5
Ccx=0.33
Vbx=7
Vcx=17
Cay=1
Cby=0.5
Ccy=0.33
Vby=7
Vcy=3
Theta=4520
-elif {$Exemples==5}
Egalite_Param_X_Y=0
Cax=1
Cbx=0.5
Ccx=0.25
Vbx=1
Vcx=6
Cay=0.8
Cby=0.2
Ccy=1
Vby=9
Vcy=12
Theta=493
-elif {$Exemples==6}
Egalite_Param_X_Y=1
Cax=1
Cbx=0.5
Ccx=0.33
Vbx=-5
Vcx=17
Theta=10
-endif
-if {$Egalite_Param_X_Y==1}
Cay=$Cax
Cby=$Cbx
Ccy=$Ccx
Vby=$Vbx
Vcy=$Vcx
-endif
-rm[-1]
$Dimension,$Dimension,1,4
-fill_color[-1] 0,0,0,0
# tracer la courbe en couleur noire sans Antialiasing , sans Decoration ,   X(t) :  cos(t)+(0.5*cos(7*t))+((cos((3.14/2)-(17*t)))/3)  ,  Y(t) :  (sin(t)+(0.5*sin(7*t))+((sin((3.14/2)-(17*t)))/3)
-fx_equation_parametric[-1] "(cos(t)*"$Cax")+("$Cbx"*cos("$Vbx"*t))+((cos(("{pi/2}")-("$Vcx"*t)))*"$Ccx")","(sin(t)*"$Cay")+("$Cby"*sin("$Vby"*t))+((sin(("{pi/2}")-("$Vcy"*t)))*"$Ccy")",0,$Theta,$Dimension,1,1,0,0,0,0,0,0,1,0,0
-to_rgba[-1]
-replace_color[-1] 100%,0,255,255,255,255,0,0,0,0
-replace_color[-1] 100%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a
-if {$Couleurs_aleatoires==0}
-replace_color[-1] 100%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a
-else
$Dimension,$Dimension,1,4
-fill_color[-1] 0,0,0,0
-fx_corner_gradient[-1] {round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255
-blend[-1,-2] add,1,0
-to_rgba[-1]
-endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{$Dimension/2},{$Dimension/2} -endif
$Dimension,$Dimension,1,4
-fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond
-if {$Bruit>0} -apply_channels[-1] "-fx_noise "$Bruit",0,22,1",1 -endif
#-blend[-2,-1] alpha,1,1
-gimp_blend_1651[-2,-1] 1,0,1,0,1
#@gui Samj Chains Solidify : samj_Chains_Solidify, samj_Chains_Solidify(1)
#@gui : sep = separator(), note = note("<span foreground="orangered">samj_Chains_Solidify</span>")
#@gui : sep = separator(), note = note("<small>Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle Tilt = float(0,0,360)
#@gui : sep = separator(), note = note("<small>Circles</small>")
#@gui : Radius Center Circle = float(6,-100,100)
#@gui : Nb Circles Surrounding = int(56,7,360)
#@gui : sep = separator(), note = note("<small>Rings</small>")
#@gui : Nb Rings = int(20,1,100)
#@gui : Offset Angle % = float(50,-100,100)
#@gui : Change Increment % = float(0,-100,200)
#@gui : sep = separator(), note = note("<small>Coulors</small>")
#@gui : Color A = color(255,0,221,255)
#@gui : Color B = color(72,0,255,255)
#@gui : Color C = color(0,145,255,255)
#@gui : Color D = color(0,255,144,255)
#@gui : Color E = color(72,255,0,255)
#@gui : Color F = color(255,217,0,255)
#@gui : Color G = color(255,0,0,255)
#@gui : Choice Of Colors = choice(5,"Couleurs / Colors AB","Couleurs / Colors ABC","Couleurs / Colors ABCD","Couleurs / Colors ABCDE","Couleurs / Colors ABCDEF","Couleurs / Colors ABCDEFG","Ordre ABCDEFG")
#@gui : Center Color = color(255,127,0,255)
#@gui : Background = color(0,0,0,255)
#@gui : Variation = float(100,0,1000)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2017/01/07</i>.</small>")
samj_Chains_Solidify :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Angle_inclinaison=$3
-if {$4>0}
Rayon_Cercle_Centre={round({{w}*$4/{100}})}
-else
Rayon_Cercle_Centre={round({-{h}*$4/{100}})}
-endif
Nb_Circles_Surrounding=$5
Nb_Anneaux=$6
Angle_Decalage=$7
Variation_Increment_Anneaux=$8
R_a=$9
V_a=$10
B_a=$11
A_a=$12
R_b=$13
V_b=$14
B_b=$15
A_b=$16
R_c=$17
V_c=$18
B_c=$19
A_c=$20
R_d=$21
V_d=$22
B_d=$23
A_d=$24
R_e=$25
V_e=$26
B_e=$27
A_e=$28
R_f=$29
V_f=$30
B_f=$31
A_f=$32
R_g=$33
V_g=$34
B_g=$35
A_g=$36
Rendu=$37
R_centre=$38
V_centre=$39
B_centre=$40
A_centre=$41
R_Fond=$42
V_Fond=$43
B_Fond=$44
A_Fond=$45
Effet=$46
Largeur_Origine={w}
Hauteur_Origine={h}
-rm[0]
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] 0,0,0,0
--Je_passe_l_hiver_en_Floride[-1]
Angle_Theta={pi/$Nb_Circles_Surrounding}
-if {$Rayon_Cercle_Centre<1}
Rayon_Cercle_Centre=1
-endif
Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Angle_Decalage_En_Cours=0
Nb_boucles_anneaux=0
Rayon_Cercle_Centre_En_Cours=0
Ra_en_cours=0
Va_en_cours=0
Ba_en_cours=0
Aa_en_cours=0
Suite_Couleurs=0
-point[-1] $X,$Y,0,1,$R_centre,$V_centre,$B_centre,$A_centre
-repeat $Nb_Anneaux
Nb_boucles=0
Suite_Couleurs=0
Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage/100*$Nb_boucles_anneaux}
-if {$Nb_boucles_anneaux==0}
Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
-else
Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
-endif
Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
-repeat $Nb_Circles_Surrounding
-if {$Rendu==6}
-if {{{($Nb_boucles%7)}==0}&&{$Suite_Couleurs==0}}
Ra_en_cours=$R_a
Va_en_cours=$V_a
Ba_en_cours=$B_a
Aa_en_cours=$A_a
Suite_Couleurs=1
-endif
-if {{{($Nb_boucles%7)}==1}&&{$Suite_Couleurs==1}}
Ra_en_cours=$R_b
Va_en_cours=$V_b
Ba_en_cours=$B_b
Aa_en_cours=$A_b
Suite_Couleurs=2
-endif
-if {{{($Nb_boucles%7)}==2}&&{$Suite_Couleurs==2}}
Ra_en_cours=$R_c
Va_en_cours=$V_c
Ba_en_cours=$B_c
Aa_en_cours=$A_c
Suite_Couleurs=3
-endif
-if {{{($Nb_boucles%7)}==3}&&{$Suite_Couleurs==3}}
Ra_en_cours=$R_d
Va_en_cours=$V_d
Ba_en_cours=$B_d
Aa_en_cours=$A_d
Suite_Couleurs=4
-endif
-if {{{($Nb_boucles%7)}==4}&&{$Suite_Couleurs==4}}
Ra_en_cours=$R_e
Va_en_cours=$V_e
Ba_en_cours=$B_e
Aa_en_cours=$A_e
Suite_Couleurs=5
-endif
-if {{{($Nb_boucles%7)}==5}&&{$Suite_Couleurs==5}}
Ra_en_cours=$R_f
Va_en_cours=$V_f
Ba_en_cours=$B_f
Aa_en_cours=$A_f
Suite_Couleurs=6
-endif
-if {{{($Nb_boucles%7)}==6}&&{$Suite_Couleurs==6}}
Ra_en_cours=$R_g
Va_en_cours=$V_g
Ba_en_cours=$B_g
Aa_en_cours=$A_g
Suite_Couleurs=0
-endif
-endif
-if {$Rendu<6}
-if {{($Nb_boucles%2)}==0}
Ra_en_cours=$R_a
Va_en_cours=$V_a
Ba_en_cours=$B_a
Aa_en_cours=$A_a
-endif
-if {{($Nb_boucles%2)}==1}
Ra_en_cours=$R_b
Va_en_cours=$V_b
Ba_en_cours=$B_b
Aa_en_cours=$A_b
-endif
-if {{{($Nb_boucles%3)}==2}&&{$Rendu>0}}
Ra_en_cours=$R_c
Va_en_cours=$V_c
Ba_en_cours=$B_c
Aa_en_cours=$A_c
-endif
-if {{{($Nb_boucles%4)}==3}&&{$Rendu>1}}
Ra_en_cours=$R_d
Va_en_cours=$V_d
Ba_en_cours=$B_d
Aa_en_cours=$A_d
-endif
-if {{{($Nb_boucles%5)}==4}&&{$Rendu>2}}
Ra_en_cours=$R_e
Va_en_cours=$V_e
Ba_en_cours=$B_e
Aa_en_cours=$A_e
-endif
-if {{{($Nb_boucles%6)}==5}&&{$Rendu>3}}
Ra_en_cours=$R_f
Va_en_cours=$V_f
Ba_en_cours=$B_f
Aa_en_cours=$A_f
-endif
-if {{{($Nb_boucles%7)}==6}&&{$Rendu>4}}
Ra_en_cours=$R_g
Va_en_cours=$V_g
Ba_en_cours=$B_g
Aa_en_cours=$A_g
-endif
-endif
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Nb_boucles={$Nb_boucles+1}
-ellipse[-2] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/100*$Effet},{$Rayon_Cercles_Ext/100*$Effet},0,1,0xFFFFFFFF,$R_Fond,$V_Fond,$B_Fond,$A_Fond
-point[-1] $X_ext,$Y_ext,0,1,$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Aa_en_cours
-done
Nb_boucles_anneaux={$Nb_boucles_anneaux+1}
-done
-ellipse[-2] $X,$Y,{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},0,1,0xFFFFFFFF,$R_Fond,$V_Fond,$B_Fond,$A_Fond
-blend[-1,-2] alpha
-solidify[-1]
#@gui Samj Palette De Degrades : samj_Palette_De_Degrades, samj_Palette_De_Degrades_preview(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_Palette_De_Degrades - Gradient Palette</b></span>")
#@gui : sep = separator(), note = note("<span foreground="blue">Obtenir des degrades avec 12 couleurs plus noir et blanc en option - Lent</span>")
#@gui : note = note("<span foreground="blue">Get gradients from 12 colors with optional black and white - Slow</span>")
#@gui : sep = separator()
#@gui : Couleur - Color A = color(159,190,195)
#@gui : Couleur - Color B = color(55,67,140)
#@gui : Couleur - Color C = color(54,40,39)
#@gui : Couleur - Color D = color(140,81,88)
#@gui : Couleur - Color E = color(207,175,190)
#@gui : Couleur - Color F = color(220,202,196)
#@gui : Couleur - Color G = color(170,186,192)
#@gui : Couleur - Color H = color(130,149,139)
#@gui : Couleur - Color I = color(112,96,96)
#@gui : Couleur - Color J = color(237,168,138)
#@gui : Couleur - Color K = color(220,199,205)
#@gui : Couleur - Color L = color(234,217,219)
#@gui : Ajouter Du Noir - Add Black = bool(0)
#@gui : Ajouter Du Blanc - Add White = bool(0)
#@gui : Etendue Degrade - Width = int(256,2,1024)
#@gui : Hauteur De Un Degrade - Height Of One Gradient = int(2,2,20)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2018/02/18</i>.</small>")
samj_Palette_De_Degrades :
R_a=$1
V_a=$2
B_a=$3
R_b=$4
V_b=$5
B_b=$6
R_c=$7
V_c=$8
B_c=$9
R_d=$10
V_d=$11
B_d=$12
R_e=$13
V_e=$14
B_e=$15
R_f=$16
V_f=$17
B_f=$16
R_g=$19
V_g=$20
B_g=$21
R_h=$22
V_h=$23
B_h=$25
R_i=$25
V_i=$26
B_i=$27
R_j=$28
V_j=$29
B_j=$30
R_k=$31
V_k=$32
B_k=$33
R_l=$34
V_l=$35
B_l=$36
Ajouter_Noir=$37
Ajouter_Blanc=$38
Etendue_Degrade=$39
Hauteur_De_Un_Degrade=$40
Hauteur_Degrade={66*$Hauteur_De_Un_Degrade}
Hauteur_Origine_Degrade=-1
-if {{$Ajouter_Noir+$Ajouter_Blanc}==1}
Hauteur_Degrade={78*$Hauteur_De_Un_Degrade}
-endif
-if {{$Ajouter_Noir+$Ajouter_Blanc}==2}
Hauteur_Degrade={91*$Hauteur_De_Un_Degrade}
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_b,$V_b,$B_b,255
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_c,$V_c,$B_c,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_d,$V_d,$B_d,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_e,$V_e,$B_e,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_f,$V_f,$B_f,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_g,$V_g,$B_g,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_h,$V_h,$B_h,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_c,$V_c,$B_c,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_d,$V_d,$B_d,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_e,$V_e,$B_e,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_f,$V_f,$B_f,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_g,$V_g,$B_g,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_h,$V_h,$B_h,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_d,$V_d,$B_d,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_e,$V_e,$B_e,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_f,$V_f,$B_f,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_g,$V_g,$B_g,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_h,$V_h,$B_h,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_e,$V_e,$B_e,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_f,$V_f,$B_f,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_g,$V_g,$B_g,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_h,$V_h,$B_h,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_f,$V_f,$B_f,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_g,$V_g,$B_g,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_h,$V_h,$B_h,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_g,$V_g,$B_g,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_h,$V_h,$B_h,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_h,$V_h,$B_h,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_i,$V_i,$B_i,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,$R_j,$V_j,$B_j,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,$R_k,$V_k,$B_k,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_k,$V_k,$B_k,255,$R_l,$V_l,$B_l,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_k,$V_k,$B_k,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_k,$V_k,$B_k,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Noir==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_l,$V_l,$B_l,255,0,0,0,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-if {$Ajouter_Blanc==1}
$Etendue_Degrade,$Hauteur_Degrade,1,4
-samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_l,$V_l,$B_l,255,255,255,255,255
Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} -rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 -blend[-1,-2] alpha,1,1
-endif
-rv[-2,-1]
samj_Palette_De_Degrades_preview :
-samj_Palette_De_Degrades[-1] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,2
#@gui Samj Splines Test : samj_Splines_Test , samj_Splines_Test_preview (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_Splines_Test</b></span>")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(50,0,100)
#@gui : Angle Origine = Float(30,0,360)
#@gui : Variation Angle = Float(30,-360,360)
#@gui : Variation Dimension = int(90,1,400)
#@gui : Repetition Spline = int(30,1,360)
#@gui : Repetition Dim = int(1,1,8)
#@gui : Increment Angle = Float(10,-360,360)
#@gui : UA0 = Float(2,-100,100)
#@gui : VA0 = Float(2,-100,100)
#@gui : UA1 = Float(2,-100,100)
#@gui : VA1 = Float(2,-100,100)
#@gui : UB0 = Float(2,-100,100)
#@gui : VB0 = Float(2,-100,100)
#@gui : UB1 = Float(2,-100,100)
#@gui : VB1 = Float(2,-100,100)
#@gui : Couleur Spline A = color(255,255,0,255)
#@gui : Couleur Spline B = color(0,255,255,255)
#@gui : Dilatation = int(1,1,8)
#@gui : Blend = bool(0)
#@gui : Version De Spline = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/09</i>.</small>")
samj_Splines_Test :
XO={round({{w}/100*$1})}
YO={round({{h}/100*$2})}
Angle_Origine=$3
Variation_Angle=$4
Var_Dim=$5
Repetition_Spline=$6
Repetition_Dim=$7
Inc_Angle=$8
uA0={round({{{w}+{h}}/200*$9})}
vA0={round({{{w}+{h}}/200*$10})}
uA1={round({{{w}+{h}}/200*$11})}
vA1={round({{{w}+{h}}/200*$12})}
uB0={round({{{w}+{h}}/200*$13})}
vB0={round({{{w}+{h}}/200*$14})}
uB1={round({{{w}+{h}}/200*$15})}
vB1={round({{{w}+{h}}/200*$16})}
R_a=$17
V_a=$18
B_a=$19
A_a=$20
R_b=$21
V_b=$22
B_b=$23
A_b=$24
Dilatation=$25
Validation_Blend=$26
Version_Spline=$27
deg_to_rad={pi/180}
X_Debut=$XO
Y_Debut=$YO
XF=0
YF=0
XA=0
YA=0
XB=0
YB=0
-to_rgba[-1]
{w},{h},1,4
-repeat $Repetition_Spline
XO=$X_Debut
YO=$Y_Debut
Angle_Origine={$Angle_Origine+$Inc_Angle}
-repeat $Repetition_Dim
XF={$XO+{cos({$Angle_Origine+$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
YF={$YO+{sin({$Angle_Origine+$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
XA={round({$XO+{{$XF-$XO}/100*$uA0}})}
YA={round({$YO+{{$YF-$YO}/100*$vA0}})}
XB={round({$XF-{{$XF-$XO}/100*$uA1}})}
YB={round({$YF-{{$YF-$YO}/100*$vA1}})}
-if {$Version_Spline==0}
-spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1,$R_a,$V_a,$B_a,$A_a
-else
-spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1024,1,$R_a,$V_a,$B_a,$A_a
-endif
XO=$XF
YO=$YF
XF={$XO+{cos({$Angle_Origine-$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
YF={$YO+{sin({$Angle_Origine-$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
XA={round({$XO+{{$XF-$XO}/100*$uB0}})}
YA={round({$YO+{{$YF-$YO}/100*$vB0}})}
XB={round({$XF-{{$XF-$XO}/100*$uB1}})}
YB={round({$YF-{{$YF-$YO}/100*$vB1}})}
-if {$Version_Spline==0}
-spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1,$R_b,$V_b,$B_b,$A_b
-else
-spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1024,1,$R_b,$V_b,$B_b,$A_b
-endif
XO=$XF
YO=$YF
-done
-done
-dilate[-1] $Dilatation
-if {$Validation_Blend==1} -blend[-1,-2] alpha -else -reverse[-1,-2] -endif
samj_Splines_Test_preview :
-samj_Splines_Test[-1] $1,$2,$3,$4,{$5/2},$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27
-if {$26==0} -rm[-1] -endif
#@gui Samj Test Visu 3D : samj_Test_Visu_3D, samj_Test_Visu_3D(1)
#@gui : sep = separator(), note = note("<span foreground="orangered">samj_Test_Visu_3D</span>")
#@gui : Type 3D = choice(1,"Fichier 3D .off","elevation3d","imageplane3d","imagecube3d","gmic3d")
#@gui : Fichier 3D .Off = text("C:\\\\GimpEval-2.9.5-Win\\\\images_test\\\\GMIC\\\\cube.off")
#@gui : Elevation3d = float(0.5,0,1)
#@gui : sep = separator(), note = note("<span foreground="orangered">rotate3d</span>")
#@gui : U = bool(1)
#@gui : V = bool(1)
#@gui : W = bool(0)
#@gui : Angle = float(0,0,360)
#@gui : sep = separator(), note = note("<span foreground="orangered">gaussians3d</span>")
#@gui : Size = int(0,0,32)
#@gui : Opacity = float(1,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered">Rendu</span>")
#@gui : Type = choice(0,"fx render3d","snapshot3d")
#@gui : Autocrop = bool(0)
#@gui : Dimensions Origine = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered">fx render3d</span>")
#@gui : Width = int(1024,8,4096)
#@gui : Height = int(1024,8,4096)
#@gui : Object Size = float(0.5,0,3)
#@gui : X Angle = float(0,0,360)
#@gui : Y Angle = float(0,0,360)
#@gui : Z Angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X Light = float(0,-100,100)
#@gui : Y Light = float(0,-100,100)
#@gui : Z Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered">snapshot3d</span>")
#@gui : Dimension = int(400,256,4096)
#@gui : Zoom = float(1,1,2)
#@gui : Fond = color(225,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2017/01/15</i>.</small>")
samj_Test_Visu_3D :
Choix=$1
Fichier=$2
Val_Elevation=$3
R_U=$4
R_V=$5
R_W=$6
R_angle=$7
G_Size=$8
G_Opacity=$9
Type_Rendu=$10
Valider_Autocrop=$11
Dimensions_Origine=$12
Width=$13
Height=$14
Object_size=$15
X_angle=$16
Y_angle=$17
Z_angle=$18
FOV=$19
X_light=$20
Y_light=$21
Z_light=$22
Specular_lightness=$23
Specular_shininess=$24
Rendering_mode=$25
Antialiasing=$26
S_Dimension=$27
S_Zoom=$28
S_R=$29
S_V=$30
S_B=$31
S_A=$32
Largeur_Origine={w}
Hauteur_Origine={h}
-if {$Choix==0}
-rm[0]
-input $Fichier
-elif {$Choix==1}
-elevation3d[-1] $Val_Elevation
-elif {$Choix==2}
-imageplane3d[-1]
-elif {$Choix==3}
-imagecube3d[-1]
-elif {$Choix==4}
-rm[-1]
-gmic3d
-endif
-rotate3d[-1] $R_U,$R_V,$R_W,$R_angle
-if {$G_Size>0} -gaussians3d[-1] $G_Size,$G_Opacity -endif
-if {$Type_Rendu==0}
-fx_render3d[-1] $Width,$Height,$Object_size,$X_angle,$Y_angle,$Z_angle,$FOV,$X_light,$Y_light,$Z_light,$Specular_lightness,$Specular_shininess,$Rendering_mode,$Antialiasing
-elif {$Type_Rendu==1}
-snapshot3d[-1] $S_Dimension,$S_Zoom,$S_R,$S_V,$S_B,$S_A
-endif
-if {$Valider_Autocrop==1} -autocrop[-1] -endif
-if {$Dimensions_Origine==1} -resize[-1] $Largeur_Origine,$Hauteur_Origine -endif
#@gui Simple Geometric Shapes : samj_Formes_Geometriques_Simples, samj_Formes_Geometriques_Simples(1)
#@gui : sep = separator(), note = note("<span foreground="black">Formes G\303\251ometriques Simples / Simple Geometric Shapes</span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Effet</small></span>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Couleur Externe / External Color = color(127,127,127,127)
#@gui : Couleur Interne / Interior Color = color(255,255,0,255)
#@gui : Couleur / Color Contour = color(0,0,255,255)
#@gui : Forme / Shape = choice(5,"Polygone Inscrit Dimension 1","Polygone Inscrit Dimension 2","Cercle / Ellipse","Etoile Star Dimension 1","Etoile Star Dimension 2","Polygone Etoile Star Dimension 1","Polygone Etoile Star Dimension 2")
#@gui : Dimension 1  (% Width) = float(40,0,400)
#@gui : Dimension 2  (% Height) = float(40,0,400)
#@gui : Nb C\303\264t\303\251s / Number Of Sides = int(4,3,26)
#@gui : Angle Inclinaison / Tilt = float(0,0,120)
#@gui : Dilate = int(0,0,48)
#@gui : Blend = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/09</i>.</small>")
samj_Formes_Geometriques_Simples :
X_Position={round({{w}*{$1/100}})}
Y_Position={round({{h}*{$2/100}})}
R_Externe=$3
V_Externe=$4
B_Externe=$5
A_Externe=$6
R_Interne=$7
V_Interne=$8
B_Interne=$9
A_Interne=$10
R_Contour=$11
V_Contour=$12
B_Contour=$13
A_Contour=$14
Forme=$15
Dimension_Un={round({{w}*{$16/100}})}
Dimension_Deux={round({{h}*{$17/100}})}
Nb_Cotes=$18
Angle_Inclinaison=$19
Dilatation=$20
Melange=$21
Largeur_Origine={w}
Hauteur_Origine={h}
Valeur_Angle=0
Nb_Boucles=0
Rayon_Cercle_Circonscrit=0
-if {$Forme==0}
Rayon_Cercle_Circonscrit=$Dimension_Un
-elif {$Forme==1}
Rayon_Cercle_Circonscrit=$Dimension_Deux
-elif {$Forme==3}
Rayon_Cercle_Circonscrit=$Dimension_Un
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-elif {$Forme==4}
Rayon_Cercle_Circonscrit=$Dimension_Deux
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-elif {$Forme==5}
Rayon_Cercle_Circonscrit=$Dimension_Un
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-elif {$Forme==6}
Rayon_Cercle_Circonscrit=$Dimension_Deux
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-endif
-if {$Melange==0}
-rm[-1]
-else
-to_rgba[-1]
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $R_Externe,$V_Externe,$B_Externe,$A_Externe
-if {$Forme==2}
-ellipse[-1] $X_Position,$Y_Position,$Dimension_Un,$Dimension_Deux,$Angle_Inclinaison,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-ellipse[-1] $X_Position,$Y_Position,$Dimension_Un,$Dimension_Deux,$Angle_Inclinaison,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-else
-repeat $Nb_Cotes
Nb_Boucles={$Nb_Boucles+1}
-if {$Nb_Boucles==1}
X_a={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_a={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==2}
X_b={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_b={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==3}
X_c={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_c={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==4}
X_d={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_d={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==5}
X_e={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_e={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==6}
X_f={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_f={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==7}
X_g={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_g={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==8}
X_h={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_h={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==9}
X_i={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_i={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==10}
X_j={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_j={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==11}
X_k={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_k={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==12}
X_l={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_l={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==13}
X_m={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_m={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==14}
X_n={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_n={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==15}
X_o={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_o={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==16}
X_p={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_p={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==17}
X_q={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_q={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==18}
X_r={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_r={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==19}
X_s={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_s={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==20}
X_t={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_t={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==21}
X_u={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_u={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==22}
X_v={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_v={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==23}
X_w={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_w={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==24}
X_x={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_x={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==25}
X_y={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_y={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==26}
X_z={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_z={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-endif
Valeur_Angle={$Valeur_Angle+{360/$Nb_Cotes}}
-done
-endif
-if {$Forme==0||$Forme==1}
-if {$Nb_Cotes==3}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==4}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==5}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==6}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==7}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==8}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==9}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==10}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==11}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==12}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==13}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==14}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==15}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==16}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==17}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==18}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==19}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==20}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==21}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==22}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==23}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==24}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==25}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==26}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-endif
-endif
-if {$Forme==3||$Forme==4}
# Etoiles Impaires
-if {$Nb_Cotes==5}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==7}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==9}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==11}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==13}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==15}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==17}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==19}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==21}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==23}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==25}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
# toiles Paires
-elif {$Nb_Cotes==6}
-polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==8}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==10}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==12}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==14}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==16}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==18}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==20}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==22}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==24}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==26}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-endif
-endif
-if {$Forme==5||$Forme==6}
# Polygones + toiles Impaires
-if {$Nb_Cotes==5}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==7}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==9}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==11}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==13}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==15}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==17}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==19}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==21}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==23}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==25}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
# Polygones + toiles Paires
-elif {$Nb_Cotes==6}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==8}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==10}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==12}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==14}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==16}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==18}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==20}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==22}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==24}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==26}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-endif
-endif
-if {$Dilatation>1}
-dilate_circ[-1] $Dilatation
-endif
#-text_outline[-1] $X_Position,10,10,32,1,1,255,255,255
#-text_outline[-1] $Y_Position,10,35,32,1,1,255,255,255
#-text_outline[-1] $Dimension_Un,10,60,32,1,1,255,255,255
#-text_outline[-1] $Dimension_Deux,10,85,32,1,1,255,255,255
#-text_outline[-1] $Nb_Cotes,10,110,32,1,1,255,255,255
#-text_outline[-1] $Angle_Inclinaison,10,135,32,1,1,255,255,255
-if {$Melange==1}
-blend[-1,-2] alpha,1,0
-endif
#@gui Simple Geometric Shapes : samj_en_Formes_Geometriques_Simples, samj_en_Formes_Geometriques_Simples(0)
#@gui : sep = separator(), note = note("<span foreground="black">Simple Geometric Shapes</span>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Effect</small></span>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : External Color = color(127,127,127,127)
#@gui : Interior Color = color(255,255,0,255)
#@gui : Color Contour = color(0,0,255,255)
#@gui : Forme / Shape = choice(5,"Joined polygon Dimension 1","Joined polygon Dimension 2","Circle / Ellipse","Star Dimension 1","Star Dimension 2","Polygon Star Dimension 1","Polygon Star Dimension 2")
#@gui : Dimension 1  (% Width) = float(40,0,400)
#@gui : Dimension 2  (% Height) = float(40,0,400)
#@gui : Number Of Sides = int(4,3,26)
#@gui : Tilt = float(0,0,120)
#@gui : Dilate = int(0,0,48)
#@gui : Blend = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/09</i>.</small>")
samj_en_Formes_Geometriques_Simples :
-samj_Formes_Geometriques_Simples $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21
#@gui Spirograph : Spirographe_samj_en, Spirographe_samj_en(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Spirograph")
#@gui : sep = separator(), note = note("<small>Center</small>")
#@gui : Center X (%) = float(50,0,100)
#@gui : Center Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Spirographe</small>")
#@gui : Radius R (>0 W) (<0 H) = float(200,-500,500)
#@gui : Radius R (>0 W) (<0 H) = float(50,-500,500)
#@gui : Pen (Position) (>0 W) (<0 H) = float(150,-500,500)
#@gui : Pen (Color) = color(192,128,64,255)
#@gui : Pen (Color Variation) = choice("No change","Random colors","Poorly nuanced","Moderately nuanced","Highly nuanced")
#@gui : Pen (Dilate Pixels) = int(0,0,32)
#@gui : Number of Turns = float(3,0.01,20)
#@gui : Iterations = choice(0,"Turns * 1","Turns * 10 SLOW","Turns * 100 VERY SLOW")
#@gui : Angular Increment (Degr\303\251s) = float(1,1,360)
#@gui : Divide = choice(0,"Angular increment / 1","Angular increment /10 SLOW","Angular increment /100 VERY SLOW")
#@gui : Rendering = choice("Formula 1","Formula 2","Formula 3","Formula 4","Formula 5","Formula 6","Formula 7","Formula 8")
#@gui : Points (Radius) = int(0,0,32)
#@gui : Points (Color) = color(255,0,0,255)
#@gui : Lines (Thickness) = int(0,0,32)
#@gui : Lines (Color) = color(255,255,0,255)
#@gui : sep = separator(), note = note("<small>Distorsions</small>")
#@gui : Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Deform = float(0,0,25)
#@gui : sep = separator(), note = note("<small>Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/15</i>.</small>")
Spirographe_samj_en :
-Spirographe_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31
#@gui Spirographe Samj : Spirographe_samj, Spirographe_samj(1)
#@gui : note = link("http://en.wikipedia.org/wiki/Spirograph")
#@gui : sep = separator(), note = note("<small>Centre / Center</small>")
#@gui : Centre / Center X (%) = float(50,0,100)
#@gui : Centre / Center Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Spirographe</small>")
#@gui : Rayon/Radius R (>0 W) (<0 H) = float(200,-500,500)
#@gui : Rayon/Radius R (>0 W) (<0 H) = float(50,-500,500)
#@gui : Stylo / Pen (Position) (>0 W) (<0 H) = float(150,-500,500)
#@gui : Stylo / Pen (Couleur/Color) = color(192,128,64,255)
#@gui : Stylo / Pen (Variation De Couleur/Color Variation) = choice("Pas de variation / No change","Couleurs aleatoires / Random colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : Stylo / Pen (Dilate Pixels) = int(0,0,32)
#@gui : Nombre De Tours / Number of Turns = float(3,0.01,20)
#@gui : Multiplier = choice(0,"Tours / Turns * 1","Tours / Turns * 10 LENT / SLOW","Tours / Turns * 100 TRES LENT / VERY SLOW")
#@gui : Incr\303\251ment Angulaire / Angular Increment (Degr\303\251s) = float(1,1,360)
#@gui : Diviser / Divide = choice(0,"Increment angulaire-Angular increment / 1","Increment angulaire-Angular increment /10 LENT / SLOW","Increment angulaire-Angular increment /100 TRES LENT / VERY SLOW")
#@gui : Type De Rendu / Rendering Type = choice("Formule/Formula 1","Formule/Formula 2","Formule/Formula 3","Formule/Formula 4","Formule/Formula 5","Formule/Formula 6","Formule/Formula 7","Formule/Formula 8")
#@gui : Points (Rayon/Radius) = int(0,0,32)
#@gui : Points (Couleur/Color) = color(255,0,0,255)
#@gui : Lignes (Epaisseur/Thickness) = int(0,0,32)
#@gui : Lignes (Couleur/Color) = color(255,255,0,255)
#@gui : sep = separator(), note = note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : D\303\251formation = float(0,0,25)
#@gui : sep = separator(), note = note("<small>M\303\251lange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
Spirographe_samj :
centre_origine_X={$1/100*w}
centre_origine_Y={$2/100*h}
-if {$3>0}
Rayon_1={{w}*$3/{1000}}
-else
Rayon_1={-{h}*$3/{1000}}
-endif
-if {$4>0}
Rayon_2={{w}*$4/{1000}}
-else
Rayon_2={-{h}*$4/{1000}}
-endif
-if {$5>0}
Position_Stylo={{w}*$5/{1000}}
-else
Position_Stylo={-{h}*$5/{1000}}
-endif
R_Couleur_Stylo=$6
V_Couleur_Stylo=$7
B_Couleur_Stylo=$8
A_Couleur_Stylo=$9
Variation_de_couleur=$10
Dilate_Stylo=$11
Nombre_de_tours=$12
Multiplier_tours=$13
Increment_angulaire=$14
Diviser_Increment_angulaire=$15
Type_de_rendu=$16
Points_Rayon=$17
R_Couleur_Points=$18
V_Couleur_Points=$19
B_Couleur_Points=$20
A_Couleur_Points=$21
Lignes_epaisseur=$22
R_Couleur_Lignes=$23
V_Couleur_Lignes=$24
B_Couleur_Lignes=$25
A_Couleur_Lignes=$26
Flou_Spirographe=$27
Spread_Spirographe=$28
Deform_Spirographe=$29
blend=$30
opacite=$31
Revert_layers=0
-to_rgba
{w},{h},1,4
Nb_Boucle=1
theta=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
-if {$Rayon_2==0}
Rayon_2=1
-endif
-if {$Multiplier_tours==1}
Nombre_de_tours={$Nombre_de_tours*10}
-endif
-if {$Multiplier_tours==2}
Nombre_de_tours={$Nombre_de_tours*100}
-endif
-if {$Diviser_Increment_angulaire==1}
Increment_angulaire={$Increment_angulaire/10}
-endif
-if {$Diviser_Increment_angulaire==2}
Increment_angulaire={$Increment_angulaire/100}
-endif
Nombre_de_tours={$Nombre_de_tours/$Increment_angulaire*360}
R_Couleur_origine=$R_Couleur_Stylo
V_Couleur_origine=$V_Couleur_Stylo
B_Couleur_origine=$B_Couleur_Stylo
A_Couleur_origine=$A_Couleur_Stylo
-if {$Dilate_Stylo>0}
-repeat $Nombre_de_tours
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
-if {$Type_de_rendu==0}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==1}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==2}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==3}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==4}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==5}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==6}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==7}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Nb_Boucle>1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
theta={$theta+$Increment_angulaire}
Nb_Boucle={$Nb_Boucle+1}
-done
-dilate_circ[-1] $Dilate_Stylo
Nb_Boucle=1
theta=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
-if {{$Lignes_epaisseur>0}||{$Points_Rayon>0}}
-repeat $Nombre_de_tours
-if {$Type_de_rendu==0}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==1}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==2}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==3}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==4}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==5}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==6}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==7}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Nb_Boucle>1}
-if {$Lignes_epaisseur>0}
-if {$Points_Rayon>0}
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-trait_epais_samj $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,$Lignes_epaisseur,1,$R_Couleur_Lignes,$V_Couleur_Lignes,$B_Couleur_Lignes,$A_Couleur_Lignes
-if {$Points_Rayon>0}
-circle[-1] $Nouveau_point_X,$Nouveau_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
-if {$Points_Rayon>0}
-if {$Variation_de_couleur==1}
R_Couleur_Points={round(u)*255}
V_Couleur_Points={round(u)*255}
B_Couleur_Points={round(u)*255}
-endif
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
theta={$theta+$Increment_angulaire}
Nb_Boucle={$Nb_Boucle+1}
-done
-endif
-else
-repeat $Nombre_de_tours
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
-if {$Type_de_rendu==0}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==1}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==2}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==3}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==4}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==5}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==6}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==7}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Nb_Boucle>1}
-if {$Lignes_epaisseur>0}
-if {$Points_Rayon>0}
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-trait_epais_samj $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,$Lignes_epaisseur,1,$R_Couleur_Lignes,$V_Couleur_Lignes,$B_Couleur_Lignes,$A_Couleur_Lignes
-if {$Points_Rayon>0}
-circle[-1] $Nouveau_point_X,$Nouveau_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
-if {$Lignes_epaisseur<1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
-if {$Points_Rayon>0}
-if {$Variation_de_couleur==1}
R_Couleur_Points={round(u)*255}
V_Couleur_Points={round(u)*255}
B_Couleur_Points={round(u)*255}
-endif
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
theta={$theta+$Increment_angulaire}
Nb_Boucle={$Nb_Boucle+1}
-done
-endif
-if {$Flou_Spirographe>0} -blur[-1] $Flou_Spirographe,0 -endif
-if {$Spread_Spirographe>1} -spread[-1] $Spread_Spirographe -endif
-if {$Deform_Spirographe>0} -deform[-1] $Deform_Spirographe -endif
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
#@gui Straight Lines : samj_en_Des_Lignes_002, samj_en_Des_Lignes_002(1)
#@gui : sep = separator(), note = note("<small>Straight Lines</small>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Lines parameters</small></span>")
#@gui : Number Of Lines = int(100,1,4096)
#@gui : Random Colors = bool(0)
#@gui : Gray = bool(0)
#@gui : Color = color(192,128,64,255)
#@gui : Symmetry = int(0,0,3)
#@gui : Effect = choice(0,"1","2","3","4","5","6","7","8","9","10","11","12")
#@gui : Extend = float(1,1,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Effect 12</small></span>")
#@gui : Origine X (% W) = float(50,-400,400)
#@gui : Origine Y (% H) = float(50,-400,400)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Distorsions</small></span>")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Blend = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2015/03/09</i>.</small>")
samj_en_Des_Lignes_002 :
-samj_Des_Lignes_002 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
#@gui Straight Lines : samj_Des_Lignes_002, samj_Des_Lignes_002(1)
#@gui : sep = separator(), note = note("<small>Des Lignes / Straight Lines</small>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Param\303\250tres des lignes</small></span>")
#@gui : Nombre Lignes / Number Of Lines = int(100,1,4096)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Gris / Gray = bool(0)
#@gui : Couleur / Color = color(192,128,64,255)
#@gui : Sym\303\251trie / Symmetry = int(0,0,3)
#@gui : Effet / Effect = choice(0,"1","2","3","4","5","6","7","8","9","10","11","12")
#@gui : Etendue / Extent = float(1,1,10)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Effet 12 / Effect 12</small></span>")
#@gui : Origine X (% W) = float(50,-400,400)
#@gui : Origine Y (% H) = float(50,-400,400)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Distorsions</small></span>")
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>M\303\251lange / Blend</small></span>")
#@gui : M\303\251lange / Blend = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Des_Lignes_002 :
Nombre_Lignes=$1
Random_Colors=$2
Gris=$3
R_Couleur=$4
V_Couleur=$5
B_Couleur=$6
A_Couleur=$7
Symetrie=$8
Effet=$9
Etendue=$10
point_X={{w}/100*$11}
point_Y={{h}/100*$12}
Flou=$13
Dilatation=$14
Deformation=$15
Bruit=$16
Melange=$17
Inc_L={{w}/{{$Nombre_Lignes+1}*$Etendue}}
Inc_H={{h}/{{$Nombre_Lignes+1}*$Etendue}}
Origine_L=0
Origine_H=0
-if {$Melange==1}
{w},{h},1,4
-else
-to_rgba[-1]
-fill_color[-1] 0,0,0,0
-endif
-repeat $Nombre_Lignes
Origine_L={$Origine_L+$Inc_L}
Origine_H={$Origine_H+$Inc_H}
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==1}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==3}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==5}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==9}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==11}
-line[-1] $point_X,$point_Y,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-line[-1] $point_X,$point_Y,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-line[-1] $point_X,$point_Y,0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-line[-1] $point_X,$point_Y,$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==2}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==3}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==6}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==10}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==1}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==4}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==7}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==10}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==2}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==4}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==8}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==9}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-done
-if {$Symetrie==1}
-mirror[-1] x
-elif {$Symetrie==2}
-mirror[-1] y
-elif {$Symetrie==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Melange==1}
-blend[-1,-2] alpha,1,0
-endif
# -text_outline[-1] $Effet,10,10,64,1,1,255,255,255
#@gui Superposition Triangles Sierpinski : samj_Superposition_Triangles_Sierpinski, samj_Superposition_Triangles_Sierpinski(1)
#@gui : sep = separator(), note = note("<small>Rendu - Rendering</small>")
#@gui : Nombre De Zones = int(6,3,24)
#@gui : Nombre De Superpositions = int(6,1,50)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Dimension Premier Cercle (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Coeff. Superpositions = float(1,0,4)
#@gui : Hauteur Triangle = float(20,0,100)
#@gui : Angle Inclinaison = float(30,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage = choice(1,"Sans Contours Triangles Ext.","Sans Contours Triangles Int.","Sans Contours Triangles Ext. et Lat.","Sans Contours Triangles Int. et Lat.","Triangles Ext.","Triangles Int.","Triangles Ext. et Lat.","Triangles Int. et Lat.")
#@gui : Recursions Sierpinski = int(4,0,7)
#@gui : Triangle A = color(0,0,255,127)
#@gui : Triangle B = color(255,255,0,127)
#@gui : Triangle Lat. A = color(128,64,192,127)
#@gui : Triangle Lat. B = color(64,128,192,127)
#@gui : Cercle = color(0,255,255,127)
#@gui : Afficher Cercle = bool(0)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : D\303\251formation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : D\303\251calage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : D\303\251calage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
samj_Superposition_Triangles_Sierpinski :
Nombre_de_zones=$1
Nombre_de_superpositions=$2
X={round({{w}*{$3/100}})}
Y={round({{h}*{$4/100}})}
-if {$5>0}
Rayon_Premier_Cecle={round({{w}*$5/{200*{2^0.5}}})}
-else
Rayon_Premier_Cecle={round({-{h}*$5/{200*{2^0.5}}})}
-endif
Coeff_Superpositions=$6
Hauteur_Triangle={round({{{w}+{h}}*$7/2400})}
Angle_inclinaison=$8
R_Contours=$9
V_Contours=$10
B_Contours=$11
A_Contours=$12
Affichage=$13
Recursions_Sierpinski=$14
R_Tr=$15
V_Tr=$16
B_Tr=$17
A_Tr=$18
R_Trb=$19
V_Trb=$20
B_Trb=$21
A_Trb=$22
R_Lat=$23
V_Lat=$24
B_Lat=$25
A_Lat=$26
R_Latb=$27
V_Latb=$28
B_Latb=$29
A_Latb=$30
R_Cercle=$31
V_Cercle=$32
B_Cercle=$33
A_Cercle=$34
Afficher_Cercle=$35
Couleurs_aleatoires=$36
Inversions=$37
Flou=$38
Dilatation=$39
Deformation=$40
Bruit=$41
Ombre=$42
X_Ombre=$43
Y_Ombre=$44
Smoothness_Ombre=$45
Curvature_Ombre=$46
Compensation_Decalage_Ombre_X=$47
Compensation_Decalage_Ombre_Y=$48
Canal_Alpha=$49
Largeur_Origine={w}
Hauteur_Origine={h}
Angle=$Angle_inclinaison
Increment_angle={360/$Nombre_de_zones}
Rayon_Cercle_A=$Rayon_Premier_Cecle
H_Tr=$Hauteur_Triangle
Rayon_Cercle_B=0
Rayon_Cercle_C=0
Rayon_Contour=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage>3}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
Nb_boucles_superpositions=0
-repeat $Nombre_de_superpositions
Nb_boucles_superpositions={$Nb_boucles_superpositions+1}
Nb_boucles_zones=0
Angle=$Angle_inclinaison
-repeat $Nombre_de_zones
Nb_boucles_zones={$Nb_boucles_zones+1}
-if {$Couleurs_aleatoires==1}
R_Tr={round(u)*255}
V_Tr={round(u)*255}
B_Tr={round(u)*255}
R_Trb={round(u)*255}
V_Trb={round(u)*255}
B_Trb={round(u)*255}
R_Lat={round(u)*255}
V_Lat={round(u)*255}
B_Lat={round(u)*255}
R_Latb={round(u)*255}
V_Latb={round(u)*255}
B_Latb={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
Rayon_Cercle_B={{{$Rayon_Cercle_A*$Rayon_Cercle_A}+{{$Rayon_Cercle_A*{tan({pi/180*{180/$Nombre_de_zones}})}}*{$Rayon_Cercle_A*{tan({pi/180*{180/$Nombre_de_zones}})}}}}^0.5}
X_A={$X+{{$Rayon_Cercle_A+$H_Tr}*{cos({pi/180*$Angle})}}}
Y_A={$Y+{{$Rayon_Cercle_A+$H_Tr}*{sin({pi/180*$Angle})}}}
X_B={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
Y_B={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
X_C={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
Rayon_Cercle_C={{{{$Rayon_Cercle_A+$H_Tr}*{$Rayon_Cercle_A+$H_Tr}}+{{{$Rayon_Cercle_A+$H_Tr}*{tan({pi/180*{180/$Nombre_de_zones}})}}*{{$Rayon_Cercle_A+$H_Tr}*{tan({pi/180*{180/$Nombre_de_zones}})}}}}^0.5}
X_D={$X+{$Rayon_Cercle_A*{cos({pi/180*$Angle})}}}
Y_D={$Y+{$Rayon_Cercle_A*{sin({pi/180*$Angle})}}}
X_E={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
Y_E={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
X_F={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
-if {{($Affichage%2)}==0}
Rayon_Contour={$Rayon_Cercle_A+$H_Tr}
-if {$Recursions_Sierpinski==0}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-else
-if {{($Nb_boucles_superpositions%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-endif
-if {{$Affichage==2}||{$Affichage==6}}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_E,$Y_E,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-polygon[-1] 3,$X_A,$Y_A,$X_C,$Y_C,$X_F,$Y_F,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-else
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_E,$Y_E,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-polygon[-1] 3,$X_A,$Y_A,$X_C,$Y_C,$X_F,$Y_F,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-endif
-endif
-if {$Affichage>3}
-polygon[-2] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-else
Rayon_Contour=$Rayon_Cercle_C
-if {$Recursions_Sierpinski==0}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-polygon[-1] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-else
-if {{($Nb_boucles_superpositions%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-endif
-if {{$Affichage==3}||{$Affichage==7}}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_D,$Y_D,$X_B,$Y_B,$X_E,$Y_E,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-polygon[-1] 3,$X_D,$Y_D,$X_C,$Y_C,$X_F,$Y_F,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-else
-polygon[-1] 3,$X_D,$Y_D,$X_B,$Y_B,$X_E,$Y_E,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-polygon[-1] 3,$X_D,$Y_D,$X_C,$Y_C,$X_F,$Y_F,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-endif
-endif
-if {$Affichage>3}
-polygon[-2] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
Angle={$Angle_inclinaison+{$Increment_angle*$Nb_boucles_zones}}
-done
Rayon_Cercle_A={$Rayon_Cercle_A+$H_Tr}
H_Tr={$Hauteur_Triangle*$Nb_boucles_superpositions*$Coeff_Superpositions}
-done
-if {$Afficher_Cercle==1}
$Largeur_Origine,$Hauteur_Origine,1,4
-polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1
-ellipse[-1] $X,$Y,$Rayon_Contour,$Rayon_Contour,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-blend[-2,-1] alpha,1,1
-if {$Affichage>3}
-ellipse[-2] $X,$Y,$Rayon_Contour,$Rayon_Contour,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
-if {$Affichage>3}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -fx_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#@gui Traits Strokes : Traits_Strokes_samj, Traits_Strokes_samj(1)
#@gui : sep = separator(), note = note("<small>Origine</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Traits / Strokes</small>")
#@gui : L O N G U E U R / Length (>0 %W) (<0 $H) = float(35,-400,400)
#@gui : Mode Variations = choice(0,"Non / No","Plus / More","Moins / Less","Plus / More [milieu-middle]","Moins / Less [milieu-middle]")
#@gui : Variations % (Longueur/Length) = float(100,0,1000)
#@gui : \303\211loignement Du Centre (>0 %W) (<0 $H) = float(0,-400,400)
#@gui : N O M B R E   D E   T R a I T S / Number of Strokes = int(30,1,2160)
#@gui : Angle (D\303\251part / Start) = float(0,0,360)
#@gui : Angle (Fin / End) = float(360,0,360)
#@gui : Couleur/ Color = color(240,60,120,255)
#@gui : Variation De Couleur / Color Variation = choice("Pas de variation / No change","Couleurs aleatoires / Random colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : \303\211paisseur / Thickness = int(0,0,32)
#@gui : sep = separator(), note = note("<small>Sym\303\251trie / Symmetry</small>")
#@gui : Sym\303\251trie / Symmetry = bool(0)
#@gui : Longueur / Length (%) = float(20,0,100)
#@gui : sep = separator(), note = note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : D\303\251formation = float(0,0,25)
#@gui : sep = separator(), note = note("<small>M\303\251lange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
Traits_Strokes_samj:
Position_X={round({{w}*{$1/100}})}
Position_Y={round({{h}*{$2/100}})}
-if {$3>0}
Longueur={{w}*$3/{100}}
-else
Longueur={-{h}*$3/{100}}
-endif
Variations_Formes=$4
Variations_Longueur=$5
-if {$6>0}
Eloignement_du_centre={{w}*$6/{100}}
-else
Eloignement_du_centre={-{h}*$6/{100}}
-endif
Nombre_de_traits=$7
Angle_Depart=$8
Angle_Fin=$9
R_Couleur=$10
V_Couleur=$11
B_Couleur=$12
A_Couleur=$13
Variation_de_couleur=$14
Epaisseur=$15
Symetrie=$16
Pourcent_Longueur_Sym=$17
Flou_traits=$18
Spread_traits=$19
Deform_traits=$20
blend=$21
opacite=$22
Revert_layers=0
-to_rgba
{w},{h},1,4
Angle=$Angle_Depart
-if {$Angle_Depart>$Angle_Fin}
Angle_Fin={$Angle_Fin+360}
-endif
increment_theta={{$Angle_Fin-$Angle_Depart}/$Nombre_de_traits}
-if {$Variations_Formes==1}
Variation={{$Longueur/100*$Variations_Longueur}/$Nombre_de_traits}
-endif
-if {$Variations_Formes==2}
Variation={{-$Longueur/1000*$Variations_Longueur}/$Nombre_de_traits}
-endif
-if {$Variations_Formes==3}
Variation={{$Longueur/100*$Variations_Longueur}/{$Nombre_de_traits/2}}
-endif
-if {$Variations_Formes==4}
Variation={{-$Longueur/1000*$Variations_Longueur}/{$Nombre_de_traits/2}}
-endif
Longueur_calculee=$Longueur
Nb_Boucle=1
R_Couleur_origine=$R_Couleur
V_Couleur_origine=$V_Couleur
B_Couleur_origine=$B_Couleur
A_Couleur_origine=$A_Couleur
-repeat $Nombre_de_traits
-if {$Variation_de_couleur==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
A_Couleur={{round(u)*200}+55}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur>255}
R_Couleur=$R_Couleur_origine
-endif
-if {$R_Couleur<0}
R_Couleur=$R_Couleur_origine
-endif
V_Couleur={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur>255}
V_Couleur=$V_Couleur_origine
-endif
-if {$V_Couleur<0}
V_Couleur=$V_Couleur_origine
-endif
B_Couleur={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur>255}
B_Couleur=$B_Couleur_origine
-endif
-if {$B_Couleur<0}
B_Couleur=$B_Couleur_origine
-endif
-endif
Debut_X={$Position_X+{round(cos(pi/180*$Angle)*$Eloignement_du_centre)}}
Debut_Y={$Position_Y+{round(sin(pi/180*$Angle)*$Eloignement_du_centre)}}
Extremite_X={$Position_X+{round(cos(pi/180*$Angle)*{$Longueur_calculee+$Eloignement_du_centre})}}
Extremite_Y={$Position_Y+{round(sin(pi/180*$Angle)*{$Longueur_calculee+$Eloignement_du_centre})}}
-line[-1] $Debut_X,$Debut_Y,$Extremite_X,$Extremite_Y,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-if {$Symetrie==1}
Debut_X={$Position_X+{round(cos(pi/180*{$Angle+180})*$Eloignement_du_centre)}}
Debut_Y={$Position_Y+{round(sin(pi/180*{$Angle+180})*$Eloignement_du_centre)}}
Extremite_X={$Position_X+{round(cos(pi/180*{$Angle+180})*{{$Longueur_calculee/100*$Pourcent_Longueur_Sym}+$Eloignement_du_centre})}}
Extremite_Y={$Position_Y+{round(sin(pi/180*{$Angle+180})*{{$Longueur_calculee/100*$Pourcent_Longueur_Sym}+$Eloignement_du_centre})}}
-line[-1] $Debut_X,$Debut_Y,$Extremite_X,$Extremite_Y,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
Angle={$Angle+$increment_theta}
-if {{$Variations_Formes==1}||{$Variations_Formes==2}}
Longueur_calculee={$Longueur_calculee+$Variation}
-endif
-if {{$Variations_Formes==3}||{$Variations_Formes==4}}
-if {$Nb_Boucle<{$Nombre_de_traits/2}}
Longueur_calculee={$Longueur_calculee+$Variation}
-else
Longueur_calculee={$Longueur_calculee-$Variation}
-endif
-endif
Nb_Boucle={$Nb_Boucle+1}
-done
-if {$Epaisseur>0}
-dilate_circ[-1] $Epaisseur
-endif
-blur[-1] $Flou_traits
-spread[-1] $Spread_traits
-deform[-1] $Deform_traits
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
#@gui Triangles Shades Adjacents : Triangles_Shades_Adjacents, Triangles_Shades_Adjacents(1)
#@gui : note = note("<span foreground="orangered"><b>Image Finale / Resulting Image</b></span>")
#@gui : Supprimer Calque Origine / Delete Layer Source = bool(0)
#@gui : Position Centre X / X Center = float(50,0,100)
#@gui : Position Centre Y / Y Center = float(50,0,100)
#@gui : Nb Triangles = int(60,3,360)
#@gui : Artefacts / Artifacts = int(-1,-1,10)
#@gui : note = note("<span foreground="orangered"><b>Couleurs / Colors</b></span>")
#@gui : D\303\251calage Des Couleurs / Offset (Angle) = float(0,-360,360)
#@gui : - - -  Centre / Center - - - = color(255,255,255)
#@gui : Couleur / Color A = color(255,0,221)
#@gui : Couleur / Color B = color(72,0,255)
#@gui : Couleur / Color C = color(0,145,255)
#@gui : Couleur / Color D = color(0,255,144)
#@gui : Couleur / Color E = color(72,255,0)
#@gui : Couleur / Color F = color(255,217,0)
#@gui : Couleur / Color G = color(255,0,0)
#@gui : Choix Des Couleurs / Choice Of Colors = choice(5,"Couleurs / Colors AB","Couleurs / Colors ABC","Couleurs / Colors ABCD","Couleurs / Colors ABCDE","Couleurs / Colors ABCDEF","Couleurs / Colors ABCDEFG")
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b>Color Balance</b></span>")
#@gui : Activer / Enable Color Balance = bool(0)
#@gui : Neutral Color = color(128,128,128)
#@gui : Stretch Colors = bool(1)
#@gui : note = note("<span foreground="orangered"><b>M\303\251lange / Blend</b></span>")
#@gui : Activer M\303\251lange / Enable Blend = bool(0)
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : Revert Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
Triangles_Shades_Adjacents:
Supprimer_Calque_Origine=$1
Position_Centre_X=$2
Position_Centre_Y=$3
Nombre_De_Triangles=$4
Artefacts=$5
Angle_Decalage_Couleurs=$6
R_Centre=$7
V_Centre=$8
B_Centre=$9
R_a=$10
V_a=$11
B_a=$12
R_b=$13
V_b=$14
B_b=$15
R_c=$16
V_c=$17
B_c=$18
R_d=$19
V_d=$20
B_d=$21
R_e=$22
V_e=$23
B_e=$24
R_f=$25
V_f=$26
B_f=$27
R_g=$28
V_g=$29
B_g=$30
#Choix_Des_Couleurs
Rendu=$31
Couleurs_aleatoires=$32
Activer_Color_Balance=$33
R_Neutral_color=$34
V_Neutral_color=$35
B_Neutral_color=$36
Stretch_colors=$37
Activer_Melange=$38
Mode=$39
Opacity=$40
Revert_layers=$41
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Ra_en_cours=0
Va_en_cours=0
Ba_en_cours=0
Rb_en_cours=0
Vb_en_cours=0
Bb_en_cours=0
Rc_en_cours=0
Vc_en_cours=0
Bc_en_cours=0
Rayon_De_Couleur={round({{{{$Largeur_Origine^2}+{$Hauteur_Origine^2}}^0.5}+1})}
Angle_Rayon_De_Couleur={360/$Nombre_De_Triangles}
Angle_Artefacts=0
Angle_Rayon_De_Couleur_Ref=0
Angle_Rayon_De_Couleur_En_Cours=0
Angle_Rayon_De_Couleur_En_Cours_Fin=0
-if {$Nombre_De_Triangles==3} Rayon_De_Couleur={$Rayon_De_Couleur*3} -endif
-if {{$Nombre_De_Triangles-{$Rendu+2}}<0} Rendu={$Nombre_De_Triangles-2} -endif
-if {$Artefacts==-1} Angle_Artefacts={0.5-{0.1/$Nombre_De_Triangles}} -else Angle_Artefacts=$Artefacts -endif
-to_rgba[0]
# 1 nouvelle images couleurs
$Largeur_Origine,$Hauteur_Origine,1,3
-fill_color[-1] 0,0,0,255
-repeat $Nombre_De_Triangles
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-if {{($Nb_boucles%{$Rendu+2})}==0}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_a
Vb_en_cours=$V_a
Bb_en_cours=$B_a
Rc_en_cours=$R_b
Vc_en_cours=$V_b
Bc_en_cours=$B_b
-endif
-if {{($Nb_boucles%{$Rendu+2})}==1}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_b
Vb_en_cours=$V_b
Bb_en_cours=$B_b
-if {$Rendu==0}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_c
Vc_en_cours=$V_c
Bc_en_cours=$B_c
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==2}&&{$Rendu>0}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_c
Vb_en_cours=$V_c
Bb_en_cours=$B_c
-if {$Rendu==1}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_d
Vc_en_cours=$V_d
Bc_en_cours=$B_d
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==3}&&{$Rendu>1}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_d
Vb_en_cours=$V_d
Bb_en_cours=$B_d
-if {$Rendu==2}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_e
Vc_en_cours=$V_e
Bc_en_cours=$B_e
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==4}&&{$Rendu>2}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_e
Vb_en_cours=$V_e
Bb_en_cours=$B_e
-if {$Rendu==3}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_f
Vc_en_cours=$V_f
Bc_en_cours=$B_f
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==5}&&{$Rendu>3}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_f
Vb_en_cours=$V_f
Bb_en_cours=$B_f
-if {$Rendu==4}
Rb_en_cours=$R_a
Vb_en_cours=$V_a
Bb_en_cours=$B_a
-else
Rc_en_cours=$R_g
Vc_en_cours=$V_g
Bc_en_cours=$B_g
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==6}&&{$Rendu>4}}
R_en_cours=$R_g
V_en_cours=$V_g
B_en_cours=$B_g
-endif
Angle_Rayon_De_Couleur_Ref={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs+$Angle_Artefacts}
-if {$Nb_boucles==0}
-else
-endif
Angle_Rayon_De_Couleur_En_Cours={$Angle_Rayon_De_Couleur_Ref-$Angle_Artefacts}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur_Ref+$Angle_Rayon_De_Couleur+$Angle_Artefacts}
-triangle_shade[-1] {$Position_Centre_X*$Largeur_Origine/100},{$Position_Centre_Y*$Hauteur_Origine/100},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*{$Angle_Rayon_De_Couleur_En_Cours}})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*{$Angle_Rayon_De_Couleur_En_Cours}})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*{$Angle_Rayon_De_Couleur_En_Cours_Fin}})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*{$Angle_Rayon_De_Couleur_En_Cours_Fin}})}}},$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Rb_en_cours,$Vb_en_cours,$Bb_en_cours,$Rc_en_cours,$Vc_en_cours,$Bc_en_cours
Nb_boucles={$Nb_boucles+1}
-done
-if {$Activer_Color_Balance==1}
-fx_balance_gamma[-1] $R_Neutral_color,$V_Neutral_color,$B_Neutral_color,$Stretch_colors=$34
-endif
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-else
-if {$Activer_Melange==1}
-if {$Revert_layers==1}
-reverse[-1,-2]
-endif
-gimp_blend_1651[-2,-1] $Mode,0,$Opacity,0
-else
-reverse[-1,-2]
-endif
-endif
#@gui Twisted Rays Samj : Twisted_Rays, Twisted_Rays(1)
#@gui : note = note("<span foreground="orangered"><b>Image Finale</b></span>")
#@gui : Dimension En Pixels = int(800,256,1920)
#@gui : Supprimer Calque Origine = bool(1)
#@gui : Twirl = float(0.2,-5,5)
#@gui : M\303\251langes Rayons = choice(2,"Add","And","Average","Darken","Difference","Edges","Grainextract","Grainmerge","Multiply","Negation","Or","Screen","Softburn","Softdodge","Subtract","Xor","- NON / NO -")
#@gui : Rendu = choice(5,"Rayons Couleurs AB","Rayons Couleurs ABC","Rayons Couleurs ABCD","Rayons Couleurs ABCDE","Rayons Couleurs ABCDEF","Rayons Couleurs ABCDEFG")
#@gui : note = note("<span foreground="orangered"><b>Rayons De Couleurs</b></span>")
#@gui : Nombre De Rayons = int(21,3,360)
#@gui : Angle D\303\251calage Des Couleurs A = float(0,-360,360)
#@gui : Angle D\303\251calage Des Couleurs B = float(0,-360,360)
#@gui : Couleur / Color A = color(0,0,255,255)
#@gui : Couleur / Color B = color(0,255,255,255)
#@gui : Couleur / Color C = color(0,255,0,255)
#@gui : Couleur / Color D = color(255,255,0,255)
#@gui : Couleur / Color E = color(255,0,0,255)
#@gui : Couleur / Color F = color(255,0,255,255)
#@gui : Couleur / Color G = color(255,255,255,255)
#@gui : Couleurs Al\303\251atoires / Random Colors = bool(0)
#@gui : note = note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(0)
#@gui : Dilate Contours = int(2,1,16)
#@gui : Flou / Blur Contours = float(2,0,5)
#@gui : Sharpen = int(0,200,400)
#@gui : note = note("<span foreground="orangered"><b>Symmetrizoscope</b></span>")
#@gui : Activer Symmetrizoscope = bool(0)
#@gui : Iterations = int(5,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Symmetry Sides = choice("Backward","Forward","Swap")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/02/02</i>.</small>")
Twisted_Rays:
Dimension_Finale=$1
Supprimer_Calque_Origine=$2
Amplitude_Twirl=$3
Melanges_Rayons=$4
Rendu=$5
Nb_De_Rayon_De_Couleur=$6
Angle_Decalage_Couleurs_A=$7
Angle_Decalage_Couleurs_B=$8
R_a=$9
V_a=$10
B_a=$11
A_a=$12
R_b=$13
V_b=$14
B_b=$15
A_b=$16
R_c=$17
V_c=$18
B_c=$19
A_c=$20
R_d=$21
V_d=$22
B_d=$23
A_d=$24
R_e=$25
V_e=$26
B_e=$27
A_e=$28
R_f=$29
V_f=$30
B_f=$31
A_f=$32
R_g=$33
V_g=$34
B_g=$35
A_g=$36
Couleurs_aleatoires=$37
R_Contours=$38
V_Contours=$39
B_Contours=$40
A_Contours=$41
Affichage_Contours=$42
Dilate_Contours=$43
Flou_Contours=$44
Sharpen_Contours=$45
Filtre_Symmetrizoscope=$46
Iterations_Symmetrizoscope=$47
Angle_Symmetrizoscope=$48
Symmetry_Sides=$49
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Rayon_Cercle_Final={round({{$Dimension_Finale/2}-1})}
Rayon_De_Couleur={round({1+{$Dimension_Finale*{2^0.5}}})}
Angle_Rayon_De_Couleur={360/$Nb_De_Rayon_De_Couleur}
Angle_Rayon_De_Couleur_En_Cours_A=0
Angle_Rayon_De_Couleur_En_Cours_Fin_A=0
Angle_Rayon_De_Couleur_En_Cours_B=0
Angle_Rayon_De_Couleur_En_Cours_Fin_B=0
R_en_cours=0
V_en_cours=0
B_en_cours=0
A_en_cours=0
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-endif
# 2 nouvelles images contours
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
# 2 nouvelles images Rayons
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-repeat $Nb_De_Rayon_De_Couleur
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-if {{($Nb_boucles%{$Rendu+2})}==0}
R_en_cours=$R_a
V_en_cours=$V_a
B_en_cours=$B_a
A_en_cours=$A_a
-endif
-if {{($Nb_boucles%{$Rendu+2})}==1}
R_en_cours=$R_b
V_en_cours=$V_b
B_en_cours=$B_b
A_en_cours=$A_b
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==2}&&{$Rendu>0}}
R_en_cours=$R_c
V_en_cours=$V_c
B_en_cours=$B_c
A_en_cours=$A_c
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==3}&&{$Rendu>1}}
R_en_cours=$R_d
V_en_cours=$V_d
B_en_cours=$B_d
A_en_cours=$A_d
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==4}&&{$Rendu>2}}
R_en_cours=$R_e
V_en_cours=$V_e
B_en_cours=$B_e
A_en_cours=$A_e
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==5}&&{$Rendu>3}}
R_en_cours=$R_f
V_en_cours=$V_f
B_en_cours=$B_f
A_en_cours=$A_f
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==6}&&{$Rendu>4}}
R_en_cours=$R_g
V_en_cours=$V_g
B_en_cours=$B_g
A_en_cours=$A_g
-endif
Angle_Rayon_De_Couleur_En_Cours_A={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_A}
Angle_Rayon_De_Couleur_En_Cours_Fin_A={{{$Nb_boucles+1}*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_A}
Angle_Rayon_De_Couleur_En_Cours_B={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_B}
Angle_Rayon_De_Couleur_En_Cours_Fin_B={{{$Nb_boucles+1}*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_B}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_A})}}},1,$R_en_cours,$V_en_cours,$B_en_cours,$A_en_cours
-polygon[-2] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_B})}}},1,$R_en_cours,$V_en_cours,$B_en_cours,$A_en_cours
-if {$Affichage_Contours==1}
-line[-3] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-line[-4] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_boucles={$Nb_boucles+1}
-done
-dilate_circ[-3,-4] 2
-twirl[-1,-3] $Amplitude_Twirl,50%,50%,0
-twirl[-2,-4] -$Amplitude_Twirl,50%,50%,0
-blend[-3,-4] alpha,1,0
# contour cercle
-if {$Affichage_Contours==1}
-ellipse[-3] 50%,50%,$Rayon_Cercle_Final,$Rayon_Cercle_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-3] 50%,50%,{$Rayon_Cercle_Final-1},{$Rayon_Cercle_Final-1},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-3] 50%,50%,{$Rayon_Cercle_Final-2},{$Rayon_Cercle_Final-2},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilate_Contours>1} -dilate_circ[-3] $Dilate_Contours -endif
-if {$Flou_Contours>0} -blur[-3] $Flou_Contours,0 -endif
-if {$Sharpen_Contours>0} -sharpen[-3] $Sharpen_Contours -endif
-if {$Filtre_Symmetrizoscope==1}
-fx_symmetrizoscope[-1,-2,-3] $Iterations_Symmetrizoscope,$Angle_Symmetrizoscope,0,$Symmetry_Sides
-endif
# creation masque temporaire rond
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 255,255,255,255
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,0
# mlanges
-blend[-4,-1] alpha,1,0
-replace_color[-3] 100%,0,255,255,255,255,0,0,0,0
# creation masque temporaire rond
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
# mlanges
-reverse[-1,-3]
-blend[-3,-1] add,1,0
# creation masque temporaire rond
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
# mlanges
-reverse[-1,-2]
-blend[-2,-1] add,1,0
-if {$Melanges_Rayons==0}
-blend[-1,-2] add,1,0
-elif {$Melanges_Rayons==1}
-blend[-1,-2] and,1,0
-elif {$Melanges_Rayons==2}
-blend[-1,-2] average,1,0
-elif {$Melanges_Rayons==3}
-blend[-1,-2] darken,1,0
-elif {$Melanges_Rayons==4}
-blend[-1,-2] difference,1,0
-elif {$Melanges_Rayons==5}
-blend[-1,-2] edges,1,0
-elif {$Melanges_Rayons==6}
-blend[-1,-2] grainextract,1,0
-elif {$Melanges_Rayons==7}
-blend[-1,-2] grainmerge,1,0
-elif {$Melanges_Rayons==8}
-blend[-1,-2] multiply,1,0
-elif {$Melanges_Rayons==9}
-blend[-1,-2] negation,1,0
-elif {$Melanges_Rayons==10}
-blend[-1,-2] or,1,0
-elif {$Melanges_Rayons==11}
-blend[-1,-2] screen,1,0
-elif {$Melanges_Rayons==12}
-blend[-1,-2] softburn,1,0
-elif {$Melanges_Rayons==13}
-blend[-1,-2] softdodge,1,0
-elif {$Melanges_Rayons==14}
-blend[-1,-2] subtract,1,0
-elif {$Melanges_Rayons==15}
-blend[-1,-2] xor,1,0
-elif {$Melanges_Rayons==16}
-endif
-c[-1,-2] 0,255
-if {$Supprimer_Calque_Origine==1}
-if {$Melanges_Rayons==16}
-reverse[-3,-2,-1]
-else
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-endif
-else
-if {$Melanges_Rayons==16}
-reverse[-3,-2,-1,0]
-else
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-reverse[0,-1]
-endif
-endif
#@gui _
#@gui <i>Repair</i>
#@gui Samj CorLine : samj_CorLine, samj_CorLine_preview
#@gui : note = note("<i>samj_CorLine</i> pour vieilles photos d\303\251color\303\251es scann\303\251es \r\n<i>samj_CorLine</i> for old faded scanned photos")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Couleurs</b></span>")
#@gui : Balance = int(0,-64,64)
#@gui : Chroma = int(10,0,50)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Nettet\303\251</b></span>")
#@gui : Nettet\303\251 A = float(0.5,0,1.5)
#@gui : Nettet\303\251 B = float(0,0,1.5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>R\303\251paration</b></span>")
#@gui : Type = choice(0,"Anisotropic","Diffusion")
#@gui : Amplitude = int(50,0,100)
#@gui : Repetition(s) = int(1,1,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Preview</b></span>")
#@gui : Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/05/10</i>.</small>")
samj_CorLine:
Balance_Couleurs=$1
Chroma_Couleurs=$2
Nettete_A=$3
Nettete_B=$4
Type_Reparation=$5
Amplitude_Reparation=$6
Repetition_Reparation=$7
--Je_passe_l_hiver_en_Floride[0]
-to_rgb[-1]
-fx_balance_gamma[-1] {127+$Balance_Couleurs},{127+$Balance_Couleurs},{127+$Balance_Couleurs},1
-fx_boost_chroma[-1] {$Chroma_Couleurs/100},1
-fx_unsharp_octave[-1] 1,5,$Nettete_A,0,2,0,24
-if {$Type_Reparation==0}
-repeat $Repetition_Reparation
-fx_smooth_anisotropic[-1] $Amplitude_Reparation,0.7,0.3,0.6,1.1,0.8,30,2,0,1,1,2
-done
-elif {$Type_Reparation==1}
-repeat $Repetition_Reparation
-fx_smooth_diffusion[-1] 0.7,0.3,0.6,{0.5+{$Amplitude_Reparation/100}},15,8,0,0,24
-done
-endif
-if {$Nettete_B>0} -fx_unsharp_octave[-1] 1,5,$Nettete_B,0,2,0,24 -endif
-reverse[-1,-2]
samj_CorLine_preview :
-gui_split_preview "-samj_CorLine $*",$-1
samj_rien_sequences :
-Je_passe_l_hiver_en_Floride[-1]
samj_rien_various :
-Je_passe_l_hiver_en_Floride[-1]
samj_RGB_to_LCH_or_Lab:
-v -
Type_de_demande=$1
Ra=$2
Ga=$3
Ba=$4
Matrices_RGB=$5
XYZ_Tristimulus=$6
Choix=$7
# http://www.easyrgb.com/index.php?X=MATH
# Conversions RGB > XYZ
nt_Ra={$Ra/255}
nt_Ga={$Ga/255}
nt_Ba={$Ba/255}
-if {$nt_Ra>0.04045}
nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
# http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
Xa={$nt_Ra*1.0000000+$nt_Ga*0.0000000+$nt_Ba*0.0000000}
Ya={$nt_Ra*0.0000000+$nt_Ga*1.0000000+$nt_Ba*0.0000000}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0000000+$nt_Ba*1.0000000}
-if {$Matrices_RGB==0}
Xa={$nt_Ra*0.5767309+$nt_Ga*0.1855540+$nt_Ba*0.1881852}
Ya={$nt_Ra*0.2973769+$nt_Ga*0.6273491+$nt_Ba*0.0752741}
Za={$nt_Ra*0.0270343+$nt_Ga*0.0706872+$nt_Ba*0.9911085}
-elif {$Matrices_RGB==1}
Xa={$nt_Ra*0.4497288+$nt_Ga*0.3162486+$nt_Ba*0.1844926}
Ya={$nt_Ra*0.2446525+$nt_Ga*0.6720283+$nt_Ba*0.0833192}
Za={$nt_Ra*0.0251848+$nt_Ga*0.1411824+$nt_Ba*0.9224628}
-elif {$Matrices_RGB==2}
Xa={$nt_Ra*0.6326696+$nt_Ga*0.2045558+$nt_Ba*0.1269946}
Ya={$nt_Ra*0.2284569+$nt_Ga*0.7373523+$nt_Ba*0.0341908}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0095142+$nt_Ba*0.8156958}
-elif {$Matrices_RGB==3}
Xa={$nt_Ra*0.6712537+$nt_Ga*0.1745834+$nt_Ba*0.1183829}
Ya={$nt_Ra*0.3032726+$nt_Ga*0.6637861+$nt_Ba*0.0329413}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0407010+$nt_Ba*0.7845090}
-elif {$Matrices_RGB==4}
Xa={$nt_Ra*0.4674162+$nt_Ga*0.2944512+$nt_Ba*0.1886026}
Ya={$nt_Ra*0.2410115+$nt_Ga*0.6835475+$nt_Ba*0.0754410}
Za={$nt_Ra*0.0219101+$nt_Ga*0.0736128+$nt_Ba*0.9933071}
-elif {$Matrices_RGB==5}
Xa={$nt_Ra*0.4887180+$nt_Ga*0.3106803+$nt_Ba*0.2006017}
Ya={$nt_Ra*0.1762044+$nt_Ga*0.8129847+$nt_Ba*0.0108109}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0102048+$nt_Ba*0.9897952}
-elif {$Matrices_RGB==6}
Xa={$nt_Ra*0.5093439+$nt_Ga*0.3209071+$nt_Ba*0.1339691}
Ya={$nt_Ra*0.2748840+$nt_Ga*0.6581315+$nt_Ba*0.0669845}
Za={$nt_Ra*0.0242545+$nt_Ga*0.1087821+$nt_Ba*0.6921735}
-elif {$Matrices_RGB==7}
Xa={$nt_Ra*0.6457711+$nt_Ga*0.1933511+$nt_Ba*0.1250978}
Ya={$nt_Ra*0.2783496+$nt_Ga*0.6879702+$nt_Ba*0.0336802}
Za={$nt_Ra*0.0037113+$nt_Ga*0.0179861+$nt_Ba*0.8035125}
-elif {$Matrices_RGB==8}
Xa={$nt_Ra*0.6502043+$nt_Ga*0.1780774+$nt_Ba*0.1359384}
Ya={$nt_Ra*0.3202499+$nt_Ga*0.6020711+$nt_Ba*0.0776791}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0678390+$nt_Ba*0.7573710}
-elif {$Matrices_RGB==9}
Xa={$nt_Ra*0.5938914+$nt_Ga*0.2729801+$nt_Ba*0.0973485}
Ya={$nt_Ra*0.2606286+$nt_Ga*0.7349465+$nt_Ba*0.0044249}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0419969+$nt_Ba*0.7832131}
-elif {$Matrices_RGB==10}
Xa={$nt_Ra*0.6068909+$nt_Ga*0.1735011+$nt_Ba*0.2003480}
Ya={$nt_Ra*0.2989164+$nt_Ga*0.5865990+$nt_Ba*0.1144845}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0660957+$nt_Ba*1.1162243}
-elif {$Matrices_RGB==11}
Xa={$nt_Ra*0.4306190+$nt_Ga*0.3415419+$nt_Ba*0.1783091}
Ya={$nt_Ra*0.2220379+$nt_Ga*0.7066384+$nt_Ba*0.0713236}
Za={$nt_Ra*0.0201853+$nt_Ga*0.1295504+$nt_Ba*0.9390944}
-elif {$Matrices_RGB==12}
Xa={$nt_Ra*0.7976749+$nt_Ga*0.1351917+$nt_Ba*0.0313534}
Ya={$nt_Ra*0.2880402+$nt_Ga*0.7118741+$nt_Ba*0.0000857}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0000000+$nt_Ba*0.8252100}
-elif {$Matrices_RGB==13}
Xa={$nt_Ra*0.3935891+$nt_Ga*0.3652497+$nt_Ba*0.1916313}
Ya={$nt_Ra*0.2124132+$nt_Ga*0.7010437+$nt_Ba*0.0865432}
Za={$nt_Ra*0.0187423+$nt_Ga*0.1119313+$nt_Ba*0.9581563}
-elif {$Matrices_RGB==14}
Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
-elif {$Matrices_RGB==15}
Xa={$nt_Ra*0.7161046+$nt_Ga*0.1009296+$nt_Ba*0.1471858}
Ya={$nt_Ra*0.2581874+$nt_Ga*0.7249378+$nt_Ba*0.0168748}
Za={$nt_Ra*0.0000000+$nt_Ga*0.0517813+$nt_Ba*0.7734287}
-endif
Xca=$Xa
Yca=$Ya
Zca=$Za
# http://www.easyrgb.com/index.php?X=MATH&H=15#text15
ref_Xa=100.000
ref_Ya=100.000
ref_Za=100.000
-if {$XYZ_Tristimulus==0}
ref_Xa=109.850
ref_Ya=100.000
ref_Za=35.585
-elif {$XYZ_Tristimulus==1}
ref_Xa=98.074
ref_Ya=100.000
ref_Za=118.232
-elif {$XYZ_Tristimulus==2}
ref_Xa=96.422
ref_Ya=100.000
ref_Za=82.521
-elif {$XYZ_Tristimulus==3}
ref_Xa=95.682
ref_Ya=100.000
ref_Za=92.149
-elif {$XYZ_Tristimulus==4}
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
-elif {$XYZ_Tristimulus==5}
ref_Xa=94.972
ref_Ya=100.000
ref_Za=122.638
-elif {$XYZ_Tristimulus==6}
ref_Xa=99.187
ref_Ya=100.000
ref_Za=67.395
-elif {$XYZ_Tristimulus==7}
ref_Xa=95.044
ref_Ya=100.000
ref_Za=108.755
-elif {$XYZ_Tristimulus==8}
ref_Xa=100.966
ref_Ya=100.000
ref_Za=64.370
-elif {$XYZ_Tristimulus==10}
ref_Xa=111.144
ref_Ya=100.000
ref_Za=35.200
-elif {$XYZ_Tristimulus==11}
ref_Xa=97.285
ref_Ya=100.000
ref_Za=116.145
-elif {$XYZ_Tristimulus==12}
ref_Xa=96.720
ref_Ya=100.000
ref_Za=81.427
-elif {$XYZ_Tristimulus==13}
ref_Xa=95.799
ref_Ya=100.000
ref_Za=90.926
-elif {$XYZ_Tristimulus==14}
ref_Xa=94.811
ref_Ya=100.000
ref_Za=107.304
-elif {$XYZ_Tristimulus==15}
ref_Xa=94.416
ref_Ya=100.000
ref_Za=120.641
-elif {$XYZ_Tristimulus==16}
ref_Xa=103.280
ref_Ya=100.000
ref_Za=69.026
-elif {$XYZ_Tristimulus==17}
ref_Xa=95.792
ref_Ya=100.000
ref_Za=107.687
-elif {$XYZ_Tristimulus==18}
ref_Xa=103.866
ref_Ya=100.000
ref_Za=65.627
-endif
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={($nt_Xa)^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={($nt_Ya)^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={($nt_Za)^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_La={{116*$nt_Ya}-16}
CIE_aa={500*{$nt_Xa-$nt_Ya}}
CIE_ba={200*{$nt_Ya-$nt_Za}}
-if {$Choix==1}
-if {$Type_de_demande==0} -u {$CIE_La}","{$CIE_aa}","{$CIE_ba}
-elif {$Type_de_demande==1} -u {$CIE_La}
-elif {$Type_de_demande==2} -u {$CIE_aa}
-elif {$Type_de_demande==3} -u {$CIE_ba}
-endif
-elif {$Choix==0}
var_H={atan2($CIE_ba,$CIE_aa)}
-if {$var_H>0}
var_H={{$var_H/pi}*180}
-else
var_H={360-{{abs($var_H)/pi}*180}}
-endif
CIE_L=$CIE_La
CIE_C={({{$CIE_aa*$CIE_aa}+{$CIE_ba*$CIE_ba}})^0.5}
CIE_H=$var_H
-if {$Type_de_demande==0} -u {$CIE_L}","{$CIE_C}","{$CIE_H}
-elif {$Type_de_demande==1} -u {$CIE_L}
-elif {$Type_de_demande==2} -u {$CIE_C}
-elif {$Type_de_demande==3} -u {$CIE_H}
-endif
-endif
-v +
samj_LCH_or_Lab_to_RGB:
-v -
Type_de_demande=$1
Matrices_RGB=$5
XYZ_Tristimulus=$6
Choix=$7
-if {$Choix==1}
CIE_Lca=$2
CIE_aca=$3
CIE_bca=$4
-elif {$Choix==0}
CIE_Lca=$2
CIE_aca={{cos({pi/180*$4})}*$3}
CIE_bca={{sin({pi/180*$4})}*$3}
-endif
# Conversions Lab > XYZ
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{($nt_Yca)^3}>0.008856}
nt_Yca={($nt_Yca)^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{($nt_Xca)^3}>0.008856}
nt_Xca={($nt_Xca)^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{($nt_Zca)^3}>0.008856}
nt_Zca={($nt_Zca)^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
# http://www.easyrgb.com/index.php?X=MATH&H=15#text15
ref_Xca=100.000
ref_Yca=100.000
ref_Zca=100.000
-if {$XYZ_Tristimulus==0}
ref_Xca=109.850
ref_Yca=100.000
ref_Zca=35.585
-elif {$XYZ_Tristimulus==1}
ref_Xca=98.074
ref_Yca=100.000
ref_Zca=118.232
-elif {$XYZ_Tristimulus==2}
ref_Xca=96.422
ref_Yca=100.000
ref_Zca=82.521
-elif {$XYZ_Tristimulus==3}
ref_Xca=95.682
ref_Yca=100.000
ref_Zca=92.149
-elif {$XYZ_Tristimulus==4}
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
-elif {$XYZ_Tristimulus==5}
ref_Xca=94.972
ref_Yca=100.000
ref_Zca=122.638
-elif {$XYZ_Tristimulus==6}
ref_Xca=99.187
ref_Yca=100.000
ref_Zca=67.395
-elif {$XYZ_Tristimulus==7}
ref_Xca=95.044
ref_Yca=100.000
ref_Zca=108.755
-elif {$XYZ_Tristimulus==8}
ref_Xca=100.966
ref_Yca=100.000
ref_Zca=64.370
-elif {$XYZ_Tristimulus==10}
ref_Xca=111.144
ref_Yca=100.000
ref_Zca=35.200
-elif {$XYZ_Tristimulus==11}
ref_Xca=97.285
ref_Yca=100.000
ref_Zca=116.145
-elif {$XYZ_Tristimulus==12}
ref_Xca=96.720
ref_Yca=100.000
ref_Zca=81.427
-elif {$XYZ_Tristimulus==13}
ref_Xca=95.799
ref_Yca=100.000
ref_Zca=90.926
-elif {$XYZ_Tristimulus==14}
ref_Xca=94.811
ref_Yca=100.000
ref_Zca=107.304
-elif {$XYZ_Tristimulus==15}
ref_Xca=94.416
ref_Yca=100.000
ref_Zca=120.641
-elif {$XYZ_Tristimulus==16}
ref_Xca=103.280
ref_Yca=100.000
ref_Zca=69.026
-elif {$XYZ_Tristimulus==17}
ref_Xca=95.792
ref_Yca=100.000
ref_Zca=107.687
-elif {$XYZ_Tristimulus==18}
ref_Xca=103.866
ref_Yca=100.000
ref_Zca=65.627
-endif
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
# Conversions XYZ > Lab
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
# http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
nt_R={$nt_X*1.0000000+$nt_Y*0.0000000+$nt_Z*0.0000000}
nt_G={$nt_X*0.0000000+$nt_Y*1.0000000+$nt_Z*0.0000000}
nt_B={$nt_X*0.0000000+$nt_Y*0.0000000+$nt_Z*1.0000000}
-if {$Matrices_RGB==0}
nt_R={$nt_X*2.0413690+$nt_Y*-0.5649464+$nt_Z*-0.3446944}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0134474+$nt_Y*-0.1183897+$nt_Z*1.0154096}
-elif {$Matrices_RGB==1}
nt_R={$nt_X*2.9515373+$nt_Y*-1.2894116+$nt_Z*-0.4738445}
nt_G={$nt_X*-1.0851093+$nt_Y*1.9908566+$nt_Z*0.0372026}
nt_B={$nt_X*0.0854934+$nt_Y*-0.2694964+$nt_Z*1.0912975}
-elif {$Matrices_RGB==2}
nt_R={$nt_X*1.7552599+$nt_Y*-0.4836786+$nt_Z*-0.2530000}
nt_G={$nt_X*-0.5441336+$nt_Y*1.5068789+$nt_Z*0.0215528}
nt_B={$nt_X*0.0063467+$nt_Y*-0.0175761+$nt_Z*1.2256959}
-elif {$Matrices_RGB==3}
nt_R={$nt_X*1.6832270+$nt_Y*-0.4282363+$nt_Z*-0.2360185}
nt_G={$nt_X*-0.7710229+$nt_Y*1.7065571+$nt_Z*0.0446900}
nt_B={$nt_X*0.0400013+$nt_Y*-0.0885376+$nt_Z*1.2723640}
-elif {$Matrices_RGB==4}
nt_R={$nt_X*2.7454669+$nt_Y*-1.1358136+$nt_Z*-0.4350269}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0112723+$nt_Y*-0.1139754+$nt_Z*1.0132541}
-elif {$Matrices_RGB==5}
nt_R={$nt_X*2.3706743+$nt_Y*-0.9000405+$nt_Z*-0.4706338}
nt_G={$nt_X*-0.5138850+$nt_Y*1.4253036+$nt_Z*0.0885814}
nt_B={$nt_X*0.0052982+$nt_Y*-0.0146949+$nt_Z*1.0093968}
-elif {$Matrices_RGB==6}
nt_R={$nt_X*2.6422874+$nt_Y*-1.2234270+$nt_Z*-0.3930143}
nt_G={$nt_X*-1.1119763+$nt_Y*2.0590183+$nt_Z*0.0159614}
nt_B={$nt_X*0.0821699+$nt_Y*-0.2807254+$nt_Z*1.4559877}
-elif {$Matrices_RGB==7}
nt_R={$nt_X*1.7603902+$nt_Y*-0.4881198+$nt_Z*-0.2536126}
nt_G={$nt_X*-0.7126288+$nt_Y*1.6527432+$nt_Z*0.0416715}
nt_B={$nt_X*0.0078207+$nt_Y*-0.0347411+$nt_Z*1.2447743}
-elif {$Matrices_RGB==8}
nt_R={$nt_X*1.7827618+$nt_Y*-0.4969847+$nt_Z*-0.2690101}
nt_G={$nt_X*-0.9593623+$nt_Y*1.9477962+$nt_Z*-0.0275807}
nt_B={$nt_X*0.0859317+$nt_Y*-0.1744674+$nt_Z*1.3228273}
-elif {$Matrices_RGB==9}
nt_R={$nt_X*2.0043819+$nt_Y*-0.7304844+$nt_Z*-0.2450052}
nt_G={$nt_X*-0.7110285+$nt_Y*1.6202126+$nt_Z*0.0792227}
nt_B={$nt_X*0.0381263+$nt_Y*-0.0868780+$nt_Z*1.2725438}
-elif {$Matrices_RGB==10}
nt_R={$nt_X*1.9099961+$nt_Y*-0.5324542+$nt_Z*-0.2882091}
nt_G={$nt_X*-0.9846663+$nt_Y*1.9991710+$nt_Z*-0.0283082}
nt_B={$nt_X*0.0583056+$nt_Y*-0.1183781+$nt_Z*0.8975535}
-elif {$Matrices_RGB==11}
nt_R={$nt_X*3.0628971+$nt_Y*-1.3931791+$nt_Z*-0.4757517}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0678775+$nt_Y*-0.2288548+$nt_Z*1.0693490}
-elif {$Matrices_RGB==12}
nt_R={$nt_X*1.3459433+$nt_Y*-0.2556075+$nt_Z*-0.0511118}
nt_G={$nt_X*-0.5445989+$nt_Y*1.5081673+$nt_Z*0.0205351}
nt_B={$nt_X*0.0000000+$nt_Y*0.0000000+$nt_Z*1.2118128}
-elif {$Matrices_RGB==13}
nt_R={$nt_X*3.5053960+$nt_Y*-1.7394894+$nt_Z*-0.5439640}
nt_G={$nt_X*-1.0690722+$nt_Y*1.9778245+$nt_Z*0.0351722}
nt_B={$nt_X*0.0563200+$nt_Y*-0.1970226+$nt_Z*1.0502026}
-elif {$Matrices_RGB==14}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-elif {$Matrices_RGB==15}
nt_R={$nt_X*1.4628067+$nt_Y*-0.1840623+$nt_Z*-0.2743606}
nt_G={$nt_X*-0.5217933+$nt_Y*1.4472381+$nt_Z*0.0677227}
nt_B={$nt_X*0.0349342+$nt_Y*-0.0968930+$nt_Z*1.2884099}
-endif
-if {$nt_R>0.0031308}
nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Type_de_demande==0} -u {$Rconv}","{$Gconv}","{$Bconv}
-elif {$Type_de_demande==1} -u {$Rconv}
-elif {$Type_de_demande==2} -u {$Gconv}
-elif {$Type_de_demande==3} -u {$Bconv}
-endif
-v +
ancien_Tom_Keil_Colortemp :
-repeat $! -l[$>] -if {$2==1} --luminance[-1] -to_rgb[-2]
-s[-2] c  avb={-2,127.5-ia} avg={-3,127.5-ia} avr={-4,127.5-ia}
-+[-4] $avr -+[-3] $avg -+[-2] $avb -a[-4,-3,-2] c -rv -compose_luminance -endif
-fx_mix_lab 1,0,0,1,{if({$1>=0},{$1/4},{$1*0.75})},0,1,$1,0,0,2,0 -endl -done
ancien_gimp_morpho :
-apply_channels "-__ancien_gimp_morpho ${^0}",$5,$6
__ancien_gimp_morpho :
-if {$4==1} suf="_oct" -elif {$4==0} suf="" -else suf="_circ" -endif
-if {$1==0} -erode$suf $2
-elif {$1==1} -dilate$suf $2
-elif {$1==2} -erode$suf $2 -dilate$suf $2
-elif {$1==3} -dilate$suf $2 -erode$suf $2
-elif {$1==4} -repeat $! --erode$suf $2 --[-2,-1] -mv[-1] 0 -done
-elif {$1==5} -repeat $! --dilate$suf $2 -rv[-2,-1] --[-2,-1] -mv[-1] 0 -done
-elif {$1==6} -repeat $! --erode$suf $2 -dilate$suf[-1] $2 --[-2,-1] -mv[-1] 0 -done
-else -repeat $! --dilate$suf $2 -erode$suf[-1] $2 -rv[-2,-1] --[-2,-1] -mv[-1] 0 -done
-endif
-if $3 -repeat $! -l[$>] -split_opacity -negative[0] -a c -endl -done -endif
at_ancien : -skip ${1=0},${2=0},${3=0}
-v - --z. ${1-3},${1-3} -u {^} -rm. -v +
gimp_blend_1651 :
mode=${-arg\ 1+$1,add,alpha,and,average,blue,burn,darken,difference,\
divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
shapeaverage,shapeaverage0,softburn,softdodge,softlight,screen,stamp,subtract,value,\
vividlight,xor}
-if {$2==0} -repeat {int($!/2)} -l[$>,{$>+1}] -rv -blend $mode,$3,$4 -endl -done
-elif {$2==1" && "$!>1} -blend[^0] [0],$mode,$3,1 -rm[0]
-elif {$2==2" && "$!>1} -blend[^-1] [-1],$mode,$3,0 -rm[-1]
-endif
trait_epais_samj :
## Variables
-verbose -
-if {{$3-$1}==0} X1={$1-{$5/2}} Y1=$2 X2={$3-{$5/2}} Y2=$4 X3={$3+{$5/2}} Y3=$4 X4={$1+{$5/2}} Y4=$2
-else
-if {{$4-$2}==0} X1=$1 Y1={$2+{$5/2}} X2=$3 Y2={$4+{$5/2}} X3=$3 Y3={$4-{$5/2}} X4=$1 Y4={$2-{$5/2}}
-else angle_triangle={{{pi}/2}-{atan({{$4-$2}/{$3-$1}})}} X_triangle={{$5/2}*{cos($angle_triangle)}} Y_triangle={{$5/2}*{sin($angle_triangle)}}
X1={$1-$X_triangle} Y1={$2+$Y_triangle} X2={$3-$X_triangle} Y2={$4+$Y_triangle} X3={$3+$X_triangle} Y3={$4-$Y_triangle} X4={$1+$X_triangle} Y4={$2-$Y_triangle}
-endif
-endif
-polygon[-1] 4,$X1,$Y1,$X2,$Y2,$X3,$Y3,$X4,$Y4,1,$7,$8,$9,$10
-if {$6==1} -circle[-1] $1,$2,{$5/2},1,$7,$8,$9,$10 -circle[-1] $3,$4,{$5/2},1,$7,$8,$9,$10 -endif
-verbose +
samj_sierpinski_absolu : -check ${1=7}>=0 -skip ${2=0},${3=0},${4=10},${5=100},${6=150},${7=20},${8=255},${9=255},${10=0},${11=255}
-e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
-v - -_samj_sierpinski_absolu ${2-11},$1  -v +
_samj_sierpinski_absolu :
-if {$11<=0} -polygon 3,$1,$2,$3,$4,$5,$6,1,$7,$8,$9,$10 -return -endif
-_samj_sierpinski_absolu $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},$7,$8,$9,$10,{$11-1}
-_samj_sierpinski_absolu {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},$7,$8,$9,$10,{$11-1}
-_samj_sierpinski_absolu {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},$7,$8,$9,$10,{$11-1}
samj_snowflake_absolu :
-v -
-to_rgba
-polygon 3,$2,$3,$4,$5,$6,$7,${8--1},255
-_samj_snowflake_absolu $1,$2,$3,$6,$7,${8--1}
-_samj_snowflake_absolu $1,$6,$7,$4,$5,${8--1}
-_samj_snowflake_absolu $1,$4,$5,$2,$3,${8--1}
-v +
_samj_snowflake_absolu :
x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
c={cos(-pi/3)} s={sin(-pi/3)}
x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
-polygon 3,$x0,$y0,$x1,$y1,$x2,$y2,${6--1},255
-if $1
-_samj_snowflake_absolu {$1-1},$2,$3,$x0,$y0,${6--1}
-_samj_snowflake_absolu {$1-1},$x0,$y0,$x2,$y2,${6--1}
-_samj_snowflake_absolu {$1-1},$x2,$y2,$x1,$y1,${6--1}
-_samj_snowflake_absolu {$1-1},$x1,$y1,$4,$5,${6--1}
-endif
samj_snowflake_contours_absolu :
-v -
-to_rgba
-polygon 3,$2,$3,$4,$5,$6,$7,$8,0xFFFFFFFF,$9,$10,$11,255
-_samj_snowflake_contours_absolu $1,$2,$3,$6,$7,${8--1}
-_samj_snowflake_contours_absolu $1,$6,$7,$4,$5,${8--1}
-_samj_snowflake_contours_absolu $1,$4,$5,$2,$3,${8--1}
-v +
_samj_snowflake_contours_absolu :
x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
c={cos(-pi/3)} s={sin(-pi/3)}
x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
-polygon 3,$x0,$y0,$x1,$y1,$x2,$y2,$6,0xFFFFFFFF,${7--1},255
-if $1
-_samj_snowflake_contours_absolu {$1-1},$2,$3,$x0,$y0,${6--1}
-_samj_snowflake_contours_absolu {$1-1},$x0,$y0,$x2,$y2,${6--1}
-_samj_snowflake_contours_absolu {$1-1},$x2,$y2,$x1,$y1,${6--1}
-_samj_snowflake_contours_absolu {$1-1},$x1,$y1,$4,$5,${6--1}
-endif
twirl_ancien_euclidean2polar_ancien_polar2euclidean : -skip ${1=1},${2=50%},${3=50%},${4=1}
-e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center point at ($2%,$3%)."
-v - -euclidean2polar_ancien $2,$3,1,$4 -repeat $!
[$>],[$>],1,1,$1*x -channels[-1] -1,0 -warp[$>] [-1],1,1,2 -rm[-1]
-done -polar2euclidean_ancien $2,$3,1,1 -v +
euclidean2polar_ancien : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
-e[^-1] "Apply euclidean to polar transform on image$?."
-v - -repeat $! -l[$>]
({w},{h}) ($1,$2) -*[-2,-1] ({"sqrt(max("{@0}","{-2,w}"-"{@0}")^2 + max("{@1}","{-2,h}"-"{@1}")^2)"})
-a[-2,-1] x
[-2],[-2],1,1,{@2}"*(x/w)^$3*cos(y*2*pi/h)" -+[-1] {-2,@0}
[-1],[-1],1,1,{-2,@2}"*(x/w)^$3*sin(y*2*pi/h)" -+[-1] {-3,@1}
-rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
-endl -done -v +
polar2euclidean_ancien : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
-e[^-1] "Apply polar to euclidean transform on image$?."
-v - -repeat $! -l[$>]
({w},{h}) ($1,$2) -*[-2,-1] ({"sqrt(max("{@0}","{-2,w}"-"{@0}")^2 + max("{@1}","{-2,h}"-"{@1}")^2)"})
-a[-2,-1] x
[-2],[-2],1,1,"w*(sqrt((x-"{@0}")^2 + (y-"{@1}")^2)/"{@2}")^(1/$3)"
[-1],[-1],1,1,"(atan2(y-"{-2,@1}",x-"{-2,@0}")*h/(2*pi)+h)%h"
-rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
-endl -done -v +
#@gui Samj CorLine B : samj_CorLine_B, samj_CorLine_B_preview
#@gui : note = note("<i>samj_CorLine_B</i> pour vieilles photos d\303\251color\303\251es scann\303\251es \r\n<i>samj_CorLine_B</i> for old faded scanned photos")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Couleurs</b></span>")
#@gui : Balance = int(0,-64,64)
#@gui : Gamma = float(1,0.8,2.2)
#@gui : Chroma = int(10,0,50)
#@gui : Cyan = int(0,-127,128)
#@gui : Magenta = int(0,-127,128)
#@gui : Jaune = int(0,-127,128)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Nettet\303\251</b></span>")
#@gui : Nettet\303\251 A = float(0.5,0,1.5)
#@gui : Nettet\303\251 B = float(0,0,1.5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>R\303\251paration</b></span>")
#@gui : Type = choice(0,"Anisotropic","Diffusion")
#@gui : Amplitude = int(50,0,100)
#@gui : Repetition(s) = int(1,1,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Preview</b></span>")
#@gui : Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/05/11</i>.</small>")
samj_CorLine_B:
Balance_Couleurs=$1
Valeur_Gamma=$2
Chroma_Couleurs=$3
Cyan=$4
Magenta=$5
Jaune=$6
Nettete_A=$7
Nettete_B=$8
Type_Reparation=$9
Amplitude_Reparation=$10
Repetition_Reparation=$11
--Je_passe_l_hiver_en_Floride[0]
-to_rgb[-1]
-fx_balance_gamma[-1] {127+$Balance_Couleurs},{127+$Balance_Couleurs},{127+$Balance_Couleurs},1
-fx_boost_chroma[-1] {$Chroma_Couleurs/100},1
-fx_unsharp_octave[-1] 1,5,$Nettete_A,0,2,0,24
-apply_gamma[-1] $Valeur_Gamma
-if {$Type_Reparation==0}
-repeat $Repetition_Reparation
-fx_smooth_anisotropic[-1] $Amplitude_Reparation,0.7,0.3,0.6,1.1,0.8,30,2,0,1,1,2
-done
-elif {$Type_Reparation==1}
-repeat $Repetition_Reparation
-fx_smooth_diffusion[-1] 0.7,0.3,0.6,{0.5+{$Amplitude_Reparation/100}},15,8,0,0,24
-done
-endif
-if {$Nettete_B>0} -fx_unsharp_octave[-1] 1,5,$Nettete_B,0,2,0,24 -endif
-if {$Cyan!=0}
Cyan={127+$Cyan}
-apply_channels[-1] "-apply_curve 1,0,0,128,"$Cyan",255,255",cmy_c,0
-endif
-if {$Magenta!=0}
Magenta={127+$Magenta}
-apply_channels[-1] "-apply_curve 1,0,0,128,"$Magenta",255,255",cmy_m,0
-endif
-if {$Jaune!=0}
Jaune={127+$Jaune}
-apply_channels[-1] "-apply_curve 1,0,0,128,"$Jaune",255,255",cmy_y,0
-endif
-reverse[-1,-2]
samj_CorLine_B_preview :
-gui_split_preview "-samj_CorLine_B $*",$-1
#@gui _
#@gui <i>Various</i>
#@gui CeKoaSa 001 : samj_CeKoaSa_001, samj_CeKoaSa_001_preview(0)
#@gui : sep = separator()
#@gui : Douceur / Smoothness = float(0,0,10)
#@gui : Seuil / Threshold = float(15,0,50)
#@gui : D\303\251formation = float(3,0,6)
#@gui : Renforcer Couleurs / Boost = bool(1)
#@gui : Taille / Size = int(3,1,10)
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/05/31</i>.</small>")
samj_CeKoaSa_001 :
-repeat $! -l[$>]
Smoothness_thin_edges=$1
Threshold_thin_edges=$2
Amplitude_ripple=$3
Boost=$4
Size_morpho=$5
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-fx_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
--Je_passe_l_hiver_en_Floride[-1]
-ripple[-1] $Amplitude_ripple,20,2,0
-blend[-1,-2] average,1,1
-ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
-fx_edges[-2] 0,15,0,0
-blend[-1,-2] average,1,1
-if {$Boost==1}
-fx_balance_gamma[-1] 128,128,128,1
-endif
-ancien_gimp_morpho[-1] 0,$Size_morpho,0,2,0,1
-fx_normalize_local[-2] 2,6,5,20,1,3
-blend[-1,-2] softlight,1,0
-fx_LCE[-1] 80,0.5,1,1,3,0
-endl -done
samj_CeKoaSa_001_preview :
-gui_split_preview "-samj_CeKoaSa_001 $*",$-1
#@gui CeKoaSa 002 : samj_CeKoaSa_002, samj_CeKoaSa_002_preview(1)
#@gui : sep = separator()
#@gui : Douceur / Smoothness = float(0,0,10)
#@gui : Seuil / Threshold = float(15,0,50)
#@gui : D\303\251formation = float(3,0,6)
#@gui : Renforcer Couleurs / Boost = bool(1)
#@gui : Taille / Size = int(3,1,10)
#@gui : Otsu = bool(1)
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/05/31</i>.</small>")
samj_CeKoaSa_002 :
-repeat $! -l[$>]
Smoothness_thin_edges=$1
Threshold_thin_edges=$2
Amplitude_ripple=$3
Boost=$4
Size_morpho=$5
Valider_Otsu=$6
-to_rgba[-1]
-fx_frame[-1] 0,100,0,100,1,1,0,0,0,255,1,255,255,255,255
-if {$Valider_Otsu==1}
-otsu[-1] 4 -n[-1] 0,255
-endif
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-fx_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
--Je_passe_l_hiver_en_Floride[-1]
-ripple[-1] $Amplitude_ripple,20,2,0
-blend[-1,-2] average,1,1
-ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
-fx_edges[-2] 0,15,0,0
-blend[-1,-2] average,1,1
-if {$Boost==1}
-fx_balance_gamma[-1] 128,128,128,1
-endif
-ancien_gimp_morpho[-1] 0,$Size_morpho,0,2,0,1
-fx_normalize_local[-2] 2,6,5,20,1,3
-blend[-1,-2] softlight,1,0
-Polygonize_GUI[-1] 10,10,10,10,10,0
-fx_LCE[-1] 80,0.5,1,1,3,0
-endl -done
samj_CeKoaSa_002_preview :
-gui_split_preview "-samj_CeKoaSa_002 $*",$-1
#@gui CeKoaSa 003 : samj_CeKoaSa_003, samj_CeKoaSa_003_preview(0)
#@gui : sep = separator()
#@gui : Douceur / Smoothness = float(0,0,10)
#@gui : Seuil / Threshold = float(5,0,50)
#@gui : D\303\251formation = float(1,0,6)
#@gui : Renforcer Couleurs / Boost = bool(1)
#@gui : Taille / Size = int(3,1,10)
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/05/31</i>.</small>")
samj_CeKoaSa_003 :
-repeat $! -l[$>]
Smoothness_thin_edges=$1
Threshold_thin_edges=$2
Amplitude_ripple=$3
Boost=$4
Size_morpho=$5
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-fx_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
--Je_passe_l_hiver_en_Floride[-1]
-ripple[-1] $Amplitude_ripple,20,2,0
-blend[-1,-2] average,1,1
-ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
-fx_edges[-2] 0,15,0,0
-blend[-1,-2] average,1,1
-if {$Boost==1}
-fx_balance_gamma[-1] 128,128,128,1
-endif
-ancien_gimp_morpho[-1] 0,$Size_morpho,0,2,0,1
-fx_normalize_local[-2] 2,6,5,20,1,3
-blend[-1,-2] softlight,1,0
-fx_LCE[-1] 80,0.5,1,1,3,0
-Polygonize_GUI[-2] 10,10,10,10,10,0
-fx_gaussian_blur[-2] 20,0,0,1,0,0
-blend[-1,-2] average,0.5,1
-endl -done
samj_CeKoaSa_003_preview :
-gui_split_preview "-samj_CeKoaSa_003 $*",$-1
#@gui CeKoaSa 004 : samj_CeKoaSa_004, samj_CeKoaSa_004_preview(0)
#@gui : sep = separator()
#@gui : Modulo = int(30,0,130)
#@gui : N\303\251gatif = bool(0)
#@gui : Filtre B&W Pencil = int(0,0,120)
#@gui : Opacit\303\251 / Opacity = float(0.8,0.5,1)
#@gui : Filtre Denoise = int(0,0,20)
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/05/31</i>.</small>")
samj_CeKoaSa_004 :
-repeat $! -l[$>]
Modulo=$1
Negatif=$2
B_W_pencil_amplitude=$3
Opacity_blend_edges=$4
Denoise_Image=$5
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-mod[-1] {20+$Modulo}
-n[-1] 0,255
-fx_ditheredbw[-1] 0,1,0,0,0,0
-if {$Negatif==1}
-negate[-1]
-endif
-if {$B_W_pencil_amplitude>0}
-pencilbw[-1] 0.3,$B_W_pencil_amplitude
-endif
-fx_blend_edges[-1,-2] 1,$Opacity_blend_edges,0
-if {$Denoise_Image>0}
-denoise[-1] $Denoise_Image,$Denoise_Image,5,6,1,0
-endif
-endl -done
samj_CeKoaSa_004_preview :
-gui_split_preview "-samj_CeKoaSa_004 $*",$-1
#@gui CeKoaSa 005 : samj_CeKoaSa_005, samj_CeKoaSa_005_preview(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Grille / Grid</small></span>")
#@gui : Grille / Grid X = int(16,2,100)
#@gui : Grille / Grid Y = int(16,2,100)
#@gui : Grille Carr\303\251e X = bool(0)
#@gui : Grille Carr\303\251e Y = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small>Couleurs / Colors</small></span>")
#@gui : Intensit\303\251 = float(0.2,0,1)
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacit\303\251 / Opacity = float(1,0,1)
#@gui : Inverser Calques / Revert Layers = bool(0)
#@gui : Normaliser = bool(1)
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_CeKoaSa_005 :
-repeat $! -l[$>]
Grille_X=$1
Grille_Y=$2
Grille_Carree_X=$3
Grille_Carree_Y=$4
Intensite=$5
Mode_Melange=$6
Opacity_Melange=$7
Revert_layers_Melange=$8
Normaliser=$9
--Je_passe_l_hiver_en_Floride[-1]
-if {$Grille_Carree_X==1}
Grille_Y=$Grille_X
-endif
-if {$Grille_Carree_Y==1}
Grille_X=$Grille_Y
-endif
-rand[-1] 0,255
-imagegrid[-1,-2] $Grille_X,$Grille_Y
--Je_passe_l_hiver_en_Floride[-1]
-blend[-1,-2] add,$Intensite,0
-gimp_blend_1651[-1,-2]  $Mode_Melange,0,$Opacity_Melange,$Revert_layers_Melange,1
-if {$Normaliser==1}
-n[-1] 0,255
-endif
-to_colormode[-1] 4
-endl -done
samj_CeKoaSa_005_preview :
-gui_split_preview "-samj_CeKoaSa_005 $*",$-1
#@gui Do Nothing : Je_passe_l_hiver_en_Floride, Je_passe_l_hiver_en_Floride
#@gui : note = note("<small><b>Note</b> : This filters does nothing on the image. Use it to manipulate layers in conjunction with the input/output options of the G'MIC plug-in.</small>")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/12/29</i>.</small>")
Je_passe_l_hiver_en_Floride :
#@gui Polygonize : Polygonize_GUI, Polygonize_GUI_preview(1)
#@gui : sep = separator(), note = note("<small>Param\303\250tres filtre Polygonize / Polygonize parameters</small>")
#@gui : Amplitude = int(300,0,2000)
#@gui : Douceur / Smoothness = float(10,0,100)
#@gui : Surface Minimale / Minimal Area = float(10,0,100)
#@gui : X-Resolution = float(10,1,256)
#@gui : Y-Resolution = float(10,1,256)
#@gui : sep = separator(), note = note("<small>Test</small>")
#@gui : Test Cadre Et Otsu = bool(0)
#@gui : sep = separator(), Type Aper\303\247u = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui : sep = separator(), note = note("<small>Filtre cr\303\251\303\251 par David Tschumperl&#233;  Derni\303\250re mise \303\240 jour : <i>2014/01/20</i>.</small>")
Polygonize_GUI :
-repeat $! -l[$>]
-polygonize[-1] $1,$2,$3,$4,$5
-if {$6==1} -to_rgba[-1] -fx_frame[-1] 0,100,0,100,1,1,0,0,0,255,1,255,255,255,255 -otsu[-1] 4 -n[-1] 0,255 -polygonize[-1] $1,$2,$3,$4,$5 -endif
-endl -done
Polygonize_GUI_preview :
-gui_split_preview "-Polygonize_GUI $*",$-1
#@gui Recolorize 20130115 : gimp_recolorize_20130115_modifie, gimp_recolorize_20130115_modifie(1)
#@gui : note = link("http://www.flickr.com/groups/gmic/discuss/72157632525934815/","http://www.flickr.com/groups/gmic/discuss/72157632525934815/")
#@gui : note = link("http://www.gimpchat.com/viewtopic.php?f=28&t=6207&start=0","http://www.gimpchat.com/viewtopic.php?f=28&t=6207&start=0")
#@gui : Douceur / Smoothness = float(30,0,200)
#@gui : Nuances/Decompose = choice(0,"Origine","Canal Y de YUV","Canal L de HSL 8","Canal L de LCH","Canal K de CMYK")
#@gui : \303\211tendue / Normalize A = int(0,0,255)
#@gui : \303\211tendue / Normalize B = int(255,0,255)
#@gui : D\303\251goulinade A / Extension Colors A = int(0,0,20)
#@gui : D\303\251goulinade B / Extension Colors B = float(0,0,10)
#@gui : Pr\303\251cision = bool(1)
#@gui : sep = separator()
#@gui : note = note{"<b>Note :</b> This filter needs two layers to work properly. The bottom layer can be a B&amp;W or a colored image, while the
#@gui : top layer contains color patches that will be extrapolated in a smart way (edge-directed) to fill the entire image. At the end,
#@gui : you get a completely recolored image."}
#@gui : sep = separator(), note = note("<small>Auteur / Author : <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Derni\303\250re mise \303\240 jour: <i>2013/01/18 samj</i>.</small>")
gimp_recolorize_20130115_modifie :
Smoothness=$1
Nuances=$2
Normalize_A=$3
Normalize_B=$4
Degoulinade_A=$5
Degoulinade_B=$6
Precision=$7
-rv[-2,-1]
-dilate_circ[-1] $Degoulinade_A
-if {$Nuances==0}
-channels[-2] 0
-elif {$Nuances==1}
-fx_decompose_channels[-2] 4,0,1,0 -remove[-2,-3]
-elif {$Nuances==2}
-to_rgb[-2] -rgb2hsl8[-2] -split[-2] c -rm[-3,-4]
-elif {$Nuances==3}
-to_rgb[-2] -rgb2lab8[-2] -split[-2] c -rm[-2,-3]
-elif {$Nuances==4}
-to_rgb[-2] -rgb2cmyk[-2] -split[-2] c -rm[-3,-4,-5] -negate[-2]
-endif
-to_rgb[-2] -to_rgba[-1]
-n[-2] $Normalize_A,$Normalize_B
-split_opacity[-1]
-neq[-1] 0
# il y a 3 images : -3=l'image grise  -2=les couleurs  -1=le masque
-srgb2rgb[-3,-2]
-rgb2lab8[-3,-2]
-channels[-3] 0
-channels[-2] 1,2
-+[-2] 1
-*[-2] [-1]
--gradient_norm[-3]
-blur[-1] $Degoulinade_B
-*[-1] -1
-watershed[-3] [-1]
-rm[-1]
--[-2] 1
# Get first estimate for the color interpolation.
-if {$Precision==1}
--diffusiontensors[-3] 0,1,1,1
-eq[-2] 0
-*[-1] [-2]
-rm[-2]
-smooth[-2] [-1],$Smoothness,0.8,45,2,0
-endif
-rm[-1]
-a[-2,-1] c
-lab82rgb[-1]
-rgb2srgb[-1]
#@gui Samj BoxFiter Map : samj_BoxFiter_Map, samj_BoxFiter_Map(1)
#@gui : note = note("samj_BoxFiter_Map")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>BoxFiter</b></span>")
#@gui : Blur = int(2,0,32)
#@gui : X = int(3,1,32)
#@gui : Y = int(3,1,32)
#@gui : Codage = choice(0,"Gray","Luminance")
#@gui : Blend = choice(0,"Alpha","Add")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Sharpen</b></span>")
#@gui : Type = choice(0,"No","Decompose 2","Decompose 6")
#@gui : Iterations = int(2,0,3)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Map</b></span>")
#@gui : Equalize = int(127,1,256)
#@gui : Colormap = int(16,2,256)
#@gui : Dithering = float(0,0,1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Transfer Color - Slow</b></span>")
#@gui : Transfer = bool(0)
#@gui : Luminosity Constraints = float(0.2,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/13</i>.</small>")
samj_BoxFiter_Map :
Flou=$1
Valeur_X=$2
Valeur_Y=$3
Codage=$4
Melange=$5
samj_Wavelet_Sharpen=$6
Iterations_Wavelet_Sharpen=$7
Valeur_Equalize=$8
Valeur_Colormap=$9
Valeur_Dithering=$10
Autorisation_Transfer=$11
Transfer_Luminosity_Constraints=$12
Transfer_Gamma=0.3
Transfer_Regularization=8
Transfer_RGB_Resolution=16
Transfer_Is_Constraints=0
Val_Max_Norm=255
-if {$Melange==1} Val_Max_Norm=127 -endif
--Je_passe_l_hiver_en_Floride[-1]
-blur[-1] $Flou
--Je_passe_l_hiver_en_Floride[-1]
-boxfilter[-1] y,$Valeur_Y,1
-n[-1] 0,$Val_Max_Norm
-to_graya[-1]
-reverse[-2,-1]
-boxfilter[-1] x,$Valeur_X,1
-n[-1] 0,$Val_Max_Norm
-to_graya[-1]
-if {$Codage==1} -luminance[-1,-2] -endif
-if {$Melange==0} -blend[-1,-2] alpha -else -blend[-1,-2] add -endif
-to_rgb[-1]
-if {$samj_Wavelet_Sharpen>0} -samj_Wavelet_Sharpen_Test_en[-1] {$samj_Wavelet_Sharpen-1},$Iterations_Wavelet_Sharpen -endif
-equalize[-1] $Valeur_Equalize,0,255
-n[-1] 0,255
-reverse[-2,-1]
-to_rgb[-1]
-if {$Autorisation_Transfer==1} Valeur_Colormap={round({{256*0.8}+{$Valeur_Colormap*0.2}})} -endif
-colormap[-1] $Valeur_Colormap
-index[-2] [-1],$Valeur_Dithering,0
-if {$Autorisation_Transfer==1} -transfer_rgb[-2] [-1],$Transfer_Gamma,$Transfer_Regularization,$Transfer_Luminosity_Constraints,$Transfer_RGB_Resolution,$Transfer_Is_Constraints -endif
-rm[-1]
-n[-1] 0,255
#@gui Samj BoxFiter Test : samj_BoxFiter_Test, samj_BoxFiter_Test(1)
#@gui : note = note("samj_BoxFiter_Test")
#@gui : Blur = int(2,0,32)
#@gui : X = int(3,1,32)
#@gui : Y = int(3,1,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Sharpen</b></span>")
#@gui : Type = choice(1,"No","Decompose 2","Decompose 6")
#@gui : Iterations = int(2,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/12</i>.</small>")
samj_BoxFiter_Test :
Flou=$1
Valeur_X=$2
Valeur_Y=$3
samj_Wavelet_Sharpen=$4
Iterations_Wavelet_Sharpen=$5
-blur[-1] $Flou
--Je_passe_l_hiver_en_Floride[-1]
-boxfilter[-1] y,$Valeur_Y,1
-n[-1] 0,255
-to_graya[-1]
-reverse[-2,-1]
-boxfilter[-1] x,$Valeur_X,1
-n[-1] 0,255
-to_graya[-1]
-blend[-1,-2] alpha
-to_graya[-1]
-if {$samj_Wavelet_Sharpen>0} -samj_Wavelet_Sharpen_Test_en[-1] {$samj_Wavelet_Sharpen-1},$Iterations_Wavelet_Sharpen -endif
-n[-1] 0,255
#@gui Samj CeKoaSa 007 : samj_CeKoaSa_007 , samj_CeKoaSa_007 (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_CeKoaSa_007</b></span>")
#@gui : Max Patch = int(8,1,32)
#@gui : Min Patch = int(8,1,32)
#@gui : Dilate = int(10,1,16)
#@gui : Pixelize = int(8,2,100)
#@gui : Blur = int(8,0,30)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2016/11/15</i>.</small>")
samj_CeKoaSa_007  :
Val_Max_Patch=$1
Val_Min_Patch=$2
Val_Dilate=$3
Val_Pixelize=$4
Flou=$5
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-max_patch[-1] $Val_Max_Patch
-n[-1] 0,255
-min_patch[-2] $Val_Min_Patch
-n[-2] 0,255
-dilate[-1,-2] $Val_Dilate
-blend[-1,-2] edges
-blur[-1] $Flou
-pixelize[-1,-2,-3] $Val_Pixelize,$Val_Pixelize
--luminance[-1]
-blend[-1,-2,-3] edges
-blend[-1,-2] grainmerge
#@gui Samj CeKoaSa 008 : samj_CeKoaSa_008, samj_CeKoaSa_008_preview(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b><u>Filtre Lent</u></b></span>")
#@gui : D\303\251tection A = int(64,0,127)
#@gui : D\303\251tection B = int(64,0,127)
#@gui : Flou Lissage = float(4,0,10)
#@gui : Couleur = float(1,0,4)
#@gui : Rendu = int(2,1,7)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Topographic Map</b></span>")
#@gui : Levels = int(16,4,256)
#@gui : Smoothness = float(1,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Stained Glass</b></span>")
#@gui : Edges = float(20,0,100)
#@gui : Shading = float(0.1,0,0.5)
#@gui : Thin Separators = bool(0)
#@gui : Intensit\303\251 = int(1,1,8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Isophotes</b></span>")
#@gui : Isophotes Nb Levels = int(64,1,128)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [Antialias] = bool(1)
#@gui : Amplitude = float(2,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/12/04</i>.</small>")
samj_CeKoaSa_008:
Detection_A=$1
Detection_B=$2
Flou_Lissage=$3
Couleur=$4
Type_Rendu=$5
Niveaux_TM=$6
Adoucissement_TM=$7
Edges_SG=$8
Shading_SG=$9
Is_Precise_SG=$10
Intensite_SG=$11
Isophotes_Nb_Levels=$12
Validation_Smooth_Antialias=$13
V_Amplitude=$14
V_Edge_Threshold=$15
V_Smoothness=$16
R_a=$17
V_a=$18
B_a=$19
A_a=$20
-blur[-1] $Flou_Lissage
-n[-1] 0,255
-c[-1] {127-$Detection_A},{127+$Detection_B}
-n[-1] 0,255
-mul[-1] $Couleur
-topographic_map[-1] $Niveaux_TM,$Adoucissement_TM
--Je_passe_l_hiver_en_Floride[-1]
-stained_glass[-1] $Edges_SG,$Shading_SG,$Is_Precise_SG
-repeat $Intensite_SG
--Je_passe_l_hiver_en_Floride[-1]
-blend[-1,-2] overlay
-done
-if {$Type_Rendu==1}
-to_graya[-1]
-blend[-1,-2] overlay
-elif {$Type_Rendu==2}
-to_graya[-1]
-blend[-1,-2] alpha
-elif {$Type_Rendu==3}
-to_graya[-1]
-blend[-1,-2] edges
-elif {$Type_Rendu==4}
-blend[-1,-2] overlay
-elif {$Type_Rendu==5}
-blend[-1,-2] alpha
-elif {$Type_Rendu==6}
-blend[-1,-2] edges
-elif {$Type_Rendu==7}
-blend[-1,-2] average
-endif
-isophotes[-1] $Isophotes_Nb_Levels
-if {$Validation_Smooth_Antialias==1} -fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness -endif
{w},{h},1,4
-fill_color[-1] $R_a,$V_a,$B_a,$A_a
-reverse[-1,-2]
-blend[-1,-2] alpha
samj_CeKoaSa_008_preview :
-gui_split_preview "-samj_CeKoaSa_008 $*",$-1
#@gui Samj CeKoaSa 009 : samj_CeKoaSa_009, samj_CeKoaSa_009(0)
#@gui : sep = separator(), url = link("Essai adaptation du didacticiel de Sebastien Guyader et du code de Iain Fergusson","https://discuss.pixls.us/t/highlight-bloom-and-photoillustration-look/2509/29")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Smooth</b></span>")
#@gui : Iterations = int(1,1,10)
#@gui : Amplitude = float(5,0,1000)
#@gui : Sharpness = float(0.5,0,2)
#@gui : Anisotropy = float(0.63,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(2.35,0,10)
#@gui : Spatial Precision = float(0.8,0.1,2)
#@gui : Angular Precision = float(30,1,180)
#@gui : Value Precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Iain Fergusson - Simplelocal Contrast</b></span>")
#@gui : Edge Sensitivity = float (25,0,25)
#@gui : Iterations = int (1,1,5)
#@gui : Paint Effect = float (50,0,50)
#@gui : Channels = Choice (1,"Colour","Luminance Only")
#@gui : Pre Gamma = float (1.0,0.1,5)
#@gui : Post Gamma = float (1.2,0.1,5)
#@gui : note = note("<small>Luminance Mask</small>" )
#@gui : Blacks = float (1,0,1)
#@gui : Dark Grey = float (1,0,1)
#@gui : Mid Grey = float (1,0,1)
#@gui : Light Grey = float (1,0,1)
#@gui : Whites = float (1,0,1)
#@gui : Parallel Processing = Choice (1,"Auto","None")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Wavelet Sharpen</b></span>")
#@gui : Wavelet Sharpen Vs Graphic Novel = Choice (0,"Wavelet Sharpen","Photocomix Graphic Novel")
#@gui : Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Iterations = int(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Script Origine de Iain Fergusson</b></span>")
#@gui : Script Origine = bool(0)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Courbes</b></span>")
#@gui : Utiliser Courbes = choice(0,"Non"," Utiliser Curves Interactive")
#@gui : Colorspace = choice{7,"RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr"}
#@gui : Output Preset as a HaldCLUT Layer = value(0)
#@gui : Apply Transformation From = _choice("New curves [interactive]","Curves defined previously")
#@gui : Colorspace = value(0)
#@gui : Keypoints = value(0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2017/01/05</i>.</small>")
samj_CeKoaSa_009:
SM_Iterations=$1
SM_Amplitude=$2
SM_Sharpness=$3
SM_Anisotropy=$4
SM_Gradient_smoothness=$5
SM_Tensor_smoothness=$6
SM_Spatial_precision=$7
SM_Angular_precision=$8
SM_Value_precision=$9
SM_Interpolation=$10
SM_Fast_approximation=$11
SC_Edge_Sensitivity=$12
SC_Iterations=$13
SC_Paint_effect=$14
SC_Channels=$15
SC_Pre_gamma=$16
SC_Post_gamma=$17
SC_Blacks=$18
SC_Dark_grey=$19
SC_Mid_grey=$20
SC_Light_grey=$21
SC_Whites=$22
SC_Parallel_Processing=$23
Wavelet_Sharpen=$24
Wavelet_Sharpen_Type=$25
Wavelet_Sharpen_Iterations=$26
Script_Origine=$27
Utiliser_courbes=$28
-if {$Script_Origine==1}
--fx_smooth_anisotropic[0] 10,0.16,0.63,0.6,2.35,0.8,30,2,0,1,1,0,1
-sub[0] [1]
-simplelocalcontrast_p[1] 25,1,50,1,1,1.2,1,1,1,1,1,1
-fx_graphic_novelfxl[1] 1,2,6,5,20,0,1,100,0,1,0,0.78,1.92,0,0,2,1,1,1,1.26,0.37,1.05
-add
-c 0,255
-else
--Je_passe_l_hiver_en_Floride[-1]
-repeat $SM_Iterations
-smooth[-1] $SM_Amplitude,$SM_Sharpness,$SM_Anisotropy,$SM_Gradient_smoothness,$SM_Tensor_smoothness,$SM_Spatial_precision,$SM_Angular_precision,$SM_Value_precision,$SM_Interpolation,$SM_Fast_approximation
-done
-sub[-2] [-1]
-simplelocalcontrast_p[-1] $SC_Edge_Sensitivity,$SC_Iterations,$SC_Paint_effect,$SC_Channels,$SC_Pre_gamma,$SC_Post_gamma,$SC_Blacks,$SC_Dark_grey,$SC_Mid_grey,$SC_Light_grey,$SC_Whites,$SC_Parallel_Processing
-if {$Wavelet_Sharpen==0}
-samj_Wavelet_Sharpen_Test_en[-1] $Wavelet_Sharpen_Type,$Wavelet_Sharpen_Iterations
-elif {$Wavelet_Sharpen==0}
-fx_graphic_novelfxl[-1] 1,2,6,5,20,0,1,100,0,1,0,0.78,1.92,0,0,2,1,1,1,1.26,0.37,1.05
-endif
-rm[-2]
-c[-1] 0,255
-endif
-if {$Utiliser_courbes==1}
-fx_curves_interactive[-1] $29,$30,$31,$32,$33
-endif
#@gui Samj CeKoaSa 010 : samj_CeKoaSa_010 , samj_CeKoaSa_010(1)
#@gui : Flou A = int(30,0,128)
#@gui : Flou B = int(10,0,128)
#@gui : Diff A = float(0.1,0.1,16)
#@gui : Diff B = float(2,0.1,16)
#@gui : Isop = int(10,2,16)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/18</i>.</small>")
samj_CeKoaSa_010  :
FlouA=$1
FlouB=$2
DiffA=$3
DiffB=$4
Isop=$5
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-blur[-1] $FlouA
-blur[-2] $FlouB
-diffusiontensors[-1] 0,1,1,$DiffA,1
-diffusiontensors[-2] 0,1,1,$DiffB,1
-abs[-1,-2]
-n[-1,-2] 0,255
-transfer_colors[-1] [-3]
-transfer_colors[-2] [-3]
-blend[-1,-2] add
-c[-1] 0,255
-n[-1] 0,255
-isophotes[-1] $Isop
-blur[-2] {{{w}+{h}}/4}
-blend[-1,-2] alpha
#@gui Samj Relief A : samj_Relief_A, samj_Relief_A(1)
#@gui : sep = separator(), note = note("<span foreground="orangered">Vanvliet</span>")
#@gui : Variation = float (3,0,6)
#@gui : Order = int (1,0,3)
#@gui : Axis = choice (0,"X","Y","-X","-Y")
#@gui : Boundary = choice (1,"Dirichlet","Neumann")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Iain Fergusson - Simplelocal Contrast</b></span>")
#@gui : Edge Sensitivity = float (16,0,25)
#@gui : Iterations = int (1,1,5)
#@gui : Paint Effect = float (50,0,50)
#@gui : Channels = Choice (1,"Colour","Luminance Only")
#@gui : Pre Gamma = float (1.0,0.1,5)
#@gui : Post Gamma = float (1.2,0.1,5)
#@gui : note = note("<small>Luminance Mask</small>" )
#@gui : Blacks = float (1,0,1)
#@gui : Dark Grey = float (1,0,1)
#@gui : Mid Grey = float (1,0,1)
#@gui : Light Grey = float (1,0,1)
#@gui : Whites = float (1,0,1)
#@gui : Parallel Processing = Choice (1,"Auto","None")
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Wavelet Sharpen</b></span>")
#@gui : Sharpen = choice(0,"Sharpen A","Sharpen B","Sharpen A B")
#@gui : Sharpen A Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Sharpen A Iterations = int(0,0,2)
#@gui : Sharpen B Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Sharpen B Iterations = int(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered">Relief</span>")
#@gui : Cut A % = float(0,0,100)
#@gui : Cut B % = float(100,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. -   Latest Update: <i>2017/01/10</i>.</small>")
samj_Relief_A :
V_variation=$1
V_order=$2
V_axis=$3
V_boundary=$4
SC_Edge_Sensitivity=$5
SC_Iterations=$6
SC_Paint_effect=$7
SC_Channels=$8
SC_Pre_gamma=$9
SC_Post_gamma=$10
SC_Blacks=$11
SC_Dark_grey=$12
SC_Mid_grey=$13
SC_Light_grey=$14
SC_Whites=$15
SC_Parallel_Processing=$16
Wavelet_Sharpen_Selection=$17
Wavelet_Sharpen_Type_A=$18
Wavelet_Sharpen_Iterations_A=$19
Wavelet_Sharpen_Type_B=$20
Wavelet_Sharpen_Iterations_B=$21
Cut_A=$22
Cut_B=$23
--Je_passe_l_hiver_en_Floride[-1]
-if {$V_axis==0}
-vanvliet[-1] $V_variation,$V_order,x,$V_boundary
-elif {$V_axis==1}
-vanvliet[-1] $V_variation,$V_order,y,$V_boundary
-elif {$V_axis==2}
-mirror[-1] x
-vanvliet[-1] $V_variation,$V_order,x,$V_boundary
-mirror[-1] x
-elif {$V_axis==3}
-mirror[-1] y
-vanvliet[-1] $V_variation,$V_order,y,$V_boundary
-mirror[-1] y
-endif
-n[-1] 0,{{iM}-{im}}
-c[-1] {{iM}/100*$Cut_A},{iM}
-n[-1] 0,{iM}
-c[-1] 0,{{iM}/100*$Cut_B}
-n[-1] 0,255
-to_gray[-1]
-if {{$Wavelet_Sharpen_Selection==1}||{$Wavelet_Sharpen_Selection==2}}
-samj_Wavelet_Sharpen_Test_en[-1] $Wavelet_Sharpen_Type_B,$Wavelet_Sharpen_Iterations_B
-endif
-simplelocalcontrast_p[-2] $SC_Edge_Sensitivity,$SC_Iterations,$SC_Paint_effect,$SC_Channels,$SC_Pre_gamma,$SC_Post_gamma,$SC_Blacks,$SC_Dark_grey,$SC_Mid_grey,$SC_Light_grey,$SC_Whites,$SC_Parallel_Processing
-if {{$Wavelet_Sharpen_Selection==0}||{$Wavelet_Sharpen_Selection==2}}
-samj_Wavelet_Sharpen_Test_en[-2] $Wavelet_Sharpen_Type_A,$Wavelet_Sharpen_Iterations_A
-endif
-blend[-1,-2] grainextract
#@gui Samj Test A : samj_test_A, samj_test_A(1)
#@gui : note = note("samj_test_A")
#@gui : A = int(64,0,255)
#@gui : B = int(192,0,255)
#@gui : C = int(500,0,10000)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/14</i>.</small>")
samj_test_A :
-or[-1] {$1} -to_rgb[-1] -and[-1] {$2} -smooth[-1] $3 -n[-1] 0,255 -Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0
#@gui Samj Test B : samj_test_B, gui_no_preview
#@gui : note = note("samj_test_B")
#@gui : A = int(100,10,200)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/15</i>.</small>")
samj_test_B :
-samj_Points_Aleatoires_001[-1] $1,255,255,0,255,3,1,1 --Je_passe_l_hiver_en_Floride[-1] -fx_flower[-1] 30,6,100,0,50,50,1 -to_rgb[-1] -smooth[-1] 500 -n[-1] 0,255 -Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0 -fx_boost_chroma[-1] 1,0,0
#@gui Samj Test C : samj_test_C, gui_no_preview
#@gui : note = note("samj_test_C")
#@gui : A = int(100,10,200)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/16</i>.</small>")
samj_test_C :
-samj_Points_Aleatoires_001[-1] $1,255,255,0,255,3,1,1 --Je_passe_l_hiver_en_Floride[-1] -fx_segment_watershed[-1] 8,0,0,0,0 -fx_flower[-1] 10,20,0,360,50,50,1 -Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0
#@gui Samj Test D : samj_test_D, samj_test_D(1)
#@gui : note = note("samj_test_D")
#@gui : Var Sub = float(40,0,255)
#@gui : Var N = float(255,0,255)
#@gui : Var Spread = float(10,0,60)
#@gui : Var Dilate = float(30,0,60)
#@gui : Var Blur = float(5,0,20)
#@gui : D\303\251formation = float(0,0,5)
#@gui : sep = separator()
#@gui : Levels = int(8,1,256)
#@gui : Smoothness = float(0,0,5)
#@gui : Var Dilate Circ = float(4,0,60)
#@gui : sep = separator()
#@gui : Inner Fading = float(0,0,100)
#@gui : Outer Fading = float(25,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_test_D :
Var_sub=$1
Var_n=$2
Var_spread=$3
Var_dilate=$4
Var_blur=$5
Deformation=$6
Levels=$7
Smoothness=$8
Var_dilate_circ=$9
Inner_fading=$10
Outer_fading=$11
--Je_passe_l_hiver_en_Floride[-1]
-if {$Var_sub>0}
-sub[-1] $Var_sub
-abs[-1]
-endif
-n[-1] 0,$Var_n
-if {$Var_spread>0} -spread[-1] $Var_spread -endif
-if {$Var_dilate>0} -dilate[-1] $Var_dilate -endif
-if {$Var_blur>0} -blur[-1] $Var_blur -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-fx_isophotes[-2] $Levels,$Smoothness,0
-if {$Var_dilate_circ>0} -dilate_circ[-2] $Var_dilate_circ -endif
-fx_blend_seamless[-2,-1] 0,$Inner_fading,$Outer_fading,0,0
#@gui Samj Test Dither Color : samj_test_Dither_Color, samj_test_Dither_Color(1)
#@gui : note = note("samj_test_Dither_Color")
#@gui : Flou = int(2,0,10)
#@gui : Dilatation = int(0,0,10)
#@gui : Couleur Fond = color(230,230,150)
#@gui : Tolerance (%) = float(0,0,100)
#@gui : Smoothness (%) = float(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/11/08</i>.</small>")
samj_test_Dither_Color :
Flou_a=$1
Dilatation=$2
R_C=$3
V_C=$4
B_C=$5
Tolerance_C=$6
Smoothness_C=$7
--Je_passe_l_hiver_en_Floride[-1]
-gradient_norm[-1]
-blur[-1] $Flou_a
-dilate_circ[-1] $Dilatation
-negative[-1]
-n[-1] 0,255
-ditheredbw[-1]
#-pixelize[-1] {w},{h},1
-to_rgb[-1]
-blend[-1,-2] add
-to_rgb[-1]
-n[-1] 0,255
-replace_color[-1] $Tolerance_C,$Smoothness_C,255,255,255,$R_C,$V_C,$B_C
#@gui Samj Test E : samj_test_E, samj_test_E(1)
#@gui : note = note("samj_test_E")
#@gui : note = note("<span foreground="orangered"><small>Exemples</small></span>")
#@gui : Exemple = choice{"Non/No","A","B","C"}
#@gui : note = note("<span foreground="orangered"><small>diffusiontensors</small></span>")
#@gui : Sharpness = float(0.7,0,2)
#@gui : Anisotropy = float(0.3,0,1)
#@gui : Alpha = float(0.6,0,10)
#@gui : Sigma = float(1.1,0,10)
#@gui : Is Sqrt = bool(0)
#@gui : note = note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Fond / Background Color = color(200,125,50)
#@gui : Mode = choice{"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/19</i>.</small>")
samj_test_E :
exemple=$1
sharpness=$2
anisotropy=$3
alpha=$4
sigma=$5
is_sqrt=$6
rf=$7
vf=$8
bf=$9
Mode=$10
Opacity=$11
-if {$exemple==1}
anisotropy=0
alpha=0
sigma=0
-elif {$exemple==2}
anisotropy=0
alpha=4
sigma=0
-elif {$exemple==3}
sharpness=0.5
anisotropy=0.3
alpha=$4
sigma={$sigma/10}
is_sqrt=1
-endif
-diffusiontensors[-1] $sharpness,$anisotropy,$alpha,$sigma,$is_sqrt
-n[-1] 0,255
-equalize[-1]
-fx_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-to_rgb[-1]
-fx_8bits[-1] 100,10000,256
{w},{h},1,3
-fill_color[-1] $rf,$vf,$bf
-gimp_blend_1651[-1,-2] $Mode,0,$Opacity,0
#@gui Samj Test F : samj_test_F, samj_test_F(1)
#@gui : note = note("samj_test_F")
#@gui : note = note("<span foreground="orangered"><small>Flou Effet Verre</small></span>")
#@gui : A = float(40,0.1,200)
#@gui : B = float(50,0.1,200)
#@gui : It\303\251rations = int(1,1,8)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/04/20</i>.</small>")
samj_test_F :
-repeat $3
-fx_custom_deformation "cos(x*$1)*$2*sin(y)*(w+h)/10000","cos(y*$1)*$2*sin(x)*(w+h)/10000",1,1,1
-done
#@gui Samj Test G : samj_test_G, samj_test_G(1)
#@gui : note = note("samj_test_G")
#@gui : A = int(0,0,20)
#@gui : B = float(0,0,10)
#@gui : C = float(0,0,1)
#@gui : D = int(30,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2016/01/20</i>.</small>")
samj_test_G :
-fx_spread $1,$1,0,0,0
-fx_boost_fade[-1] $2,0
--Je_passe_l_hiver_en_Floride[-1]
-fx_local_orientation[-1] $3,0,100,0,16,0
-fx_blend[-1,-2] 14,0,1,1
-fx_lightglow[-1] $4,0.5,8,0.8,0,0
#@gui Samj Test Solidify : samj_Test_Solidify , samj_Test_Solidify (1)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>samj_Quelques_Isophotes</b></span>")
#@gui : \303\211paisseur = int(10,1,32)
#@gui : Pr\303\251cision = int(10,1,32)
#@gui : Coeff Pr\303\251cision = float(1,0.1,8)
#@gui : Coeff Flou = float(0.02,0,1)
#@gui : Isophotes = int(8,2,32)
#@gui : sep = separator(), note = note("<span foreground="orangered"><b>Solidify</b></span>")
#@gui : Valider Solidify = bool(1)
#@gui : Smoothness % = float(75,0,100)
#@gui : Diffusion Type = choice(0,"Isotropic","Delaunay Oriented","Edge Oriented")
#@gui : Diffusion Iter = int(20,1,200)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2017/01/05</i>.</small>")
samj_Test_Solidify :
Epaisseur=$1
Precision=$2
Coeff_Precision_Pixelise=$3
Coeff_Precision_Flou=$4
Nb_Isophotes=$5
Valider_Solidify=$6
smoothness=$7
diffusion_type=$8
diffusion_iter=$9
-samj_Quelques_Isophotes[-1] $Epaisseur,$Precision,$Coeff_Precision_Pixelise,$Coeff_Precision_Flou,$Nb_Isophotes
-if {$Valider_Solidify==1} -solidify[-1] $smoothness,$diffusion_type,$diffusion_iter -endif
#@gui Test Courbes : samj_test_x_color_curves, samj_test_x_color_curves(0)
#@gui : note = note("Demo. samj_test_x_color_curves")
#@gui : note = note("")
#@gui : Utiliser = choice(1,"x_color_curves","gimp_curves_interactive")
#@gui : Appliquer Courbes = choice("Aucun","Appliquer le Dernier","RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/04</i>.</small>")
samj_test_x_color_curves :
Utiliser=$1
Appliquer_courbes=$2
-if {$Utiliser==0}
-if {$Appliquer_courbes==0}
-blur[-1] 5
-elif {$Appliquer_courbes==1}
-x_color_curves[-1] last
-elif {$Appliquer_courbes==2}
-x_color_curves[-1] rgb
-elif {$Appliquer_courbes==3}
-x_color_curves[-1] cmy
-elif {$Appliquer_courbes==4}
-x_color_curves[-1] cmyk
-elif {$Appliquer_courbes==5}
-x_color_curves[-1] hsi
-elif {$Appliquer_courbes==6}
-x_color_curves[-1] hsl
-elif {$Appliquer_courbes==7}
-x_color_curves[-1] hsv
-elif {$Appliquer_courbes==8}
-x_color_curves[-1] lab
-elif {$Appliquer_courbes==9}
-x_color_curves[-1] lch
-elif {$Appliquer_courbes==10}
-x_color_curves[-1] ycbcr
-endif
-else
-if {$Appliquer_courbes==0}
-blur[-1] 5
-elif {$Appliquer_courbes==1}
-deform[-1] 20
-elif {$Appliquer_courbes==2}
-fx_curves_interactive[-1] 0,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==3}
-fx_curves_interactive[-1] 1,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==4}
-fx_curves_interactive[-1] 2,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==5}
-fx_curves_interactive[-1] 3,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==6}
-fx_curves_interactive[-1] 4,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==7}
-fx_curves_interactive[-1] 5,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==8}
-fx_curves_interactive[-1] 6,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==9}
-fx_curves_interactive[-1] 7,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==10}
-fx_curves_interactive[-1] 8,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-endif
-endif
#@gui Texture 002 : samj_gimp_texture_zero_zero_deux, samj_gimp_texture_zero_zero_deux(1)
#@gui : Details = int(0,0,127)
#@gui : Resolution = float(10,4,20)
#@gui : Threshold = float(4,2,20)
#@gui : sep = separator()
#@gui : Edges = float(10,5,20)
#@gui : Blend Colors = float(0.5,0,1)
#@gui : Colors Boost = bool(1)
#@gui : Boost Intensity = float(1,0,1)
#@gui : sep = separator()
#@gui : Black Lines = bool(1)
#@gui : Blend Black Lines = float(0.3,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/11/16</i>.</small>")
samj_gimp_texture_zero_zero_deux :
Details_TA=$1
Polygonize_Resolution_TA=$2
Threshold_Thin_Edges_TA=$3
Edges_Threshold=$4
Blend_Colors_Opacity=$5
Colors_Boost=$6
Boost_Intensity=$7
Black_Lines=$8
Blend_Black_Lines_Opacity=$9
--Je_passe_l_hiver_en_Floride[-1]
-if {$Colors_Boost==1}
-n[-1] 0,255
-endif
-samj_Toile_D_Araignee[-1] $Details_TA,$Polygonize_Resolution_TA,$Threshold_Thin_Edges_TA
-if {$Black_Lines==1}
--Je_passe_l_hiver_en_Floride[-1]
-fx_edges[-1] 0,$Edges_Threshold,0
-fx_local_orientation[-1] 0,0,100,0,0,0
-blend[-1,-3] average,$Blend_Colors_Opacity,0
-blend[-1,-2] luminance,$Blend_Black_Lines_Opacity,0
-else
-fx_edges[-1] 0,$Edges_Threshold,0
-fx_local_orientation[-1] 0,0,100,0,0,0
-blend[-1,-2] average,$Blend_Colors_Opacity,0
-endif
-if {$Colors_Boost==1}
--Je_passe_l_hiver_en_Floride[-1]
-n[-1,-2] 0,255
-blend[-1,-2] softlight,$Boost_Intensity,0
-endif
#@gui Texture 003 : samj_Texture_Aquarelle_1, samj_Texture_Aquarelle_1(1)
#@gui : note = note("<small>Texture</small>")
#@gui : Amplitude Noise = float(10,5,200)
#@gui : Density Hardsketchbw = float(10,5,100)
#@gui : Spread Variations = float(4,3,20)
#@gui : Amplitude Water = float(3,2,10)
#@gui : sep = separator()
#@gui : note = note("<small>Couleur / Color</small>")
#@gui : Couleur / Color = color(251,237,206)
#@gui : Opacit\303\251 / Opacity = float(1,-1,1)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/11/16</i>.</small>")
samj_Texture_Aquarelle_1 :
Amplitude_Noise=$1
Density_Hardsketchbw=$2
Spread_Variations=$3
Amplitude_Water=$4
R3=$5
V3=$6
B3=$7
Opacite=$8
{w},{h},1,3
-rm[-2]
-fill_color[-1] 255,255,255
-to_rgb[-1]
-fx_noise[-1] $Amplitude_Noise,0,2,0
-fx_hardsketchbw[-1] 300,$Density_Hardsketchbw,1,0.1,20,0,0
{w},{h},1,3
-fill_color[-1] 255,255,255
-to_rgb[-1]
-fx_noise[-1] $Amplitude_Noise,0,2,0
-fx_hardsketchbw[-1] 300,$Density_Hardsketchbw,1,0.1,20,0,0
-fx_spread[-1] $Spread_Variations,$Spread_Variations,0,0
-blend[-1,-2] average,1,0
-water[-1] $Amplitude_Water,0
{w},{h},1,3
-fill_color[-1] $R3,$V3,$B3
-to_rgb[-1]
-if {$Opacite>=0}
-blend[-1,-2] average,$Opacite,0
-else
-blend[-1,-2] edges,{1+$Opacite},1
-endif
#@gui Toile Araign&#233;E : samj_Toile_D_Araignee, samj_Toile_D_Araignee(1)
#@gui : Details = int(0,0,127)
#@gui : Resolution = float(10,4,20)
#@gui : Threshold = float(4,2,20)
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Latest update : <i>2016/11/16</i>.</small>")
samj_Toile_D_Araignee :
Details=$1
Polygonize_Resolution=$2
Threshold_Thin_Edges=$3
-apply_curve[0] $Details,-1,128,-1,128,-1,128,-1,128,-1,128,255,1,0,0,0,0
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-fx_polygonize[-2] 300,100,0,$Polygonize_Resolution,$Polygonize_Resolution,0,0,0,255
-fx_thin_edges[-1] 0,$Threshold_Thin_Edges,0
-fx_blend[-2,-1] 36,1,1
-fx_isophotes[-1] 8,0,1
-fx_blend_edges[-2,-1] 1,5,0
-to_rgb[-1]
-rgb2hsl8[-1]
-split[-1] c
-rm[-2,-3]
-fx_thin_edges[-1] 0,15,0,0
#@gui Tout Interactif : samj_test_tout_interactif, gui_no_preview
#@gui : note = note("Demo. Tout interactif")
#@gui : note = note("")
#@gui : note = note("2 filtres interactifs successifs : x_paint et threshold")
#@gui : note = note("x_paint : Choisir un pinceau, appliquer et fermer image")
#@gui : note = note("threshold : Appliquer la souris et fermer image")
#@gui : note = note("")
#@gui : note = note("2 successive interactive filters : x_paint et threshold")
#@gui : note = note("x_paint : Choose a brush, apply and close picture")
#@gui : note = note("threshold : Move the mouse and close picture")
#@gui : note = note("")
#@gui : sep = separator(), note = note("<small>Author: <i>Samj</i>. - Derni\303\250re mise \303\240 jour : <i>2015/03/03</i>.</small>")
samj_test_tout_interactif :
-x_paint[-1]
-threshold[-1]
-n[-1] 0,255
#@gui __
#@gui <i>Souphead</i>
#@gui My Filter : fx_souphead_filter, fx_souphead_filter_preview
#@gui : Sigma = float(0,0,20)
fx_souphead_filter :
-b $1
fx_souphead_filter_preview :
-fx_souphead_filter $1
-text_outline "Preview only",5,5,24,2,1,255,128,255
#@gui _
#@gui <i>Telperion</i>
#@gui Mc Flou : mc_flou, mc_flou_preview
#@gui : sep = separator()
#@gui : Sharp = float(30,10,400)
#@gui : Blur = float(6,3,20)
#@gui : Blend = float(1,0,1)
#@gui : sep = separator() ,note = note("Base image adjustement:")
#@gui : Skip = bool(true)
#@gui : Gamma = float(1,0.2,2)
#@gui : Value Min = int(0,0,127)
#@gui : Value Max = int(255,128,255)
#@gui : Gamma R = float(1,0.2,2)
#@gui : Gamma G = float(1,0.2,2)
#@gui : Gamma B = float(1,0.2,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator() ,note = note("Apply a flou effect with edges protection. v.1.1")
mc_flou:
if {$4==0}
to_rgb
apply_gamma[0] $5
c[0] $6,$7 n[0] 0,255
s[0] c
apply_gamma[0] $8
apply_gamma[1] $9
apply_gamma[2] $10
a[0,1,2] c
fi
+fx_gradient_norm[0] 0,1.5,0,50.38,1,0
sharpen[0] $1
b[1] 0.5
n[1] 0,255
equalize[1] 4,0%,98%
+a[0,1] c
b[2] $2
blend[0,2] alpha,$3
remove_opacity[0]
k[0]
mc_flou_preview:
gui_split_preview "-mc_flou $*",$-1
#@gui Mc Pendraw : mc_pendraw, mc_pendraw_preview
#@gui : sep = separator()
#@gui : Amplitude = float(8,0,30)
#@gui : Blur = float(0.8,0.1,2)
#@gui : Sharp = float(450,100,2000)
#@gui : Color = int(21,4,256)
#@gui : Dithering = float(0.5,0,1)
#@gui : Value = float(1,0,1)
#@gui : Mode 2 = bool(false)
#@gui : Color Equal. = bool(false)
#@gui : Equal. Limit = int(255,100,255)
#@gui : sep = separator()
#@gui : Lowers Contrast = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
mc_pendraw:
repeat $! l[$>]
split_opacity
l[0]
to_rgb
if {$10>0}
[0]
b[0] 1
negate[0]
luminance[0]
rv[0,1]
blend[0,1] overlay,$10
fi
+fx_gradient_norm[0] 0,1.5,0,50.38,1,0
[0]
smooth $1,0.2,1,3,3
b $2
sharpen $3
[0]
r[0] 20,20,1,3,2
equalize[0] 256,0%,98%
index[3] [0],1,1
rm[0]
nm[0] linee
nm[1] orig
nm[2] pen
if {$7==0}
rv[pen,linee]
blend[pen,linee] multiply,1
elif {$7==1}
rv[orig,linee]
blend[orig,linee] multiply,1
fi
n[0] 5,250
autoindex[0] $4,$5
rv[0,1]
blend[0,1] value,$6
if {$8==1}
equalize 21,30,$9
fi
endl a c endl done
mc_pendraw_preview:
gui_split_preview "-mc_pendraw $*",$-1
#@gui _
#@gui <i>Tom Keil</i>
#@gui About : _none_, fx_tk_about
#@gui : note = note{"
#@gui : <span foreground="purple">( <b>T</b>om Keils <b>F</b>ilter <b>S</b>et for <b>G'MIC</b>)</span>\n\nis proposed to you by"}
#@gui : note = note("Tom Keil")
#@gui : note = note{"\n"}
#@gui : sep = separator()
#@gui : note = note{"
#@gui : The source code of this set of filters and additional informations and tutorials are available at :"}
#@gui : sep = separator()
#@gui : note = note{"\nThe filters in this folder are still under development and may be subject to changes. Some filters appearing here are also part of the main filter tree of GMIC. If they appear here too it means there are changes and updates not yet implemented in the main filter tree."}
fx_tk_about :
-fx_logo "Tom Keils Filters"
tk_fx_channel_processing :
-fx_channel_processing {$3*100/255},{$2<1?-min(1,$2-1)*100:min(1,0.25*($2-1))*100},{log($1)},${4--1}
tk_fx_select_color :
($4^$5^$6^$7) -_fx_select_color[-1] $1 color={^} -rm[-1]
-repeat $!
-if {$8==0}
--_fx_select_color[-1] $1
-select_color[-1] $2%,$color
-b[-1] $3%
-if $9 -*[-1] -1 -+[-1] 1 -endif
-to_rgba[-2] -s[-2] c -*[-2,-1] -a[-4--1] c
-else
-_fx_select_color[-1] $1
-select_color[-1] $2%,$color
-b[-1] $3
-if $9 -*[-1] -1 -+[-1] 1 -endif
-*[-1] 255 -r[-1] 100%,100%,1,4
-endif
-mv[-1] 0 -done
tk_fx_replace_color :
-to_rgba -replace_color $1,$2%,${3--1} -c 0,255
#@gui Beauty Retouch : fx_tk_retouch, fx_tk_retouch_preview(0)
#@gui : sep = separator()
#@gui : Smoothness = float(30,0,100)
#@gui : Details = float(3,0,10)
#@gui : Smoothing Strength = float(1,0,5)
#@gui : Edge Threshold = float(20,0,50)
#@gui : Edge Smoothness = float(1.5,0,10)
#@gui : Sharpening Radius = float(1,0,10)
#@gui : Sharpening Strength = float(2.5,0,5)
#@gui : View Edge Mask = bool(0)
#@gui : Smoothen Skin Tones Only = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>.      Latest update: <i>2011/05/01</i>.</small>")
#@gui : note = link("Filter explained here","http://www.flickr.com/groups/gmic/discuss/72157625538669041/")
fx_tk_retouch :
-repeat $! -l[$>]
-if {$8==1}
--fx_edges $5,$4,0,0 -fx_gaussian_blur {$5*5},0,0,1,1,0,0
-else
--to_rgba[0]  --to_gray[0] -fx_edges[2] $5,$4,0,0
-fx_gaussian_blur[2] {$5*5},0,0,1,1,0,0 -to_gray[2] --to_rgba[0] --negate[2]
-fx_highpass[1] {$1},2,1,1,0
-fx_gaussian_blur[1] $2,0,0,1,1,0,0
-to_rgba[0]
-if {$9==1}  --to_rgba[0] -channels[5] 0
-tk_fx_channel_processing[5] 1,1,4,0,0,0,100,256,0,0,0,2,7,0
-fx_gaussian_blur[5] {{w+h}/1000},0,0,1,0,0,0 -to_gray[5] -endif
-split[1] c  -reverse[4,5] -compose_multiply[4,5]
-if {$9==1} -reverse[4,-1] -compose_multiply[4,-1] -endif
-append[-6,-5,-4,-3] c
-reverse[0,1] -fx_compose_softlight[0,1] {$3/5}
-fx_unsharp[-2] 0,$6,30,$7,0.00,1.00,0.5,1,0,7,0
-split[-2] c  -reverse[-1,-2] -compose_multiply[-1,-2] -append[-4,-3,-2,-1] c
-blend[0,1] alpha
-endif
-endl -done
fx_tk_retouch_preview :
-gui_split_preview "-fx_tk_retouch ${1--2}",$-1
#@gui DOF Manipulation : fx_tk_dof, fx_tk_dof_preview(1)
#@gui : sep = separator()
#@gui : Focal Point X = float (50,0,100)
#@gui : Focal Point Y = float (50,0,100)
#@gui : DOF 1 = int (30,0,255)
#@gui : DOF 2 = int (60,0,255)
#@gui : Transition = float(5,0,25)
#@gui : Defocus Strength = float(15,0,200)
#@gui : Defocus Style = choice(2,"median","gaussian","mixed")
#@gui : Depth Estimation Model = choice("automatic depth estimation","daylight scene","individual focus field mask","individual depth map")
#@gui : Bokeh Strength = float(0,0,1)
#@gui : Highlights Threshold = float(200,0,255)
#@gui : Bokeh Size = float(40,2,200)
#@gui : Bokeh Blur = float(2,0,20)
#@gui : Aperture Type = choice("circular","octogonal")
#@gui : Remove Blurring Artifacts = bool(0)
#@gui : sep = separator()
#@gui : Scheimpflug Effect = choice("none","vertical blend","horizontal blend","vertical only","horizontal only")
#@gui : Tilt Plane 1 = float(0,0,100)
#@gui : Tilt Plane 2 = float(0.01,0,100)
#@gui : sep = separator()
#@gui : Output Mode = choice("image","layers in focus/out of focus","focus field mask only","depth estimation only")
#@gui : Computation Mode = choice(1,"high quality","normal","high speed")
#@gui : Use Treshold Mask Mode = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>      Latest update: <i>2012/01/21</i>.</small>")
fx_tk_dof :
-if {{$8==0}||{$8==1}} -if {{$!}!=1} -error[] "Select input mode ACTIVE. This option is available for single layer only."
-endif -endif
-if {{$8==2}||{$8==3}} -if {{$15==3}||{$15==4}||{$17==3}} -error[] "Option not available for individual mask" -endif -endif
-if {{$8==2}||{$8==3}} -if {{$!}!=2} -error[] "For individual mask select input mode ACTIVE AND BELOW" -endif -endif
tr={$5} dfs={$6} bsi={$11} bsb={$12}
-if {$19==1} scdo=50 scup=200 tr={$5/2} dfs={$6/2} bsi={$11/2} bsb={$12/2} -endif
-if {$19==2} scdo=25 scup=400 tr={$5/4} dfs={$6/4} bsi={$11/4} bsb={$12/4} -endif
-if {{$8==0}||{$8==1}} -if {$19!=0} --r[0] $scdo%,$scdo% -else [0] -endif
-else -if {$19!=0} -r[-1] $scdo%,$scdo% -endif -endif
-if {$19!=0} --r[0] $scdo%,$scdo% -else [0] -endif
-if {{$8==2}||{$8==3}} -rv[-1,-2] -endif
-if {{$15==0}||{$15==1}||{$15==2}}
-if {$8==0} -fx_tk_autodepth[-1]
-elif {$8==1} -fx_tk_depthmap[-1] 1,20,0,0,0,0,0
-elif {{$8==2}||{$8==3}} -endif
-if {$18!=3} -if {$8!=2}
-if {$20==1} -to_rgb[-1]
--f[-1] if(i>={{255-$3}+{$4/2}},0,i)
--f[-1] if(i<={{255-$3}-{$4/2}},0,i) -compose_darken[-1,-2]
-n[-1] 0,255 -f[-1] if(i>=1,255,i) -rm[-2]
-else
-local_similarity_mask[-1] $1,$2,$3,$4,4,0
-endif
-blur_xy[-1] $tr
-endif -endif
-endif
-if {{$15==1}||{$15==3}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,180,100,$16
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,0,$17
-compose_darken[-1,-2]
-endif
-if {{$15==2}||{$15==4}}
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,90,100,$16
--fx_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,$17
-compose_darken[-1,-2]
-endif
-if {{$15==1}||{$15==2}} -rv[-1,-2] -compose_lighten[-1,-2] -endif
-if {{$15==3}||{$15==4}} -rm[-2] -endif
-if {{$18==0}||{$18==1}}
-if {$14==1} [-1,-2]
-blur_xy[-1] {$tr/2}
-ir[-1] 1,256 -n[-1] 0,255
-tk_fx_replace_color[-1] 1,0,0,0,0,255,0,0,0,0
-inpaint[-2] [-1] -rm[-1,1] -rv[-1,-2]
-endif
-if {$7==0} -median[-2] $dfs
-elif {$7==1} -blur_xy[-2] $dfs
-elif {$7==2} -median[-2] {$dfs/2} -blur_xy[-1] {$dfs/5}
-endif
-if {$9!=0} -if {$19==0}  [0] -else --r[0] $scdo%,$scdo% -endif
-fx_morpho[-1] 1,$bsi,0,{2-$13},0,1,0
-tk_fx_replace_color[-1] {$10*1.765},0,0,0,0,255,0,0,0,0
-blur_xy[-1] $bsb
-rv[-1,-3] -fx_compose_lighten[-1,-3] $9
-endif
-if {$19!=0} -r[1,2] $scup%,$scup% -endif
-to_rgba[0] -s[0] c -rv[3,5]
-compose_multiply[3,5] -to_gray[3]
-a[0,1,2,3] c
-if {$18==0} -rv[0,1] -compose_rgba[0,1] -endif
-endif
-if {$18!=1} -k[-1] -endif
-if {{$18==2}||{$18==3}} -if {$19!=0} -r[-1] $scup%,$scup% -endif -endif
fx_tk_dof_preview :
-to_rgba
-if {{$8==0}||{$8==1}} -if {{$!}!=1} -error[] "Select input mode ACTIVE. This option is available for single layer only."
-endif -endif
-if {{$8!=2}&&{$8!=3}}
-gui_split_preview "-fx_tk_dof ${1--2}",$-1
-else -fx_tk_dof ${1--1} -endif
-to_rgba
-if {$20==0}
-line 100%,$2%,{$1+5}%,$2%,1,255,0,0
-line 0%,$2%,{$1-5}%,$2%,1,255,0,0
-line $1%,100%,$1%,{$2+5}%,1,255,0,0
-line $1%,0%,$1%,{$2-5}%,1,255,0,0
-endif
#@gui Infrared Simulation : fx_tk_infrared, fx_tk_infrared_preview(1)
#@gui : Filter Density = float(0.75,0.01,0.99)
#@gui : Wood Effect Saturation = float(0.5,0,1)
#@gui : Wood Effect Color = int(-100,-180,180)
#@gui : Wood Effect Falloff = float(0.75,0,1)
#@gui : Sky Color = int(0,-180,180)
#@gui : Sky Falloff = float(1,0,1)
#@gui : Infrared Defocus = float(0,0,3)
#@gui : Exposure = int(0,-255,255)
#@gui : Contrast = float(1,0,4)
#@gui : Saturation = float(1,0,2)
#@gui : Color / B&amp;W = bool(0)
#@gui : Add Grain = float(50,0,200)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Tom Keil</i>      Latest update: <i>2012/17/07</i>.</small>")
fx_tk_infrared :
-repeat $! -l[$>]
--fx_hsv_equalizer 0,120,{240*$4},{if({$2==0},0,$3)},{if({$2==0},-$1,{-1+$2})},$1,240,{120*$6},$5,0,-$1,0,0,0,0,0
-blur[-1] $7 -fx_compose_alpha $1,0
-tk_fx_channel_processing 1,$9,$8,0,0,0,100,256,0,0,0,2,0,0
-fx_mix_lab 1,0,0,$10,0,0,$10,0,0,0,2,0
-if {$11==1} -fx_blackandwhite 0.299,0,0.587,0,0.114,0,1,1,0,0,0,$12,$12,$12,2,{{w+h}/60000},0,0,16,4,0,0,0 -endif
-endl -done
fx_tk_infrared_preview :
-gui_split_preview "-fx_tk_infrared ${1--2}",$-1
#@gui _
#@gui <i>Zonderr</i>
#@gui Demo Mathmap Ra : demo_ra, demo_ra
#@gui : note = note("mathmap ra: demo")
#@gui : sep = separator()
#@gui : Radius Scale = float(1,0,10)
#@gui : Angle Scale = float(1,0,10)
demo_ra:
mathmap_ra "rmath*$1","amath*$2"
#@gui Demo Mathmap XY : demo_xy, demo_xy
#@gui : note = note("mathmap xy: demo")
#@gui : sep = separator()
#@gui : X Scale = float(1,0,10)
#@gui : Y Scale = float(1,0,10)
demo_xy:
mathmap_xy "xmath*$1","ymath*$2"
#@gui Fourier Picture Watermark : fx_fourier_picture_watermark, _none_
#@gui : Relative Size = float(0.2,0.1,0.5)
#@gui : sep = separator()
#@gui : note = note("Note : To make the watermark visible afterwards, use the 'Fourier Analysis' filter. ")
fx_fourier_picture_watermark :
resize_ratio2d[0] {1,w*$1},{1,h*$1} to_gray[0] threshold[0] 127
watermark_fourier2 c 0,255
#@cli watermark_fourier2 :
watermark_fourier2 :
fft[-1] shift[-2,-1] {int(w/2)},{int(h/2)},0,0,2
[0],[0],1,{s}
image[-3,-2] [-1],3,3,0,0,1,[0]
mirror[0] x
image[-3,-2] [-1],{{-2,w}-2-{0,w}},3,0,0,1,[0]
mirror[0] y
image[-3,-2] [-1],{{-2,w}-2-{0,w}},{{-2,h}-2-{0,h}},0,0,1,[0]
mirror[0] x
image[-3,-2] [-1],3,{{-2,h}-2-{0,h}},0,0,1,[0]
mirror[0] y
rm[-1] shift[-2,-1] -{int(w/2)},-{int(h/2)},0,0,2 ifft[-2,-1] rm[-1]
mv[-1] 1
rm[0]
#@cli invert_rgb
#@cli : Inverts images in the RGB colour space.
invert_rgb:
repeat $! split_opacity
l[0] c 0,255 *[$>] -1 +[$>] 255 endl
a c
done
#@cli invert_alpha
#@cli : Inverts the alpha channel of images.
invert_alpha:
repeat $! split_opacity
l[1] c 0,255 *[$>] -1 +[$>] 255 endl
a c
done
#@gui Mathmap Flag : mathmap_flag, mathmap_flag
#@gui : Amp = float(0.05,0,1)
#@gui : Len = float(5,0,50)
#@gui : Speed = int(1,1,5)
#@gui : Time = float(5,0,50)
mathmap_flag:
mathmap_xy "xmath","ymath+$1*sin(pi*$2/1*(-xmath+$4*2*$3/$2))"
#@gui Rel2ellv3 : mathmap_rel2ellv3,mathmap_rel2ellv3
mathmap_rel2ellv3:
mathmap_xy "xmath/sqrt(1-4*(ymath/H)*(ymath/H))","ymath/sqrt(1-4*(xmath/W)*(xmath/W))"
#@gui __
#@gui <b>Various</b>
#@gui Custom Code [Global] : fx_custom_code, fx_custom_code_preview(1)
#@gui : Code = text(1,"repeat $! l[$>]\n\n  to_rgb\n  +deform 20\n  blend_edges 3\n\n-endl done\n\n\n")
#@gui : sep = separator(), Channel(s) = choice{"None (Allows Multi-layers)","All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]"}
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : Display Debug Info on Preview = bool(0)
#@gui : Debug Font Size = choice(2,"Tiny","Small","Normal","Large")
#@gui : sep = separator(), Preview Type = choice{"Full (Allows Multi-Layers)","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"}, Preview Split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note: </b>
#@gui : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gui : Here, you can then test some commands before creating your own G'MIC custom commands and plug-in menu entries.\n\n
#@gui : Please look at the documentation reference web page :</small>"}
#@gui : url = link("https://gmic.eu/reference.shtml")
#@gui : note = note{"<small>
#@gui : to learn more about available <b>G'MIC</b> commands.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/03/10</i>.</small>")
fx_custom_code : skip "${1=-skip ,}"
m "_fx_custom_code_start : $1"
if $4
_nb_in=$!
_dim_in="" sep="" repeat $! l[$>] _dim_in=$_dim_in$sep"["$>"] = "{w}x{h}x{d}x{s}", in ["{_round([im,iM],0.1)}"]" sep="\n" endl done
fi
if $2
ac "_fx_custom_code_start _status_out=${}",{$2-1},$3
else
_fx_custom_code_start _status_out=${}
if {$3==1} c 0,255 elif {$3==2} n 0,255 fi
fi
if $4
_nb_out=$!
_dim_out="" sep="" repeat $! l[$>]
_dim_out=$_dim_out$sep"["$>"] = "{w}x{h}x{d}x{s}", in ["{_round([im,iM],0.1)}"]" sep="\n" endl done
fi
uncommand _fx_custom_code_start
fx_custom_code_preview : skip "${1=-skip ,}"
w={w} h={h}
l
_gcp_arg="$1"
if $6 gui_split_preview "fx_custom_code $_gcp_arg,${2--2}",${-3--1}
else fx_custom_code $_gcp_arg,${2--2}
fi
onfail
error_msg=${}
rr2d $w,$h,2,1
gui_print_preview "Syntax error:",,{``$error_msg},20,40
endl
if $4
if {!$3} % 256 fi
if {$_preview_mode>=4} gui_preview fi
siz0=13 siz1=17 siz2=19 siz3=22
if {['$_status_out']==0} _status_out=(empty) fi
info="Input images: "#$_nb_in"\n"\
$_dim_in"\n\n"\
"Output images: "#$_nb_out"\n"\
$_dim_out"\n\n"\
"Output status: "$_status_out
0 t. {``$info},0,0,${siz$5},1,255 expand_xy. 5,0 +dilate. 3 a[-2,-1] c
rr2d[^-1] ${-max_wh},2,2
r. ..,..,1,100%,0 drgba[^-1]
/[^-1] 2 blend[^-1] .,alpha rm.
fi
#@gui Custom Code [Local] : fx_custom_code, fx_custom_code_preview(0)
#@gui : Code = text(1,"repeat $! l[$>]\n\n  to_rgb\n  +deform 20\n  blend_edges 3\n\n-endl done\n\n\n")
#@gui : sep = separator()
#@gui : sep = separator(), Channel(s) = choice{"None (Allows Multi-layers)","All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]"}
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : Display Debug Info on Preview = bool(0)
#@gui : Debug Font Size = choice(2,"Tiny","Small","Normal","Large")
#@gui : sep = separator(), Preview Type = choice{"Full (Allows Multi-Layers)","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"}, Preview Split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note: </b>
#@gui : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gui : Here, you can then test some commands before creating your own G'MIC custom commands and plug-in menu entries.\n\n
#@gui : Please look at the documentation reference web page :</small>"}
#@gui : url = link("https://gmic.eu/reference.shtml")
#@gui : note = note{"<small>
#@gui : to learn more about available <b>G'MIC</b> commands.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/03/10</i>.</small>")
#@gui Games &amp; Demos : fx_gmic_demos, fx_gmic_demos_preview
#@gui : Selection = choice("2048","Blobs Editor","Bouncing Balls","Connect-Four","Fire Effect","Fireworks","Fish-Eye Effect","Fourier Filtering","Hanoi Tower",
#@gui : "Histogram","Hough Transform","Jawbreaker","Virtual Landscape","The Game of Life","Light Effect","Mandelbrot Explorer","3D Metaballs","Minesweeper",
#@gui : "Minimal Path","Pacman","Paint","Plasma Effect","RGB Quantization","3D Reflection","3D Rubber Object","Shadebobs","Spline Editor",
#@gui : "3D Starfield","Tetris","Tic-Tac-Toe","3D Waves","Fractal Whirl")
#@gui : sep = separator()
#@gui : note = note("<small><b>Note:</b> This filter proposes a showcase of some interactive demos, all written as G'MIC scripts.
#@gui : </small>")
#@gui : note = note{"<small>On most demos, you can use the keyboard shortcut <b>CTRL+D</b> to double the window size (and <b>CTRL+C</b> to go back to the original size).
#@gui : Also, feel free to use the mouse buttons, as they are often used to perform an action.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2014/10/09</i>.</small>")
fx_gmic_demos :
coms=2048,blobs,bouncing,connect4,fire,fireworks,fisheye,fourier,hanoi,histogram,hough,jawbreaker,landscape,life,light,\
mandelbrot,metaballs3d,minesweeper,minimal_path,pacman,paint,plasma,quantize_rgb,reflection3d,\
rubber3d,shadebobs,spline,starfield3d,tetris,tictactoe,waves,whirl
com=${arg\ {1+$1},$coms}
if {$!>0} sel=0 else sel= fi
+l[$sel] m "foo : x_"$com foo rm uncommand foo endl
fx_gmic_demos_preview :
rm filename=${-path_tmp}gmic_demos.cimgz
if $filename $filename
else l[] https://gmic.eu/img/gmic_demos.cimgz o $filename endl
fi
k[$1,-1] rows. $1 map[0] [1] k[0]
#@gui Histogram Analysis : _none_, fx_display_histogram(1)
#@gui : Number of Clusters = int(256,2,1024)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_display_histogram :
mode=${arg\ 1+$2,all,rgba,rgb,rgb_r,rgb_g,rgb_b,rgba_a,\
lrgb,lrgb_r,lrgb_g,lrgb_b,\
ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
lab_l,lab_ab,lab_a,lab_b,\
lch_ch,lch_c,lch_h,\
hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
yiq_y,yiq_iq}
_ac_$mode m "_ac_precond : "$_p m "_ac_forward : "$_f m "_ac_backward : "$_b
repeat $! l[$>]
_ac_precond _ac_forward[0] channels $_s
display_histogram {w},{h},$1,0,255
if {s==2" || "s==4} channels 0,2 fi
endl done
#@gui Import Data : fx_import_image, gui_no_preview
#@gui : Filename = filein()
#@gui : Normalize = bool(1)
#@gui : note = note{"\n<small><b>Note: </b>
#@gui : This filter can import any image data read by the <b>G'MIC</b> language interpreter.
#@gui : It includes exotic formats as : <i>Pandore, CImg, Inrimage, AVI/MPEG (requires FFMPEG installed), ...</i>
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_import_image : skip "${1=}"
rm i "$1" s z if $2 n 0,255 else c 0,255 fi
#@gui Intarsia : fx_intarsia, fx_intarsia_preview
#@gui : note = note{"<small><b>Note:</b>
#@gui : Intarsia is a method of Crochet/Knitting with a number of colours, in which a separate ball of yarn
#@gui : is used for each area of colour.
#@gui : This filter creates a HTML version of a graph chart which is solely used for this purpose
#@gui : </small>"}
#@gui : sep = separator()
#@gui : Output Directory = _folder("")
#@gui : Output HTML File = _text("intarsia.html")
#@gui : sep = separator()
#@gui : Maximum Image Size = int(512,2,1024)
#@gui : Maximum Number of Image Colors = _int(12,2,64)
#@gui : Starting Point = choice(1,"Top Left","Top Right","Bottom Left","Bottom Right")
#@gui : Loop Method = choice("Row by Row","Column by Column")
#@gui : sep = separator()
#@gui : Add Comment Area in HTML Page = _bool(1)
#@gui : Preview Progress (%) = float(100,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2015/09/07</i>.</small>")
fx_intarsia :
to_rgb repeat $! nm=${gui_layer_name[$>]} +l[$>]
if {max(w,h)>$3} rr2d $3,$3,0 fi
+colormap 0
if {w>$4} rm. +colormap $4,1 fi
round[1] index[0] [1]
0 nm. $nm ({'{b}'}) f. 'if(x,i,if(i>=97&&i<=122,i-32,i))' image_basename={t} rm[-2,-1]
({'"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\
\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\
<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n\
<head></head><body bgcolor=\"#FFFDFF\"><center><font size=\"-1\">\n\
<h2>"$image_basename" ("{0,w}x{0,h}")</h2>\n\
<table border=\"0\" cellpadding=\"8\"><tr><td>\n\
<table border=\"0\" cellpadding=\"4\">\n"'})
0 nm. "$2" image_name={b} rm.
nb_cols={1,w}
repeat $nb_cols
color={1,I($>)}
R={arg(1,$color)} G={arg(2,$color)} B={arg(3,$color)}
({'${dec2hex\ {$R*65536+$G*256+$B}}'}) -. {'0'} r. 6,1,1,1,0,0,1,0 +. {'0'}
f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
hcolor={t} rm.
48,32,1,4 fc. $color,255 frame. 1,1,0,0,0,255 o. "$1/"${image_name}_$>.png rm.
({'"<tr><td><b>Colour "$>"</b></td><td><img src=\""${image_name}_$>.png"\" /></td><td>#"$hcolor"</td></tr>\n"'})
done
({'"</table>\n</td><td>"'})
starting=${"arg {1+$5},\"Top left\",\"Top right\",\"Bottom left\",\"Bottom right\""}
label=${"arg {1+$6},Row,Column"}
if $6 dir0="T &#8594; B" dir1="B &#8594; T" else dir0="L &#8594; R" dir1="R &#8594; L" fi
dir={arg(1+2*$5+$6,0,0,1,0,0,1,1,1)}
+map[0] [1]
+fx_intarsia_preview. ${1-7},63 drgba.
rr2d.. 200,200,1,1
to_rgba[-2,-1] frame[-2,-1] 1,1,0,0,0,255 frame[-2,-1] 0,20,0,0,0,0
t.. "Result",0,0,16,1,0,0,0,255
t. "Ordering overview",0,0,16,1,0,0,0,255
frame[-2,-1] 20,20,0,0,0,0
o.. "$1/"${image_name}_A.png
o. "$1/"${image_name}_B.png
rm[-2,-1]
({'"<table border=\"0\"><tr><td><img src=\""${image_name}_A.png"\" /></td></tr><tr><td><img src=\""${image_name}_B.png"\" /></td></tr></table></td></tr></table>\n"'})
if $7 ({'"<p><b>Additional comments:</b><br/><textarea cols=\"80\" rows=\"10\" placeholder=\"Enter comments here...\"></textarea></p>\n"'}) fi
({'"<p><b>Starting point:</b> "$starting"\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Orientation:</b> "$label" by "$label"</p>\n"'})
rm[1]
({'"<table cellspacing=\"0\" cellpadding=\"4\" border=\"1\">\n"'})
_fx_intarsia[0] $5,$6,0
+l[0]
s y
repeat $! l[$>]
if {$>%2} mirror. x fi
im={im} compress_rle 0,0 rows 6,100%
({'"<tr><td valign=\"top\"><b>"$label" "{1+$>}"</b></td><td valign=\"top\">"${dir$dir}"</td><td>\n"'})
i=0 n=0 do
val={0,i[$i]} i+=1
if {$val>=0} occ=1
else
occ={-$val}
val={0,i[$i]}
if {$val<0} val=0 else i+=1 fi
fi
val+=$im
({'"colour:<b>"$val"</b> "$occ'})
if {0,$i<h} ({'", "'}) fi
n+=1
if {!($n%8)} ({'"<br/>\n"'}) fi
while {0,$i<h}
({'"</td></tr>\n"'})
rm[0] a x
dir={!$dir}
endl done
a x
endl
rm[0]
({'"</table>\n</font></center>\n</body>"'})
a x o raw:"$1/$2",uchar
rm
endl done
fx_intarsia_preview :
to_rgb repeat $! l[$>]
if {max(w,h)>$3} rr2d $3,$3,0 fi
to_rgba
_fx_intarsia $5,$6,0
100%,100%,1,1,'if(y%2,y*w+w-1-x,y*w+x)<$8*wh/100' *
if {min(w,h)<140} rr2d 140,140,1,1 fi
expand_xy 16,0
100%,100% circle. 16,16,1%,1,1
arrow3d. 0,0,0,{w/4},0,0,2%,15%,10% col3d. 1 j3d.. .,16,16,0,1,2,0,0 rm.
+dilate. 3 r.. 100%,100%,1,3,0,0,0,0,0,0.5 a[-2,-1] c *. 255
blend alpha
_fx_intarsia $5,$6,1
endl done
_fx_intarsia :
if {$3" && "$2} transpose fi
if {$1==0}
elif {$1==1}
mirror x
elif {$1==2}
mirror y
elif {$1==3}
mirror xy
fi
if {!$3" && "$2} transpose fi
#@gui Sample Image : fx_image_sample, fx_image_sample_preview
#@gui : Input = choice{"Random","Apples","Barbara","Boats","Bottles","Butterfly","Cameraman","Car","Cat","Cliff","David","Dog","Duck","Eagle","Elephant","Earth","Flower",
#@gui : "Fruits","Gmicky (Deevad)","Gmicky (Mahvin)","Gmicky & Wilber","Greece","Gummy","House","Inside","Landscape","Leaf","Lena","Leno","Lion","Mandrill","Mona Lisa","Monkey","Parrots","Pencils","Peppers","Roddy",
#@gui : "Rooster","Rose","Square","Teddy","Tiger","Wall","Waterfall","Zelda"}
#@gui : note = note("<small>Choosing <b>0</b> for parameters <i>Width</i> or <i>Height</i> means <i>Automatic</i>.</small>")
#@gui : Width = _int(0,0,1024)
#@gui : Height = _int(0,0,1024)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/16/01</i>.</small>")
fx_image_sample :
if $1 sp {$1-1},$2,$3 else sp ?,$2,$3 fi
mv. 0
fx_image_sample_preview :
w={w} h={h} rm
fx_image_sample $1,{$w>$h?$w:0},{$h>$w?$h:0}
#@gui Solve Maze : fx_solve_maze, fx_solve_maze_preview(1)
#@gui : Starting Point (%) = point(5,5)
#@gui : Ending Point (%) = point(95,95)
#@gui : Smoothness = float(0.1,0,1)
#@gui : Thickness = int(3,1,10)
#@gui : Color = color(255,0,0)
#@gui : Maze Type = choice("Dark Walls","White Walls")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest Update: <i>2011/01/09</i>.</small>")
fx_solve_maze :
repeat $!
+norm. >=. 50%
if {!$10} negate. fi
*. 255 +b. $5% *.. 1e10 +[-2,-1]
minimal_path. $1%,$2%,0,$3%,$4%,0
pointcloud. 0 dilate. $6 r. ..,..,1,1,0
to_rgba.
replace_color. 0,0,1,1,1,255,${7-9},255
replace_color. 0,0,0,0,0,255,0,0,0,0
ellipse. $1%,$2%,5,5,0,1,${7-9},255
ellipse. $3%,$4%,5,5,0,1,${7-9},255
rv[-2,-1]
mv[-2,-1] 0 done
fx_solve_maze_preview :
drgba
line $1%,$2%,$3%,$4%,1,0xCCCCCCCC,${7-9}
ellipse $1%,$2%,3,3,0,1,${7-9}
ellipse $1%,$2%,3,3,0,1,0x1,0
ellipse $3%,$4%,3,3,0,1,${7-9}
ellipse $3%,$4%,3,3,0,1,0x1,0
#@cli :: Additional Gallery Images
#@cli gallery_arrays
#@cli : This entry defines some examples of array filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_frame_blur 30,30,0,5,0,0,128,128,128,0,5,255,255,255,2,2,1,0,0.5,0.5,0 _label="Frame~[blur]"
#@cli : $ sample tiger,leno,monkey,duck,eagle frame 3,3,0 frame 3,3,255 montage A _label="Montage"
#@cli : $ image.jpg fx_puzzle 5,5,0.5,0,0,0.3,100,0.2,255,100,0,0,0,0,0,0 _label="Puzzle"
#@cli gallery_artistic
#@cli : This entry defines some examples of artistic filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_engrave 0.5,4,0,7.68,15.2,0,0,1,10,1,0,0,0,1,0 gui_merge_layers _label="Engrave"
#@cli : $ image.jpg fx_bokeh 3,8,0,30,8,4,0.3,0.2,210,210,80,160,0.7,30,20,20,1,2,170,130,20,110,0.15,0 _label="Bokeh"
#@cli : $ image.jpg fx_8bits 25,800,16,0 _label="Oldschool~8bits"
#@cli : $ image.jpg fire_edges 0.7,0.25,0.5,25,20 _fps=6 _label="Edges~on~fire"
#@cli : $ image.jpg fx_diffusiontensors 10,5,3,1,0.15,1,0,3,0 _label="Diffusion~tensors"
#@cli : $ image.jpg fx_dreamsmooth 3,1,1,0.8,0,0.8,1,24,0 _label="Dream~smoothing"
#@cli : $ image.jpg fx_feltpen 300,50,1,0.1,20,5,0 _label="Felt~pen"
#@cli : $ image.jpg gtutor_fpaint 0.5,0.5,0,0,45,0.5,0.5,0.5,0 _label="Finger~paint"
#@cli : $ image.jpg fx_graphic_novelfxl 0,2,6,5,20,0,0.62,14,0,1,0.5,0.78,1.92,0,0,0,1,1,1,0.5,0.8,1.28 _label="Novel~FX"
#@cli : $ image.jpg fx_illustration_look 100,0,0,0,0 _label="Illustration~look"
#@cli : $ image.jpg fx_lylejk_painting 10,2,4,10,0 _label="Lylejk~painting"
#@cli : $ image.jpg fx_painting 5,2.5,1.5,50,1,0 _label="Painting"
#@cli : $ image.jpg fx_posterize 150,30,1,6,0,0,1,0 _label="Posterize"
#@cli : $ image.jpg fx_quadtree 2,1024,1.05,0,2.33,0.68,0.39,1,0 _label="Quadtree~variations"
#@cli : $ image.jpg fx_vector_painting 9.37,0 _label="Vector~painting"
#@cli gallery_blackandwhite
#@cli : This entry defines some examples of black-and-white filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_freaky_bw 90,20,0,0,0,0 _label="Freaky~B&amp;W"
#@cli : $ image.jpg fx_engrave 0.5,50,0,8,40,0,0,0,10,1,0,0,0,1,0 _label="Engrave"
#@cli : $ image.jpg fx_gcd_layeretch 11,4,12,0.12,100,8.5,5,0,0,3,1,1,0 _label="Multi-layer~etch"
#@cli : $ image.jpg fx_pencil_portraitbw 30,120,1,0.5,144,79,21,0 _label="Pencil~portrait"
#@cli : $ image.jpg fx_gcd_etch 125,153,171,185,0.1,50,80,50,10,15,12,20,0,1,0.3,1,0,0 _label="Threshold~etch"
#@cli gallery_colors
#@cli : This entry defines some examples of color filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_color_abstraction 1,10,0.2,0 _label="Color~abstraction"
#@cli : $ image.jpg fx_boost_chroma 90,0,0 _label="Boost~chromaticity"
#@cli : $ image.jpg fx_retrofade 20,6,40,0 _label="Retro~fade"
#@cli : $ image.jpg fx_tk_vintage 2,0.85,0.7,80,200,5,147,26,161,0.3,235,220,176,0.4,190,181,108,0.2,0,0,100,0,0.3,25,0,0 _label="Vintage~style"
#@cli gallery_deformations
#@cli : This entry defines some examples of deformation filters for the G'MIC gallery page.
#@cli : $ image.jpg animate "flower","30,10,0,0","30,10,0,360",10 rm. _fps=6 _label="flower"
#@cli : $ image.jpg fx_conformal_maps 8,1,0,"((1.1 + i*z/6)/(1.04 - i*z/6))^6.2",0,0,0,0,0,3,0,0,"1024","1024" _label="Conformal~maps"
#@cli : $ image.jpg souphead_droste10 40,100,1,1,1,0,0,0,0,0,1,10,1,0,90,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0 _label="Continuous~droste"
#@cli : $ image.jpg fx_crease 30,10,3 _label="Crease"
#@cli : $ image.jpg fx_distort_lens 0.29,0,0.23,50,50,0,0 _label="Distort~lens"
#@cli : $ image.jpg fx_drop_water 0,20,2,80,0,3,35,10,1,0.5,0.25,0.5,0.75,0.05,0.15,1 gui_merge_layers _label="Drop~water"
#@cli : $ image.jpg fx_reflect 50,1,110,160,190,64,0,1.5,0,-3.3,7,1.5 _label="Reflection"
#@cli : $ image.jpg fx_square_circle 0,1,0,0,0,0,0,0 _label="Square~to~circle"
#@cli : $ image.jpg fx_textured_glass 40,40,1,1,0,2,0,0 _label="Textured~glass"
#@cli : $ sample lena,leno,320 morph 40 _fps=5 _label="morph"
#@cli gallery_filtering
#@cli : This entry defines some examples of filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_gcd_crt 1.8,1.8,0,0 equalize 256 _label="CRT~sub-pixels"
#@cli : $ image.jpg fx_dirty 30,1,0,0,0 _label="Dirty"
#@cli : $ image.jpg fx_freaky_details 2,10,1,11,0,32,0 _label="Freaky~details"
#@cli : $ image.jpg jeje_normalize_local_variance 50,5,5,1,0,0 _label="Local~variance~normalization"
#@cli : $ image.jpg fx_mighty_details 25,1,25,1,11,0 _label="Mighty~details"
#@cli gallery_patterns
#@cli : This entry defines some examples of pattern filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_rain 65,10,50,0.1,1,1,0 gui_merge_layers _label="Rain~&amp;~snow"
#@cli : $ 400,400,1,3 fx_camouflage 9,12,100,30,46,33,75,90,65,179,189,117,255,246,158 _label="Camouflage"
#@cli : $ image.jpg jeje_clouds 50,0.5 _label="Clouds"
#@cli : $ image.jpg fx_crystal 50,0.2,20,0 _label="Crystal"
#@cli : $ 400,400,1,3 fx_crystal_background 10,25,0,100,1 _label="Crystal~background"
#@cli : $ image.jpg fx_marble 0.5,1,0,0,0.4,0.6,0.6,1.1,0,100 _label="Marble"
#@cli : $ image.jpg fx_mineral_mosaic 1,2,1,100,0 _label="Mineral~mosaic"
#@cli : $ image.jpg fx_shapes 1,16,10,2,5,106.8,2,0,0,1,0 _label="Op~art"
#@cli : $ 400,400,1,3 fx_satin 20,1,0,0,0,0,255,255,255,255,255,0,0,0,-50,0,0 _label="Satin"
#@cli : $ 400,400,1,3 fx_seamless_turbulence 15,20,0,1,3,1 _label="Seamless~turbulence"
#@cli : $ image.jpg fx_shockwaves 10,10,20,0,0 _label="Shock~waves"
#@cli : $ 400,400,1,3 fx_equation_parametric "sin(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)","cos(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)",0,100,4096,1,0,64,0,0,128,0,0,1,1,1 _label="Equation~plot~[parametric]"
#@cli : $ 400,400,1,3 KittyRings 30,8,0,1,113,0,113,0,255,0 _label="Kitaoka~spin~illusion"
#@cli : $ 400,400,1,3 fx_neon_lightning 50,50,0,50,50,100,50,0.7,3,130,80,50,0.25,0 _label="Neon~lighting"
#@cli : $ image.jpg fx_lava 8,5,3,0,0 _label="Lava"
#@cli : $ sample monkey,lion,monkey 100%,100% plasma. equalize. 256 transition[0,1,2] [3],10 rm. _fps=10 _label="transition"
#@cli : $ image.jpg fx_shapeism 2,7,0.38,0,1,5,32,8,3,1,5,0.5,1,0,0,0,255 _label="Shapeism"
#@cli gallery_3drendering
#@cli : This entry defines some examples of 3D rendering filters for the G'MIC gallery page.
#@cli : $ sample leno,lion,leno resize 400,400 transition3d 20,5,5 rm. _fps=10 _label="transition3d"
#@cli : $ 256,192 fx_text_pointcloud3d 64,"G'MIC","Rocks!",1,200,220,255,255,255,255,255,2,2,1,19 _fps=10 _label="3D~text~pointcloud"
#@cli gallery_stylization
#@cli : This entry defines some examples of image stylization for the G'MIC gallery page.
#@cli : $ sample car _fx_stylize starrynight _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Starry~Night"
#@cli : $ sample car _fx_stylize graytree _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Mondrian:~Gray~Tree"
#@cli : $ sample car _fx_stylize yellowredblue _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Kandinsky:~Yellow-Red-Blue"
#@cli : $ sample car _fx_stylize littlebayatlaciotat _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~Little~Bay~at~La~Ciotat"
#@cli : $ sample car _fx_stylize leviaducalestaque _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~Le~Viaduc~a~l'Estaque"
#@cli : $ sample car _fx_stylize greatwave _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Hokusai:~The~Great~Wave"
#@cli : $ sample elephant input ../img/hatching.png _output_mode=1 +fx_stylize 1,4,0,0,1,2,3,0.5,0.1,2,5,0,0.7,0,0,1,0,5,5,7,1,30,10,2,1.85,0 _label="from~Hatch Drawing"
#@cli : $ sample cat input ../img/hatching.png _output_mode=1 +fx_stylize 1,4,0,0,1,2,3,0.5,0.1,2,5,0,0.7,0,0,1,0,5,5,7,1,30,10,2,1.85,0 _label="from~Hatch Drawing"
#@cli : $ sample bottles _fx_stylize starrynight _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,1,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Starry~Night"
#@cli : $ sample cat _fx_stylize summertime9a _output_mode=1 +fx_stylize 1,6,0,0,2,0,1,0.5,0.1,2,5,0,0.7,0,2,1,0,5,5,7,1,130,1000,2,1.85,0 _label="from~Pollock:~Summertime~No~9A"
#@cli : $ sample cat _fx_stylize greatwave _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Hokusai:~The~Great~Wave"
#@cli : $ sample dog _fx_stylize convergence _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Pollock:~Convergence"
#@cli : $ sample dog _fx_stylize irises _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,1,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Irises"
#@cli : $ sample mandrill _fx_stylize themandola _output_mode=1 +fx_stylize 1,5,0,0,0,3,1,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~The~Mandola"
#@cli : $ sample square _fx_stylize orientalpleasuregardenanagoria _output_mode=1 +fx_stylize 1,6,0,0,0.52,0.5,3,0.14,0.1,2,5,0,0.7,3.39,0,1,0,5,5,7,5,30,100,2,1.85,0 _label="from~Klee:~Oriental~Pleasure~Garden~Anagoria"
#@cli : $ sample monalisa _fx_stylize squareswithconcentriccircles _output_mode=1 +fx_stylize 1,4,0,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Kandisnky:~Squares~with~Concentric~Circles"
#@cli : $ sample monalisa _fx_stylize inthestyleofkairouan _output_mode=1 +fx_stylize 1,4,2,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Klee:~In~the~Style~of~Kairouan"
#@cli : $ sample square _fx_stylize polyphony2 _output_mode=1 +fx_stylize 1,6,0,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Klee:~Polyphony~2"
#@cli : $ sample square _fx_stylize wheatstacksendofsummer _output_mode=1 +fx_stylize 1,6,0,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Monet:~Wheatstacks~-~End~of~Summer"
#@cli : $ sample square _fx_stylize portraitdemetzinger _output_mode=1 +fx_stylize 1,5,0,0,0.1,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Delaunay:~Portrait~de~Metzinger"
#@cli : $ sample monalisa input ../img/mandelbrot.jpg _output_mode=1 +fx_stylize 1,3,3,0,0.15,4,3,0.5,0.1,0,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Mandelbrot Fractal~Set"
#@cli : $ sample bottles _fx_stylize redtree _output_mode=1 +fx_stylize 1,5,0,0,2.12,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Mondrian:~Evening;~Red~Tree"
#@cli : $ sample bottles _fx_stylize redwaistcoat _output_mode=1 +fx_stylize 1,4,0,0,0.67,3.17,3,0.5,0.06,2,1,0,0.7,5,0,2,0,5,5,7,1,30,1090,2.05,1.85,0 _label="from~Klee:~Red~Waistcoat"
#@cli : $ sample bottles _fx_stylize reservoirhortadeebro _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Picasso:~The~Reservoir"
#@cli : $ sample bottles _fx_stylize almondblossom _output_mode=1 +fx_stylize 1,6,0,0,0,3,3,0.5,0.1,2,5,0,0.7,5,0,2,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Almond~Blossom"
#@cli : $ sample bottles _fx_stylize landscapenearantwerp _output_mode=1 +fx_stylize 1,6,0,0,2.17,3.65,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~Landscape~near~Antwerp"
#@cli : $ sample bottles _fx_stylize wheatfieldwithcrows _output_mode=1 +fx_stylize 1,6,0,0,3.86,2,3,0.5,0.1,1,5,0,0.7,3.35,1,1,0,5,5,7,1,30,1000,5,1.85,0 _label="from~Van~Gogh:~Wheat~Field~with~Crows"
#@cli gallery_codesamples
#@cli : This entry defines some examples of coding-fun filters for the G'MIC gallery page.
#@cli : $ https://gmic.eu/samples/lissajous.gmic go _fps=10 _label="Lissajous"
#@cli : $ https://gmic.eu/samples/torus3d.gmic go _fps=10 _label="3D~torus"
#@cli : $ https://gmic.eu/samples/pacman.gmic go _fps=25 _label="Pacman"
#@cli : $ https://gmic.eu/samples/scrolling.gmic go _fps=25 _label="Scrolling"
#@cli : $ https://gmic.eu/samples/landscape.gmic go _fps=12 _label="Landscape"
#@cli : $ https://gmic.eu/samples/mandelbrot.gmic go _fps=8 _label="Mandelbrot"

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC update file)
